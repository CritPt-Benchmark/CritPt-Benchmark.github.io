<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>My Calculated Fidelity for a Noisy GHZ State</strong></p>
<p>Alright, let&rsquo;s break this down. I&rsquo;m tasked with figuring out the fidelity of a specific 4-qubit state, born from a circuit with Hadamards and CNOTs, and then peppered with two-qubit depolarizing noise after each CNOT. The goal is to see how well the final state matches our ideal GHZ state.</p>
<p>First, I need to get the &ldquo;ideal&rdquo; state. Since the initial state isn&rsquo;t given, I&rsquo;m assuming, as usual, all qubits start at <span class="arithmatex">\(|0\rangle\)</span>. My brain immediately jumps to calculating the successive states after each gate. I have the circuit: <span class="arithmatex">\(H_2\)</span>, <span class="arithmatex">\(CNOT_{21}\)</span>, <span class="arithmatex">\(H_0\)</span>, <span class="arithmatex">\(CNOT_{03}\)</span>. The ideal state should satisfy the definition of a GHZ in this particular [[4,2,2]] code. I went through the steps and derived the final ideal state to be <span class="arithmatex">\(\frac{1}{2}(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)\)</span>. This has to be the target state because the gates are correct and applying them as described produces this state. It&rsquo;s the physical representation of <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> within the [[4,2,2]] code, as required by the problem.</p>
<p>Now, the noise. Each CNOT is followed by a two-qubit depolarizing channel acting on the control and target qubits. This is where things get messy, but not insurmountable. I need to figure out what happens when these error channels mess up the perfect state. My first instinct is to build a density matrix model. The depolarizing channel introduces all possible Pauli errors (<span class="arithmatex">\(X\)</span>, <span class="arithmatex">\(Y\)</span>, <span class="arithmatex">\(Z\)</span>, and combinations) with probability <span class="arithmatex">\(p\)</span>. The formula is: <span class="arithmatex">\(\mathcal{E}_{ij}(\rho) = (1-p)\rho + \frac{p}{15} \sum_{k=1}^{15} P_k \rho P_k\)</span>. The key is to keep track of <em>where</em> these errors occur relative to the circuit operations.</p>
<p>I traced the full process with density matrices, applying each gate and then the noise channel after the CNOT. This makes the math complicated because each gate transformation affects the next. The thing to remember is the order, <span class="arithmatex">\(H_2 \rightarrow CNOT \rightarrow\)</span> Error Channel on (Q1,Q2) <span class="arithmatex">\(\rightarrow H_0 \rightarrow CNOT \rightarrow\)</span> Error Channel on (Q0,Q3). The ideal final state is unaffected by gates that do not involve either qubit of the 2-qubit noise channel. My math shows that each noise channel affects <em>only</em> the gate prior to its operation. Because of this, the order of operations helps simplify things.</p>
<p>Now for fidelity calculation. I need to calculate <span class="arithmatex">\(F = \langle \psi_{ideal} | \rho_{actual} | \psi_{ideal} \rangle\)</span>.  where <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span> is what I got earlier, and <span class="arithmatex">\(\rho_{actual}\)</span> is my messy density matrix after everything. I know <span class="arithmatex">\(\rho_{actual}\)</span> will be a mix of the ideal state and error states. This is a mix of the ideal state combined with the sum of all the Pauli matrices. The simplification stems from noting that the stabilizer state is an eigenstate of most of these operations. This is a stabilizer code! With a stabilizer code, I can apply the depolarizing channels in sequence, noting that the error channel on qubits (1,2) is separate from that on (0,3).</p>
<p>I went through the math and the process yielded, using properties of stabilizer states, <span class="arithmatex">\(F = (1-p)^2 + (\frac{p}{15})^2 3\)</span>.  I did need to count the stabilizer operators. The stabilizers for a GHZ state are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>. After calculation, I know my state <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span> is stabilized by <span class="arithmatex">\(I\)</span>, <span class="arithmatex">\(XXXX\)</span>, <span class="arithmatex">\(ZZZZ\)</span>, and <span class="arithmatex">\(YYYY\)</span>.  The final fidelity turns out to be <span class="arithmatex">\(1 - 2p + \frac{76}{75}p^2\)</span>.  That&rsquo;s my final answer. It takes a little elbow grease, but I&rsquo;m confident in the math and the result!</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>The problem asks for the physical state fidelity of a prepared logical two-qubit GHZ state, accounting for depolarizing errors after each CNOT gate.</p>
<p>First, let&rsquo;s determine the ideal final state.
The initial state is typically <span class="arithmatex">\(|0000\rangle\)</span>.
The circuit operations are applied in reverse order of the given equation: <span class="arithmatex">\(H_2\)</span>, then <span class="arithmatex">\(CNOT_{21}\)</span>, then <span class="arithmatex">\(H_0\)</span>, then <span class="arithmatex">\(CNOT_{03}\)</span>.</p>
<ol>
<li>
<p><strong>Initial State</strong>: <span class="arithmatex">\(|\psi_0\rangle = |0000\rangle\)</span>.</p>
</li>
<li>
<p><strong>Apply <span class="arithmatex">\(H_2\)</span> (on qubit 2)</strong>:
    <span class="arithmatex">\(|\psi_1\rangle = H_2 |\psi_0\rangle = I_0 \otimes I_1 \otimes H_2 \otimes I_3 |0000\rangle = |00\rangle \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle) |0\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|0010\rangle)\)</span>.</p>
</li>
<li>
<p><strong>Apply <span class="arithmatex">\(CNOT_{21}\)</span> (control 2, target 1)</strong>:
    <span class="arithmatex">\(|\psi_2\rangle = CNOT_{21} |\psi_1\rangle = CNOT_{21} \frac{1}{\sqrt{2}}(|0000\rangle+|0010\rangle)\)</span>.
    <span class="arithmatex">\(CNOT_{21}|0000\rangle = |0000\rangle\)</span> (qubit 2 is 0, qubit 1 unchanged).
    <span class="arithmatex">\(CNOT_{21}|0010\rangle = |0110\rangle\)</span> (qubit 2 is 1, qubit 1 flipped).
    So, <span class="arithmatex">\(|\psi_2\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|0110\rangle)\)</span>.</p>
</li>
<li>
<p><strong>Apply <span class="arithmatex">\(H_0\)</span> (on qubit 0)</strong>:
    <span class="arithmatex">\(|\psi_3\rangle = H_0 |\psi_2\rangle = H_0 \frac{1}{\sqrt{2}}(|0000\rangle+|0110\rangle)\)</span>.
    <span class="arithmatex">\(H_0|0000\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|1000\rangle)\)</span>.
    <span class="arithmatex">\(H_0|0110\rangle = \frac{1}{\sqrt{2}}(|0110\rangle+|1110\rangle)\)</span>.
    So, <span class="arithmatex">\(|\psi_3\rangle = \frac{1}{2}(|0000\rangle+|1000\rangle+|0110\rangle+|1110\rangle)\)</span>.</p>
</li>
<li>
<p><strong>Apply <span class="arithmatex">\(CNOT_{03}\)</span> (control 0, target 3)</strong>:
    <span class="arithmatex">\(|\psi_{ideal}\rangle = CNOT_{03} |\psi_3\rangle = CNOT_{03} \frac{1}{2}(|0000\rangle+|1000\rangle+|0110\rangle+|1110\rangle)\)</span>.
    <span class="arithmatex">\(CNOT_{03}|0000\rangle = |0000\rangle\)</span>.
    <span class="arithmatex">\(CNOT_{03}|1000\rangle = |1001\rangle\)</span>.
    <span class="arithmatex">\(CNOT_{03}|0110\rangle = |0110\rangle\)</span>.
    <span class="arithmatex">\(CNOT_{03}|1110\rangle = |1111\rangle\)</span>.
    So, <span class="arithmatex">\(|\psi_{ideal}\rangle = \frac{1}{2}(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)\)</span>.</p>
</li>
</ol>
<p>This is the ideal target physical state. Let&rsquo;s verify it corresponds to the logical GHZ state <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>.
For the given logical operators, the typical encoded states in the [[4,2,2]] code are:
<span class="arithmatex">\(|00\rangle_{AB} = \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle)\)</span>
<span class="arithmatex">\(|11\rangle_{AB} = \frac{1}{\sqrt{2}}(|0110\rangle+|1001\rangle)\)</span>
Indeed, for these states <span class="arithmatex">\(Z_A|00\rangle_{AB}=|00\rangle_{AB}\)</span>, <span class="arithmatex">\(Z_B|00\rangle_{AB}=|00\rangle_{AB}\)</span>, <span class="arithmatex">\(Z_A|11\rangle_{AB}=-|11\rangle_{AB}\)</span>, <span class="arithmatex">\(Z_B|11\rangle_{AB}=-|11\rangle_{AB}\)</span>.
The target logical GHZ state is <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>. Substituting the physical representations:
<span class="arithmatex">\(|\psi_{target}\rangle = \frac{1}{\sqrt{2}} \left( \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) + \frac{1}{\sqrt{2}}(|0110\rangle+|1001\rangle) \right)\)</span>
<span class="arithmatex">\(|\psi_{target}\rangle = \frac{1}{2}(|0000\rangle+|1111\rangle+|0110\rangle+|1001\rangle)\)</span>.
This matches <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span>.</p>
<p>Next, we incorporate the error model. Each CNOT gate is followed by a two-qubit depolarizing error channel.
Let <span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>.
The circuit has two CNOT gates: <span class="arithmatex">\(CNOT_{21}\)</span> and <span class="arithmatex">\(CNOT_{03}\)</span>.
The operations are <span class="arithmatex">\(U_1=H_2\)</span>, <span class="arithmatex">\(U_2=CNOT_{21}\)</span>, <span class="arithmatex">\(U_3=H_0\)</span>, <span class="arithmatex">\(U_4=CNOT_{03}\)</span>.</p>
<p>The density matrix evolves as:
<span class="arithmatex">\(\rho_0 \xrightarrow{U_1} \rho_1 = U_1 \rho_0 U_1^\dagger = |\psi_1\rangle\langle\psi_1|\)</span>
<span class="arithmatex">\(\rho_1 \xrightarrow{U_2} \rho_2^{pre-err} = U_2 \rho_1 U_2^\dagger = |\psi_2\rangle\langle\psi_2|\)</span>
<span class="arithmatex">\(\rho_2^{pre-err} \xrightarrow{\mathcal{E}_{21}} \rho_2 = \mathcal{E}_{21}(\rho_2^{pre-err})\)</span>, where <span class="arithmatex">\(\mathcal{E}_{21}(\sigma) = (1-p)\sigma + \frac{p}{15} \sum_{P_{12}} P_{12} \sigma P_{12}\)</span> (sum over 15 non-identity Pauli operators on qubits 1 and 2).
<span class="arithmatex">\(\rho_2 \xrightarrow{U_3} \rho_3 = U_3 \rho_2 U_3^\dagger\)</span>
<span class="arithmatex">\(\rho_3 \xrightarrow{U_4} \rho_4^{pre-err} = U_4 \rho_3 U_4^\dagger\)</span>
<span class="arithmatex">\(\rho_4^{pre-err} \xrightarrow{\mathcal{E}_{03}} \rho_{actual} = \mathcal{E}_{03}(\rho_4^{pre-err})\)</span>, where <span class="arithmatex">\(\mathcal{E}_{03}(\sigma) = (1-p)\sigma + \frac{p}{15} \sum_{Q_{03}} Q_{03} \sigma Q_{03}\)</span> (sum over 15 non-identity Pauli operators on qubits 0 and 3).</p>
<p>The Hadamard gate <span class="arithmatex">\(H_0\)</span> acts on qubit 0. The CNOT gate <span class="arithmatex">\(CNOT_{03}\)</span> acts on qubits 0 and 3. The error operator <span class="arithmatex">\(P_{12}\)</span> acts on qubits 1 and 2. Since these operations act on disjoint sets of qubits, they commute.
<span class="arithmatex">\(U_3 P_{12} U_3^\dagger = H_0 P_{12} H_0^\dagger = P_{12}\)</span>.
<span class="arithmatex">\(U_4 P_{12} U_4^\dagger = CNOT_{03} P_{12} CNOT_{03}^\dagger = P_{12}\)</span>.
So, <span class="arithmatex">\(\rho_3 = (U_3 U_2 U_1) \rho_0 (U_3 U_2 U_1)^\dagger = U_3 \mathcal{E}_{21}(U_2 \rho_1 U_2^\dagger) U_3^\dagger = (1-p) |\psi_3\rangle\langle\psi_3| + \frac{p}{15} \sum_{P_{12}} P_{12} |\psi_3\rangle\langle\psi_3| P_{12}\)</span>.
Similarly, <span class="arithmatex">\(\rho_4^{pre-err} = (1-p) |\psi_{ideal}\rangle\langle\psi_{ideal}| + \frac{p}{15} \sum_{P_{12}} P_{12} |\psi_{ideal}\rangle\langle\psi_{ideal}| P_{12}\)</span>.
Let <span class="arithmatex">\(|\Psi\rangle = |\psi_{ideal}\rangle\)</span>.
<span class="arithmatex">\(\rho_{actual} = \mathcal{E}_{03}(\rho_4^{pre-err}) = (1-p)\rho_4^{pre-err} + \frac{p}{15} \sum_{Q_{03}} Q_{03} \rho_4^{pre-err} Q_{03}\)</span>.
Substitute <span class="arithmatex">\(\rho_4^{pre-err}\)</span>:</p>
<div class="arithmatex">\[
\rho_{actual} = (1-p) \left[ (1-p)|\Psi\rangle\langle\Psi| + \frac{p}{15} \sum_{P_{12}} P_{12} |\Psi\rangle\langle\Psi| P_{12} \right] \\ + \frac{p}{15} \sum_{Q_{03}} Q_{03} \left[ (1-p)|\Psi\rangle\langle\Psi| + \frac{p}{15} \sum_{P_{12}} P_{12} |\Psi\rangle\langle\Psi| P_{12} \right] Q_{03}.
\]</div>
<p>Since <span class="arithmatex">\(P_{12}\)</span> and <span class="arithmatex">\(Q_{03}\)</span> act on disjoint sets of qubits, they commute.</p>
<div class="arithmatex">\[
\rho_{actual} = (1-p)^2 |\Psi\rangle\langle\Psi| + (1-p)\frac{p}{15} \sum_{P_{12}} P_{12} |\Psi\rangle\langle\Psi| P_{12} \\ + (1-p)\frac{p}{15} \sum_{Q_{03}} Q_{03} |\Psi\rangle\langle\Psi| Q_{03} + \left(\frac{p}{15}\right)^2 \sum_{P_{12}} \sum_{Q_{03}} Q_{03} P_{12} |\Psi\rangle\langle\Psi| P_{12} Q_{03}.
\]</div>
<p>The physical state fidelity is <span class="arithmatex">\(F = \langle \Psi | \rho_{actual} | \Psi \rangle\)</span>.
Since <span class="arithmatex">\(|\Psi\rangle\)</span> is a stabilizer state (it&rsquo;s a code word in a stabilizer code), for any Pauli operator <span class="arithmatex">\(O\)</span>, <span class="arithmatex">\(\langle \Psi | O |\Psi\rangle\)</span> is either <span class="arithmatex">\(\pm 1\)</span> if <span class="arithmatex">\(O|\Psi\rangle=\pm|\Psi\rangle\)</span>, or <span class="arithmatex">\(0\)</span> if <span class="arithmatex">\(O|\Psi\rangle\)</span> is orthogonal to <span class="arithmatex">\(|\Psi\rangle\)</span>. Therefore, <span class="arithmatex">\(|\langle \Psi | O |\Psi\rangle|^2\)</span> is either 1 or 0.</p>
<div class="arithmatex">\[
F = (1-p)^2 + (1-p)\frac{p}{15} \sum_{P_{12}} |\langle \Psi | P_{12} |\Psi\rangle|^2 \\ + (1-p)\frac{p}{15} \sum_{Q_{03}} |\langle \Psi | Q_{03} |\Psi\rangle|^2 + \left(\frac{p}{15}\right)^2 \sum_{P_{12}} \sum_{Q_{03}} |\langle \Psi | Q_{03} P_{12} |\Psi\rangle|^2.
\]</div>
<p>We need to count how many operators <span class="arithmatex">\(P_{12}\)</span>, <span class="arithmatex">\(Q_{03}\)</span>, and <span class="arithmatex">\(Q_{03}P_{12}\)</span> stabilize <span class="arithmatex">\(|\Psi\rangle\)</span> (i.e., cause <span class="arithmatex">\(|\langle \Psi | O |\Psi\rangle|^2 = 1\)</span>).
The state <span class="arithmatex">\(|\Psi\rangle = \frac{1}{2}(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)\)</span> is in the +1 eigenspace of <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>. It is also stabilized by <span class="arithmatex">\(YYYY = XXXX \cdot ZZZZ\)</span>. The stabilizer group of <span class="arithmatex">\(|\Psi\rangle\)</span> is <span class="arithmatex">\(G_{|\Psi\rangle} = \{I, XXXX, ZZZZ, YYYY\}\)</span>.</p>
<ol>
<li>
<p><strong>Count for <span class="arithmatex">\(P_{12}\)</span></strong>: Operators <span class="arithmatex">\(P_{12}\)</span> are non-identity Paulis on qubits 1 and 2 (i.e., <span class="arithmatex">\(I_0 \otimes P_{12} \otimes I_3\)</span>). For <span class="arithmatex">\(P_{12}\)</span> to stabilize <span class="arithmatex">\(|\Psi\rangle\)</span>, <span class="arithmatex">\(I_0 P_{12} I_3\)</span> must be in <span class="arithmatex">\(G_{|\Psi\rangle}\)</span>.</p>
<ul>
<li>If <span class="arithmatex">\(I_0 P_{12} I_3 = I_0 I_1 I_2 I_3\)</span>, then <span class="arithmatex">\(P_{12} = I_1 I_2\)</span>. But <span class="arithmatex">\(P_{12}\)</span> must be non-identity. So this doesn&rsquo;t count.</li>
<li>If <span class="arithmatex">\(I_0 P_{12} I_3 = XXXX\)</span>, then <span class="arithmatex">\(I_0=X_0\)</span> and <span class="arithmatex">\(I_3=X_3\)</span>, which is false. Similarly for <span class="arithmatex">\(ZZZZ\)</span> and <span class="arithmatex">\(YYYY\)</span>.
Thus, there are <strong>0</strong> non-identity <span class="arithmatex">\(P_{12}\)</span> operators that stabilize <span class="arithmatex">\(|\Psi\rangle\)</span>.</li>
</ul>
</li>
<li>
<p><strong>Count for <span class="arithmatex">\(Q_{03}\)</span></strong>: Operators <span class="arithmatex">\(Q_{03}\)</span> are non-identity Paulis on qubits 0 and 3 (i.e., <span class="arithmatex">\(Q_{03} \otimes I_1 I_2\)</span>). For <span class="arithmatex">\(Q_{03}\)</span> to stabilize <span class="arithmatex">\(|\Psi\rangle\)</span>, <span class="arithmatex">\(Q_{03} I_1 I_2\)</span> must be in <span class="arithmatex">\(G_{|\Psi\rangle}\)</span>.</p>
<ul>
<li>Similar to <span class="arithmatex">\(P_{12}\)</span>, no non-identity <span class="arithmatex">\(Q_{03}\)</span> operator will be in <span class="arithmatex">\(G_{|\Psi\rangle}\)</span>.
Thus, there are <strong>0</strong> non-identity <span class="arithmatex">\(Q_{03}\)</span> operators that stabilize <span class="arithmatex">\(|\Psi\rangle\)</span>.</li>
</ul>
</li>
<li>
<p><strong>Count for <span class="arithmatex">\(Q_{03} P_{12}\)</span></strong>: Operators <span class="arithmatex">\(Q_{03} P_{12}\)</span> are products of a non-identity <span class="arithmatex">\(Q_{03}\)</span> and a non-identity <span class="arithmatex">\(P_{12}\)</span>. These are 4-qubit Pauli operators <span class="arithmatex">\(Q_0 P_1 P_2 Q_3\)</span>. We need to count how many of these stabilize <span class="arithmatex">\(|\Psi\rangle\)</span>.</p>
<ul>
<li>If <span class="arithmatex">\(Q_0 P_1 P_2 Q_3 = I_4\)</span>, this implies <span class="arithmatex">\(Q_0=I_0, P_1=I_1, P_2=I_2, Q_3=I_3\)</span>. But <span class="arithmatex">\(Q_{03}\)</span> and <span class="arithmatex">\(P_{12}\)</span> must be non-identity. So this doesn&rsquo;t count.</li>
<li>If <span class="arithmatex">\(Q_0 P_1 P_2 Q_3 = XXXX\)</span>: This requires <span class="arithmatex">\(Q_0=X_0, P_1=X_1, P_2=X_2, Q_3=X_3\)</span>. In this case, <span class="arithmatex">\(Q_{03}=X_0 X_3\)</span> (non-identity) and <span class="arithmatex">\(P_{12}=X_1 X_2\)</span> (non-identity). This counts as <strong>1</strong>.</li>
<li>If <span class="arithmatex">\(Q_0 P_1 P_2 Q_3 = ZZZZ\)</span>: This requires <span class="arithmatex">\(Q_0=Z_0, P_1=Z_1, P_2=Z_2, Q_3=Z_3\)</span>. In this case, <span class="arithmatex">\(Q_{03}=Z_0 Z_3\)</span> (non-identity) and <span class="arithmatex">\(P_{12}=Z_1 Z_2\)</span> (non-identity). This counts as <strong>1</strong>.</li>
<li>If <span class="arithmatex">\(Q_0 P_1 P_2 Q_3 = YYYY\)</span>: This requires <span class="arithmatex">\(Q_0=Y_0, P_1=Y_1, P_2=Y_2, Q_3=Y_3\)</span>. In this case, <span class="arithmatex">\(Q_{03}=Y_0 Y_3\)</span> (non-identity) and <span class="arithmatex">\(P_{12}=Y_1 Y_2\)</span> (non-identity). This counts as <strong>1</strong>.
Thus, there are <strong>3</strong> combinations of non-identity <span class="arithmatex">\(Q_{03} P_{12}\)</span> that stabilize <span class="arithmatex">\(|\Psi\rangle\)</span>.</li>
</ul>
</li>
</ol>
<p>Substituting these counts into the fidelity formula:</p>
<div class="arithmatex">\[
F = (1-p)^2 + (1-p)\frac{p}{15}(0) + (1-p)\frac{p}{15}(0) + \left(\frac{p}{15}\right)^2 (3).
\]</div>
<div class="arithmatex">\[
F = (1-p)^2 + \frac{3p^2}{15^2}
\]</div>
<div class="arithmatex">\[
F = (1-2p+p^2) + \frac{3p^2}{225}
\]</div>
<div class="arithmatex">\[
F = 1 - 2p + p^2 + \frac{p^2}{75}
\]</div>
<div class="arithmatex">\[
F = 1 - 2p + \left(1 + \frac{1}{75}\right) p^2
\]</div>
<div class="arithmatex">\[
F = 1 - 2p + \frac{76}{75} p^2.
\]</div>
<p>The final answer is <span class="arithmatex">\(\boxed{1 - 2p + \frac{76}{75} p^2}\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="mi">76</span><span class="o">/</span><span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.350738
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>