<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Analysis of Physical State Fidelity in a [[4,2,2]] Code</strong></p>
<p>My task is to calculate the fidelity of a prepared logical GHZ state in a [[4,2,2]] quantum error-correcting code, considering the effect of depolarizing errors on the circuit.  First, I need to thoroughly understand the properties of this code, which involves four physical qubits, two logical qubits, and specific stabilizer and logical operators.  The goal is to analyze a circuit intended to create a GHZ state and determine the impact of depolarizing errors on its fidelity.</p>
<p>The circuit starts with the initial state <span class="arithmatex">\(|0000\rangle\)</span>, applies a Hadamard gate to qubit 2, followed by a CNOT gate between qubits 2 (control) and 1 (target). It then applies a Hadamard gate to qubit 0 and a CNOT gate between qubits 0 (control) and 3 (target). Ideally, the circuit&rsquo;s output should represent the logical GHZ state <span class="arithmatex">\((|00\rangle_{AB} + |11\rangle_{AB})/\sqrt{2}\)</span>.  My objective is to define the perfect output state based on the circuit operation, then quantify how much it deviates from it due to the errors.</p>
<p>I&rsquo;ve determined the ideal state by simulating the circuit. The result, <span class="arithmatex">\(|\psi_F^{\text{ideal}}\rangle = \frac{1}{2}(|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle)\)</span>, is a codeword in the code space, and importantly, an eigenstate of the operator <span class="arithmatex">\(X_A X_B\)</span> with eigenvalue +1 (where <span class="arithmatex">\(X_A\)</span> and <span class="arithmatex">\(X_B\)</span> are <em>physical</em> operators defined in the code). The state is also an eigenstate of <span class="arithmatex">\(Z_A Z_B\)</span> with eigenvalue +1. This, in turn, demonstrates that the state the circuit generates, in the absence of noise, represents the target logical GHZ state.</p>
<p>The core of the problem involves the error model, a two-qubit depolarizing channel applied after each CNOT gate. The fidelity calculation is based on the overlap between the ideal state and the final state after the error channels. The final state <span class="arithmatex">\(\rho_{\text{final}}\)</span> is determined by tracing the state evolution through each gate and error channel.</p>
<p>I am analyzing the error channels after each CNOT and how they impact the initial pure state. Because of the nature of the error channels, each Pauli operator in the expression of fidelity contributes an additional degree of freedom, but with the specific state <span class="arithmatex">\(|\psi\rangle\)</span>, most are zero. I have determined that, of the 225 terms used in the calculation, only <span class="arithmatex">\(P=I\)</span> has an expectation value of unity.</p>
<p>Through a rigorous derivation, I&rsquo;ve reduced the fidelity calculation to a simple expression. The final state fidelity <span class="arithmatex">\(F\)</span> should be <span class="arithmatex">\(1 - \frac{8p}{5} + \frac{142p^2}{225}\)</span>, where <span class="arithmatex">\(p\)</span> is the depolarizing parameter.  The analysis confirms that the fidelity decreases quadratically with increasing <span class="arithmatex">\(p\)</span>.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>The problem asks for the physical state fidelity of a prepared logical two-qubit GHZ state in the [[4,2,2]] code, subject to depolarizing errors on two-qubit gates.</p>
<p>First, let&rsquo;s determine the ideal target state. The circuit operations are applied from right to left:</p>
<div class="arithmatex">\[
U = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)
\]</div>
<p>Starting from the initial state <span class="arithmatex">\(|0000\rangle\)</span>:</p>
<ol>
<li>Apply <span class="arithmatex">\(H_2\)</span> on qubit 2:</li>
</ol>
<div class="arithmatex">\[
|\psi_1\rangle = I_0 I_1 H_2 I_3 |0000\rangle = |00+0\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)
\]</div>
<ol start="2">
<li>Apply <span class="arithmatex">\(CNOT_{21}\)</span> (control qubit 2, target qubit 1):</li>
</ol>
<div class="arithmatex">\[
|\psi_2\rangle = CNOT_{21} |\psi_1\rangle = \frac{1}{\sqrt{2}}(CNOT_{21}|0000\rangle + CNOT_{21}|0010\rangle)
\]</div>
<div class="arithmatex">\[
CNOT_{21}|0000\rangle = |0000\rangle
\]</div>
<div class="arithmatex">\[
CNOT_{21}|0010\rangle = |0110\rangle
\]</div>
<div class="codehilite"><pre><span></span><code>So,
</code></pre></div>

<div class="arithmatex">\[
|\psi_2\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)
\]</div>
<ol start="3">
<li>Apply <span class="arithmatex">\(H_0\)</span> on qubit 0:</li>
</ol>
<div class="arithmatex">\[
|\psi_3\rangle = H_0 I_1 I_2 I_3 |\psi_2\rangle = \frac{1}{\sqrt{2}}(H_0|0000\rangle + H_0|0110\rangle)
\]</div>
<div class="arithmatex">\[
H_0|0000\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |1000\rangle)
\]</div>
<div class="arithmatex">\[
H_0|0110\rangle = \frac{1}{\sqrt{2}}(|0110\rangle + |1110\rangle)
\]</div>
<div class="codehilite"><pre><span></span><code>So,
</code></pre></div>

<div class="arithmatex">\[
|\psi_3\rangle = \frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)
\]</div>
<ol start="4">
<li>Apply <span class="arithmatex">\(CNOT_{03}\)</span> (control qubit 0, target qubit 3):</li>
</ol>
<div class="arithmatex">\[
|\psi_{\text{target}}\rangle = CNOT_{03} |\psi_3\rangle = \frac{1}{2}(CNOT_{03}|0000\rangle + CNOT_{03}|1000\rangle + CNOT_{03}|0110\rangle + CNOT_{03}|1110\rangle)
\]</div>
<div class="arithmatex">\[
CNOT_{03}|0000\rangle = |0000\rangle
\]</div>
<div class="arithmatex">\[
CNOT_{03}|1000\rangle = |1001\rangle
\]</div>
<div class="arithmatex">\[
CNOT_{03}|0110\rangle = |0110\rangle
\]</div>
<div class="arithmatex">\[
CNOT_{03}|1110\rangle = |1111\rangle
\]</div>
<div class="codehilite"><pre><span></span><code>The ideal final state is:
</code></pre></div>

<div class="arithmatex">\[
|\psi_{\text{target}}\rangle = \frac{1}{2}(|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle)
\]</div>
<p>We should verify that this state is indeed a logical GHZ state and is in the code space.
The stabilizers are <span class="arithmatex">\(S_X = X_0X_1X_2X_3\)</span> and <span class="arithmatex">\(S_Z = Z_0Z_1Z_2Z_3\)</span>.
For <span class="arithmatex">\(S_X\)</span>:
<span class="arithmatex">\(X_0X_1X_2X_3(|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle) = (|1111\rangle + |1001\rangle + |0110\rangle + |0000\rangle)\)</span>, so <span class="arithmatex">\(S_X|\psi_{\text{target}}\rangle = |\psi_{\text{target}}\rangle\)</span>.
For <span class="arithmatex">\(S_Z\)</span>:
<span class="arithmatex">\(Z_0Z_1Z_2Z_3(|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle) = (|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle)\)</span> (each term maps to itself because an even number of Z gates act on 1-qubits), so <span class="arithmatex">\(S_Z|\psi_{\text{target}}\rangle = |\psi_{\text{target}}\rangle\)</span>.
Thus, <span class="arithmatex">\(|\psi_{\text{target}}\rangle\)</span> is a valid codeword.</p>
<p>The logical operators are <span class="arithmatex">\(X_A = X_0X_2\)</span>, <span class="arithmatex">\(X_B=X_0X_1\)</span>, <span class="arithmatex">\(Z_A = Z_0Z_1\)</span>, <span class="arithmatex">\(Z_B = Z_0Z_2\)</span>.
The logical GHZ state <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> satisfies <span class="arithmatex">\(X_A X_B |\text{GHZ}\rangle = |\text{GHZ}\rangle\)</span> and <span class="arithmatex">\(Z_A Z_B |\text{GHZ}\rangle = |\text{GHZ}\rangle\)</span>.
Let&rsquo;s check this for <span class="arithmatex">\(|\psi_{\text{target}}\rangle\)</span>:
<span class="arithmatex">\(X_A X_B = (X_0X_2)(X_0X_1) = X_0^2 X_1 X_2 = I_0X_1X_2I_3\)</span>.
<span class="arithmatex">\(I_0X_1X_2I_3|\psi_{\text{target}}\rangle = \frac{1}{2}(X_1X_2|0000\rangle + X_1X_2|0110\rangle + X_1X_2|1001\rangle + X_1X_2|1111\rangle)\)</span>
<span class="arithmatex">\(= \frac{1}{2}(|0110\rangle + |0000\rangle + |1111\rangle + |1001\rangle) = |\psi_{\text{target}}\rangle\)</span>.
<span class="arithmatex">\(Z_A Z_B = (Z_0Z_1)(Z_0Z_2) = Z_0^2 Z_1 Z_2 = I_0Z_1Z_2I_3\)</span>.
<span class="arithmatex">\(I_0Z_1Z_2I_3|\psi_{\text{target}}\rangle = \frac{1}{2}(Z_1Z_2|0000\rangle + Z_1Z_2|0110\rangle + Z_1Z_2|1001\rangle + Z_1Z_2|1111\rangle)\)</span>
<span class="arithmatex">\(= \frac{1}{2}((+1)|0000\rangle + (-1)(-1)|0110\rangle + (+1)(+1)|1001\rangle + (-1)(-1)|1111\rangle)\)</span>
<span class="arithmatex">\(= \frac{1}{2}(|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle) = |\psi_{\text{target}}\rangle\)</span>.
The state <span class="arithmatex">\(|\psi_{\text{target}}\rangle\)</span> is indeed a physical representative of the logical GHZ state.</p>
<p>Now, let&rsquo;s incorporate the errors. Each CNOT gate is followed by a two-qubit depolarizing error channel. The Hadamard gates are assumed ideal.
Let <span class="arithmatex">\(\rho_0 = |0000\rangle\langle 0000|\)</span>.
The circuit is <span class="arithmatex">\(U_2 U_1\)</span>, where <span class="arithmatex">\(U_1 = (CNOT_{21})(H_2)\)</span> and <span class="arithmatex">\(U_2 = (CNOT_{03})(H_0)\)</span>.
The operations occur in this order: <span class="arithmatex">\(H_2\)</span>, <span class="arithmatex">\(CNOT_{21}\)</span>, <span class="arithmatex">\(H_0\)</span>, <span class="arithmatex">\(CNOT_{03}\)</span>.
The errors are applied after <span class="arithmatex">\(CNOT_{21}\)</span> and <span class="arithmatex">\(CNOT_{03}\)</span>.</p>
<ol>
<li>Initial state <span class="arithmatex">\(\rho_0 = |0000\rangle\langle 0000|\)</span>.</li>
<li>Apply <span class="arithmatex">\(H_2\)</span>: <span class="arithmatex">\(\rho_1 = H_2 \rho_0 H_2^\dagger = |\psi_1\rangle\langle\psi_1|\)</span>.</li>
<li>Apply <span class="arithmatex">\(CNOT_{21}\)</span>: <span class="arithmatex">\(\rho_2' = C_{21} \rho_1 C_{21}^\dagger = |\psi_2\rangle\langle\psi_2|\)</span>.</li>
<li>Apply depolarizing channel <span class="arithmatex">\(\mathcal{E}_{12}\)</span> on qubits (1,2) after <span class="arithmatex">\(CNOT_{21}\)</span>:</li>
</ol>
<div class="arithmatex">\[
\rho_2 = (1-p)\rho_2' + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} \rho_2' P_k^{(12)\dagger}
\]</div>
<div class="codehilite"><pre><span></span><code>where $P_k^{(12)}$ are the 15 non-identity two-qubit Paulis acting on qubits 1 and 2.
</code></pre></div>

<ol start="5">
<li>Apply <span class="arithmatex">\(H_0\)</span>: <span class="arithmatex">\(\rho_3' = H_0 \rho_2 H_0^\dagger\)</span>. Since <span class="arithmatex">\(H_0\)</span> acts on qubit 0, it commutes with <span class="arithmatex">\(P_k^{(12)}\)</span>.</li>
</ol>
<div class="arithmatex">\[
\rho_3' = (1-p)H_0\rho_2'H_0^\dagger + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} (H_0\rho_2'H_0^\dagger) P_k^{(12)\dagger}
\]</div>
<div class="codehilite"><pre><span></span><code>Let $\rho_3 = H_0|\psi_2\rangle\langle\psi_2|H_0^\dagger = |\psi_3\rangle\langle\psi_3|$. Then,
</code></pre></div>

<div class="arithmatex">\[
\rho_3' = (1-p)\rho_3 + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} \rho_3 P_k^{(12)\dagger}
\]</div>
<ol start="6">
<li>Apply <span class="arithmatex">\(CNOT_{03}\)</span>: <span class="arithmatex">\(\rho_4' = C_{03} \rho_3' C_{03}^\dagger\)</span>. Since <span class="arithmatex">\(C_{03}\)</span> acts on qubits 0 and 3, it commutes with <span class="arithmatex">\(P_k^{(12)}\)</span>.</li>
</ol>
<div class="arithmatex">\[
\rho_4' = (1-p)C_{03}\rho_3 C_{03}^\dagger + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} (C_{03}\rho_3 C_{03}^\dagger) P_k^{(12)\dagger}
\]</div>
<div class="codehilite"><pre><span></span><code>Let $\rho_{\text{target}} = C_{03}|\psi_3\rangle\langle\psi_3|C_{03}^\dagger = |\psi_{\text{target}}\rangle\langle\psi_{\text{target}}|$. Then,
</code></pre></div>

<div class="arithmatex">\[
\rho_4' = (1-p)\rho_{\text{target}} + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} \rho_{\text{target}} P_k^{(12)\dagger}
\]</div>
<ol start="7">
<li>Apply depolarizing channel <span class="arithmatex">\(\mathcal{E}_{03}\)</span> on qubits (0,3) after <span class="arithmatex">\(CNOT_{03}\)</span>:</li>
</ol>
<div class="arithmatex">\[
\rho_{\text{final}} = (1-p)\rho_4' + \frac{p}{15} \sum_{m=1}^{15} P_m^{(03)} \rho_4' P_m^{(03)\dagger}
\]</div>
<div class="codehilite"><pre><span></span><code>where $P_m^{(03)}$ are the 15 non-identity two-qubit Paulis acting on qubits 0 and 3.
</code></pre></div>

<p>Substitute <span class="arithmatex">\(\rho_4'\)</span> into the expression for <span class="arithmatex">\(\rho_{\text{final}}\)</span>:</p>
<div class="arithmatex">\[
\rho_{\text{final}} = (1-p) \left[ (1-p)\rho_{\text{target}} + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} \rho_{\text{target}} P_k^{(12)\dagger} \right]
\]</div>
<div class="arithmatex">\[
\qquad + \frac{p}{15} \sum_{m=1}^{15} P_m^{(03)} \left[ (1-p)\rho_{\text{target}} + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} \rho_{\text{target}} P_k^{(12)\dagger} \right] P_m^{(03)\dagger}
\]</div>
<p>The physical state fidelity is <span class="arithmatex">\(F = \langle\psi_{\text{target}}| \rho_{\text{final}} |\psi_{\text{target}}\rangle\)</span>. Let <span class="arithmatex">\(|\psi\rangle = |\psi_{\text{target}}\rangle\)</span>.
Since <span class="arithmatex">\(P_k^{(12)}\)</span> acts on qubits 1,2 and <span class="arithmatex">\(P_m^{(03)}\)</span> acts on qubits 0,3, they commute (<span class="arithmatex">\(P_m^{(03)} P_k^{(12)} = P_k^{(12)} P_m^{(03)}\)</span>). Also, <span class="arithmatex">\(P_k^\dagger = P_k\)</span>.</p>
<div class="arithmatex">\[
F = (1-p)^2 \langle\psi|\rho_{\text{target}}|\psi\rangle + (1-p)\frac{p}{15} \sum_{k=1}^{15} \langle\psi|P_k^{(12)}\rho_{\text{target}}P_k^{(12)}|\psi\rangle
\]</div>
<div class="arithmatex">\[
\qquad + (1-p)\frac{p}{15} \sum_{m=1}^{15} \langle\psi|P_m^{(03)}\rho_{\text{target}}P_m^{(03)}|\psi\rangle
\]</div>
<div class="arithmatex">\[
\qquad + \left(\frac{p}{15}\right)^2 \sum_{m=1}^{15} \sum_{k=1}^{15} \langle\psi|P_m^{(03)}P_k^{(12)}\rho_{\text{target}}P_k^{(12)}P_m^{(03)}|\psi\rangle
\]</div>
<p>Since <span class="arithmatex">\(\rho_{\text{target}} = |\psi\rangle\langle\psi|\)</span> and <span class="arithmatex">\(\langle\psi|\psi\rangle = 1\)</span>:</p>
<div class="arithmatex">\[
F = (1-p)^2 + (1-p)\frac{p}{15} \sum_{k=1}^{15} |\langle\psi|P_k^{(12)}|\psi\rangle|^2
\]</div>
<div class="arithmatex">\[
\qquad + (1-p)\frac{p}{15} \sum_{m=1}^{15} |\langle\psi|P_m^{(03)}|\psi\rangle|^2
\]</div>
<div class="arithmatex">\[
\qquad + \left(\frac{p}{15}\right)^2 \sum_{m=1}^{15} \sum_{k=1}^{15} |\langle\psi|P_m^{(03)}P_k^{(12)}|\psi\rangle|^2
\]</div>
<p>Now we need to compute the expectation values <span class="arithmatex">\(\langle\psi|P|\psi\rangle\)</span> for various Pauli operators <span class="arithmatex">\(P\)</span>.
<span class="arithmatex">\(|\psi\rangle = \frac{1}{2}(|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle)\)</span>.</p>
<ol>
<li>
<p><strong>For <span class="arithmatex">\(P_k^{(12)}\)</span> (Paulis on qubits 1 and 2):</strong>
    The set <span class="arithmatex">\(\mathcal{P}_{12}\)</span> consists of 15 non-identity Paulis of the form <span class="arithmatex">\(I \otimes P_1 \otimes P_2 \otimes I\)</span>.
    The expectation value <span class="arithmatex">\(\langle\psi|P_k^{(12)}|\psi\rangle\)</span> is non-zero only for specific correlators:</p>
<ul>
<li><span class="arithmatex">\(\langle\psi|X_1X_2|\psi\rangle = \frac{1}{4} \langle (0000) + (0110) + (1001) + (1111) | X_1X_2 | (0000) + (0110) + (1001) + (1111) \rangle\)</span>
    <span class="arithmatex">\(= \frac{1}{4} (\langle 0000|X_1X_2|0110\rangle + \langle 0110|X_1X_2|0000\rangle + \langle 1001|X_1X_2|1111\rangle + \langle 1111|X_1X_2|1001\rangle)\)</span>
    <span class="arithmatex">\(= \frac{1}{4} (1+1+1+1) = 1\)</span>. So <span class="arithmatex">\(|\langle\psi|X_1X_2|\psi\rangle|^2 = 1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Y_1Y_2|\psi\rangle\)</span>: <span class="arithmatex">\(Y_1Y_2|0000\rangle = -|0110\rangle\)</span>, <span class="arithmatex">\(Y_1Y_2|0110\rangle = -|0000\rangle\)</span>, <span class="arithmatex">\(Y_1Y_2|1001\rangle = -|1111\rangle\)</span>, <span class="arithmatex">\(Y_1Y_2|1111\rangle = -|1001\rangle\)</span>.
    So <span class="arithmatex">\(\langle\psi|Y_1Y_2|\psi\rangle = \frac{1}{4} (-1-1-1-1) = -1\)</span>. So <span class="arithmatex">\(|\langle\psi|Y_1Y_2|\psi\rangle|^2 = 1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Z_1Z_2|\psi\rangle = \frac{1}{4} (\langle 0000|Z_1Z_2|0000\rangle + \langle 0110|Z_1Z_2|0110\rangle + \langle 1001|Z_1Z_2|1001\rangle + \langle 1111|Z_1Z_2|1111\rangle)\)</span>
    <span class="arithmatex">\(= \frac{1}{4} (1 \cdot 1 + (-1) \cdot (-1) + 1 \cdot 1 + (-1) \cdot (-1)) = \frac{1}{4}(1+1+1+1) = 1\)</span>. So <span class="arithmatex">\(|\langle\psi|Z_1Z_2|\psi\rangle|^2 = 1\)</span>.
For all other 12 Paulis in <span class="arithmatex">\(\mathcal{P}_{12}\)</span> (e.g., <span class="arithmatex">\(X_1I_2\)</span>, <span class="arithmatex">\(I_1X_2\)</span>, <span class="arithmatex">\(X_1Y_2\)</span>), the expectation value is 0.
Thus, <span class="arithmatex">\(\sum_{k=1}^{15} |\langle\psi|P_k^{(12)}|\psi\rangle|^2 = 1+1+1 = 3\)</span>.</li>
</ul>
</li>
<li>
<p><strong>For <span class="arithmatex">\(P_m^{(03)}\)</span> (Paulis on qubits 0 and 3):</strong>
    Similarly, the set <span class="arithmatex">\(\mathcal{P}_{03}\)</span> consists of 15 non-identity Paulis of the form <span class="arithmatex">\(P_0 \otimes I_1 \otimes I_2 \otimes P_3\)</span>.
    The expectation values are non-zero for correlators <span class="arithmatex">\(X_0X_3, Y_0Y_3, Z_0Z_3\)</span>:</p>
<ul>
<li><span class="arithmatex">\(\langle\psi|X_0X_3|\psi\rangle = \frac{1}{4} (\langle 0000|X_0X_3|1001\rangle + \langle 0110|X_0X_3|1111\rangle + \langle 1001|X_0X_3|0000\rangle + \langle 1111|X_0X_3|0110\rangle) = 1\)</span>. So <span class="arithmatex">\(|\langle\psi|X_0X_3|\psi\rangle|^2 = 1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Y_0Y_3|\psi\rangle = -1\)</span>. So <span class="arithmatex">\(|\langle\psi|Y_0Y_3|\psi\rangle|^2 = 1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Z_0Z_3|\psi\rangle = 1\)</span>. So <span class="arithmatex">\(|\langle\psi|Z_0Z_3|\psi\rangle|^2 = 1\)</span>.
For all other 12 Paulis in <span class="arithmatex">\(\mathcal{P}_{03}\)</span>, the expectation value is 0.
Thus, <span class="arithmatex">\(\sum_{m=1}^{15} |\langle\psi|P_m^{(03)}|\psi\rangle|^2 = 1+1+1 = 3\)</span>.</li>
</ul>
</li>
<li>
<p><strong>For <span class="arithmatex">\(P_m^{(03)}P_k^{(12)}\)</span> (product of Paulis from disjoint sets):</strong>
    These are 4-qubit Paulis where <span class="arithmatex">\(P_m \in \mathcal{P}_{03}\)</span> and <span class="arithmatex">\(P_k \in \mathcal{P}_{12}\)</span>.
    An expectation value <span class="arithmatex">\(\langle\psi|P_m P_k|\psi\rangle\)</span> is non-zero only if <span class="arithmatex">\(P_m\)</span> and <span class="arithmatex">\(P_k\)</span> are two-qubit Paulis (not single qubit Paulis like <span class="arithmatex">\(X_0 I_3\)</span>).
    This means <span class="arithmatex">\(P_m \in \{X_0X_3, Y_0Y_3, Z_0Z_3\}\)</span> (3 terms) and <span class="arithmatex">\(P_k \in \{X_1X_2, Y_1Y_2, Z_1Z_2\}\)</span> (3 terms).
    There are <span class="arithmatex">\(3 \times 3 = 9\)</span> such combinations. Let <span class="arithmatex">\(A = P_m^{(03)}\)</span> and <span class="arithmatex">\(B = P_k^{(12)}\)</span>.</p>
<ul>
<li><span class="arithmatex">\(\langle\psi|X_0X_3 X_1X_2|\psi\rangle = \langle\psi|X_0X_1X_2X_3|\psi\rangle = \langle\psi|S_X|\psi\rangle = 1\)</span>. So <span class="arithmatex">\(1^2=1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|X_0X_3 Y_1Y_2|\psi\rangle = 0\)</span>. So <span class="arithmatex">\(0^2=0\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|X_0X_3 Z_1Z_2|\psi\rangle = \frac{1}{4} (\langle 0000|X_0Z_1Z_2X_3|1001\rangle + \langle 0110|X_0Z_1Z_2X_3|1111\rangle + \langle 1001|X_0Z_1Z_2X_3|0000\rangle + \langle 1111|X_0Z_1Z_2X_3|0110\rangle) = 1\)</span>. So <span class="arithmatex">\(1^2=1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Y_0Y_3 X_1X_2|\psi\rangle = 0\)</span>. So <span class="arithmatex">\(0^2=0\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Y_0Y_3 Y_1Y_2|\psi\rangle = \langle\psi|Y_0Y_1Y_2Y_3|\psi\rangle = 1\)</span>. So <span class="arithmatex">\(1^2=1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Y_0Y_3 Z_1Z_2|\psi\rangle = \frac{1}{4} (\langle 0000|Y_0Z_1Z_2Y_3|1001\rangle + \langle 0110|Y_0Z_1Z_2Y_3|1111\rangle + \langle 1001|Y_0Z_1Z_2Y_3|0000\rangle + \langle 1111|Y_0Z_1Z_2Y_3|0110\rangle) = 1\)</span>. So <span class="arithmatex">\(1^2=1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Z_0Z_3 X_1X_2|\psi\rangle = \frac{1}{4} (\langle 0000|Z_0X_1X_2Z_3|0110\rangle + \langle 0110|Z_0X_1X_2Z_3|0000\rangle + \langle 1001|Z_0X_1X_2Z_3|1111\rangle + \langle 1111|Z_0X_1X_2Z_3|1001\rangle) = 1\)</span>. So <span class="arithmatex">\(1^2=1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Z_0Z_3 Y_1Y_2|\psi\rangle = \frac{1}{4} (\langle 0000|Z_0Y_1Y_2Z_3|0110\rangle + \langle 0110|Z_0Y_1Y_2Z_3|0000\rangle + \langle 1001|Z_0Y_1Y_2Z_3|1111\rangle + \langle 1111|Z_0Y_1Y_2Z_3|1001\rangle) = -1\)</span>. So <span class="arithmatex">\((-1)^2=1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Z_0Z_3 Z_1Z_2|\psi\rangle = \langle\psi|Z_0Z_1Z_2Z_3|\psi\rangle = \langle\psi|S_Z|\psi\rangle = 1\)</span>. So <span class="arithmatex">\(1^2=1\)</span>.
Thus, <span class="arithmatex">\(\sum_{m=1}^{15} \sum_{k=1}^{15} |\langle\psi|P_m^{(03)}P_k^{(12)}|\psi\rangle|^2 = 1+0+1+0+1+1+1+1+1 = 7\)</span>.</li>
</ul>
</li>
</ol>
<p>Substitute these values back into the fidelity expression:</p>
<div class="arithmatex">\[
F = (1-p)^2 + (1-p)\frac{p}{15}(3) + (1-p)\frac{p}{15}(3) + \left(\frac{p}{15}\right)^2(7)
\]</div>
<div class="arithmatex">\[
F = (1-2p+p^2) + \frac{6p(1-p)}{15} + \frac{7p^2}{225}
\]</div>
<div class="arithmatex">\[
F = (1-2p+p^2) + \frac{2p(1-p)}{5} + \frac{7p^2}{225}
\]</div>
<div class="arithmatex">\[
F = 1 - 2p + p^2 + \frac{2p}{5} - \frac{2p^2}{5} + \frac{7p^2}{225}
\]</div>
<p>Group terms by powers of <span class="arithmatex">\(p\)</span>:</p>
<div class="arithmatex">\[
F = 1 + p\left(-2 + \frac{2}{5}\right) + p^2\left(1 - \frac{2}{5} + \frac{7}{225}\right)
\]</div>
<div class="arithmatex">\[
F = 1 + p\left(-\frac{10}{5} + \frac{2}{5}\right) + p^2\left(\frac{225}{225} - \frac{90}{225} + \frac{7}{225}\right)
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + p^2\left(\frac{225 - 90 + 7}{225}\right)
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + \frac{142p^2}{225}
\]</div>
<p>The final answer is <span class="arithmatex">\(\boxed{1 - \frac{8p}{5} + \frac{142p^2}{225}}\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Reflecting on the Fidelity Calculations</strong></p>
<p>Okay, so I&rsquo;ve been diligently working through this problem and I&rsquo;ve identified the crucial step where I went awry in my previous calculations for Subproblem 1. My initial derivation for the physical state fidelity, which accounts for the impact of a depolarizing noise model, was sound. My mistake lay in the summation of the expectation values.  I was failing to carefully account for the correct effect of the two-qubit Paulis, particularly with determining how they map the ideal state to orthogonal or other states within our system&rsquo;s basis.</p>
<p>Let&rsquo;s break it down again. The target state, the state we&rsquo;re trying to achieve, is a specific superposition of four computational basis states. Applying a two-qubit Pauli error channel effectively means we&rsquo;re dealing with one of fifteen different two-qubit Paulis, where each has the same probability of occurring.  To calculate the <em>physical</em> fidelity (that is, the probability of the actual physical state being correct), I need to calculate the <em>overlap</em> between the target state and the final state after the CNOT gates are implemented and the errors happen.</p>
<p>The key insight that I realized is that only specific two-qubit Pauli operators actually contribute to a <em>reduction</em> in the fidelity. Those are ones that &ldquo;flip&rdquo; the state in a way that creates orthogonality. Any operator that either does nothing to our target state or produces a global phase, doesn&rsquo;t actually affect the fidelity (the overlap is the same, up to a sign in the case of a phase). In other words,  I found that the  Pauli&rsquo;s <span class="arithmatex">\(X_1X_2\)</span>, <span class="arithmatex">\(Y_1Y_2\)</span>, and <span class="arithmatex">\(Z_1Z_2\)</span>  do precisely this, <em>within the definition of physical fidelity used in this problem</em>, and contribute to the fidelity. </p>
<p>Now, with a clear understanding of the math, I&rsquo;ve recomputed the terms and successfully arrived at the <em>correct expression for physical fidelity: <span class="arithmatex">\((1-\frac{4}{5}p)^2\)</span></em>.</p>
<p>This takes me nicely into Subproblem 2, where we want to find the <em>logical</em> state fidelity.  Since our circuit creates an error-detection code, we have to consider this aspect of the overall process.  Essentially, logical fidelity measures how well our target state is protected from errors that would move it into another logical state. This means we&rsquo;re dealing with <em>post-selection</em>: only keeping the runs where the measurement tells us no error happened.</p>
<p>I can make a few immediate deductions: post-selection, by definition, increases the fidelity. Since we&rsquo;re keeping any output only if no errors are detected, errors won&rsquo;t impact our final state&rsquo;s fidelity! Because all errors in my current state don&rsquo;t reduce the overlap <em>or</em> they are mapped into other &ldquo;valid&rdquo; states within our space (i.e., we see an <em>effective identity</em> up to some phase).  Thus, by the post-selection logic, our logical fidelity, in <em>this</em> problem scenario, will be 1!</p>
<p>As a final note, I now also have a refined grasp of the overall picture. The key is in realizing that the <em>types</em> of errors matter. It&rsquo;s not <em>just</em> about how likely an error <em>is</em>, it&rsquo;s about whether it has a significant, destabilizing <em>effect</em> on the logical state. In this case, that destabilizing, detrimental effect is completely absent.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p><strong>Subproblem 1: Recalculation of Physical State Fidelity</strong></p>
<p>First, let&rsquo;s establish the target ideal state. The circuit operations are applied from right to left:</p>
<div class="arithmatex">\[
U = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)
\]</div>
<p>Starting from the initial state <span class="arithmatex">\(|0000\rangle\)</span>:</p>
<ol>
<li>Apply <span class="arithmatex">\(H_2\)</span>: <span class="arithmatex">\(|\psi_1\rangle = H_2 |0000\rangle = |00+0\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)\)</span>.</li>
<li>Apply <span class="arithmatex">\(CNOT_{21}\)</span>: <span class="arithmatex">\(|\psi_2\rangle = CNOT_{21} |\psi_1\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\)</span>.</li>
<li>Apply <span class="arithmatex">\(H_0\)</span>: <span class="arithmatex">\(|\psi_3\rangle = H_0 |\psi_2\rangle = \frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)\)</span>.</li>
<li>Apply <span class="arithmatex">\(CNOT_{03}\)</span>: <span class="arithmatex">\(|\psi_{\text{target}}\rangle = CNOT_{03} |\psi_3\rangle = \frac{1}{2}(|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle)\)</span>.</li>
</ol>
<p>The final state density matrix <span class="arithmatex">\(\rho_{\text{final}}\)</span> is obtained by applying the sequence of gates and error channels. The ideal state is <span class="arithmatex">\(\rho_{\text{target}} = |\psi_{\text{target}}\rangle\langle\psi_{\text{target}}|\)</span>.
The error model applies a two-qubit depolarizing channel after each CNOT gate. Let <span class="arithmatex">\(p\)</span> be the probability of an error. If an error occurs, one of the 15 non-identity two-qubit Pauli operators <span class="arithmatex">\(P_E\)</span> is applied with probability <span class="arithmatex">\(p/15\)</span>.
The error channel <span class="arithmatex">\(\mathcal{E}(\rho)\)</span> after a CNOT gate <span class="arithmatex">\(U_C\)</span> transforms <span class="arithmatex">\(\rho'\)</span> to <span class="arithmatex">\(\rho\)</span>:</p>
<div class="arithmatex">\[
\rho = (1-p) \rho' + \frac{p}{15} \sum_{E \in \mathcal{P}_{15}} E \rho' E^\dagger
\]</div>
<p>where <span class="arithmatex">\(\mathcal{P}_{15}\)</span> is the set of 15 non-identity 2-qubit Pauli operators.</p>
<p>Let <span class="arithmatex">\(U_{\text{total}} = U_{CNOT_{03}} U_{H_0} U_{CNOT_{21}} U_{H_2}\)</span>.
The physical fidelity <span class="arithmatex">\(F_{\text{physical}}\)</span> is defined as <span class="arithmatex">\(F_{\text{physical}} = \langle\psi_{\text{target}}|\rho_{\text{final}}|\psi_{\text{target}}\rangle\)</span>.
Let <span class="arithmatex">\(|\psi\rangle = |\psi_{\text{target}}\rangle\)</span>.
The state evolution is:
<span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>
<span class="arithmatex">\(\rho_1 = H_2 \rho_0 H_2^\dagger\)</span>
<span class="arithmatex">\(\rho_2' = C_{21} \rho_1 C_{21}^\dagger\)</span>
<span class="arithmatex">\(\rho_2 = (1-p)\rho_2' + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} \rho_2' P_k^{(12)}\)</span>
<span class="arithmatex">\(\rho_3' = H_0 \rho_2 H_0^\dagger = (1-p) H_0\rho_2'H_0^\dagger + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} H_0\rho_2'H_0^\dagger P_k^{(12)}\)</span> (since <span class="arithmatex">\(H_0\)</span> commutes with <span class="arithmatex">\(P_k^{(12)}\)</span>)
<span class="arithmatex">\(\rho_4' = C_{03} \rho_3' C_{03}^\dagger = (1-p) C_{03}H_0\rho_2'H_0^\dagger C_{03}^\dagger + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} C_{03}H_0\rho_2'H_0^\dagger C_{03}^\dagger P_k^{(12)}\)</span> (since <span class="arithmatex">\(C_{03}\)</span> commutes with <span class="arithmatex">\(P_k^{(12)}\)</span>)
The term <span class="arithmatex">\(C_{03}H_0\rho_2'H_0^\dagger C_{03}^\dagger\)</span> is precisely <span class="arithmatex">\(|\psi\rangle\langle\psi|\)</span>.
So, <span class="arithmatex">\(\rho_4' = (1-p)|\psi\rangle\langle\psi| + \frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} |\psi\rangle\langle\psi| P_k^{(12)}\)</span>.
Finally, the second error channel after <span class="arithmatex">\(C_{03}\)</span>:
<span class="arithmatex">\(\rho_{\text{final}} = (1-p)\rho_4' + \frac{p}{15} \sum_{m=1}^{15} P_m^{(03)} \rho_4' P_m^{(03)}\)</span>.
Substituting <span class="arithmatex">\(\rho_4'\)</span> into <span class="arithmatex">\(\rho_{\text{final}}\)</span>:</p>
<div class="arithmatex">\[
\rho_{\text{final}} = (1-p)^2 |\psi\rangle\langle\psi| + (1-p)\frac{p}{15} \sum_{k=1}^{15} P_k^{(12)} |\psi\rangle\langle\psi| P_k^{(12)}
\]</div>
<div class="arithmatex">\[
\qquad + (1-p)\frac{p}{15} \sum_{m=1}^{15} P_m^{(03)} |\psi\rangle\langle\psi| P_m^{(03)} + \left(\frac{p}{15}\right)^2 \sum_{m=1}^{15} \sum_{k=1}^{15} P_m^{(03)} P_k^{(12)} |\psi\rangle\langle\psi| P_k^{(12)} P_m^{(03)}
\]</div>
<p>The physical state fidelity is <span class="arithmatex">\(F_{\text{physical}} = \langle\psi|\rho_{\text{final}}|\psi\rangle\)</span>. Since <span class="arithmatex">\(\langle\psi|P|\psi\rangle = \langle\psi|P|\psi\rangle^*\)</span>, the terms simplify to:</p>
<div class="arithmatex">\[
F_{\text{physical}} = (1-p)^2 + (1-p)\frac{p}{15} \sum_{k=1}^{15} |\langle\psi|P_k^{(12)}|\psi\rangle|^2
\]</div>
<div class="arithmatex">\[
\qquad + (1-p)\frac{p}{15} \sum_{m=1}^{15} |\langle\psi|P_m^{(03)}|\psi\rangle|^2 + \left(\frac{p}{15}\right)^2 \sum_{m=1}^{15} \sum_{k=1}^{15} |\langle\psi|P_m^{(03)}P_k^{(12)}|\psi\rangle|^2
\]</div>
<p>We need to calculate the sums of squared expectation values for the target state <span class="arithmatex">\(|\psi\rangle = \frac{1}{2}(|0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle)\)</span>.</p>
<ol>
<li>
<p><strong>For <span class="arithmatex">\(P_k^{(12)}\)</span> (Paulis on qubits 1 and 2):</strong>
    The only non-zero expectation values are:</p>
<ul>
<li><span class="arithmatex">\(\langle\psi|X_1X_2|\psi\rangle = 1\)</span>, so <span class="arithmatex">\(|\langle\psi|X_1X_2|\psi\rangle|^2 = 1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Y_1Y_2|\psi\rangle = -1\)</span>, so <span class="arithmatex">\(|\langle\psi|Y_1Y_2|\psi\rangle|^2 = 1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Z_1Z_2|\psi\rangle = 1\)</span>, so <span class="arithmatex">\(|\langle\psi|Z_1Z_2|\psi\rangle|^2 = 1\)</span>.
All other 12 Paulis in <span class="arithmatex">\(\mathcal{P}_{12}\)</span> have <span class="arithmatex">\(\langle\psi|P_k^{(12)}|\psi\rangle = 0\)</span>.
So, <span class="arithmatex">\(\sum_{k=1}^{15} |\langle\psi|P_k^{(12)}|\psi\rangle|^2 = 1+1+1 = 3\)</span>.</li>
</ul>
</li>
<li>
<p><strong>For <span class="arithmatex">\(P_m^{(03)}\)</span> (Paulis on qubits 0 and 3):</strong>
    Similarly, the only non-zero expectation values are:</p>
<ul>
<li><span class="arithmatex">\(\langle\psi|X_0X_3|\psi\rangle = 1\)</span>, so <span class="arithmatex">\(|\langle\psi|X_0X_3|\psi\rangle|^2 = 1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Y_0Y_3|\psi\rangle = -1\)</span>, so <span class="arithmatex">\(|\langle\psi|Y_0Y_3|\psi\rangle|^2 = 1\)</span>.</li>
<li><span class="arithmatex">\(\langle\psi|Z_0Z_3|\psi\rangle = 1\)</span>, so <span class="arithmatex">\(|\langle\psi|Z_0Z_3|\psi\rangle|^2 = 1\)</span>.
All other 12 Paulis in <span class="arithmatex">\(\mathcal{P}_{03}\)</span> have <span class="arithmatex">\(\langle\psi|P_m^{(03)}|\psi\rangle = 0\)</span>.
So, <span class="arithmatex">\(\sum_{m=1}^{15} |\langle\psi|P_m^{(03)}|\psi\rangle|^2 = 1+1+1 = 3\)</span>.</li>
</ul>
</li>
<li>
<p><strong>For <span class="arithmatex">\(P_m^{(03)}P_k^{(12)}\)</span> (product of Paulis from disjoint sets):</strong>
    Non-zero expectation values occur only when <span class="arithmatex">\(P_m^{(03)} \in \{X_0X_3, Y_0Y_3, Z_0Z_3\}\)</span> and <span class="arithmatex">\(P_k^{(12)} \in \{X_1X_2, Y_1Y_2, Z_1Z_2\}\)</span>. There are <span class="arithmatex">\(3 \times 3 = 9\)</span> such combinations. Detailed re-calculation shows that for each of these 9 combinations, the expectation value <span class="arithmatex">\(\langle\psi|P_m^{(03)}P_k^{(12)}|\psi\rangle\)</span> is either <span class="arithmatex">\(1\)</span> or <span class="arithmatex">\(-1\)</span>.
    For example:</p>
<ul>
<li><span class="arithmatex">\(\langle\psi|X_0X_3X_1X_2|\psi\rangle = 1\)</span></li>
<li><span class="arithmatex">\(\langle\psi|X_0X_3Y_1Y_2|\psi\rangle = -1\)</span></li>
<li><span class="arithmatex">\(\langle\psi|X_0X_3Z_1Z_2|\psi\rangle = 1\)</span></li>
<li><span class="arithmatex">\(\langle\psi|Y_0Y_3X_1X_2|\psi\rangle = -1\)</span></li>
<li><span class="arithmatex">\(\langle\psi|Y_0Y_3Y_1Y_2|\psi\rangle = 1\)</span></li>
<li><span class="arithmatex">\(\langle\psi|Y_0Y_3Z_1Z_2|\psi\rangle = -1\)</span></li>
<li><span class="arithmatex">\(\langle\psi|Z_0Z_3X_1X_2|\psi\rangle = 1\)</span></li>
<li><span class="arithmatex">\(\langle\psi|Z_0Z_3Y_1Y_2|\psi\rangle = -1\)</span></li>
<li><span class="arithmatex">\(\langle\psi|Z_0Z_3Z_1Z_2|\psi\rangle = 1\)</span>
In all 9 cases, the squared expectation value is 1.
So, <span class="arithmatex">\(\sum_{m=1}^{15} \sum_{k=1}^{15} |\langle\psi|P_m^{(03)}P_k^{(12)}|\psi\rangle|^2 = 9\)</span>.</li>
</ul>
</li>
</ol>
<p>Substitute these values into the fidelity expression:</p>
<div class="arithmatex">\[
F_{\text{physical}} = (1-p)^2 + (1-p)\frac{p}{15}(3) + (1-p)\frac{p}{15}(3) + \left(\frac{p}{15}\right)^2(9)
\]</div>
<div class="arithmatex">\[
F_{\text{physical}} = (1-2p+p^2) + \frac{6p(1-p)}{15} + \frac{9p^2}{225}
\]</div>
<div class="arithmatex">\[
F_{\text{physical}} = 1 - 2p + p^2 + \frac{2p}{5} - \frac{2p^2}{5} + \frac{9p^2}{225}
\]</div>
<div class="arithmatex">\[
F_{\text{physical}} = 1 + p\left(-2 + \frac{2}{5}\right) + p^2\left(1 - \frac{2}{5} + \frac{9}{225}\right)
\]</div>
<div class="arithmatex">\[
F_{\text{physical}} = 1 - \frac{8p}{5} + p^2\left(\frac{225 - 90 + 9}{225}\right)
\]</div>
<div class="arithmatex">\[
F_{\text{physical}} = 1 - \frac{8p}{5} + \frac{144p^2}{225}
\]</div>
<p>Simplifying the fraction <span class="arithmatex">\(\frac{144}{225}\)</span> by dividing by 9 gives <span class="arithmatex">\(\frac{16}{25}\)</span>:</p>
<div class="arithmatex">\[
F_{\text{physical}} = 1 - \frac{8p}{5} + \frac{16p^2}{25} = \left(1 - \frac{4p}{5}\right)^2
\]</div>
<p>This matches the provided correct answer.</p>
<p><strong>Subproblem 2: Logical State Fidelity with Post-Selection</strong></p>
<p>The logical state fidelity with post-selection on detectable errors is given by:</p>
<div class="arithmatex">\[
F_{\text{logical}} = \frac{\langle\psi_{\text{target}}|P_{\text{code}}\rho_{\text{final}}P_{\text{code}}|\psi_{\text{target}}\rangle}{\mathrm{Tr}(P_{\text{code}}\rho_{\text{final}})}
\]</div>
<p>Since <span class="arithmatex">\(|\psi_{\text{target}}\rangle\)</span> is a codeword, <span class="arithmatex">\(P_{\text{code}}|\psi_{\text{target}}\rangle = |\psi_{\text{target}}\rangle\)</span>.
Thus the numerator becomes <span class="arithmatex">\(\langle\psi_{\text{target}}|\rho_{\text{final}}|\psi_{\text{target}}\rangle = F_{\text{physical}}\)</span>.</p>
<p>The denominator, <span class="arithmatex">\(\mathrm{Tr}(P_{\text{code}}\rho_{\text{final}})\)</span>, represents the probability that no error is detected (i.e., the final state is in the code space).
Let <span class="arithmatex">\(E\)</span> be a general Pauli error operator (which could be <span class="arithmatex">\(I\)</span>, <span class="arithmatex">\(P_k^{(12)}\)</span>, <span class="arithmatex">\(P_m^{(03)}\)</span>, or <span class="arithmatex">\(P_m^{(03)}P_k^{(12)}\)</span>). A term in <span class="arithmatex">\(\rho_{\text{final}}\)</span> is proportional to <span class="arithmatex">\(E|\psi\rangle\langle\psi|E^\dagger\)</span>.
The trace of <span class="arithmatex">\(P_{\text{code}}\)</span> with such a term is <span class="arithmatex">\(\mathrm{Tr}(P_{\text{code}} E|\psi\rangle\langle\psi|E^\dagger) = \langle\psi|E^\dagger P_{\text{code}} E|\psi\rangle\)</span>.
Since <span class="arithmatex">\(P_{\text{code}}\)</span> is the projector onto the code space, <span class="arithmatex">\(P_{\text{code}} E|\psi\rangle\)</span> is non-zero only if <span class="arithmatex">\(E|\psi\rangle\)</span> is itself a codeword. This happens if and only if <span class="arithmatex">\(E\)</span> commutes with all stabilizers (i.e., <span class="arithmatex">\(E\)</span> is in the normalizer <span class="arithmatex">\(\mathcal{N}\)</span> of the code). If <span class="arithmatex">\(E \in \mathcal{N}\)</span>, then <span class="arithmatex">\(E|\psi\rangle\)</span> is a codeword, so <span class="arithmatex">\(P_{\text{code}}E|\psi\rangle = E|\psi\rangle\)</span>. Thus <span class="arithmatex">\(\langle\psi|E^\dagger P_{\text{code}} E|\psi\rangle = \langle\psi|E^\dagger E|\psi\rangle = \langle\psi|\psi\rangle = 1\)</span>. If <span class="arithmatex">\(E \notin \mathcal{N}\)</span>, then <span class="arithmatex">\(\langle\psi|E^\dagger P_{\text{code}} E|\psi\rangle = 0\)</span>.</p>
<p>Therefore, the denominator is the sum of coefficients for all terms where the error operator is in the normalizer <span class="arithmatex">\(\mathcal{N}\)</span>:</p>
<div class="arithmatex">\[
\mathrm{Tr}(P_{\text{code}}\rho_{\text{final}}) = (1-p)^2 \cdot 1 + (1-p)\frac{p}{15} \sum_{k \text{ s.t. } P_k^{(12)} \in \mathcal{N}} 1
\]</div>
<div class="arithmatex">\[
\qquad + (1-p)\frac{p}{15} \sum_{m \text{ s.t. } P_m^{(03)} \in \mathcal{N}} 1 + \left(\frac{p}{15}\right)^2 \sum_{m,k \text{ s.t. } P_m^{(03)}P_k^{(12)} \in \mathcal{N}} 1
\]</div>
<p>We need to identify which of the Pauli error operators are in the normalizer <span class="arithmatex">\(\mathcal{N}\)</span>. An operator <span class="arithmatex">\(E\)</span> is in <span class="arithmatex">\(\mathcal{N}\)</span> if <span class="arithmatex">\([E, S_X] = 0\)</span> and <span class="arithmatex">\([E, S_Z] = 0\)</span>.
The stabilizers are <span class="arithmatex">\(S_X = X_0X_1X_2X_3\)</span> and <span class="arithmatex">\(S_Z = Z_0Z_1Z_2Z_3\)</span>.</p>
<ol>
<li>
<p><strong>For <span class="arithmatex">\(P_k^{(12)}\)</span> (Paulis on qubits 1 and 2):</strong></p>
<ul>
<li><span class="arithmatex">\(X_1X_2\)</span>: Commutes with <span class="arithmatex">\(S_X\)</span> (2 anti-commutations) and <span class="arithmatex">\(S_Z\)</span> (2 anti-commutations). So <span class="arithmatex">\(X_1X_2 \in \mathcal{N}\)</span>.</li>
<li><span class="arithmatex">\(Y_1Y_2\)</span>: Commutes with <span class="arithmatex">\(S_X\)</span> (2 anti-commutations) and <span class="arithmatex">\(S_Z\)</span> (2 anti-commutations). So <span class="arithmatex">\(Y_1Y_2 \in \mathcal{N}\)</span>.</li>
<li><span class="arithmatex">\(Z_1Z_2\)</span>: Commutes with <span class="arithmatex">\(S_X\)</span> (0 anti-commutations) and <span class="arithmatex">\(S_Z\)</span> (0 anti-commutations). So <span class="arithmatex">\(Z_1Z_2 \in \mathcal{N}\)</span>.
All other 12 Paulis in <span class="arithmatex">\(\mathcal{P}_{12}\)</span> (e.g., <span class="arithmatex">\(X_1I_2\)</span>, <span class="arithmatex">\(X_1Z_2\)</span>) will anti-commute with at least one stabilizer.
Thus, there are 3 such terms in <span class="arithmatex">\(\mathcal{N}\)</span>.</li>
</ul>
</li>
<li>
<p><strong>For <span class="arithmatex">\(P_m^{(03)}\)</span> (Paulis on qubits 0 and 3):</strong></p>
<ul>
<li><span class="arithmatex">\(X_0X_3\)</span>: Commutes with <span class="arithmatex">\(S_X\)</span> and <span class="arithmatex">\(S_Z\)</span>. So <span class="arithmatex">\(X_0X_3 \in \mathcal{N}\)</span>.</li>
<li><span class="arithmatex">\(Y_0Y_3\)</span>: Commutes with <span class="arithmatex">\(S_X\)</span> and <span class="arithmatex">\(S_Z\)</span>. So <span class="arithmatex">\(Y_0Y_3 \in \mathcal{N}\)</span>.</li>
<li><span class="arithmatex">\(Z_0Z_3\)</span>: Commutes with <span class="arithmatex">\(S_X\)</span> and <span class="arithmatex">\(S_Z\)</span>. So <span class="arithmatex">\(Z_0Z_3 \in \mathcal{N}\)</span>.
Thus, there are 3 such terms in <span class="arithmatex">\(\mathcal{N}\)</span>.</li>
</ul>
</li>
<li>
<p><strong>For <span class="arithmatex">\(P_m^{(03)}P_k^{(12)}\)</span> (products of Paulis from disjoint sets):</strong>
    A product <span class="arithmatex">\(E_1 E_2\)</span> where <span class="arithmatex">\(E_1\)</span> acts on (0,3) and <span class="arithmatex">\(E_2\)</span> acts on (1,2) is in <span class="arithmatex">\(\mathcal{N}\)</span> if and only if both <span class="arithmatex">\(E_1 \in \mathcal{N}\)</span> and <span class="arithmatex">\(E_2 \in \mathcal{N}\)</span>.
    This means <span class="arithmatex">\(P_m^{(03)} \in \{X_0X_3, Y_0Y_3, Z_0Z_3\}\)</span> and <span class="arithmatex">\(P_k^{(12)} \in \{X_1X_2, Y_1Y_2, Z_1Z_2\}\)</span>.
    There are <span class="arithmatex">\(3 \times 3 = 9\)</span> such combinations. All these 9 terms are in <span class="arithmatex">\(\mathcal{N}\)</span>.</p>
</li>
</ol>
<p>Substitute these counts into the expression for <span class="arithmatex">\(\mathrm{Tr}(P_{\text{code}}\rho_{\text{final}})\)</span>:</p>
<div class="arithmatex">\[
\mathrm{Tr}(P_{\text{code}}\rho_{\text{final}}) = (1-p)^2 \cdot 1 + (1-p)\frac{p}{15}(3) + (1-p)\frac{p}{15}(3) + \left(\frac{p}{15}\right)^2(9)
\]</div>
<p>This expression is identical to the one calculated for <span class="arithmatex">\(F_{\text{physical}}\)</span> in Subproblem 1.</p>
<div class="arithmatex">\[
\mathrm{Tr}(P_{\text{code}}\rho_{\text{final}}) = \left(1 - \frac{4p}{5}\right)^2
\]</div>
<p>Therefore, the logical state fidelity with post-selection is:</p>
<div class="arithmatex">\[
F_{\text{logical}} = \frac{F_{\text{physical}}}{\mathrm{Tr}(P_{\text{code}}\rho_{\text{final}})} = \frac{\left(1 - \frac{4p}{5}\right)^2}{\left(1 - \frac{4p}{5}\right)^2} = 1
\]</div>
<p>This implies that all errors that reduce the physical fidelity (i.e., those with non-zero <span class="arithmatex">\(|\langle\psi|E|\psi\rangle|^2\)</span>) are also undetectable errors (i.e., <span class="arithmatex">\(E \in \mathcal{N}\)</span>). Furthermore, as seen in the recalculation for Subproblem 1, these errors specifically map <span class="arithmatex">\(|\psi\rangle\)</span> to <span class="arithmatex">\(\pm|\psi\rangle\)</span>, meaning they do not change the logical state itself. Errors that <em>would</em> change the logical state or lead to a detectable syndrome have zero overlap with <span class="arithmatex">\(|\psi\rangle\)</span> and thus don&rsquo;t contribute to the numerator (physical fidelity).</p>
<p>The final answer is <span class="arithmatex">\(\boxed{1}\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.255579
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>