<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><p>The problem asks us to calculate the logical state fidelity of a prepared logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code, under a specific error model and post-selection conditions.</p>
<p>The [[4,2,2]] code uses 4 physical qubits (0,1,2,3). The stabilizers are <span class="arithmatex">\(S_1 = X_0 X_1 X_2 X_3\)</span> and <span class="arithmatex">\(S_2 = Z_0 Z_1 Z_2 Z_3\)</span>. The logical operators are <span class="arithmatex">\(X_A = X_0 I_1 X_2 I_3\)</span>, <span class="arithmatex">\(X_B = X_0 X_1 I_2 I_3\)</span>, <span class="arithmatex">\(Z_A = Z_0 Z_1 I_2 I_3\)</span>, <span class="arithmatex">\(Z_B = Z_0 I_1 Z_2 I_3\)</span>. The target state is the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span>, which is an eigenstate of <span class="arithmatex">\(Z_A\)</span> and <span class="arithmatex">\(Z_B\)</span> with eigenvalue +1.</p>
<p>The circuit for state preparation involves 5 physical qubits (0,1,2,3,4) and is given in reverse order of operation (right to left):</p>
<div class="arithmatex">\[
U_{circuit} = M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>We assume the initial state is <span class="arithmatex">\(|00000\rangle\)</span>.</p>
<ol>
<li>
<p><strong>Ideal State Calculation:</strong>
    Let&rsquo;s trace the initial state <span class="arithmatex">\(|00000\rangle\)</span> through the circuit unitaries. The Hadamard gate <span class="arithmatex">\(H_1\)</span> acts on qubit 1. All CNOT gates are of the form <span class="arithmatex">\(CNOT_{c,t}\)</span>.
    <span class="arithmatex">\(|\psi_0\rangle = |00000\rangle\)</span>
    <span class="arithmatex">\(H_1: |\psi_1\rangle = |0\rangle_0 \frac{|0\rangle_1+|1\rangle_1}{\sqrt{2}} |0\rangle_2 |0\rangle_3 |0\rangle_4\)</span>
    <span class="arithmatex">\(CNOT_{12}: |\psi_2\rangle = |0\rangle_0 \frac{|0\rangle_1|0\rangle_2+|1\rangle_1|1\rangle_2}{\sqrt{2}} |0\rangle_3 |0\rangle_4\)</span>
    <span class="arithmatex">\(CNOT_{10}: |\psi_3\rangle = \frac{1}{\sqrt{2}} (|00000\rangle + |11100\rangle)\)</span>
    <span class="arithmatex">\(CNOT_{23}: |\psi_4\rangle = \frac{1}{\sqrt{2}} (|00000\rangle + |11110\rangle)\)</span>
    <span class="arithmatex">\(CNOT_{34}: |\psi_5\rangle = \frac{1}{\sqrt{2}} (|00000\rangle + |11111\rangle)\)</span>
    <span class="arithmatex">\(CNOT_{04}: |\psi_6\rangle = \frac{1}{\sqrt{2}} (|00000\rangle + |11110\rangle)\)</span>
    This is the ideal state before measurement on qubit 4. Let&rsquo;s call this <span class="arithmatex">\(|\Psi_{ideal}\rangle = \frac{1}{\sqrt{2}} (|0000\rangle_{0123} + |1111\rangle_{0123}) |0\rangle_4\)</span>.
    After measurement <span class="arithmatex">\(M_4\)</span> yields <span class="arithmatex">\(|0\rangle\)</span>, the state of qubits 0-3 is <span class="arithmatex">\(|\Phi_L\rangle = \frac{1}{\sqrt{2}} (|0000\rangle + |1111\rangle)\)</span>.
    Let&rsquo;s check if <span class="arithmatex">\(|\Phi_L\rangle\)</span> is the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state:
    <span class="arithmatex">\(S_1 |\Phi_L\rangle = XXXX |\Phi_L\rangle = |\Phi_L\rangle\)</span>.
    <span class="arithmatex">\(S_2 |\Phi_L\rangle = ZZZZ |\Phi_L\rangle = |\Phi_L\rangle\)</span>.
    <span class="arithmatex">\(Z_A |\Phi_L\rangle = Z_0 Z_1 I_2 I_3 |\Phi_L\rangle = |\Phi_L\rangle\)</span>.
    <span class="arithmatex">\(Z_B |\Phi_L\rangle = Z_0 I_1 Z_2 I_3 |\Phi_L\rangle = |\Phi_L\rangle\)</span>.
    Indeed, <span class="arithmatex">\(|\Phi_L\rangle\)</span> is the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state.</p>
</li>
<li>
<p><strong>Error Model and Fidelity Definition:</strong>
    Each CNOT gate <span class="arithmatex">\(C_k\)</span> is followed by a two-qubit depolarizing error channel <span class="arithmatex">\(\mathcal{E}_k\)</span>.
    <span class="arithmatex">\(\mathcal{E}_k(\rho) = (1-p)\rho + \frac{p}{15} \sum_{P_{ij} \neq I} P_{ij} \rho P_{ij}\)</span>.
    We work to first order in <span class="arithmatex">\(p\)</span>. The state after all operations and error channels is <span class="arithmatex">\(\rho_f\)</span>.
    The fidelity is <span class="arithmatex">\(F = \frac{\langle \Phi_L | \text{Tr}_4(P_{code} P_{M_0} \rho_f P_{M_0} P_{code}) | \Phi_L \rangle}{\text{Tr}(\text{Tr}_4(P_{code} P_{M_0} \rho_f P_{M_0} P_{code}))}\)</span>, where <span class="arithmatex">\(P_{M_0} = I_{0123} \otimes |0\rangle\langle 0|_4\)</span> and <span class="arithmatex">\(P_{code} = \frac{1}{4}(I+S_1)(I+S_2)\)</span>.</p>
<p>Let <span class="arithmatex">\(U_k\)</span> be the <span class="arithmatex">\(k\)</span>-th CNOT gate in execution order (from right to left in the problem statement).
<span class="arithmatex">\(U_1 = H_1\)</span> (no error channel)
<span class="arithmatex">\(U_2 = CNOT_{12}\)</span>
<span class="arithmatex">\(U_3 = CNOT_{10}\)</span>
<span class="arithmatex">\(U_4 = CNOT_{23}\)</span>
<span class="arithmatex">\(U_5 = CNOT_{34}\)</span>
<span class="arithmatex">\(U_6 = CNOT_{04}\)</span>
An error <span class="arithmatex">\(P_{ij}\)</span> occurring after <span class="arithmatex">\(U_k\)</span> is effectively equivalent to an error <span class="arithmatex">\(E_{prop} = U_{post,k} P_{ij} U_{post,k}^\dagger\)</span> acting on the ideal state <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span>, where <span class="arithmatex">\(U_{post,k} = U_6 \dots U_{k+1}\)</span>.
<span class="arithmatex">\(E_{prop}\)</span> is a 5-qubit Pauli operator, <span class="arithmatex">\(E_{prop} = E_{0123} \otimes E_4\)</span>.</p>
<p>We are interested in errors that are <em>not detected</em> by post-selection:
1.  The ancilla measurement <span class="arithmatex">\(M_4\)</span> yields <span class="arithmatex">\(|0\rangle\)</span>. This means <span class="arithmatex">\(E_4 \in \{I_4, Z_4\}\)</span>.
2.  The state must be in the code space. This means <span class="arithmatex">\(E_{0123}\)</span> must commute with both stabilizers <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>. If <span class="arithmatex">\(E_{0123}\)</span> anti-commutes with <span class="arithmatex">\(S_1\)</span> or <span class="arithmatex">\(S_2\)</span>, it&rsquo;s detected.
Among these undetected errors:
-   If <span class="arithmatex">\(E_{0123}|\Phi_L\rangle = |\Phi_L\rangle\)</span> (e.g., <span class="arithmatex">\(E_{0123}\)</span> is a product of stabilizers and logical Z operators), it contributes to the numerator (<span class="arithmatex">\(N_0\)</span>).
-   If <span class="arithmatex">\(E_{0123}|\Phi_L\rangle \neq |\Phi_L\rangle\)</span> but is still a valid logical state (e.g., <span class="arithmatex">\(E_{0123}\)</span> is a logical X operator), it contributes only to the denominator (<span class="arithmatex">\(N_L\)</span>).</p>
<p>The infidelity is <span class="arithmatex">\(p \frac{N_L}{15}\)</span>, where <span class="arithmatex">\(N_L\)</span> is the total count of errors from all 5 CNOT gates that satisfy conditions 1 and 2, but result in a logical state different from <span class="arithmatex">\(|\Phi_L\rangle\)</span>.</p>
<p>Let&rsquo;s use the <span class="arithmatex">\((\vec{x}, \vec{z})\)</span> formalism for Pauli propagation. A Pauli <span class="arithmatex">\(P\)</span> on 5 qubits is represented by two binary vectors <span class="arithmatex">\((\vec{x}, \vec{z})\)</span>, where <span class="arithmatex">\(P = \prod_{j=0}^4 X_j^{x_j} Z_j^{z_j}\)</span>.
The transformation for <span class="arithmatex">\(CNOT_{c,t}\)</span> on an error <span class="arithmatex">\(E=(\vec{x},\vec{z})\)</span> is:
<span class="arithmatex">\(x_c \to x_c \oplus x_t\)</span>
<span class="arithmatex">\(z_c \to z_c\)</span>
<span class="arithmatex">\(x_t \to x_t\)</span>
<span class="arithmatex">\(z_t \to z_t \oplus z_c\)</span></p>
<p>Let&rsquo;s analyze each CNOT gate:</p>
<p><strong>1. Errors after <span class="arithmatex">\(CNOT_{04}\)</span> (qubits 0,4, <span class="arithmatex">\(U_{post,6}=I\)</span>)</strong>
An original error <span class="arithmatex">\(P_{04}\)</span> (on qubits 0 and 4) is directly <span class="arithmatex">\(E_{prop} = P_{04}\)</span>.
-   <span class="arithmatex">\(E_4 \in \{X_4, Y_4\}\)</span> (8 errors): These flip qubit 4, so they are detected by <span class="arithmatex">\(M_4\)</span>.
-   <span class="arithmatex">\(E_4 \in \{I_4, Z_4\}\)</span> (7 errors, e.g. <span class="arithmatex">\(X_0 I_4, Y_0 I_4, Z_0 I_4, I_0 Z_4, X_0 Z_4, Y_0 Z_4, Z_0 Z_4\)</span>).
    For these, <span class="arithmatex">\(E_{0123}\)</span> is <span class="arithmatex">\(P_0\)</span>.
    -   <span class="arithmatex">\(P_0=X_0\)</span>: anti-commutes with <span class="arithmatex">\(S_1=XXXX\)</span>. Detected.
    -   <span class="arithmatex">\(P_0=Y_0\)</span>: anti-commutes with <span class="arithmatex">\(S_1=XXXX\)</span> and <span class="arithmatex">\(S_2=ZZZZ\)</span>. Detected.
    -   <span class="arithmatex">\(P_0=Z_0\)</span>: anti-commutes with <span class="arithmatex">\(S_2=ZZZZ\)</span>. Detected.
    Therefore, for <span class="arithmatex">\(CNOT_{04}\)</span>, <span class="arithmatex">\(N_0=0\)</span> and <span class="arithmatex">\(N_L=0\)</span>.</p>
<p><strong>2. Errors after <span class="arithmatex">\(CNOT_{34}\)</span> (qubits 3,4, <span class="arithmatex">\(U_{post,5}=CNOT_{04}\)</span>)</strong>
Original error <span class="arithmatex">\(P_{34}\)</span> on qubits 3,4. Initial <span class="arithmatex">\((\vec{x},\vec{z})=(0,0,0,x_3,x_4), (0,0,0,z_3,z_4)\)</span>.
Applying <span class="arithmatex">\(CNOT_{04}\)</span> (control 0, target 4):
<span class="arithmatex">\(x_0^{new} = x_0 \oplus x_4 = 0 \oplus x_4 = x_4\)</span>.
<span class="arithmatex">\(z_0^{new} = z_0 = 0\)</span>.
<span class="arithmatex">\(x_4^{new} = x_4\)</span>.
<span class="arithmatex">\(z_4^{new} = z_4 \oplus z_0 = z_4 \oplus 0 = z_4\)</span>.
Propagated error <span class="arithmatex">\((\vec{x}',\vec{z}')=(x_4,0,0,x_3,x_4), (0,0,0,z_3,z_4)\)</span>.
So <span class="arithmatex">\(E_{0123} = X_0^{x_4} X_3^{x_3} Z_3^{z_3}\)</span>. And <span class="arithmatex">\(E_4 = X_4^{x_4} Z_4^{z_4}\)</span>.
-   Ancilla detection (<span class="arithmatex">\(x_4=1\)</span>): If <span class="arithmatex">\(x_4=1\)</span>, <span class="arithmatex">\(E_4\)</span> contains <span class="arithmatex">\(X_4\)</span> or <span class="arithmatex">\(Y_4\)</span>, detected by <span class="arithmatex">\(M_4\)</span>. (8 errors)
-   No ancilla detection (<span class="arithmatex">\(x_4=0\)</span>): <span class="arithmatex">\(P_4 \in \{I_4, Z_4\}\)</span>. <span class="arithmatex">\(E_4 = Z_4^{z_4}\)</span>. <span class="arithmatex">\(E_{0123} = X_3^{x_3} Z_3^{z_3} = P_3\)</span>. (7 errors: <span class="arithmatex">\(X_3 I_4, Y_3 I_4, Z_3 I_4, I_3 Z_4, X_3 Z_4, Y_3 Z_4, Z_3 Z_4\)</span>).
    We check <span class="arithmatex">\(P_3\)</span> for detection by code (<span class="arithmatex">\(S_1, S_2\)</span>) and logical state change (<span class="arithmatex">\(Z_A, Z_B\)</span>).
    -   <span class="arithmatex">\(P_3 = I_3\)</span>: (error <span class="arithmatex">\(I_3 Z_4\)</span>, <span class="arithmatex">\(x_3=0, z_3=0\)</span>) <span class="arithmatex">\(E_{0123}=I\)</span>. Commutes with <span class="arithmatex">\(S_1, S_2, Z_A, Z_B\)</span>. <span class="arithmatex">\(N_0 \leftarrow N_0+1\)</span>.
    -   <span class="arithmatex">\(P_3 = X_3\)</span>: Anti-commutes <span class="arithmatex">\(S_1\)</span>. Detected.
    -   <span class="arithmatex">\(P_3 = Y_3\)</span>: Anti-commutes <span class="arithmatex">\(S_1, S_2\)</span>. Detected.
    -   <span class="arithmatex">\(P_3 = Z_3\)</span>: Anti-commutes <span class="arithmatex">\(S_2\)</span>. Detected.
For <span class="arithmatex">\(CNOT_{34}\)</span>, <span class="arithmatex">\(N_0=1\)</span>, <span class="arithmatex">\(N_L=0\)</span>.</p>
<p><strong>3. Errors after <span class="arithmatex">\(CNOT_{23}\)</span> (qubits 2,3, <span class="arithmatex">\(U_{post,4}=CNOT_{34} CNOT_{04}\)</span>)</strong>
Original error <span class="arithmatex">\(P_{23}\)</span>. Initial <span class="arithmatex">\((\vec{x},\vec{z})=(0,0,x_2,x_3,0), (0,0,z_2,z_3,0)\)</span>.
Applying <span class="arithmatex">\(CNOT_{34}\)</span> (control 3, target 4):
<span class="arithmatex">\(x_3^{new} = x_3\)</span>. <span class="arithmatex">\(z_3^{new} = z_3\)</span>. <span class="arithmatex">\(x_4^{new} = x_4=0\)</span>. <span class="arithmatex">\(z_4^{new} = z_4 \oplus z_3 = 0 \oplus z_3 = z_3\)</span>.
Intermediate <span class="arithmatex">\((\vec{x}_a,\vec{z}_a)=(0,0,x_2,x_3,0), (0,0,z_2,z_3,z_3)\)</span>.
Applying <span class="arithmatex">\(CNOT_{04}\)</span> (control 0, target 4):
<span class="arithmatex">\(x_0^{new} = x_0 \oplus x_4 = 0 \oplus 0 = 0\)</span>. <span class="arithmatex">\(z_0^{new} = z_0 = 0\)</span>.
<span class="arithmatex">\(x_4^{new} = x_4 = 0\)</span>. <span class="arithmatex">\(z_4^{new} = z_4 \oplus z_0 = z_3 \oplus 0 = z_3\)</span>.
Propagated error <span class="arithmatex">\((\vec{x}',\vec{z}')=(0,0,x_2,x_3,0), (0,0,z_2,z_3,z_3)\)</span>.
So <span class="arithmatex">\(E_{0123} = X_2^{x_2} Z_2^{z_2} X_3^{x_3} Z_3^{z_3} = P_{23}\)</span>. And <span class="arithmatex">\(E_4 = Z_4^{z_3}\)</span>.
-   Ancilla detection: <span class="arithmatex">\(E_4=Z_4^{z_3}\)</span>. No <span class="arithmatex">\(X_4\)</span> component, so no ancilla detection. All 15 errors pass.
-   Code detection &amp; logical change: We check <span class="arithmatex">\(P_{23}\)</span>. Commutes with <span class="arithmatex">\(S_1=XXXX\)</span> (even <span class="arithmatex">\(X/Y\)</span> count on <span class="arithmatex">\(Q_2, Q_3\)</span>) and <span class="arithmatex">\(S_2=ZZZZ\)</span> (even <span class="arithmatex">\(Z/Y\)</span> count on <span class="arithmatex">\(Q_2, Q_3\)</span>).
    -   <span class="arithmatex">\(I_2 I_3\)</span>: (<span class="arithmatex">\(x_2=0,z_2=0,x_3=0,z_3=0\)</span>) <span class="arithmatex">\(E_{0123}=I\)</span>. <span class="arithmatex">\(E_4=I_4\)</span>. Contributes to <span class="arithmatex">\(N_0\)</span>. <span class="arithmatex">\(N_0 \leftarrow N_0+1\)</span>.
    -   <span class="arithmatex">\(X_2 X_3\)</span>: (<span class="arithmatex">\(x_2=1,z_2=0,x_3=1,z_3=0\)</span>) <span class="arithmatex">\(E_{0123}=X_2 X_3\)</span>. <span class="arithmatex">\(E_4=I_4\)</span>. Commutes <span class="arithmatex">\(S_1, S_2\)</span>. Anti-commutes <span class="arithmatex">\(Z_B=Z_0 I_1 Z_2 I_3\)</span> (<span class="arithmatex">\(X_2, Z_2\)</span>). Contributes to <span class="arithmatex">\(N_L\)</span>. <span class="arithmatex">\(N_L \leftarrow N_L+1\)</span>.
    -   <span class="arithmatex">\(Y_2 Y_3\)</span>: (<span class="arithmatex">\(x_2=1,z_2=1,x_3=1,z_3=1\)</span>) <span class="arithmatex">\(E_{0123}=Y_2 Y_3\)</span>. <span class="arithmatex">\(E_4=Z_4\)</span>. Commutes <span class="arithmatex">\(S_1, S_2\)</span>. Anti-commutes <span class="arithmatex">\(Z_B=Z_0 I_1 Z_2 I_3\)</span> (<span class="arithmatex">\(Y_2, Z_2\)</span>). Contributes to <span class="arithmatex">\(N_L\)</span>. <span class="arithmatex">\(N_L \leftarrow N_L+1\)</span>.
    -   <span class="arithmatex">\(Z_2 Z_3\)</span>: (<span class="arithmatex">\(x_2=0,z_2=1,x_3=0,z_3=1\)</span>) <span class="arithmatex">\(E_{0123}=Z_2 Z_3\)</span>. <span class="arithmatex">\(E_4=Z_4\)</span>. Commutes <span class="arithmatex">\(S_1, S_2\)</span>. Commutes <span class="arithmatex">\(Z_A=Z_0 Z_1\)</span>, <span class="arithmatex">\(Z_B=Z_0 Z_2\)</span>. Contributes to <span class="arithmatex">\(N_0\)</span>. <span class="arithmatex">\(N_0 \leftarrow N_0+1\)</span>.
    All other 11 errors on <span class="arithmatex">\(P_{23}\)</span> anti-commute with <span class="arithmatex">\(S_1\)</span> or <span class="arithmatex">\(S_2\)</span>. Detected by code.
For <span class="arithmatex">\(CNOT_{23}\)</span>, <span class="arithmatex">\(N_0=2\)</span>, <span class="arithmatex">\(N_L=2\)</span>.
Cumulative: <span class="arithmatex">\(N_0=1+2=3\)</span>. <span class="arithmatex">\(N_L=0+2=2\)</span>.</p>
<p><strong>4. Errors after <span class="arithmatex">\(CNOT_{10}\)</span> (qubits 1,0, <span class="arithmatex">\(U_{post,3}=CNOT_{23} CNOT_{34} CNOT_{04}\)</span>)</strong>
Original error <span class="arithmatex">\(P_{10}\)</span>. Initial <span class="arithmatex">\((\vec{x},\vec{z})=(x_0,x_1,0,0,0), (z_0,z_1,0,0,0)\)</span>.
The three gates <span class="arithmatex">\(CNOT_{23}, CNOT_{34}, CNOT_{04}\)</span> are applied.
<span class="arithmatex">\(CNOT_{23}\)</span> (c=2, t=3): No change as it acts on qubits 2,3.
<span class="arithmatex">\(CNOT_{34}\)</span> (c=3, t=4): No change.
<span class="arithmatex">\(CNOT_{04}\)</span> (c=0, t=4):
<span class="arithmatex">\(x_0^{new} = x_0 \oplus x_4 = x_0 \oplus 0 = x_0\)</span>. <span class="arithmatex">\(z_0^{new} = z_0\)</span>.
<span class="arithmatex">\(x_4^{new} = x_4 = 0\)</span>. <span class="arithmatex">\(z_4^{new} = z_4 \oplus z_0 = 0 \oplus z_0 = z_0\)</span>.
Propagated error <span class="arithmatex">\((\vec{x}',\vec{z}')=(x_0,x_1,0,0,0), (z_0,z_1,0,0,z_0)\)</span>.
So <span class="arithmatex">\(E_{0123} = X_0^{x_0} Z_0^{z_0} X_1^{x_1} Z_1^{z_1} = P_{10}\)</span>. And <span class="arithmatex">\(E_4 = Z_4^{z_0}\)</span>.
-   Ancilla detection: <span class="arithmatex">\(E_4=Z_4^{z_0}\)</span>. No <span class="arithmatex">\(X_4\)</span> component, so no ancilla detection. All 15 errors pass.
-   Code detection &amp; logical change: We check <span class="arithmatex">\(P_{10}\)</span>. Commutes with <span class="arithmatex">\(S_1=XXXX\)</span> (even <span class="arithmatex">\(X/Y\)</span> count on <span class="arithmatex">\(Q_0, Q_1\)</span>) and <span class="arithmatex">\(S_2=ZZZZ\)</span> (even <span class="arithmatex">\(Z/Y\)</span> count on <span class="arithmatex">\(Q_0, Q_1\)</span>).
    -   <span class="arithmatex">\(I_0 I_1\)</span>: (<span class="arithmatex">\(x_0=0,z_0=0,x_1=0,z_1=0\)</span>) <span class="arithmatex">\(E_{0123}=I\)</span>. <span class="arithmatex">\(E_4=I_4\)</span>. Contributes to <span class="arithmatex">\(N_0\)</span>. <span class="arithmatex">\(N_0 \leftarrow N_0+1\)</span>.
    -   <span class="arithmatex">\(X_0 X_1\)</span>: (<span class="arithmatex">\(x_0=1,z_0=0,x_1=1,z_1=0\)</span>) <span class="arithmatex">\(E_{0123}=X_0 X_1\)</span>. <span class="arithmatex">\(E_4=I_4\)</span>. Commutes <span class="arithmatex">\(S_1, S_2\)</span>. Anti-commutes <span class="arithmatex">\(Z_A=Z_0 Z_1\)</span> (<span class="arithmatex">\(X_0, Z_0\)</span>). Contributes to <span class="arithmatex">\(N_L\)</span>. <span class="arithmatex">\(N_L \leftarrow N_L+1\)</span>.
    -   <span class="arithmatex">\(Y_0 Y_1\)</span>: (<span class="arithmatex">\(x_0=1,z_0=1,x_1=1,z_1=1\)</span>) <span class="arithmatex">\(E_{0123}=Y_0 Y_1\)</span>. <span class="arithmatex">\(E_4=Z_4\)</span>. Commutes <span class="arithmatex">\(S_1, S_2\)</span>. Anti-commutes <span class="arithmatex">\(Z_A=Z_0 Z_1\)</span> (<span class="arithmatex">\(Y_0, Z_0\)</span>). Contributes to <span class="arithmatex">\(N_L\)</span>. <span class="arithmatex">\(N_L \leftarrow N_L+1\)</span>.
    -   <span class="arithmatex">\(Z_0 Z_1\)</span>: (<span class="arithmatex">\(x_0=0,z_0=1,x_1=0,z_1=1\)</span>) <span class="arithmatex">\(E_{0123}=Z_0 Z_1\)</span>. <span class="arithmatex">\(E_4=Z_4\)</span>. Commutes <span class="arithmatex">\(S_1, S_2\)</span>. Commutes <span class="arithmatex">\(Z_A, Z_B\)</span>. Contributes to <span class="arithmatex">\(N_0\)</span>. <span class="arithmatex">\(N_0 \leftarrow N_0+1\)</span>.
    All other 11 errors on <span class="arithmatex">\(P_{10}\)</span> anti-commute with <span class="arithmatex">\(S_1\)</span> or <span class="arithmatex">\(S_2\)</span>. Detected by code.
For <span class="arithmatex">\(CNOT_{10}\)</span>, <span class="arithmatex">\(N_0=2\)</span>, <span class="arithmatex">\(N_L=2\)</span>.
Cumulative: <span class="arithmatex">\(N_0=3+2=5\)</span>. <span class="arithmatex">\(N_L=2+2=4\)</span>.</p>
<p><strong>5. Errors after <span class="arithmatex">\(CNOT_{12}\)</span> (qubits 1,2, <span class="arithmatex">\(U_{post,2}=CNOT_{10} CNOT_{23} CNOT_{34} CNOT_{04}\)</span>)</strong>
Original error <span class="arithmatex">\(P_{12}\)</span>. Initial <span class="arithmatex">\((\vec{x},\vec{z})=(0,x_1,x_2,0,0), (0,z_1,z_2,0,0)\)</span>.
Applying <span class="arithmatex">\(CNOT_{10}\)</span> (c=1, t=0):
<span class="arithmatex">\(x_1^{new} = x_1 \oplus x_0 = x_1\)</span>. <span class="arithmatex">\(z_1^{new} = z_1\)</span>. <span class="arithmatex">\(x_0^{new} = x_0=0\)</span>. <span class="arithmatex">\(z_0^{new} = z_0 \oplus z_1 = z_1\)</span>.
<span class="arithmatex">\((\vec{x}_a,\vec{z}_a)=(0,x_1,x_2,0,0), (z_1,z_1,z_2,0,0)\)</span>.
Applying <span class="arithmatex">\(CNOT_{23}\)</span> (c=2, t=3):
<span class="arithmatex">\(x_2^{new} = x_2 \oplus x_3 = x_2\)</span>. <span class="arithmatex">\(z_2^{new} = z_2\)</span>. <span class="arithmatex">\(x_3^{new} = x_3=0\)</span>. <span class="arithmatex">\(z_3^{new} = z_3 \oplus z_2 = z_2\)</span>.
<span class="arithmatex">\((\vec{x}_b,\vec{z}_b)=(0,x_1,x_2,0,0), (z_1,z_1,z_2,z_2,0)\)</span>.
Applying <span class="arithmatex">\(CNOT_{34}\)</span> (c=3, t=4):
<span class="arithmatex">\(x_3^{new} = x_3 \oplus x_4 = 0\)</span>. <span class="arithmatex">\(z_3^{new} = z_3 = z_2\)</span>. <span class="arithmatex">\(x_4^{new} = x_4=0\)</span>. <span class="arithmatex">\(z_4^{new} = z_4 \oplus z_3 = 0 \oplus z_2 = z_2\)</span>.
<span class="arithmatex">\((\vec{x}_c,\vec{z}_c)=(0,x_1,x_2,0,0), (z_1,z_1,z_2,z_2,z_2)\)</span>.
Applying <span class="arithmatex">\(CNOT_{04}\)</span> (c=0, t=4):
<span class="arithmatex">\(x_0^{new} = x_0 \oplus x_4 = 0 \oplus 0 = 0\)</span>. <span class="arithmatex">\(z_0^{new} = z_0 = z_1\)</span>.
<span class="arithmatex">\(x_4^{new} = x_4 = 0\)</span>. <span class="arithmatex">\(z_4^{new} = z_4 \oplus z_0 = z_2 \oplus z_1\)</span>.
Propagated error <span class="arithmatex">\((\vec{x}',\vec{z}')=(0,x_1,x_2,0,0), (z_1,z_1,z_2,z_2,z_1 \oplus z_2)\)</span>.
So <span class="arithmatex">\(E_{0123} = Z_0^{z_1} X_1^{x_1} Z_1^{z_1} X_2^{x_2} Z_2^{z_2} Z_3^{z_2}\)</span>. And <span class="arithmatex">\(E_4 = Z_4^{z_1 \oplus z_2}\)</span>.
-   Ancilla detection: <span class="arithmatex">\(E_4=Z_4^{z_1 \oplus z_2}\)</span>. No <span class="arithmatex">\(X_4\)</span> component, so no ancilla detection. All 15 errors pass.
-   Code detection &amp; logical change: We check <span class="arithmatex">\(E_{0123}\)</span>.
    <span class="arithmatex">\(E_{0123}\)</span> must commute with <span class="arithmatex">\(S_1=XXXX\)</span> (even <span class="arithmatex">\(X/Y\)</span> count). <span class="arithmatex">\(x_0 \oplus x_1 \oplus x_2 \oplus x_3 = 0 \oplus x_1 \oplus x_2 \oplus 0 = 0 \implies x_1=x_2\)</span>.
    <span class="arithmatex">\(E_{0123}\)</span> must commute with <span class="arithmatex">\(S_2=ZZZZ\)</span> (even <span class="arithmatex">\(Z/Y\)</span> count). <span class="arithmatex">\(z_0 \oplus z_1 \oplus z_2 \oplus z_3 = z_1 \oplus z_1 \oplus z_2 \oplus z_2 = 0\)</span>. This is always true.
    So, only errors with <span class="arithmatex">\(x_1=x_2\)</span> are not detected by <span class="arithmatex">\(S_1\)</span>. These are <span class="arithmatex">\(I_1 I_2, X_1 X_2, Y_1 Y_2, Z_1 Z_2\)</span>. (4 errors).
    -   <span class="arithmatex">\(I_1 I_2\)</span>: (<span class="arithmatex">\(x_1=0,z_1=0,x_2=0,z_2=0\)</span>) <span class="arithmatex">\(E_{0123}=I\)</span>. <span class="arithmatex">\(E_4=I_4\)</span>. Contributes to <span class="arithmatex">\(N_0\)</span>. <span class="arithmatex">\(N_0 \leftarrow N_0+1\)</span>.
    -   <span class="arithmatex">\(X_1 X_2\)</span>: (<span class="arithmatex">\(x_1=1,z_1=0,x_2=1,z_2=0\)</span>) <span class="arithmatex">\(E_{0123}=X_1 X_2\)</span>. <span class="arithmatex">\(E_4=I_4\)</span>. Commutes <span class="arithmatex">\(S_1, S_2\)</span>. Anti-commutes <span class="arithmatex">\(Z_A=Z_0 Z_1\)</span> (<span class="arithmatex">\(X_1, Z_1\)</span>). Contributes to <span class="arithmatex">\(N_L\)</span>. <span class="arithmatex">\(N_L \leftarrow N_L+1\)</span>.
    -   <span class="arithmatex">\(Y_1 Y_2\)</span>: (<span class="arithmatex">\(x_1=1,z_1=1,x_2=1,z_2=1\)</span>) <span class="arithmatex">\(E_{0123}=Z_0 X_1 Z_1 X_2 Z_2 Z_3 = Y_0 Y_1 Y_2 Z_3\)</span>. <span class="arithmatex">\(E_4=I_4\)</span>. Number of <span class="arithmatex">\(X/Y\)</span> terms is 3 (<span class="arithmatex">\(Y_0, Y_1, Y_2\)</span>). Anti-commutes <span class="arithmatex">\(S_1\)</span>. Detected by code.
    -   <span class="arithmatex">\(Z_1 Z_2\)</span>: (<span class="arithmatex">\(x_1=0,z_1=1,x_2=0,z_2=1\)</span>) <span class="arithmatex">\(E_{0123}=Z_0 Z_1 Z_2 Z_3 = S_2\)</span>. <span class="arithmatex">\(E_4=I_4\)</span>. <span class="arithmatex">\(S_2\)</span> is a stabilizer, so it belongs to <span class="arithmatex">\(N_0\)</span>. <span class="arithmatex">\(N_0 \leftarrow N_0+1\)</span>.
    All other 11 errors in <span class="arithmatex">\(P_{12}\)</span> (where <span class="arithmatex">\(x_1 \ne x_2\)</span>) anti-commute with <span class="arithmatex">\(S_1\)</span>. Detected by code.
For <span class="arithmatex">\(CNOT_{12}\)</span>, <span class="arithmatex">\(N_0=2\)</span>, <span class="arithmatex">\(N_L=1\)</span>.
Cumulative: <span class="arithmatex">\(N_0=5+2=7\)</span>. <span class="arithmatex">\(N_L=4+1=5\)</span>.</p>
</li>
</ol>
<p><strong>Total counts:</strong>
<span class="arithmatex">\(N_0 = 7\)</span> (errors that preserve the desired logical state and are not detected).
<span class="arithmatex">\(N_L = 5\)</span> (errors that map to a different logical state and are not detected).
Total undetected errors = <span class="arithmatex">\(N_0 + N_L = 7+5=12\)</span>.
Total errors in the depolarizing channels <span class="arithmatex">\(= 5 \times 15 = 75\)</span>.</p>
<p><strong>Logical Fidelity:</strong>
The fidelity <span class="arithmatex">\(F\)</span> is given by:</p>
<div class="arithmatex">\[
F = \frac{(1-p)^5 + \frac{p}{15}(1-p)^4 N_0}{(1-p)^5 + \frac{p}{15}(1-p)^4 (N_0+N_L)}
\]</div>
<p>To first order in <span class="arithmatex">\(p\)</span>:</p>
<div class="arithmatex">\[
F \approx \frac{1 - 5p + \frac{p}{15} N_0}{1 - 5p + \frac{p}{15} (N_0+N_L)}
\]</div>
<div class="arithmatex">\[
F \approx \left(1 - 5p + \frac{N_0}{15}p\right) \left(1 + 5p - \frac{N_0+N_L}{15}p\right)
\]</div>
<div class="arithmatex">\[
F \approx 1 + \left( \frac{N_0}{15} - \frac{N_0+N_L}{15} \right)p = 1 - \frac{N_L}{15}p
\]</div>
<p>Substituting <span class="arithmatex">\(N_L=5\)</span>:</p>
<div class="arithmatex">\[
F = 1 - \frac{5}{15}p = 1 - \frac{1}{3}p
\]</div>
<p>The final answer is <span class="arithmatex">\(\boxed{1 - \frac{p}{3}}\)</span></p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Final Answer Implementation</strong></p>
<p>Okay, so I need to take the final answer I calculated, which was <code>1 - p/3</code>, and integrate it into the provided Python code.  The goal here is to define the <code>F_logical</code> variable as a symbolic <code>sympy</code> expression that represents that exact result.  Essentially, I&rsquo;m just translating my earlier, human-readable solution into a format the code can understand and manipulate.  I know exactly how to do this within <code>sympy</code>; it&rsquo;s straightforward substitution of the math into the library. This should be a quick and easy modification.</p>
                      </div>
                    </details>
<div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="o">/</span><span class="mi">3</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:08.786678
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>