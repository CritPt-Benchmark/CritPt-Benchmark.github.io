<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Analyzing Physical State Fidelity in a Noisy Circuit</strong></p>
<p>As an expert in the field, I&rsquo;m tasked with calculating the fidelity of a specific state preparation circuit, taking into account the presence of two-qubit depolarizing errors. My approach involves several key steps:</p>
<ol>
<li>
<p><strong>Understanding the Target Logical State:</strong> My goal is to create the logical GHZ state, which is a superposition of |00&gt; and |11&gt;. I need to determine the mapping of this logical state to a physical 4-qubit representation using the [[4,2,2]] code properties.</p>
</li>
<li>
<p><strong>Circuit Analysis:</strong> The circuit comprises of a sequence of operations: <span class="arithmatex">\((CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span>. Since these are applied from right to left, I need to understand what state would be produced step-by-step.</p>
</li>
<li>
<p><strong>Error Modeling:</strong> I&rsquo;ll be modeling the errors in the circuit using the two-qubit depolarizing error channel applied after each CNOT gate.</p>
</li>
<li>
<p><strong>Fidelity Calculation:</strong> To quantify the performance of this noisy circuit, I will be calculating the fidelity which is the overlap between the ideal target state and the noisy state. If the ideal state is pure <span class="arithmatex">\(|\psi\rangle\)</span>, then the fidelity <span class="arithmatex">\(F = \langle\psi|\rho_{noisy}|\psi\rangle\)</span>.</p>
</li>
</ol>
<p><strong>Decoding the Circuit and Error:</strong></p>
<p>The code space is defined by two stabilizers: <span class="arithmatex">\(S_1 = X_0 X_1 X_2 X_3\)</span> and <span class="arithmatex">\(S_2 = Z_0 Z_1 Z_2 Z_3\)</span>. I&rsquo;ll use logical operators <span class="arithmatex">\(X_A, X_B, Z_A, Z_B\)</span>.</p>
<p><strong>Step 1. Encoding the Logical GHZ State:</strong></p>
<p>I&rsquo;ll proceed to determine the physical representation of the logical state through circuit application. The circuit will be applied to the state <span class="arithmatex">\(|0000\rangle\)</span>, and then each step will be followed by the error channels, generating the noisy state.
First I calculate the ideal state produced:</p>
<ol>
<li><span class="arithmatex">\(H_2: |0000\rangle \rightarrow \frac{1}{\sqrt{2}}(|0000\rangle+|0010\rangle)\)</span>.</li>
<li><span class="arithmatex">\(CNOT_{21}: \frac{1}{\sqrt{2}}(|0000\rangle+|0010\rangle) \rightarrow \frac{1}{\sqrt{2}}(|0000\rangle+|0110\rangle)\)</span>.</li>
<li><span class="arithmatex">\(H_0: \frac{1}{\sqrt{2}}(|0000\rangle+|0110\rangle) \rightarrow \frac{1}{2}(|0000\rangle+|1000\rangle+|0110\rangle+|1110\rangle)\)</span>.</li>
<li><span class="arithmatex">\(CNOT_{03}: \frac{1}{2}(|0000\rangle+|1000\rangle+|0110\rangle+|1110\rangle) \rightarrow \frac{1}{2}(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)\)</span>.
So the ideal final state is: <span class="arithmatex">\(\frac{1}{2}(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)\)</span>.
Verifying that this is a valid logical GHZ state is important. The logical GHZ must satisfy <span class="arithmatex">\(X_A X_B |\psi_{GHZ}\rangle = |\psi_{GHZ}\rangle\)</span> and <span class="arithmatex">\(Z_A Z_B |\psi_{GHZ}\rangle = |\psi_{GHZ}\rangle\)</span>, and also the stabilizers <span class="arithmatex">\(S_1, S_2\)</span> must give the state back.</li>
</ol>
<p><strong>Step 2: Accounting for the Noise.</strong></p>
<p>The fidelity calculation involves carefully tracking the state through the circuit and the depolarizing errors. The state undergoes:</p>
<p><span class="arithmatex">\(\rho_{noisy} = \mathcal{D}_{03}(CNOT_{03} H_0 \mathcal{D}_{21}(CNOT_{21} H_2 |0000\rangle\langle0000| H_2^\dagger) H_0^\dagger CNOT_{03}^\dagger)\)</span>.</p>
<p>Here I used <span class="arithmatex">\(\mathcal{D}\)</span> for the depolarizing error channels. Since the fidelity is <span class="arithmatex">\(F = \langle\psi_{ideal}|\rho_{noisy}|\psi_{ideal}\rangle\)</span>, this can be simplified by repeatedly using the cyclic property of the trace and the channel structure. The fidelity can be rewritten to consider the expectation values of the Pauli operations.</p>
<p>To simplify the calculation of the noisy state, and since the</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>The problem asks us to calculate the physical state fidelity of a specific quantum circuit designed to prepare a logical GHZ state, given a model of two-qubit depolarizing errors following each CNOT gate.</p>
<p>The state preparation circuit, applied to the initial state <span class="arithmatex">\(|0000\rangle\)</span>, is:</p>
<div class="arithmatex">\[
U_{circ} = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)
\]</div>
<p>The operations are applied from right to left, starting with <span class="arithmatex">\(|0000\rangle\)</span>.</p>
<p><strong>1. Determine the ideal final physical state:</strong></p>
<p>Let&rsquo;s trace the initial state <span class="arithmatex">\(|0000\rangle\)</span> through the ideal circuit:
*   Initial state: <span class="arithmatex">\(|\psi_{init}\rangle = |0000\rangle\)</span>.
*   After <span class="arithmatex">\(H_2\)</span> (on qubit 2):
    <span class="arithmatex">\(|\psi_A\rangle = H_2 |0000\rangle = |00\rangle_0 \frac{|0\rangle_2+|1\rangle_2}{\sqrt{2}} |0\rangle_3 = \frac{1}{\sqrt{2}}(|0000\rangle+|0010\rangle)\)</span>.
*   After <span class="arithmatex">\(CNOT_{21}\)</span> (control qubit 2, target qubit 1):
    <span class="arithmatex">\(CNOT_{21} |0000\rangle = |0000\rangle\)</span>.
    <span class="arithmatex">\(CNOT_{21} |0010\rangle = |0110\rangle\)</span>.
    <span class="arithmatex">\(|\psi_B\rangle = CNOT_{21} |\psi_A\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|0110\rangle)\)</span>.
*   After <span class="arithmatex">\(H_0\)</span> (on qubit 0):
    <span class="arithmatex">\(H_0 |0000\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|1000\rangle)\)</span>.
    <span class="arithmatex">\(H_0 |0110\rangle = \frac{1}{\sqrt{2}}(|0110\rangle+|1110\rangle)\)</span>.
    <span class="arithmatex">\(|\psi_C\rangle = H_0 |\psi_B\rangle = \frac{1}{2}(|0000\rangle+|1000\rangle+|0110\rangle+|1110\rangle)\)</span>.
*   After <span class="arithmatex">\(CNOT_{03}\)</span> (control qubit 0, target qubit 3):
    <span class="arithmatex">\(CNOT_{03} |0000\rangle = |0000\rangle\)</span>.
    <span class="arithmatex">\(CNOT_{03} |1000\rangle = |1001\rangle\)</span>.
    <span class="arithmatex">\(CNOT_{03} |0110\rangle = |0110\rangle\)</span>.
    <span class="arithmatex">\(CNOT_{03} |1110\rangle = |1111\rangle\)</span>.
    The ideal final physical state is:
    <span class="arithmatex">\(|\psi_{ideal}\rangle = CNOT_{03} |\psi_C\rangle = \frac{1}{2}(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)\)</span>.</p>
<p><strong>2. Model the noisy evolution and calculate the fidelity:</strong></p>
<p>Let the initial state be <span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>.
The circuit has two CNOT gates: <span class="arithmatex">\(CNOT_{21}\)</span> and <span class="arithmatex">\(CNOT_{03}\)</span>. Each is followed by a two-qubit depolarizing channel <span class="arithmatex">\(\mathcal{D}_{ij}\)</span> with error rate <span class="arithmatex">\(p\)</span>.
The depolarizing channel on two qubits <span class="arithmatex">\(i, j\)</span> is defined as:</p>
<div class="arithmatex">\[
\mathcal{D}_{ij}(\rho) = (1-p) \rho + \frac{p}{15} \sum_{P \in \mathcal{P}_{ij} \setminus \{I \otimes I\}} P \rho P
\]</div>
<p>where <span class="arithmatex">\(\mathcal{P}_{ij}\)</span> is the set of 16 two-qubit Pauli operators acting on qubits <span class="arithmatex">\(i,j\)</span> and identity on other qubits.</p>
<p>Let <span class="arithmatex">\(U_1=H_2\)</span>, <span class="arithmatex">\(U_2=CNOT_{21}\)</span>, <span class="arithmatex">\(U_3=H_0\)</span>, <span class="arithmatex">\(U_4=CNOT_{03}\)</span>.
The evolution of the density matrix is:</p>
<ol>
<li><span class="arithmatex">\(\rho_1 = U_1 \rho_0 U_1^\dagger = |\psi_A\rangle\langle\psi_A|\)</span>.</li>
<li><span class="arithmatex">\(\rho_2 = U_2 \rho_1 U_2^\dagger = |\psi_B\rangle\langle\psi_B|\)</span>.</li>
<li><span class="arithmatex">\(\rho_{err,1} = \mathcal{D}_{21}(\rho_2)\)</span>. (Depolarizing error on qubits 2,1 after <span class="arithmatex">\(CNOT_{21}\)</span>)</li>
<li><span class="arithmatex">\(\rho_3 = U_3 \rho_{err,1} U_3^\dagger\)</span>.</li>
<li><span class="arithmatex">\(\rho_4 = U_4 \rho_3 U_4^\dagger\)</span>.</li>
<li><span class="arithmatex">\(\rho_{noisy} = \mathcal{D}_{03}(\rho_4)\)</span>. (Depolarizing error on qubits 0,3 after <span class="arithmatex">\(CNOT_{03}\)</span>)</li>
</ol>
<p>The physical state fidelity is <span class="arithmatex">\(F = \langle\psi_{ideal}|\rho_{noisy}|\psi_{ideal}\rangle = \text{Tr}(|\psi_{ideal}\rangle\langle\psi_{ideal}| \rho_{noisy})\)</span>.
Let <span class="arithmatex">\(\Pi_{ideal} = |\psi_{ideal}\rangle\langle\psi_{ideal}|\)</span>.</p>
<p>We can expand the fidelity using linearity:</p>
<div class="arithmatex">\[
F = \text{Tr}\left(\Pi_{ideal} \left[ (1-p)\rho_4 + \frac{p}{15} \sum_{j=1}^{15} P_j^{(03)} \rho_4 P_j^{(03)} \right]\right)
\]</div>
<div class="arithmatex">\[
F = (1-p) \text{Tr}(\Pi_{ideal} \rho_4) + \frac{p}{15} \sum_{j=1}^{15} \text{Tr}(\Pi_{ideal} P_j^{(03)} \rho_4 P_j^{(03)})
\]</div>
<p>Let&rsquo;s analyze <span class="arithmatex">\(\text{Tr}(\Pi_{ideal} \rho_4)\)</span>:</p>
<div class="arithmatex">\[
\text{Tr}(\Pi_{ideal} \rho_4) = \text{Tr}(\Pi_{ideal} U_4 \rho_3 U_4^\dagger) = \text{Tr}(U_4^\dagger \Pi_{ideal} U_4 \rho_3)
\]</div>
<p>Since <span class="arithmatex">\(\Pi_{ideal} = U_4 U_3 U_2 U_1 \rho_0 U_1^\dagger U_2^\dagger U_3^\dagger U_4^\dagger\)</span>, we have <span class="arithmatex">\(U_4^\dagger \Pi_{ideal} U_4 = U_3 U_2 U_1 \rho_0 U_1^\dagger U_2^\dagger U_3^\dagger = |\psi_C\rangle\langle\psi_C|\)</span>.
So, <span class="arithmatex">\(\text{Tr}(\Pi_{ideal} \rho_4) = \langle\psi_C|\rho_3|\psi_C\rangle\)</span>.</p>
<p>Now expand <span class="arithmatex">\(\rho_3 = U_3 \rho_{err,1} U_3^\dagger\)</span>:</p>
<div class="arithmatex">\[
\langle\psi_C|\rho_3|\psi_C\rangle = \langle\psi_C|U_3 \rho_{err,1} U_3^\dagger|\psi_C\rangle = \text{Tr}(U_3^\dagger |\psi_C\rangle\langle\psi_C| U_3 \rho_{err,1})
\]</div>
<p>Since <span class="arithmatex">\(U_3^\dagger |\psi_C\rangle\langle\psi_C| U_3 = |\psi_B\rangle\langle\psi_B|\)</span>, this becomes <span class="arithmatex">\(\langle\psi_B|\rho_{err,1}|\psi_B\rangle\)</span>.
Then, substituting <span class="arithmatex">\(\rho_{err,1} = \mathcal{D}_{21}(\rho_2)\)</span>:</p>
<div class="arithmatex">\[
\langle\psi_B|\rho_{err,1}|\psi_B\rangle = (1-p)\langle\psi_B|\rho_2|\psi_B\rangle + \frac{p}{15}\sum_{k=1}^{15}\langle\psi_B|P_k^{(21)}\rho_2 P_k^{(21)}|\psi_B\rangle
\]</div>
<p>Since <span class="arithmatex">\(\rho_2=|\psi_B\rangle\langle\psi_B|\)</span>, we have <span class="arithmatex">\(\langle\psi_B|\rho_2|\psi_B\rangle = 1\)</span>.
And <span class="arithmatex">\(\langle\psi_B|P_k^{(21)}\rho_2 P_k^{(21)}|\psi_B\rangle = |\langle\psi_B|P_k^{(21)}|\psi_B\rangle|^2\)</span>.</p>
<p>So, the fidelity can be expressed as:</p>
<div class="arithmatex">\[
F = (1-p)\left[ (1-p) + \frac{p}{15} \sum_{k=1}^{15} |\langle\psi_B|P_k^{(21)}|\psi_B\rangle|^2 \right] + \frac{p}{15} \sum_{j=1}^{15} \text{Tr}(P_j^{(03)} \Pi_{ideal} P_j^{(03)} U_4 \rho_3 U_4^\dagger)
\]</div>
<p>The second term can be further simplified. Let <span class="arithmatex">\(M_j = P_j^{(03)} \Pi_{ideal} P_j^{(03)}\)</span>.
<span class="arithmatex">\(\text{Tr}(M_j U_4 \rho_3 U_4^\dagger) = \text{Tr}(U_4^\dagger M_j U_4 \rho_3)\)</span>.
<span class="arithmatex">\(U_4^\dagger M_j U_4 = U_4^\dagger P_j^{(03)} U_4 U_4^\dagger \Pi_{ideal} U_4 U_4^\dagger P_j^{(03)} U_4 = (U_4^\dagger P_j^{(03)} U_4) |\psi_C\rangle\langle\psi_C| (U_4^\dagger P_j^{(03)} U_4)\)</span>.
Let <span class="arithmatex">\(\tilde{P}_j^{(03)} = U_4^\dagger P_j^{(03)} U_4\)</span>. Then the second sum is <span class="arithmatex">\(\frac{p}{15} \sum_j \text{Tr}(\tilde{P}_j^{(03)} |\psi_C\rangle\langle\psi_C| \tilde{P}_j^{(03)} \rho_3)\)</span>.
Using <span class="arithmatex">\(\rho_3 = U_3 \rho_{err,1} U_3^\dagger\)</span>:
<span class="arithmatex">\(\text{Tr}(\tilde{P}_j^{(03)} |\psi_C\rangle\langle\psi_C| \tilde{P}_j^{(03)} U_3 \rho_{err,1} U_3^\dagger) = \text{Tr}(U_3^\dagger \tilde{P}_j^{(03)} |\psi_C\rangle\langle\psi_C| \tilde{P}_j^{(03)} U_3 \rho_{err,1})\)</span>.
Let <span class="arithmatex">\(\hat{P}_j^{(03)} = U_3^\dagger \tilde{P}_j^{(03)} U_3\)</span>. This becomes <span class="arithmatex">\(\text{Tr}(\hat{P}_j^{(03)} |\psi_B\rangle\langle\psi_B| \hat{P}_j^{(03)} \rho_{err,1})\)</span>.
Substituting <span class="arithmatex">\(\rho_{err,1} = (1-p)\rho_2 + \frac{p}{15}\sum_k P_k^{(21)}\rho_2 P_k^{(21)}\)</span>:
The terms contribute <span class="arithmatex">\(p(1-p)\frac{1}{15} \sum_j |\langle\psi_B|\hat{P}_j^{(03)}|\psi_B\rangle|^2\)</span> and <span class="arithmatex">\(p^2\frac{1}{15^2} \sum_j\sum_k |\langle\psi_B|\hat{P}_j^{(03)}P_k^{(21)}|\psi_B\rangle|^2\)</span>.</p>
<p>The exact fidelity expression is:</p>
<div class="arithmatex">\[
F = (1-p)^2 + (1-p)\frac{p}{15} \sum_{k=1}^{15} |\langle\psi_B|P_k^{(21)}|\psi_B\rangle|^2 + (1-p)\frac{p}{15} \sum_{j=1}^{15} |\langle\psi_{ideal}|P_j^{(03)}|\psi_{ideal}\rangle|^2 + \frac{p^2}{15^2} \sum_{j=1}^{15}\sum_{k=1}^{15} |\langle\psi_{ideal}|P_j^{(03)} U_4 U_3 P_k^{(21)} U_2 U_1 |0000\rangle|^2
\]</div>
<p>Let&rsquo;s evaluate each sum:</p>
<p><strong>Term 1: <span class="arithmatex">\(\sum_{k=1}^{15} |\langle\psi_B|P_k^{(21)}|\psi_B\rangle|^2\)</span></strong>
<span class="arithmatex">\(|\psi_B\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|0110\rangle)\)</span>. This can be written as <span class="arithmatex">\(|0\rangle_0 \otimes \frac{1}{\sqrt{2}}(|00\rangle_{12}+|11\rangle_{12}) \otimes |0\rangle_3\)</span>.
Let <span class="arithmatex">\(|\chi\rangle_{12} = \frac{1}{\sqrt{2}}(|00\rangle_{12}+|11\rangle_{12})\)</span>.
The operator <span class="arithmatex">\(P_k^{(21)}\)</span> acts on qubits 1 and 2, so <span class="arithmatex">\(P_k^{(21)} = I_0 \otimes P'_{12} \otimes I_3\)</span>.
So, <span class="arithmatex">\(\langle\psi_B|P_k^{(21)}|\psi_B\rangle = \langle\chi|_{12} P'_{12} |\chi\rangle_{12}\)</span>.
For the Bell state <span class="arithmatex">\(|\chi\rangle_{12}\)</span>, the expectation values of two-qubit Paulis are non-zero only for <span class="arithmatex">\(P'_{12} \in \{II, XX, YY, ZZ\}\)</span>.
<span class="arithmatex">\(\langle\chi|XX|\chi\rangle = 1\)</span>
<span class="arithmatex">\(\langle\chi|YY|\chi\rangle = -1\)</span>
<span class="arithmatex">\(\langle\chi|ZZ|\chi\rangle = 1\)</span>
The sum is over 15 non-identity Paulis. So, we exclude <span class="arithmatex">\(II\)</span>.
<span class="arithmatex">\(\sum_{k=1}^{15} |\langle\psi_B|P_k^{(21)}|\psi_B\rangle|^2 = |1|^2 + |-1|^2 + |1|^2 = 3\)</span>.</p>
<p><strong>Term 2: <span class="arithmatex">\(\sum_{j=1}^{15} |\langle\psi_{ideal}|P_j^{(03)}|\psi_{ideal}\rangle|^2\)</span></strong>
<span class="arithmatex">\(|\psi_{ideal}\rangle = \frac{1}{2}(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)\)</span>.
The operator <span class="arithmatex">\(P_j^{(03)}\)</span> acts on qubits 0 and 3, so <span class="arithmatex">\(P_j^{(03)} = P'_0 \otimes I_{12} \otimes P'_3\)</span>.
Let&rsquo;s check the expectation values for <span class="arithmatex">\(P'_0 P'_3\)</span>:
<span class="arithmatex">\(\langle\psi_{ideal}|X_0 X_3|\psi_{ideal}\rangle = 1\)</span>
<span class="arithmatex">\(\langle\psi_{ideal}|Y_0 Y_3|\psi_{ideal}\rangle = -1\)</span>
<span class="arithmatex">\(\langle\psi_{ideal}|Z_0 Z_3|\psi_{ideal}\rangle = 1\)</span>
All other 12 two-qubit Paulis on qubits 0 and 3 (e.g., <span class="arithmatex">\(X_0 I_3\)</span>, <span class="arithmatex">\(I_0 Z_3\)</span>, <span class="arithmatex">\(X_0 Z_3\)</span>, etc.) yield an expectation value of 0 due to the structure of <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span>.
For example, <span class="arithmatex">\(\langle\psi_{ideal}|X_0 I_3|\psi_{ideal}\rangle = \frac{1}{4} (\langle0000|+\langle1001|+\langle0110|+\langle1111|) (X_0 I_3) (|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)\)</span>.
<span class="arithmatex">\(X_0 I_3 |\psi_{ideal}\rangle = \frac{1}{2}(|1000\rangle+|0001\rangle+|1110\rangle+|0111\rangle)\)</span>. This is orthogonal to <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span>, so the inner product is 0.
Thus, <span class="arithmatex">\(\sum_{j=1}^{15} |\langle\psi_{ideal}|P_j^{(03)}|\psi_{ideal}\rangle|^2 = |1|^2 + |-1|^2 + |1|^2 = 3\)</span>.</p>
<p><strong>Term 3: <span class="arithmatex">\(\frac{p^2}{15^2} \sum_{j=1}^{15}\sum_{k=1}^{15} |\langle\psi_{ideal}|P_j^{(03)} U_4 U_3 P_k^{(21)} U_2 U_1 |0000\rangle|^2\)</span></strong>
Let <span class="arithmatex">\(U_{DC} = U_4 U_3 = CNOT_{03} H_0\)</span>.
The term inside the sum is <span class="arithmatex">\(|\langle\psi_{ideal}|P_j^{(03)} U_{DC} P_k^{(21)} |\psi_B\rangle|^2\)</span>.
Using <span class="arithmatex">\(|\psi_{ideal}\rangle = U_{DC} |\psi_B\rangle\)</span>, this becomes:
<span class="arithmatex">\(|\langle U_{DC} \psi_B | P_j^{(03)} U_{DC} P_k^{(21)} |\psi_B\rangle|^2 = |\langle \psi_B | U_{DC}^\dagger P_j^{(03)} U_{DC} P_k^{(21)} |\psi_B\rangle|^2\)</span>.
Let <span class="arithmatex">\(M_j = U_{DC}^\dagger P_j^{(03)} U_{DC} = H_0 CNOT_{03} P_j^{(03)} CNOT_{03} H_0\)</span>.
The operator <span class="arithmatex">\(P_j^{(03)}\)</span> acts only on qubits 0 and 3. The conjugation by <span class="arithmatex">\(CNOT_{03}\)</span> keeps the operator localized to qubits 0 and 3. The conjugation by <span class="arithmatex">\(H_0\)</span> (only on qubit 0) also keeps the operator localized to qubits 0 and 3.
So <span class="arithmatex">\(M_j\)</span> acts only on qubits 0 and 3. <span class="arithmatex">\(M_j = M_{j(03)} \otimes I_{12}\)</span>.
The operator <span class="arithmatex">\(P_k^{(21)}\)</span> acts only on qubits 1 and 2. <span class="arithmatex">\(P_k^{(21)} = I_0 \otimes P'_{k(12)} \otimes I_3\)</span>.
The state <span class="arithmatex">\(|\psi_B\rangle = |0\rangle_0 \otimes |\chi\rangle_{12} \otimes |0\rangle_3\)</span>.
So, <span class="arithmatex">\(\langle\psi_B | M_j P_k^{(21)} |\psi_B\rangle = \langle 0_0 \chi_{12} 0_3 | (M_{j(03)} \otimes I_{12}) (I_0 \otimes P'_{k(12)} \otimes I_3) | 0_0 \chi_{12} 0_3 \rangle\)</span>.
<span class="arithmatex">\(= \langle 0_0 0_3 | M_{j(03)} | 0_0 0_3 \rangle \langle \chi_{12} | P'_{k(12)} | \chi_{12} \rangle\)</span>.
This allows us to factor the sum:
<span class="arithmatex">\(\sum_{j,k} |\langle\psi_B | M_j P_k^{(21)} |\psi_B\rangle|^2 = \left( \sum_j |\langle 0_0 0_3 | M_{j(03)} | 0_0 0_3 \rangle|^2 \right) \left( \sum_k |\langle \chi_{12} | P'_{k(12)} | \chi_{12} \rangle|^2 \right)\)</span>.</p>
<p>The second factor is 3, as calculated for Term 1.
For the first factor: <span class="arithmatex">\(\langle 0_0 0_3 | M_{j(03)} | 0_0 0_3 \rangle = \langle 0_0 0_3 | H_0 CNOT_{03} P_j^{(03)} CNOT_{03} H_0 | 0_0 0_3 \rangle\)</span>.
Applying <span class="arithmatex">\(H_0\)</span> to <span class="arithmatex">\(|0\rangle_0\)</span> gives <span class="arithmatex">\(|+\rangle_0 = \frac{1}{\sqrt{2}}(|0\rangle_0+|1\rangle_0)\)</span>.
So, this is <span class="arithmatex">\(\langle +_0 0_3 | CNOT_{03} P_j^{(03)} CNOT_{03} | +_0 0_3 \rangle\)</span>.
The action of <span class="arithmatex">\(CNOT_{03}\)</span> on <span class="arithmatex">\(|+\rangle_0 |0\rangle_3\)</span> is <span class="arithmatex">\(CNOT_{03} \frac{1}{\sqrt{2}}(|00\rangle_{03}+|10\rangle_{03}) = \frac{1}{\sqrt{2}}(|00\rangle_{03}+|11\rangle_{03}) = |\Phi^+\rangle_{03}\)</span>.
So, this term is <span class="arithmatex">\(\langle \Phi^+_{03} | P_j^{(03)} | \Phi^+_{03} \rangle\)</span>.
The sum <span class="arithmatex">\(\sum_j |\langle \Phi^+_{03} | P_j^{(03)} | \Phi^+_{03} \rangle|^2\)</span> is over 15 non-identity Paulis on qubits 0 and 3, in the Bell state <span class="arithmatex">\(|\Phi^+\rangle_{03}\)</span>. This is the same form as Term 2, so the sum is 3.</p>
<p>Therefore, the third term&rsquo;s contribution is <span class="arithmatex">\(\frac{p^2}{15^2} \cdot (3 \times 3) = \frac{9p^2}{225} = \frac{p^2}{25}\)</span>.</p>
<p><strong>3. Combine terms for total fidelity:</strong></p>
<div class="arithmatex">\[
F = (1-p)^2 + (1-p)\frac{p}{15}(3) + (1-p)\frac{p}{15}(3) + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = (1-2p+p^2) + \frac{3p(1-p)}{15} + \frac{3p(1-p)}{15} + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = (1-2p+p^2) + \frac{2p(1-p)}{5} + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = 1 - 2p + p^2 + \frac{2}{5}p - \frac{2}{5}p^2 + \frac{1}{25}p^2
\]</div>
<p>Collect terms by powers of <span class="arithmatex">\(p\)</span>:</p>
<div class="arithmatex">\[
F = 1 + \left(-2 + \frac{2}{5}\right)p + \left(1 - \frac{2}{5} + \frac{1}{25}\right)p^2
\]</div>
<div class="arithmatex">\[
F = 1 + \left(\frac{-10+2}{5}\right)p + \left(\frac{25-10+1}{25}\right)p^2
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<p>This expression can also be written as <span class="arithmatex">\(F = \left(1 - \frac{4}{5}p\right)^2\)</span>.</p>
<p>The final answer is <span class="arithmatex">\(\boxed{1 - \frac{8}{5}p + \frac{16}{25}p^2}\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="mi">16</span><span class="o">/</span><span class="mi">25</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.339778
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>