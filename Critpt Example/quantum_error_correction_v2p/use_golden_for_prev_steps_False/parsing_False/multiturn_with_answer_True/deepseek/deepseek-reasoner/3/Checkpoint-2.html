<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note: The equation is written in matrix multiplication order, but the quantum operations occur in reverse order. So the actual circuit order from initial state to final state is: Start with some initial state? Typically, we start with all qubits in |0&gt;. But careful: The problem says: &ldquo;prepare a logical two-qubit GHZ state&rdquo;. That state is <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>. But note: The code is [[4,2,2]]. So the logical qubits A and B are encoded into 4 physical qubits. The circuit given: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). But wait: There is no mention of initial state? Usually, we start with all qubits in |0&gt;. But then apply these gates. Let&rsquo;s check: The circuit: From right to left: First apply H_2, then CNOT_{21}, then H_0, then CNOT_{03}. So the circuit is: 
Step 1: H on qubit 2.
Step 2: CNOT with control 2, target 1.
Step 3: H on qubit 0.
Step 4: CNOT with control 0, target 3.</p>
<p>We start with state |0000&gt;? But then what is the resulting state? Let&rsquo;s compute ideal state:
Initial: |0&gt;<em>0|0&gt;_1|0&gt;_2|0&gt;_3.
After H_2: becomes: |0&gt;_0|0&gt;_1 (H|0&gt;)_2 |0&gt;_3 = |0&gt;_0|0&gt;_1 (|0&gt;+|1&gt;)/√2 _2 |0&gt;_3.
After CNOT</em>{21}: control qubit 2, target qubit 1. So: if qubit2 is |0&gt;, then qubit1 remains; if qubit2 is |1&gt;, then flip qubit1. So state becomes: 
= (|0&gt;<em>0|0&gt;_1|0&gt;_2|0&gt;_3 + |0&gt;_0|1&gt;_1|1&gt;_2|0&gt;_3)/√2.
After H_0: Apply H on qubit0. So: 
= ( (H|0&gt;)_0|0&gt;_1|0&gt;_2|0&gt;_3 + (H|0&gt;)_0|1&gt;_1|1&gt;_2|0&gt;_3 )/√2 
= ( (|0&gt;+|1&gt;)/√2 _0|0&gt;_1|0&gt;_2|0&gt;_3 + (|0&gt;+|1&gt;)/√2 _0|1&gt;_1|1&gt;_2|0&gt;_3 )/√2 
= 1/√2 * [ 1/√2 (|0000&gt; + |1000&gt;) + 1/√2 (|0110&gt; + |1110&gt;) ]? Wait careful: 
First term: (|0&gt;+|1&gt;)_0 |0&gt;_1|0&gt;_2|0&gt;_3 = |0000&gt; + |1000&gt;.
Second term: (|0&gt;+|1&gt;)_0 |1&gt;_1|1&gt;_2|0&gt;_3 = |0110&gt; + |1110&gt;.
So overall: (1/√2)*1/√2 (|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;) = 1/2 (|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;).
After CNOT</em>{03}: control qubit 0, target qubit 3. So:
For each term: 
|0000&gt;: control 0=0, so target unchanged: |0000&gt;.
|1000&gt;: control=1, so flip target: becomes |1001&gt;.
|0110&gt;: control=0, so unchanged: |0110&gt;.
|1110&gt;: control=1, so flip: becomes |1111&gt;.
So final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>Is that the logical GHZ state? The logical GHZ state is (|00&gt;_AB + |11&gt;_AB)/√2. But what are the logical states? The code is [[4,2,2]]. The logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI.
We need to check: What are the code words? The stabilizers are XXXX and ZZZZ. So the code space is 4-dimensional? Actually, [[4,2,2]] means: n=4, k=2, d=2. So there are 2 logical qubits, so 4 logical states. They are usually: 
|00&gt;_L = (|0000&gt;+|1111&gt;)/√2? But careful: The stabilizers: XXXX and ZZZZ. The code space is the subspace of 4 qubits that are +1 eigenstates of both XXXX and ZZZZ. 
Check: For state |0000&gt;, XXXX|0000&gt; = |1111&gt;, so not eigenstate. So |0000&gt; is not in code space.
Actually, the code words: One common representation: 
|00&gt;_L = (|0000&gt;+|1111&gt;)/√2,
|01&gt;_L = (|0011&gt;+|1100&gt;)/√2,
|10&gt;__L = (|0101&gt;+|1010&gt;)/√2,
|11&gt;_L = (|0110&gt;+|1001&gt;)/√2.
But check: Our final state: 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). That equals? 
Group: (|0000&gt;+|1111&gt;)/2 + (|1001&gt;+|0110&gt;)/2. That is (|00&gt;_L + |11&gt;_L)/√2? Because |00&gt;_L = (|0000&gt;+|1111&gt;)/√2, and |11&gt;_L = (|0110&gt;+|1001&gt;)/√2. So indeed, our state is (1/√2)(|00&gt;_L + |11&gt;_L)/? Actually: 
(1/2)(|0000&gt;+|1111&gt;) = (1/√2)|00&gt;_L/√2? Wait: |00&gt;_L = (|0000&gt;+|1111&gt;)/√2, so (|0000&gt;+|1111&gt;)/2 = (1/√2)|00&gt;_L. Similarly, (|1001&gt;+|0110&gt;)/2 = (1/√2)|11&gt;_L. So overall state = 1/√2 (|00&gt;_L + |11&gt;_L). So it is the logical GHZ state. So circuit is correct.</p>
<p>Now: We want: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; 
Interpretation: The circuit has gates: H_2, CNOT_{21}, H_0, CNOT_{03}. But note: The problem says: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; But wait: What about Hadamard gates? They are single-qubit gates. Are they error-free? The problem statement: &ldquo;As a simple model of quantum errors in hardware, we will suppose that each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; So only CNOT gates have errors. The Hadamard gates are perfect? That is implied: &ldquo;each CNOT_{ij} gate&rdquo; so only CNOT gates have errors. So there are two CNOT gates: CNOT_{21} and CNOT_{03}. So each of these gates is followed by an error channel that with probability p applies a random two-qubit Pauli error on the two qubits involved (the control and target). And with probability 1-p, no error. And the error is one of the 15 non-identity Paulis, each with probability p/15.</p>
<p>We want: &ldquo;the physical state fidelity&rdquo; of the final physical state. Fidelity is between the ideal state (which is the state we get if no errors occur) and the actual state (which is a mixed state due to errors). But careful: &ldquo;physical state fidelity&rdquo; might mean the fidelity of the actual output state to the ideal state. But the actual output state is a density matrix that comes from applying the circuit with errors. So we need to compute: 
ρ_actual = E_{circuit}(|0000&gt;&lt;0000|) where E_{circuit} is the composition of perfect gates and error channels. But note: The error channels act after each CNOT. So the process: 
Start: |0&gt;&lt;0|^⊗4.
Then apply H_2 (perfect).
Then apply CNOT_{21} (perfect) followed by error channel on qubits 2 and 1. That error channel: With probability 1-p, identity; with probability p, a random Pauli from {I,X,Y,Z}⊗{I,X,Y,Z} minus II? Actually: &ldquo;non-identity two-qubit Paulis&rdquo; so there are 15. So each occurs with probability p/15.
Then apply H_0 (perfect).
Then apply CNOT_{03} (perfect) followed by error channel on qubits 0 and 3.</p>
<p>So we want the fidelity F = &lt;ψ_ideal| ρ_actual |ψ_ideal&gt; where |ψ_ideal&gt; = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;).</p>
<p>We need to compute ρ_actual. Because errors are Pauli errors, and the ideal state is a stabilizer state? Actually, the ideal state is a code state of the [[4,2,2]] code? But careful: The ideal state is not a pure stabilizer state? Actually, it is a logical GHZ state. But it is a superposition of two code words. But it is still a stabilizer state? Possibly we can compute the effect of Pauli errors on it.</p>
<p>Alternatively, we can compute the evolution step by step. But note: The errors are applied after each CNOT. And they are depolarizing channels on two qubits. So we can compute the overall channel as a composition. But careful: The gates are not all CNOTs? But we can compute the effect of errors on the final state. Alternatively, we can compute the probability that no error occurs? But errors might cancel? But since errors are random Paulis, they will generally take the state out of the ideal state. But wait: Some errors might be undetectable? But we are computing physical state fidelity, not logical fidelity. Physical state fidelity is the overlap between the actual state and the ideal state. That is: F = Tr(ρ_ideal ρ_actual). And ρ_ideal = |ψ&gt;&lt;ψ|.</p>
<p>Because the errors are Pauli errors, and the ideal state is a specific state, we can compute the average fidelity. Actually, the process is: The circuit is a unitary U (ideal circuit). Then errors occur at two steps. So the actual state is: 
ρ = E_2 ∘ U_2 ∘ E_1 ∘ U_1 (|0&gt;&lt;0|) where U_1 = CNOT_{21} after H_2? Actually, careful: The order: 
Step 1: H_2. So state becomes: ρ1 = H_2 |0&gt;&lt;0| H_2† on qubit2, others unchanged.
Step 2: CNOT_{21} (perfect). So ρ2 = CNOT_{21} ρ1 CNOT_{21}†.
Step 3: Error channel on qubits 2 and 1: This is a depolarizing channel on these two qubits. So ρ3 = (1-p) ρ2 + (p/15) * sum_{P in Paulis on {2,1}, P ≠ I⊗I} P ρ2 P†.
Step 4: H_0. So ρ4 = H_0 ρ3 H_0†.
Step 5: CNOT_{03} (perfect). So ρ5 = CNOT_{03} ρ4 CNOT_{03}†.
Step 6: Error channel on qubits 0 and 3: ρ_final = (1-p) ρ5 + (p/15) * sum_{Q in Paulis on {0,3}, Q ≠ I⊗I} Q ρ5 Q†.</p>
<p>We want F = &lt;ψ| ρ_final |ψ&gt;.</p>
<p>Because the ideal state |ψ&gt; is produced by the ideal circuit, we can also think: Let U = overall ideal circuit. Then |ψ&gt; = U|0000&gt;. And the actual process is: ρ_final = U (with errors inserted) applied to |0&gt;&lt;0|. But careful: The errors are applied in the middle. But we can &ldquo;push&rdquo; the errors through the later gates? Because the later gates are unitaries. But note: The errors are on specific qubits. And the gates after them are on other qubits? Actually, H_0 acts on qubit 0, but error on qubits 2 and 1 commutes with H_0? Not necessarily? But H_0 acts only on qubit 0, so it commutes with any operator on qubits 2 and 1. So indeed, the error on qubits 2 and1 commutes with H_0. And then CNOT_{03} acts on qubits 0 and 3. Does it commute with an error on qubits 2 and 1? Yes, because they act on disjoint sets. So we can actually push the first error channel to the end? But careful: The error channel is applied after the CNOT_{21}. But then we have H_0 and CNOT_{03}. Since these gates commute with operators on qubits 2 and 1, we can actually move the error channel to after the entire circuit? But wait: The error channel is applied to the state after CNOT_{21}. But if we conjugate that error by the subsequent unitaries that act on other qubits, they remain the same because they commute. So indeed, we can say: The overall effect is that the ideal circuit U is applied, but then we have an error channel on qubits 2 and 1 (but now the error operators are conjugated by U? Actually, careful: 
We have: ρ_final = (Error on 0,3) ∘ CNOT_{03} ∘ H_0 ∘ (Error on 2,1) ∘ CNOT_{21} ∘ H_2 (|0&gt;&lt;0|).
But since H_0 and CNOT_{03} commute with any operator on qubits 2 and 1, we can write:
ρ_final = (Error on 0,3) ∘ CNOT_{03} ∘ H_0 ∘ CNOT_{21} ∘ H_2 ∘ (Error on 2,1) (|0&gt;&lt;0|)? Not exactly: Because the error on 2,1 is applied after CNOT_{21} but before H_0. But if we want to move it to after H_0, we need to conjugate it by H_0. But H_0 commutes with operators on qubits 2 and 1, so it&rsquo;s fine. Similarly, CNOT_{03} commutes with operators on qubits 2 and 1. So indeed, we can move the error channel on qubits 2,1 to the very end. But careful: The error channel on qubits 2,1 is defined as: E_{21}(ρ) = (1-p)ρ + (p/15) ∑<em>{P in Paulis on {2,1} excluding II} P ρ P†. And if we move it through H_0 and CNOT</em>{03}, since these act on qubits 0 and 3, they commute with P on qubits 2,1. So indeed, we have:
ρ_final = (Error on 0,3) ∘ U ∘ (Error on 2,1) (|0&gt;&lt;0|) where U = CNOT_{03} ∘ H_0 ∘ CNOT_{21} ∘ H_2. But wait: Check order: Initially: H_2, then CNOT_{21}, then Error on 2,1, then H_0, then CNOT_{03}, then Error on 0,3. So if we move Error on 2,1 to after H_0, it becomes: H_0 ∘ Error on 2,1 = Error on 2,1 ∘ H_0 because H_0 commutes. Similarly, moving through CNOT_{03} gives: CNOT_{03} ∘ Error on 2,1 = Error on 2,1 ∘ CNOT_{03}. So then the entire sequence becomes: Error on 0,3 ∘ CNOT_{03} ∘ H_0 ∘ CNOT_{21} ∘ H_2 ∘ Error on 2,1. But that is U ∘ Error on 2,1? Actually careful: U = CNOT_{03} ∘ H_0 ∘ CNOT_{21} ∘ H_2. So then ρ_final = Error on 0,3 ∘ U ∘ Error on 2,1 (|0&gt;&lt;0|). But then we can also move Error on 2,1 to after U? But careful: U acts on all qubits. But Error on 2,1 acts only on qubits 2 and 1. Does U commute with operators on qubits 2 and 1? Not necessarily: U includes CNOT_{03} and H_0. Those act on qubits 0 and 3, so they commute with operators on qubits 2 and 1. But U also includes CNOT_{21} and H_2. Those act on qubits 2 and 1. So if we try to move Error on 2,1 through U, we would get: U ∘ Error on 2,1 = (CNOT_{03} ∘ H_0 ∘ CNOT_{21} ∘ H_2) ∘ Error on 2,1. But CNOT_{21} and H_2 do not commute with an arbitrary Pauli on qubits 2 and 1? Actually, they do: Because if we conjugate a Pauli on qubits 2 and 1 by CNOT_{21} and H_2, we get another Pauli on qubits 2 and 1. But then it&rsquo;s not the same error channel? But wait: The error channel is defined as: E_{21}(ρ) = (1-p)ρ + (p/15) ∑<em>{P} P ρ P†. If we conjugate this channel by a unitary V that acts on qubits 2 and 1, then V E</em>{21}(V† ρ V) V† = (1-p)ρ + (p/15) ∑<em>{P} (V P V†) ρ (V P V†)†. But that is actually the same set because as P runs over all non-identity Paulis on two qubits, so does V P V† (since Clifford group acts transitively on Paulis). So indeed, if V is a Clifford gate on those qubits, then V E</em>{21} V† = E_{21}? Check: For a depolarizing channel, it is invariant under unitary conjugation by Clifford gates? Actually, the two-qubit depolarizing channel is: ρ -&gt; (1-p)ρ + (p/15) ∑<em>{P ≠ I} P ρ P. Under conjugation by a Clifford unitary U, we get: U ρ U† -&gt; (1-p)UρU† + (p/15) ∑</em>{P ≠ I} U P U† UρU† (U P U†)† = (1-p)ρ&rsquo; + (p/15) ∑<em>{Q ≠ I} Q ρ&rsquo; Q, because the set {U P U†} is exactly the set of all non-identity Paulis (if U is Clifford). So yes, the depolarizing channel is invariant under conjugation by Clifford gates that act on the same qubits. But careful: Our U is not entirely on qubits 2 and 1; it has parts on qubits 0 and 3. But those commute. So we can actually move the error channel through U if we conjugate it appropriately. But then we would get: ρ_final = Error on 0,3 ∘ (U ∘ Error on 2,1 ∘ U†) ∘ U (|0&gt;&lt;0|) = Error on 0,3 ∘ (U Error on 2,1 U†) ∘ (U|0&gt;&lt;0|U†). And since U Error on 2,1 U† is a depolarizing channel on qubits 2 and 1? But careful: U includes gates on qubits 2 and 1: H_2 and CNOT</em>{21}. So U Error on 2,1 U† will be a channel on qubits 2 and 1 that is still depolarizing? Actually, check: U = CNOT_{03} ∘ H_0 ∘ CNOT_{21} ∘ H_2. But note: CNOT_{03} and H_0 commute with operators on qubits 2 and 1. So U Error on 2,1 U† = (CNOT_{03} H_0) ∘ (CNOT_{21} H_2) Error on 2,1 (H_2† CNOT_{21}†) ∘ (H_0† CNOT_{03}†). And since CNOT_{03} H_0 commutes with anything on qubits 2,1, this is equal to (CNOT_{21} H_2) Error on 2,1 (H_2† CNOT_{21}†). And as argued, for a Clifford gate on two qubits, the depolarizing channel is invariant. So indeed, U Error on 2,1 U† = Error on 2,1. So then we get: ρ_final = Error on 0,3 ∘ Error on 2,1 ∘ (U|0&gt;&lt;0|U†) = Error on 0,3 ∘ Error on 2,1 (|ψ&gt;&lt;ψ|), where |ψ&gt; is the ideal state.
So the overall effect is that the ideal state is first subjected to a depolarizing channel on qubits 2 and 1, and then to a depolarizing channel on qubits 0 and 3. And these two channels commute because they act on disjoint sets. So then:
ρ_final = E_{0,3} ∘ E_{2,1} (|ψ&gt;&lt;ψ|).</p>
<p>And these channels are independent. And they are two-qubit depolarizing channels: 
E(ρ) = (1-p)ρ + (p/15) ∑_{P in Paulis on that pair, P ≠ II} P ρ P.</p>
<p>So then the fidelity F = &lt;ψ| ρ_final |ψ&gt; = &lt;ψ| E_{0,3} ∘ E_{2,1} (|ψ&gt;&lt;ψ|) |ψ&gt;.</p>
<p>And because these channels are acting on disjoint qubits, we can compute the effect on the overlap. In general, if we have a state |ψ&gt; and a depolarizing channel on a subset of qubits, the fidelity is: 
F = Tr( |ψ&gt;&lt;ψ| E(ρ) ) = (1-p) + (p/15) ∑<em>{P} &lt;ψ| P |ψ&gt;&lt;ψ| P |ψ&gt;? Actually careful: 
E(ρ) = (1-p)ρ + (p/15) ∑</em>{P ≠ I} P ρ P.
So &lt;ψ| E(ρ) |ψ&gt; = (1-p) + (p/15) ∑<em>{P ≠ I} &lt;ψ| P |ψ&gt;&lt;ψ| P |ψ&gt;? But that is if ρ = |ψ&gt;&lt;ψ|. But wait: Actually, careful: For a given Pauli P acting on a set of qubits, we have: &lt;ψ| P |ψ&gt;&lt;ψ| P |ψ&gt; is not necessarily |&lt;ψ|P|ψ&gt;|^2? Actually, since |ψ&gt; is a pure state, Tr(|ψ&gt;&lt;ψ| P |ψ&gt;&lt;ψ| P) = |&lt;ψ|P|ψ&gt;|^2. So indeed, 
F = (1-p) + (p/15) ∑</em>{P ≠ I} |&lt;ψ|P|ψ&gt;|^2.</p>
<p>But careful: This is if the depolarizing channel acts on all qubits that P acts on. But here we have two separate channels on disjoint sets. And they commute. So overall, if we apply two independent depolarizing channels on disjoint sets, then the fidelity becomes:
F = &lt;ψ| E_{0,3} ∘ E_{2,1} (|ψ&gt;&lt;ψ|) |ψ&gt; = 
= (1-p)^2? Not exactly because the errors from different channels can combine? Actually, because they act on disjoint sets, the overall channel is: 
ρ -&gt; (1-p)^2 ρ + (1-p)(p/15) ∑<em>{P on {0,3} non-I} P ρ P + (1-p)(p/15) ∑</em>{Q on {2,1} non-I} Q ρ Q + (p/15)^2 ∑<em>{P on {0,3} non-I} ∑</em>{Q on {2,1} non-I} (P Q) ρ (P Q).
Then fidelity = &lt;ψ|ρ|ψ&gt; = (1-p)^2 + (1-p)(p/15) [∑<em>{P on {0,3}} |&lt;ψ|P|ψ&gt;|^2] + (1-p)(p/15) [∑</em>{Q on {2,1}} |&lt;ψ|Q|ψ&gt;|^2] + (p/15)^2 [∑<em>{P on {0,3}} ∑</em>{Q on {2,1}} |&lt;ψ|P Q|ψ&gt;|^2].</p>
<p>But careful: The sums are over non-identity Paulis. So we need to compute these overlaps for our state |ψ&gt; = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;).</p>
<p>Let&rsquo;s denote qubits: 0,1,2,3. Our state: 
|ψ&gt; = (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;)/2.</p>
<p>We want to compute &lt;ψ| P |ψ&gt; for various Paulis. But note: Paulis that act on disjoint sets: There are Paulis on qubits {0,3} and on qubits {2,1}. And also products from both sets.</p>
<p>Because the state is symmetric? Actually, it might be easier to compute the expectation values of Paulis on these pairs. Alternatively, we can compute the density matrix of |ψ&gt;&lt;ψ| on each pair? But careful: The state is entangled across these pairs. But we can compute the reduced density matrices on qubits {0,3} and on qubits {2,1}? But then the expectation of a Pauli on {0,3} is Tr(ρ_{03} P). But then we need to sum over all non-identity Paulis on that pair. But then we need to compute Tr(ρ_{03} P) for each P. But careful: That gives &lt;ψ|P|ψ&gt; if P acts only on qubits 0 and 3. But then we need to sum |&lt;ψ|P|ψ&gt;|^2? Actually, careful: The fidelity term is: (p/15) * ∑<em>{P on {0,3} non-I} |&lt;ψ|P|ψ&gt;|^2. But if we compute Tr(ρ</em>{03} P), that is exactly &lt;ψ|P|ψ&gt; because P acts only on qubits 0 and 3. So then we need to compute these for all Paulis on two qubits. There are 15 such Paulis. But maybe we can compute the reduced density matrix ρ_{03} explicitly. Similarly for qubits {2,1}.</p>
<p>Let&rsquo;s compute ρ_{03} from |ψ&gt;. 
|ψ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;). 
To get ρ_{03}, we trace out qubits 1 and 2. 
Write basis for qubits 0,3: |00&gt;, |01&gt;, |10&gt;, |11&gt;.
The state |ψ&gt; in terms of qubits 1,2 and 0,3: 
|ψ&gt; = 1/2 ( |0&gt;<em>0|0&gt;_3 |00&gt;</em>{12} + |1&gt;<em>0|0&gt;_3? Actually careful: 
Term1: |0000&gt; = |0&gt;_0|0&gt;_1|0&gt;_2|0&gt;_3 = |00&gt;</em>{03} ⊗ |00&gt;<em>{12}? But careful: Order: qubits: 0,1,2,3. So if we group as (0,3) and (1,2), then:
|0000&gt; = |0&gt;_0|0&gt;_3 ⊗ |0&gt;_1|0&gt;_2 = |00&gt;</em>{03} ⊗ |00&gt;<em>{12}.
Term2: |1001&gt; = |1&gt;_0|0&gt;_1|0&gt;_2|1&gt;_3 = |10&gt;</em>{03}? Actually: qubit0=1, qubit3=1 gives |11&gt;? Wait: careful: For qubits 0 and 3, the basis order: usually we list qubit0 then qubit3. So |1001&gt; means: qubit0=1, qubit1=0, qubit2=0, qubit3=1. So in the (0,3) group, that is: qubit0=1, qubit3=1, so that is |11&gt;<em>{03}? But then qubits (1,2): qubit1=0, qubit2=0 gives |00&gt;</em>{12}. So actually, |1001&gt; = |11&gt;<em>{03} ⊗ |00&gt;</em>{12}? But wait: That would be if qubit0=1 and qubit3=1, then it&rsquo;s |11&gt; but careful: The basis for two qubits: usually |00&gt;, |01&gt;, |10&gt;, |11&gt;. So if qubit0=1 and qubit3=1, then that is |11&gt; indeed. But then term3: |0110&gt; = |0&gt;<em>0|1&gt;_1|1&gt;_2|0&gt;_3 = |00&gt;</em>{03}? Because qubit0=0, qubit3=0 gives |00&gt;<em>{03} and qubits (1,2): qubit1=1, qubit2=1 gives |11&gt;</em>{12}. 
Term4: |1111&gt; = |1&gt;<em>0|1&gt;_1|1&gt;_2|1&gt;_3 = |11&gt;</em>{03} ⊗ |11&gt;<em>{12}.
So then |ψ&gt; = 1/2 ( |00&gt;</em>{03}|00&gt;<em>{12} + |11&gt;</em>{03}|00&gt;<em>{12} + |00&gt;</em>{03}|11&gt;<em>{12} + |11&gt;</em>{03}|11&gt;<em>{12} ) = 1/2 ( (|00&gt;</em>{03}+|11&gt;<em>{03}) ⊗ |00&gt;</em>{12} + (|00&gt;<em>{03}+|11&gt;</em>{03}) ⊗ |11&gt;<em>{12} )? That would be = 1/2 (|00&gt;</em>{03}+|11&gt;<em>{03}) ⊗ (|00&gt;</em>{12}+|11&gt;<em>{12}). But wait, check: That gives: 1/2 (|00&gt;|00&gt; + |00&gt;|11&gt; + |11&gt;|00&gt; + |11&gt;|11&gt;) which is exactly our state? But then that would mean that |ψ&gt; is a product state between pairs (0,3) and (1,2)? But is that true? Actually, our state is: |ψ&gt; = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). But if we write it as (|00&gt;</em>{03}+|11&gt;<em>{03})/√2 ⊗ (|00&gt;</em>{12}+|11&gt;<em>{12})/√2, then that product is 1/2 (|00&gt;|00&gt; + |00&gt;|11&gt; + |11&gt;|00&gt; + |11&gt;|11&gt;). But our state has terms: |0000&gt;, |1001&gt;, |0110&gt;, |1111&gt;. But careful: |1001&gt; means: qubit0=1, qubit1=0, qubit2=0, qubit3=1. In the grouping (0,3) and (1,2), |1001&gt; becomes: (qubit0,qubit3) = (1,1) so that is |11&gt;</em>{03} and (qubit1,qubit2) = (0,0) so that is |00&gt;<em>{12}. So that matches: |11&gt;</em>{03} ⊗ |00&gt;<em>{12}. And |0110&gt; becomes: (0,0) and (1,1) so that is |00&gt;</em>{03} ⊗ |11&gt;<em>{12}. So indeed, |ψ&gt; = (|00&gt;</em>{03}+|11&gt;<em>{03})/√2 ⊗ (|00&gt;</em>{12}+|11&gt;<em>{12})/√2. So the state factorizes into two Bell states on pairs (0,3) and (1,2)! That is interesting. So then:
ρ</em>{03} = Tr_{12}(|ψ&gt;&lt;ψ|) = the density matrix of the Bell state on qubits 0 and 3? Actually, careful: |ψ&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12} where |Φ^+&gt; = (|00&gt;+|11&gt;)/√2. So then ρ_{03} = |Φ^+&gt;&lt;Φ^+|<em>{03} because tracing out the other pair gives 1.
Similarly, ρ</em>{12} = |Φ^+&gt;&lt;Φ^+|_{12}.</p>
<p>So then we can compute the overlaps for Paulis on qubits 0 and 3. For a two-qubit Pauli on qubits 0 and 3, we want &lt;ψ|P|ψ&gt; = Tr(ρ_{03} P) because P acts only on qubits 0 and 3. And since ρ_{03} is the Bell state |Φ^+&gt;&lt;Φ^+|, we know that for Paulis on two qubits, the expectation values are: 
For Bell state |Φ^+&gt; = (|00&gt;+|11&gt;)/√2, we have:
&lt;Φ^+| I⊗I |Φ^+&gt; = 1.
&lt;Φ^+| X⊗X |Φ^+&gt; = 1? Actually, check: (X⊗X)|Φ^+&gt; = (|11&gt;+|00&gt;)/√2 = |Φ^+&gt;, so expectation = 1.
&lt;Φ^+| Y⊗Y |Φ^+&gt; = ? (Y⊗Y)|Φ^+&gt; = (i)(-i) (|11&gt; - |00&gt;?) Actually, compute properly: Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;. So Y⊗Y|00&gt; = i * i |11&gt; = -|11&gt;. Y⊗Y|11&gt; = (-i)<em>(-i)|00&gt; = -|00&gt;. So Y⊗Y|Φ^+&gt; = -(|11&gt;+|00&gt;)/√2 = -|Φ^+&gt;, so expectation = -1.
&lt;Φ^+| Z⊗Z |Φ^+&gt; =? Z⊗Z|00&gt; = |00&gt;, Z⊗Z|11&gt; = |11&gt;, so expectation = 1.
What about Paulis that are not symmetric? For example, I⊗X: 
(I⊗X)|Φ^+&gt; = (|01&gt;+|10&gt;)/√2 = |Ψ^+&gt;, so expectation = &lt;Φ^+|Ψ^+&gt; = 0.
Similarly, any Pauli that is not of the form A⊗A? Actually, for Bell state, the only nonzero expectations are for Paulis that are in the stabilizer of the Bell state? Actually, the Bell state |Φ^+&gt; is stabilized by X⊗X and Z⊗Z (and -Y⊗Y). So indeed, the expectation values are: 
For Pauli P on two qubits, &lt;Φ^+|P|Φ^+&gt; is nonzero only if P is I⊗I, X⊗X, Y⊗Y, Z⊗Z. And then:
I⊗I: 1
X⊗X: 1
Y⊗Y: -1
Z⊗Z: 1.
But careful: That is for the Bell state |Φ^+&gt; = (|00&gt;+|11&gt;)/√2. So then |&lt;ψ|P|ψ&gt;|^2 for P on qubits 0,3: 
If P = I⊗I, but that&rsquo;s identity, so not included in error sum.
For P = X⊗X: squared = 1.
For P = Y⊗Y: squared = 1.
For P = Z⊗Z: squared = 1.
For any other Pauli on qubits 0,3, the expectation is 0.
So there are 3 Paulis on qubits 0,3 that give nonzero squared overlap of 1.
But wait: There are 15 non-identity Paulis. Among them, how many are of the form A⊗A? Actually, the Paulis on two qubits: They are products of Paulis on each qubit. The ones that are &ldquo;symmetric&rdquo; in the sense that they are the same on both qubits? That gives: X⊗X, Y⊗Y, Z⊗Z. Also what about I⊗X? That is not symmetric. So indeed, only these 3 give nonzero expectation. But wait: Also what about X⊗I? That gives 0. So yes.
So for the depolarizing channel on qubits 0 and 3, the contribution to fidelity is: 
(1-p) from the no-error part? Actually, careful: The channel on qubits 0,3: E_{03}(ρ) = (1-p)ρ + (p/15) ∑<em>{P in Paulis on {0,3} non-I} P ρ P.
So if we apply this to |ψ&gt;&lt;ψ|, then &lt;ψ| E</em>{03}(|ψ&gt;&lt;ψ|) |ψ&gt; = (1-p) + (p/15) ∑_{P non-I} |&lt;ψ|P|ψ&gt;|^2 = (1-p) + (p/15)</em>3 = 1-p + p/5 = 1 - (4/5)p.
But wait: That is if we only had errors on qubits 0,3. But we also have errors on qubits 2,1. And similarly, for qubits 2,1, since ρ_{12} is also a Bell state (|Φ^+&gt; on qubits 1,2), the same analysis applies: For any Pauli on qubits 1,2 that is not identity, only those that are X⊗X, Y⊗Y, Z⊗Z give expectation 1, and others give 0. So similarly, if we only had errors on qubits 2,1, the fidelity would be 1 - (4/5)p.</p>
<p>But careful: These channels are applied sequentially. And they act on disjoint sets. And because the state factorizes as |ψ&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12}, the effect of the depolarizing channel on qubits 0,3 only affects the first factor, and similarly for qubits 2,1. And these channels are independent. So then the overall fidelity after both channels is the product? But careful: The channels are not necessarily giving a fidelity that multiplies because the errors are not necessarily independent in the sense of fidelity? Actually, if we have two independent depolarizing channels on two separate subsystems, and the ideal state is a product state, then the fidelity is the product of the fidelities from each channel. But here our state is a product state: |ψ&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12}. And the depolarizing channel on qubits 0,3 acts only on the first factor, and similarly on qubits 2,1 on the second factor. And these channels are applied independently. So then the overall state becomes: ρ = E_{03}(|Φ^+&gt;&lt;Φ^+|) ⊗ E_{12}(|Φ^+&gt;&lt;Φ^+|). And then the fidelity F = Tr( (|Φ^+&gt;&lt;Φ^+| ⊗ |Φ^+&gt;&lt;Φ^+|) ρ ) = [Tr(|Φ^+&gt;&lt;Φ^+| E_{03}(|Φ^+&gt;&lt;Φ^+|))] * [Tr(|Φ^+&gt;&lt;Φ^+| E_{12}(|Φ^+&gt;&lt;Φ^+|))] because the state is product. And each of those is 1 - (4/5)p. So then overall fidelity would be (1 - (4/5)p)^2.
But wait: Is that correct? Let&rsquo;s check: Our derivation earlier using moving errors to the end gave: ρ_final = E_{0,3} ∘ E_{2,1} (|ψ&gt;&lt;ψ|). And since these channels act on disjoint qubits, they commute. And if |ψ&gt; is a product state between these two pairs, then indeed E_{0,3} ∘ E_{2,1} (|ψ&gt;&lt;ψ|) = E_{0,3}(|Φ^+&gt;&lt;Φ^+|) ⊗ E_{2,1}(|Φ^+&gt;&lt;Φ^+|). And then fidelity = F_{03} * F_{12} where F_{03} = &lt;Φ^+| E_{0,3}(|Φ^+&gt;&lt;Φ^+|) |Φ^+&gt; = 1 - (4/5)p, and similarly for the other. So then overall fidelity = (1 - (4/5)p)^2.
But wait: There is also the possibility of errors from both channels simultaneously? That is included in the product because (1-p)^2 term gives fidelity 1, and cross terms: (1-p)(p/15)<em>3 from first and similarly from second give? Actually, let&rsquo;s derive properly:
E_{03}(ρ) = (1-p)ρ + (p/15) ∑<em>{P in {0,3} non-I} P ρ P.
So if ρ = |Φ^+&gt;&lt;Φ^+|, then F</em>{03} = (1-p) + (p/15)</em>3 = 1-p + p/5 = 1 - 4p/5.
Similarly, F_{12} = 1 - 4p/5.
And since the channels are independent, the overall effect on the product state is: 
ρ_final = [ (1-p)^2 + &hellip; ] Actually, careful: The combined channel is: 
E_{03} ∘ E_{12} (ρ_{03} ⊗ ρ_{12}) = E_{03}(ρ_{03}) ⊗ E_{12}(ρ_{12}) because they act on different subsystems. So then fidelity = F_{03} * F_{12} = (1 - 4p/5)^2.
So that seems to be the answer.</p>
<p>But wait: Is that the physical state fidelity? That is the overlap between the ideal state and the actual state. But careful: The actual state is not necessarily a product state? But it is because the errors act independently on disjoint sets. So yes.</p>
<p>But wait: There is also the possibility that errors from different gates could cancel? But no, because we are averaging over errors. So the fidelity is the average over error patterns. And since errors are independent, the average fidelity is indeed the product of the fidelities from each error channel? But careful: The fidelity of a channel applied to a pure state is defined as F = ∫ &lt;ψ| E(|ψ&gt;&lt;ψ|) |ψ&gt; d(error) but here we are computing exactly that: E(|ψ&gt;&lt;ψ|) is a mixture. And we computed that as (1-p)^2 |ψ&gt;&lt;ψ| + &hellip; and then &lt;ψ| that gives (1-p)^2 + &hellip; and that equals (1 - 4p/5)^2? Let&rsquo;s check by expanding:
From two independent depolarizing channels on two disjoint pairs, the overall effect on |ψ&gt;&lt;ψ| is:
With probability (1-p)^2: no error -&gt; fidelity contribution: (1-p)^2.
With probability (1-p)<em>(p/15) from first channel error (and no error on second): There are 15 such terms from first channel, but only 3 give nonzero overlap of 1, and the other 12 give 0. So contribution: (1-p)</em>(p/15)<em>3 = (1-p)</em>p/5.
Similarly, from second channel error (and no error on first): contribution: (1-p)<em>p/5.
With probability (p/15)^2 from both channels errors: There are 15</em>15 =225 terms. But careful: The overlap &lt;ψ| (P ⊗ Q) |ψ&gt;&lt;ψ| (P ⊗ Q) |ψ&gt; = |&lt;ψ|P⊗Q|ψ&gt;|^2. And since |ψ&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12}, we have &lt;ψ|P⊗Q|ψ&gt; = &lt;Φ^+|P|Φ^+&gt; * &lt;Φ^+|Q|Φ^+&gt;. So this is nonzero only if both P and Q are among the ones that give ±1. That is, P must be one of {X⊗X, Y⊗Y, Z⊗Z} on qubits 0,3, and Q must be one of {X⊗X, Y⊗Y, Z⊗Z} on qubits 1,2. So there are 3<em>3 = 9 terms. And each gives product: (&lt;Φ^+|P|Φ^+&gt;)^2 * (&lt;Φ^+|Q|Φ^+&gt;)^2. But note: (&lt;Φ^+|P|Φ^+&gt;)^2 is always 1 because even if it is -1, squared gives 1. So each such term gives 1. So contribution from both errors: (p/15)^2 * 9 = p^2/25.
So total fidelity = (1-p)^2 + 2</em>(1-p)*p/5 + p^2/25 = (1 - 2p + p^2) + (2p/5 - 2p^2/5) + p^2/25 = 1 - 2p + p^2 + 0.4p - 0.4p^2 + 0.04p^2 = 1 - 1.6p + (1 - 0.4 + 0.04)p^2 = 1 - 1.6p + 0.64p^2 = (1 - 0.8p)^2. And 0.8p = 4p/5. So indeed F = (1 - 4p/5)^2.
So the physical state fidelity is (1 - 4p/5)^2.</p>
<p>But wait: Is that the answer? That is the fidelity of the output state to the ideal state. But the problem asks: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; So answer: F = (1 - 4p/5)^2.</p>
<p>But wait: There is also the possibility of errors from the Hadamard gates? But the problem says only CNOT gates have errors. So that&rsquo;s it.</p>
<p>Thus answer for Subproblem 1: F = (1 - 4p/5)^2.</p>
<p>But wait: The problem might expect an expression in terms of p. So I&rsquo;ll put: 
Final Answer: \boxed{(1 - \frac{4p}{5})^2}</p>
<p>But let me double-check: The circuit has two CNOT gates. Each CNOT gate error channel acts on two qubits. And we showed that by moving the errors to the end, the overall effect is two independent depolarizing channels on the pairs (0,3) and (2,1). And since the ideal state is a product of Bell states on these pairs, the fidelity from a depolarizing channel on a Bell state is: F_Bell = 1 - 4/5 p? Actually, for a two-qubit depolarizing channel on a Bell state, the fidelity is: (1-p) + (p/15)*3 = 1 - p + p/5 = 1 - 4p/5. And since they are independent, overall fidelity is product: (1 - 4p/5)^2. That seems correct.</p>
<p>So I&rsquo;ll answer that.</p>
<p>Thus for Subproblem 1:</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-understand-the-circuit-and-ideal-state">Step 1. Understand the Circuit and Ideal State</h3>
<p>The goal is to prepare the logical GHZ state:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the <span class="arithmatex">\([[4,2,2]]\)</span> code, using the circuit:</p>
<div class="arithmatex">\[
(\text{CNOT}_{03}) (H_0) (\text{CNOT}_{21}) (H_2)
\]</div>
<p>The operations are applied from right to left:</p>
<ol>
<li>Apply <span class="arithmatex">\(H_2\)</span> (Hadamard on qubit 2)</li>
<li>Apply <span class="arithmatex">\(\text{CNOT}_{21}\)</span> (control qubit 2, target qubit 1)</li>
<li>Apply <span class="arithmatex">\(H_0\)</span> (Hadamard on qubit 0)</li>
<li>Apply <span class="arithmatex">\(\text{CNOT}_{03}\)</span> (control qubit 0, target qubit 3)</li>
</ol>
<p>Starting from the initial state <span class="arithmatex">\(|0000\rangle\)</span>, the ideal output is:</p>
<div class="arithmatex">\[
|\psi\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right)
\]</div>
<p>This is equivalent to:</p>
<div class="arithmatex">\[
|\psi\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}, \quad \text{where} \quad |\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}
\]</div>
<hr />
<h3 id="step-2-model-the-errors">Step 2. Model the Errors</h3>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel:</p>
<ul>
<li>With probability <span class="arithmatex">\(1 - p\)</span>, no error occurs.</li>
<li>With probability <span class="arithmatex">\(p\)</span>, a non-identity two-qubit Pauli error occurs, chosen uniformly from the 15 possibilities.</li>
</ul>
<p>The error channels act on the qubit pairs involved in each CNOT:</p>
<ul>
<li>After <span class="arithmatex">\(\text{CNOT}_{21}\)</span>: error channel on qubits 2 and 1</li>
<li>After <span class="arithmatex">\(\text{CNOT}_{03}\)</span>: error channel on qubits 0 and 3</li>
</ul>
<p>Hadamard gates are assumed to be error-free.</p>
<hr />
<h3 id="step-3-simplify-the-error-analysis">Step 3. Simplify the Error Analysis</h3>
<p>Since the later gates (<span class="arithmatex">\(H_0\)</span> and <span class="arithmatex">\(\text{CNOT}_{03}\)</span>) act on qubits disjoint from those affected by the first error channel, we can commute the first error channel to the end of the circuit. Similarly, the second error channel already acts at the end.</p>
<p>Thus, the overall effect is equivalent to applying the ideal circuit <span class="arithmatex">\(U\)</span> followed by two independent depolarizing channels:</p>
<ul>
<li><span class="arithmatex">\(E_{21}\)</span>: acts on qubits 2 and 1</li>
<li><span class="arithmatex">\(E_{03}\)</span>: acts on qubits 0 and 3</li>
</ul>
<p>So the final state is:</p>
<div class="arithmatex">\[
\rho_{\text{final}} = E_{03} \circ E_{21} \left( |\psi\rangle\langle\psi| \right)
\]</div>
<p>Since the ideal state factors as:</p>
<div class="arithmatex">\[
|\psi\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}
\]</div>
<p>and the error channels act on disjoint qubit pairs, we have:</p>
<div class="arithmatex">\[
\rho_{\text{final}} = E_{03}(|\Phi^+\rangle\langle\Phi^+|)_{03} \otimes E_{21}(|\Phi^+\rangle\langle\Phi^+|)_{12}
\]</div>
<hr />
<h3 id="step-4-compute-the-fidelity-from-one-depolarizing-channel">Step 4. Compute the Fidelity from One Depolarizing Channel</h3>
<p>The two-qubit depolarizing channel on a pair of qubits is:</p>
<div class="arithmatex">\[
E(\rho) = (1 - p)\rho + \frac{p}{15} \sum_{P \neq I \otimes I} P \rho P^\dagger
\]</div>
<p>For a Bell state <span class="arithmatex">\(|\Phi^+\rangle\)</span>, the fidelity is:</p>
<div class="arithmatex">\[
F = \langle \Phi^+ | E(|\Phi^+\rangle\langle\Phi^+|) | \Phi^+ \rangle = (1 - p) + \frac{p}{15} \sum_{P \neq I \otimes I} |\langle \Phi^+ | P | \Phi^+ \rangle|^2
\]</div>
<p>Only the Pauli operators <span class="arithmatex">\(X \otimes X\)</span>, <span class="arithmatex">\(Y \otimes Y\)</span>, and <span class="arithmatex">\(Z \otimes Z\)</span> have non-zero overlap with <span class="arithmatex">\(|\Phi^+\rangle\)</span>, and each gives <span class="arithmatex">\(|\langle \Phi^+ | P | \Phi^+ \rangle|^2 = 1\)</span>. There are 3 such operators, so:</p>
<div class="arithmatex">\[
F = 1 - p + \frac{3p}{15} = 1 - \frac{4p}{5}
\]</div>
<hr />
<h3 id="step-5-combine-the-two-independent-error-channels">Step 5. Combine the Two Independent Error Channels</h3>
<p>Since the error channels act on independent subsystems, the overall fidelity is the product of the individual fidelities:</p>
<div class="arithmatex">\[
F_{\text{total}} = \left(1 - \frac{4p}{5}\right) \cdot \left(1 - \frac{4p}{5}\right) = \left(1 - \frac{4p}{5}\right)^2
\]</div>
<hr />
<h3 id="final-answer">Final Answer:</h3>
<div class="arithmatex">\[
\boxed{\left(1 - \frac{4p}{5}\right)^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we wish to prepare a logical two-qubit GHZ state <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?&rdquo;</p>
<p>Interpretation: We have the same circuit as before. But now we are post-selecting on detectable errors. That means we measure the stabilizers (XXXX and ZZZZ) and only keep outcomes that are +1? But careful: The [[4,2,2]] code has distance 2, so it can detect any single-qubit error? Actually, it&rsquo;s a detection code. The stabilizers are XXXX and ZZZZ. The detectable errors are those that anti-commute with at least one stabilizer. But note: The code can detect any error that is not in the normalizer of the stabilizer group? Actually, the code detects errors that are not in the stabilizer group? Actually, if an error commutes with all stabilizers, it is undetectable. So detectable errors are those that anti-commute with at least one stabilizer.</p>
<p>We want: &ldquo;logical state fidelity&rdquo; after post-selection on all detectable errors. That means we discard any outcome where an error is detected. So we only consider cases where no error is detected. But careful: There might be errors that are not detected? They are undetectable errors. Those will affect the logical state fidelity.</p>
<p>So we need to compute: Given the error model (each CNOT gate followed by a depolarizing error on the two qubits involved, with probability p/15 for each non-identity Pauli on that pair), what is the fidelity of the logical state after we post-select on measurements that yield no error detection? That is, we assume we measure the stabilizers XXXX and ZZZZ. If we get -1 on either, we discard. So we only keep runs where both stabilizers give +1. In those runs, the state is in the code space. But it might be a logical error. So we want the fidelity of the logical state relative to the ideal logical state.</p>
<p>So we need to analyze which errors from the error channels are detectable and which are undetectable. And then compute the probability that no error occurs (which gives fidelity 1) and the probability that an undetectable error occurs (which might reduce fidelity). And then normalize by the total probability of success (post-selection probability).</p>
<p>Let&rsquo;s denote the error channels as before: They act on pairs: first error on qubits {2,1} and second on qubits {0,3}. And we already moved them to the end. So the overall effect is: The ideal state |ψ&gt; is subjected to two independent depolarizing channels on disjoint pairs: E_{21} and E_{03}. So the final state (before post-selection) is:
ρ = E_{03} ∘ E_{21} (|ψ&gt;&lt;ψ|) with |ψ&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12}.</p>
<p>Now, we want to post-select on the state being in the code space. The code space of the [[4,2,2]] code is the space stabilized by S1 = XXXX and S2 = ZZZZ. So we measure these stabilizers. If the state is not in the +1 eigenspace, we discard.</p>
<p>So we want to compute the conditional state given that both stabilizers measure +1. And then compute the fidelity of that state to the ideal logical state |ψ_logical&gt; = (|00&gt;_AB + |11&gt;_AB)/√2. But careful: The ideal state |ψ&gt; is exactly that logical state? Actually, yes: |ψ&gt; is the encoded GHZ state. So we want the overlap with |ψ&gt;.</p>
<p>So we need to determine which Pauli errors (from the error channels) leave the state in the code space? That is, which Pauli errors E such that E|ψ&gt; is still in the code space? But careful: The error channels apply Pauli operators on the pairs. So the errors are of the form: P on qubits {2,1} and Q on qubits {0,3}. So overall error operator: R = Q_{03} ⊗ P_{12}. And we want to know: For which R does R|ψ&gt; lie in the code space? That is equivalent to: R commutes with the stabilizers? Actually, if R is a logical operator (including stabilizers), then R|ψ&gt; is in the code space. But if R anti-commutes with a stabilizer, then R|ψ&gt; is orthogonal to the code space? Actually, if |ψ&gt; is in the code space, then S|ψ&gt; = |ψ&gt;. Then if R anti-commutes with S, then S R|ψ&gt; = - R S|ψ&gt; = - R|ψ&gt;, so R|ψ&gt; is in the -1 eigenspace of S. So it will be detected. So post-selection means we only keep errors that commute with both stabilizers. So we need to find all Pauli operators on the 4 qubits that commute with XXXX and ZZZZ. That is the normalizer of the stabilizer group. The stabilizer group is generated by XXXX and ZZZZ. The normalizer (within Pauli group) consists of Pauli operators that commute with both. What are these? They are exactly the logical operators and the stabilizers themselves. But careful: The code is [[4,2,2]], so there are 2 logical qubits. The logical operators are given: X_A = XIXI, X_B = XXII, Z_A = ZZII, Z_B = ZIZI. And also products. So the normalizer group (modulo phases) has size? Actually, the full normalizer of the stabilizer group in the Pauli group on 4 qubits: The stabilizer group has 4 elements? Actually, generated by XXXX and ZZZZ, so there are 4 stabilizers: I, XXXX, ZZZZ, and XXXX ZZZZ = -YYYY? But careful: XXXX * ZZZZ = (XZ)(XZ)(XZ)(XZ) = (-iY)^4? Actually, compute: X Z = -i Y, so (X Z)^4 = (-i)^4 Y^4 = 1? Actually, careful: For each qubit, X_i Z_i = -i Y_i. So product over i: (X1 Z1)(X2 Z2)(X3 Z3)(X4 Z4) = (-i)^4 Y1 Y2 Y3 Y4 = YYYY. So XXXX * ZZZZ = YYYY. But wait, check signs: XXXX and ZZZZ commute? They commute because they act on different Paulis? Actually, X and Z anticommute on the same qubit, but here they are on all qubits. Actually, XXXX and ZZZZ: For each qubit, X and Z anticommute. So product of signs: There are 4 qubits, so overall they commute if even number? Actually, check: XXXX * ZZZZ = (X1X2X3X4)(Z1Z2Z3Z4) = (-1)^4 (Z1Z2Z3Z4)(X1X2X3X4) = they commute. So the stabilizer group is {I, XXXX, ZZZZ, XXXX ZZZZ} but note: XXXX ZZZZ = YYYY? But careful: XXXX ZZZZ = (X1Z1)(X2Z2)(X3Z3)(X4Z4) = (-iY1)(-iY2)(-iY3)(-iY4) = (-i)^4 Y1Y2Y3Y4 = YYYY. So yes.
So the stabilizer group has 4 elements. The normalizer of this group in the Pauli group on 4 qubits: The Pauli group on 4 qubits has 4^4 * center? Actually, the Pauli group modulo phases has size 4^4 = 256. The normalizer of the stabilizer group will be those Paulis that commute with XXXX and ZZZZ. Let&rsquo;s determine conditions. A Pauli operator is of the form i^c * X^a Z^b, where a,b are binary vectors of length 4. Commutation with XXXX: XXXX is X⊗X⊗X⊗X. A Pauli operator P = ± X^a Z^b commutes with XXXX if and only if the number of qubits where both have X and Z? Actually, simpler: XXXX commutes with a Pauli if and only if the product of the signs from each qubit is 1. For each qubit, if the Pauli has either I, X, Y, Z? Actually, XXXX is all X. So for a single qubit, X commutes with I and X, but anticommutes with Z and Y. So overall, XXXX commutes with a Pauli if and only if the number of qubits where the Pauli is Z or Y is even. Similarly, ZZZZ commutes with a Pauli if and only if the number of qubits where the Pauli is X or Y is even.
So the condition for a Pauli (ignoring phase) to be in the normalizer is: The number of qubits with Pauli in {Z, Y} is even, and the number of qubits with Pauli in {X, Y} is even.
Now, our errors come from two independent channels on pairs: {0,3} and {2,1}. So we want to list all Pauli errors on these pairs that commute with both stabilizers. But careful: The errors are applied as: R = Q on {0,3} and P on {2,1}. So overall, the Pauli is on qubits: qubit0: from Q, qubit3: from Q, qubit2: from P, qubit1: from P.
Let&rsquo;s label qubits: 0,1,2,3. But careful: Our pairs: The first error acts on qubits {2,1}? Actually, the circuit: CNOT_{21} so that acts on qubits 2 and 1. So the error channel after that acts on qubits 2 and 1. And the second error acts on qubits 0 and 3.
So let’s denote:
For qubits 0 and 3: error operator Q. Q can be any of the 16 Paulis on two qubits (including identity). But we are interested in non-identity? Actually, we want to compute the probability of success and the fidelity conditional on success.
For qubits 1 and 2: error operator P.</p>
<p>Now, the condition for the overall Pauli R = Q ⊗ P (tensor product on qubits: qubit0 from Q, qubit3 from Q, qubit1 from P, qubit2 from P) to be in the normalizer (i.e., undetectable) is:
Condition from XXXX: The number of qubits where the Pauli is Z or Y must be even.
Condition from ZZZZ: The number of qubits where the Pauli is X or Y must be even.</p>
<p>Let&rsquo;s denote the Pauli on each qubit as: 
Q on qubits 0 and 3: Let Q = A ⊗ B, where A acts on qubit0, B acts on qubit3.
P on qubits 1 and 2: Let P = C ⊗ D, where C acts on qubit1, D acts on qubit2.
But careful: The ordering: qubits: 0,1,2,3. So:
Q gives: qubit0: type from A, qubit3: type from B.
P gives: qubit1: type from C, qubit2: type from D.</p>
<p>Now, condition from XXXX: The Pauli on each qubit: 
Qubit0: if A is Z or Y, then count 1.
Qubit1: if C is Z or Y, count 1.
Qubit2: if D is Z or Y, count 1.
Qubit3: if B is Z or Y, count 1.
Total must be even.
Condition from ZZZZ: 
Qubit0: if A is X or Y, count 1.
Qubit1: if C is X or Y, count 1.
Qubit2: if D is X or Y, count 1.
Qubit3: if B is X or Y, count 1.
Total must be even.</p>
<p>Now, note that our ideal state |ψ&gt; is a product of two Bell states on pairs (0,3) and (1,2). And we are applying errors that are products on these pairs. So it might be easier to analyze each pair separately? But careful: The conditions for being undetectable are global conditions across all four qubits. However, because the errors are independent on the two pairs, we can compute the probability that an error on a given pair is &ldquo;allowed&rdquo; (i.e., when combined with some error on the other pair, the overall is undetectable)? But actually, post-selection: We measure stabilizers. That means we only keep if both stabilizers give +1. That condition depends on both errors. So we need to consider joint errors.</p>
<p>Maybe we can compute: The total probability of success (no detection) is sum over all error patterns R that commute with stabilizers of the probability that R occurs. And then among those, the fidelity is: &lt;ψ| R |ψ&gt;? But careful: If R is a logical operator that is not the identity, then R|ψ&gt; might be a different logical state. So we need to compute the overlap with |ψ&gt;. For a Pauli R that is in the normalizer, R|ψ&gt; will be some logical state. The fidelity contribution from that error pattern is |&lt;ψ| R |ψ&gt;|^2. And if R is a stabilizer, then R|ψ&gt; = |ψ&gt; because |ψ&gt; is in the code space? Actually, check: If R is a stabilizer, then R|ψ&gt; = |ψ&gt; if the stabilizer is +1. But careful: The stabilizers are XXXX and ZZZZ. But our state |ψ&gt; is a logical state. Is it stabilized by these? Yes, because it&rsquo;s in the code space. So if R is in the stabilizer group, then R|ψ&gt; = |ψ&gt;. So fidelity = 1.
If R is a logical operator that is not the identity on the logical qubits, then it might flip the logical state. For example, if R = X_A, then X_A|ψ&gt; = ? |ψ&gt; is (|00&gt;+|11&gt;)/√2. X_A acts on logical qubit A. That would give (|10&gt;+|01&gt;)/√2, which is orthogonal to |ψ&gt; if |ψ&gt; is GHZ? Actually, careful: The logical GHZ state is (|00&gt;<em>AB + |11&gt;_AB)/√2. If we apply X on qubit A, we get (|10&gt;+|01&gt;)/√2, which has overlap 0 with the original. So fidelity = 0.
But wait: There might be logical operators that are not identity but still leave |ψ&gt; invariant? For example, if we apply X_A X_B, then that sends |00&gt; to |11&gt; and |11&gt; to |00&gt;? Actually, X_A X_B on |00&gt; gives |11&gt; and on |11&gt; gives |00&gt;, so it actually leaves the state invariant? Check: (|00&gt;+|11&gt;)/√2 under X_A X_B becomes (|11&gt;+|00&gt;)/√2 = same state. So operators that are logical operators that are products of X on both logical qubits might preserve the GHZ state? But careful: Our logical operators are given: X_A = XIXI, X_B = XXII. So X_A X_B = (XIXI)(XXII) = ? Actually, compute: X_A X_B: On qubit0: X from X_A and X from X_B gives X? Actually, careful: X_A = X on qubit0? Actually, given: X_A = XIXI. That means: qubit0: X, qubit1: I, qubit2: X, qubit3: I? Wait: The notation: X_A = XIXI. The qubits are labeled 0,1,2,3. So X_A acts on qubit0 and qubit2? But then X_B = XXII acts on qubits 0 and 1? That is interesting: They overlap on qubit0. So then X_A X_B = (X on qubit0 from both gives X^2=I?) Actually, careful: XIXI means: Pauli on qubit0: X, qubit1: I, qubit2: X, qubit3: I. And XXII means: qubit0: X, qubit1: X, qubit2: I, qubit3: I. So their product: qubit0: X * X = I, qubit1: I * X = X, qubit2: X * I = X, qubit3: I * I = I. So X_A X_B = I X X I? That is not necessarily a stabilizer? Check commutation with stabilizers: XXXX would require? Actually, it might be a logical operator. But then does it preserve the GHZ state? The GHZ state is (|00&gt;_AB+|11&gt;_AB)/√2. Under X_A X_B, logical state: |00&gt; goes to? X_A X_B on logical qubits: Actually, we need to know the action on logical states. The logical operators are defined. But maybe we can compute the overlap &lt;ψ| R |ψ&gt; directly from the fact that |ψ&gt; factors as Bell states on (0,3) and (1,2). And R is a product of errors on these pairs. So we can compute &lt;ψ| R |ψ&gt; = &lt;Φ^+|</em>{03} Q |Φ^+&gt;<em>{03} * &lt;Φ^+|</em>{12} P |Φ^+&gt;<em>{12}. And we already computed that for a two-qubit Pauli on a Bell state, the overlap is nonzero only if the Pauli is of the form A⊗A (symmetric) and then it is ±1. So actually, for an error pattern R = Q ⊗ P (on pairs (0,3) and (1,2)), the fidelity contribution is: 
F(R) = |&lt;ψ|R|ψ&gt;|^2 = (|&lt;Φ^+|Q|Φ^+&gt;|^2) * (|&lt;Φ^+|P|Φ^+&gt;|^2). And we know that for a two-qubit Pauli on a Bell state, if it is of the form I⊗I, X⊗X, Y⊗Y, Z⊗Z, then the squared overlap is 1. For any other Pauli, it is 0.
So that means that even if R is an undetectable error (commutes with stabilizers), if it does not have the form that gives overlap 1 on each pair, then the fidelity will be 0. But wait: Could there be an error that is undetectable but still gives overlap 0? For example, consider a stabilizer itself: XXXX. But XXXX on the whole state: That acts on qubits 0,1,2,3. But our errors are on pairs separately. But note: Our errors are products: Q on {0,3} and P on {1,2}. So can XXXX be written as a product of a Pauli on {0,3} and a Pauli on {1,2}? XXXX = (X on qubit0)(X on qubit3) * (X on qubit1)(X on qubit2) = (X⊗X)</em>{03} ⊗ (X⊗X)<em>{12}. So that is of the form Q = X⊗X and P = X⊗X. And then &lt;Φ^+|X⊗X|Φ^+&gt; = 1. So that gives fidelity 1.
What about ZZZZ? That is (Z⊗Z)</em>{03} ⊗ (Z⊗Z)<em>{12}. That gives fidelity 1.
What about XXXX ZZZZ = YYYY? That is (Y⊗Y)</em>{03} ⊗ (Y⊗Y)<em>{12}. But careful: &lt;Φ^+|Y⊗Y|Φ^+&gt; = -1, so squared is 1.
So stabilizers give fidelity 1.
What about a logical operator like X_A? X_A = XIXI. That means on qubits: qubit0: X, qubit1: I, qubit2: X, qubit3: I. But can that be factored as a product on pairs (0,3) and (1,2)? That would require: On pair (0,3): we need something that gives X on qubit0 and I on qubit3. That is X⊗I. On pair (1,2): we need I on qubit1 and X on qubit2. That is I⊗X. So X_A = (X⊗I)</em>{03} ⊗ (I⊗X)<em>{12}. But then &lt;Φ^+|X⊗I|Φ^+&gt; = 0 because it&rsquo;s not symmetric. So fidelity = 0.
Similarly, X_B = XXII = (X on qubit0 and qubit1) but careful: XXII: qubit0: X, qubit1: X, qubit2: I, qubit3: I. That factors as (X⊗I)</em>{03}? Actually, on pair (0,3): qubit0: X, qubit3: I so that is X⊗I. On pair (1,2): qubit1: X, qubit2: I so that is X⊗I? But wait: That would be (X⊗I) ⊗ (X⊗I) but then overall: qubit0: X, qubit1: X, qubit2: I, qubit3: I. But that is not XXII? Actually, XXII means: qubit0: X, qubit1: X, qubit2: I, qubit3: I. So yes, X_B = (X⊗I)<em>{03} ⊗ (X⊗I)</em>{12}. But then &lt;Φ^+|X⊗I|Φ^+&gt; = 0. So fidelity = 0.
What about Z_A = ZZII = (Z on qubit0 and qubit1)? That factors as (Z⊗I)<em>{03} ⊗ (Z⊗I)</em>{12} so fidelity = 0.
Z_B = ZIZI = (Z on qubit0 and qubit2)? That factors as (Z⊗I)<em>{03}? Actually, careful: ZIZI: qubit0: Z, qubit1: I, qubit2: Z, qubit3: I. So on pair (0,3): (Z⊗I), on pair (1,2): (I⊗Z) so fidelity = 0.
What about products like X_A X_B? That we computed: X_A X_B = (I X X I) actually? Let&rsquo;s compute properly:
X_A = XIXI: so on qubits: 0:X, 1:I, 2:X, 3:I.
X_B = XXII: so on qubits: 0:X, 1:X, 2:I, 3:I.
Product: qubit0: X<em>X = I, qubit1: I</em>X = X, qubit2: X<em>I = X, qubit3: I</em>I = I.
So X_A X_B = I, X, X, I. That factors as: on pair (0,3): (I⊗I) and on pair (1,2): (X⊗X). So then fidelity = 1 * 1 = 1. So indeed, X_A X_B preserves the state.
Similarly, Z_A Z_B? Z_A = ZZII: qubit0:Z, qubit1:Z, qubit2:I, qubit3:I.
Z_B = ZIZI: qubit0:Z, qubit1:I, qubit2:Z, qubit3:I.
Product: qubit0: Z<em>Z = I, qubit1: Z</em>I = Z, qubit2: I<em>Z = Z, qubit3: I</em>I = I.
So that is (I⊗I)</em>{03} and (Z⊗Z)<em>{12} so fidelity = 1.
What about X_A Z_A? That would be? But likely the pattern is: An error pattern R = Q ⊗ P will have nonzero fidelity if and only if Q is one of {I⊗I, X⊗X, Y⊗Y, Z⊗Z} and P is one of {I⊗I, X⊗X, Y⊗Y, Z⊗Z}. But wait: Is that sufficient for R to be undetectable? Let&rsquo;s check: If Q is, say, X⊗X and P is I⊗I, then overall R = (X⊗X)</em>{03} ⊗ (I⊗I)<em>{12}. That is actually XXXX on qubits 0 and 3? But careful: That gives: qubit0: X, qubit1: I, qubit2: I, qubit3: X. That is not necessarily a stabilizer? Check commutation with XXXX: For qubit0: X -&gt; count for Z? Actually, use conditions: For R = (X⊗X)</em>{03} and (I⊗I)<em>{12}. Then qubit0: X -&gt; for XXXX: X is not Z or Y so count 0? Actually, condition: XXXX: count qubits with Pauli in {Z,Y}. Here qubit0: X -&gt; 0; qubit1: I -&gt; 0; qubit2: I -&gt; 0; qubit3: X -&gt; 0. So it commutes. For ZZZZ: count qubits with Pauli in {X,Y}. qubit0: X -&gt; 1; qubit1: I -&gt; 0; qubit2: I -&gt; 0; qubit3: X -&gt; 1; total 2, even. So it commutes. So it is undetectable. And indeed fidelity = 1.
What if Q = X⊗X and P = X⊗I? That would give fidelity 0 because &lt;Φ^+|X⊗I|Φ^+&gt;=0. But would that be undetectable? Check: R = (X⊗X)</em>{03} ⊗ (X⊗I)<em>{12}. Then qubits: 0: X, 1: X, 2: I, 3: X. For XXXX: count qubits with Z or Y: qubit0: X -&gt; 0; qubit1: X -&gt; 0; qubit2: I -&gt; 0; qubit3: X -&gt; 0; so okay. For ZZZZ: count qubits with X or Y: qubit0: X -&gt; 1; qubit1: X -&gt; 1; qubit2: I -&gt; 0; qubit3: X -&gt; 1; total 3, odd. So it would be detected. So indeed, for an error to be undetectable, it must that on each pair, the Pauli is either identity or one of the symmetric ones? But is that necessary? Let&rsquo;s check: Suppose Q = X⊗I and P = I⊗X? That gives overall: qubit0: X, qubit1: I, qubit2: X, qubit3: I. That is X_A? Actually, X_A = XIXI. That we already determined: For XXXX: qubit0: X -&gt; 0; qubit1: I -&gt; 0; qubit2: X -&gt; 0; qubit3: I -&gt; 0; so okay. For ZZZZ: qubit0: X -&gt; 1; qubit1: I -&gt; 0; qubit2: X -&gt; 1; qubit3: I -&gt; 0; total 2, even. So that is undetectable. But fidelity: &lt;Φ^+|X⊗I|Φ^+&gt; = 0, and &lt;Φ^+|I⊗X|Φ^+&gt; = 0, so fidelity = 0. So indeed, even if undetectable, fidelity can be 0.
So pattern: For an error pattern R = Q ⊗ P to yield nonzero fidelity, we need that Q is in the set S = {I⊗I, X⊗X, Y⊗Y, Z⊗Z} and P is in S. And then fidelity = 1.
What about errors that are products of stabilizers? Those are in S as well because stabilizers are: XXXX = (X⊗X)</em>{03} (X⊗X)<em>{12} so that is both in S. ZZZZ = (Z⊗Z)</em>{03} (Z⊗Z)<em>{12}. And XXXX ZZZZ = (Y⊗Y)</em>{03} (Y⊗Y)_{12}. So indeed, the errors that preserve the state (fidelity=1) are exactly those where on each pair, the error is either identity or a Pauli that is the same on both qubits (X⊗X, Y⊗Y, Z⊗Z). But wait: Is that sufficient for the error to be undetectable? Check: If Q = X⊗X and P = I⊗I, then as above, it is undetectable. So yes.
So then, the successful post-selection events are those error patterns R that commute with both stabilizers. But note: Not all such patterns give fidelity 1. They give fidelity 1 only if additionally, on each pair, the error is symmetric. But wait: Could there be an error pattern that is undetectable but not of that form yet still gives fidelity 1? Consider: Q = X⊗I and P = X⊗I? That gives overall: qubit0: X, qubit1: X, qubit2: I, qubit3: I. That is X_B? Actually, X_B = XXII. Check: For XXXX: qubit0: X -&gt; 0; qubit1: X -&gt; 0; qubit2: I -&gt; 0; qubit3: I -&gt; 0; so okay. For ZZZZ: qubit0: X -&gt; 1; qubit1: X -&gt; 1; qubit2: I -&gt; 0; qubit3: I -&gt; 0; total 2, even. So it is undetectable. But fidelity: &lt;Φ^+|X⊗I|Φ^+&gt; = 0, so fidelity = 0. So no.
What about Q = X⊗I and P = I⊗X? That is X_A, fidelity 0.
What about Q = X⊗I and P = X⊗X? That gives: qubit0: X, qubit1: X, qubit2: X, qubit3: X? Actually, careful: Q = X⊗I means on pair (0,3): qubit0: X, qubit3: I. P = X⊗X means on pair (1,2): qubit1: X, qubit2: X. So overall: qubit0: X, qubit1: X, qubit2: X, qubit3: I. That pattern: For XXXX: qubit0: X -&gt; 0; qubit1: X -&gt; 0; qubit2: X -&gt; 0; qubit3: I -&gt; 0; so okay. For ZZZZ: qubit0: X -&gt; 1; qubit1: X -&gt; 1; qubit2: X -&gt; 1; qubit3: I -&gt; 0; total 3, odd. So actually, that would be detected. So it&rsquo;s not undetectable.
So indeed, the condition for undetectability (commuting with stabilizers) actually forces that on each pair, the error must be either both identity or both non-identity? Let&rsquo;s check: Suppose on pair (0,3), we have an error that is not symmetric, say X⊗I. For it to be undetectable, the condition from ZZZZ: The number of qubits with X or Y from pair (0,3) is 1 (from qubit0). So then from pair (1,2), we need an odd number of qubits with X or Y to make total even? That would be 1 or 3. But on two qubits, the only possibility to have an odd number is if exactly one qubit has X or Y and the other has I or Z? But then check XXXX condition: On pair (0,3), X⊗I: qubit0: X -&gt; 0; qubit3: I -&gt; 0 so that&rsquo;s 0. So then pair (1,2) must have an even number of qubits with Z or Y. If we take on pair (1,2) an error like I⊗X, then that gives: qubit1: I -&gt; 0; qubit2: X -&gt; 0 so that&rsquo;s 0. So overall, X⊗I on (0,3) and I⊗X on (1,2) gives undetectable? That is X_A. And we already computed that gives fidelity 0. So such errors are undetectable but yield fidelity 0.
So then, for the logical fidelity after post-selection, we only care about error patterns that are undetectable and that yield fidelity 1. And these are exactly the patterns where on each pair, the error is in the set S = {I, X⊗X, Y⊗Y, Z⊗Z}? But wait: Is it necessary that both pairs are in S? Consider: What if one pair is I and the other is something that is not in S but still gives overlap? But as we computed, for a Bell state, the only Paulis that give nonzero overlap are those in S. So indeed, for fidelity to be 1, we need that on each pair, the error is in S.
But wait: Could there be an error pattern that is not a product of errors on the pairs? But our errors come as independent on the pairs. So we only consider products.
So then, the successful events (post-selection) are those where the overall error R is such that it commutes with both stabilizers. But note: Even if R is in the normalizer, if it is not of the form with both pairs in S, then the fidelity is 0. But wait: Is it possible that an error pattern that is not in S on both pairs still gives fidelity 1? For example, if the error on one pair is something that gives phase -1? But then squared overlap is still 1. So indeed, we require that on each pair, the Pauli is either I, X⊗X, Y⊗Y, or Z⊗Z. But careful: For Y⊗Y, the overlap is -1, but squared is 1. So yes.
So then, the conditional logical fidelity will be: 
F_logical = (Probability that error pattern is in the set that gives fidelity 1) / (Probability that error pattern is undetectable) 
because if undetectable but not fidelity 1, then the state is orthogonal to the ideal state, so fidelity = 0.</p>
<p>So we need to compute:
P_success = probability that the overall error R (from both channels) is undetectable (i.e., commutes with both stabilizers).
And within that, P_good = probability that R is such that on pair (0,3), Q is in S, and on pair (1,2), P is in S. But careful: Is it true that if Q is in S and P is in S, then R is undetectable? Check: If Q is in S, then Q is either I, X⊗X, Y⊗Y, Z⊗Z. For any of these, what are the conditions? For Q = X⊗X: On qubits 0 and 3, for XXXX: none are Z or Y? Actually, X is not Z or Y, so count=0. For ZZZZ: both are X, so count=2 (even). So okay. For Y⊗Y: then each qubit is Y, so for XXXX: Y counts as 1 each, total 2 even; for ZZZZ: Y counts as 1 each, total 2 even. For Z⊗Z: then for XXXX: Z counts as 1 each, total 2 even; for ZZZZ: Z does not count? Actually, Z is not X or Y, so count=0. So yes. So indeed, if both pairs are in S, then R is undetectable. So the good events are a subset of the undetectable events.
But are there undetectable events that are not in S? Yes, as we saw: X_A = (X⊗I on (0,3)) and (I⊗X on (1,2)) is undetectable but not in S because X⊗I is not in S (since its overlap with Bell state is 0). So such events will be post-selected (they are undetectable) but they yield fidelity 0.
So then the logical fidelity after post-selection is:
F = (Probability of good events) / (Probability of undetectable events).</p>
<p>Now, we need to compute these probabilities from the error model.
The error channels are independent on the two pairs.
On each pair, the error channel is: With probability 1-p, no error (identity). With probability p, a random non-identity Pauli is applied uniformly among 15 possibilities.
So on a given pair (say pair (0,3)), the probability distribution over Paulis is:
P(Q = I) = 1-p.
For any non-identity Pauli, P(Q = specific Pauli) = p/15.
Similarly for pair (1,2).</p>
<p>Now, we want to compute: 
P(undetectable) = Sum over Q and P such that R = Q⊗P commutes with stabilizers.
And P(good) = Sum over Q in S and P in S.</p>
<p>But careful: &ldquo;undetectable&rdquo; means that R is in the normalizer of the stabilizer group. But note: The normalizer includes also the stabilizers themselves. But that&rsquo;s fine.</p>
<p>Let&rsquo;s compute for one pair first: The set of Paulis on two qubits. There are 16. They can be categorized by their effect on the Bell state? But we need to know which ones, when combined with something on the other pair, yield undetectability. But since the conditions are global, we need to compute joint probabilities. But maybe we can compute the probability that a given error pattern on a pair is &ldquo;compatible&rdquo; with undetectability? But it depends on the other pair. So we need to sum over both pairs.</p>
<p>Let&rsquo;s denote:
For pair (0,3): Let Q be a Pauli. For pair (1,2): Let P be a Pauli.
The condition for undetectability is:
Condition from XXXX: (number of qubits in {0,3} with Pauli in {Z,Y}) + (number from {1,2} with Pauli in {Z,Y}) is even.
Condition from ZZZZ: (number from {0,3} with Pauli in {X,Y}) + (number from {1,2} with Pauli in {X,Y}) is even.</p>
<p>Let&rsquo;s define for a two-qubit Pauli on a pair (say on qubits i and j). Actually, careful: The pairs are (0,3) and (1,2). But note: The conditions are symmetric? Actually, they are symmetric if we swap the pairs? But careful: The conditions are on the total over all four qubits. So we can compute: For a given Pauli on two qubits, we can compute two parity bits: 
a = parity of the number of qubits in that pair that have Pauli in {Z,Y}? Actually, we need the sum mod 2. So define for a Pauli Q on two qubits:
f_X(Q) = (number of qubits in that pair with Pauli in {X,Y}) mod 2.
f_Z(Q) = (number of qubits in that pair with Pauli in {Z,Y}) mod 2.
Then the conditions for undetectability for R = Q⊗P are:
f_X(Q) + f_X(P) ≡ 0 mod 2,
f_Z(Q) + f_Z(P) ≡ 0 mod 2.
So if we know the distribution of f_X and f_Z for Paulis on a pair, we can compute the probability that two independent Paulis (from the error channels) satisfy these conditions.</p>
<p>Also, what is the set S (good events)? S is the set of Paulis on two qubits that have nonzero overlap with the Bell state. As we determined, that is exactly the Paulis that are of the form: I, X⊗X, Y⊗Y, Z⊗Z. But wait: Is that all? Check: What about X⊗Y? That gives overlap 0. So yes.
So for a Pauli in S, what are f_X and f_Z?
For I: f_X(I)=0, f_Z(I)=0.
For X⊗X: On both qubits, Pauli is X. So f_X: X is in {X,Y} so each gives 1, so total 2 mod 2 = 0. f_Z: X is not in {Z,Y} so 0 mod 2 = 0.
For Y⊗Y: Each gives: Y is in both {X,Y} and {Z,Y}, so each gives 1, so total 2 mod 2 = 0 for both.
For Z⊗Z: f_X: Z is not in {X,Y} so 0; f_Z: Z is in {Z,Y} so each gives 1, so total 2 mod 2 = 0.
So indeed, for any Q in S, we have f_X(Q)=0 and f_Z(Q)=0.
What about other Paulis? They can have f_X and f_Z values of 0 or 1. Let&rsquo;s compute for all two-qubit Paulis. There are 16. They are products of Paulis on each qubit. Let&rsquo;s list by type? Actually, we can compute based on the number of qubits that are not I. But careful: f_X and f_Z are mod2 sums. For a single qubit Pauli:
I: f_X=0, f_Z=0.
X: f_X=1, f_Z=0.
Y: f_X=1, f_Z=1.
Z: f_X=0, f_Z=1.
So for a two-qubit Pauli Q = A ⊗ B, we have:
f_X(Q) = (f_X(A) + f_X(B)) mod 2.
f_Z(Q) = (f_Z(A) + f_Z(B)) mod 2.
So then the possible (f_X, f_Z) pairs for a two-qubit Pauli:
If Q = I⊗I: (0,0).
If Q = I⊗X: (1,0)
I⊗Y: (1,1)
I⊗Z: (0,1)
X⊗I: (1,0)
X⊗X: (0,0) because 1+1=2 mod2=0.
X⊗Y: (1+1=0 mod2? Actually, careful: X⊗Y: f_X(X)=1, f_X(Y)=1, so sum=0 mod2; f_Z(X)=0, f_Z(Y)=1, so sum=1 mod2) so (0,1)
X⊗Z: (1+0=1 mod2; 0+1=1 mod2) so (1,1)
Y⊗I: (1,1)
Y⊗X: (1+1=0, 1+0=1) so (0,1)
Y⊗Y: (1+1=0, 1+1=0) so (0,0)
Y⊗Z: (1+0=1, 1+1=0 mod2? Actually, f_Z(Y)=1, f_Z(Z)=1, so sum=0 mod2) so (1,0)
Z⊗I: (0,1)
Z⊗X: (0+1=1, 1+0=1) so (1,1)
Z⊗Y: (0+1=1, 1+1=0) so (1,0)
Z⊗Z: (0,0)</p>
<p>So summarizing: The 16 Paulis on two qubits have the following (f_X, f_Z) values:
(0,0): Which ones? I⊗I, X⊗X, Y⊗Y, Z⊗Z. That is 4.
(1,0): I⊗X, X⊗I, Y⊗Z, Z⊗Y. That is 4.
(0,1): I⊗Z, Z⊗I, X⊗Y, Y⊗X. That is 4.
(1,1): I⊗Y, Y⊗I, X⊗Z, Z⊗X. That is 4.
So indeed, evenly distributed: 4 each.</p>
<p>Now, the error channel on a pair: Probability that the Pauli is I: 1-p.
For each non-identity Pauli, probability = p/15.
So if we want to compute the probability that a given pair has a Pauli with a certain (f_X, f_Z) value, we can do:
For (0,0): That includes I and the other three non-identity ones that are in S? Actually, careful: (0,0) non-identity: X⊗X, Y⊗Y, Z⊗Z. So total probability for (0,0) on a pair = (1-p) + 3<em>(p/15) = 1-p + p/5 = 1 - (4/5)p.
For (1,0): There are 4 non-identity Paulis with (1,0)? But wait: Is I included? No, I is (0,0). So for (1,0), probability = 4</em>(p/15) = 4p/15.
Similarly, (0,1): probability = 4p/15.
(1,1): probability = 4p/15.</p>
<p>But careful: That sums to: 1-p + 3p/15 + 4p/15+4p/15+4p/15 = 1-p + 15p/15 = 1. Good.</p>
<p>Now, the condition for undetectability for two independent pairs is: 
f_X(Q) + f_X(P) ≡ 0 mod 2, and f_Z(Q) + f_Z(P) ≡ 0 mod 2.
That means that (f_X(Q), f_Z(Q)) must equal (f_X(P), f_Z(P)). So the pairs must have the same parity pair.
So, the probability that the overall error R is undetectable is:
P(undetectable) = Sum over the four parity types of [Probability that pair1 has that type] * [Probability that pair2 has that type].
= [P(0,0)^2 + P(1,0)^2 + P(0,1)^2 + P(1,1)^2].
We computed: P(0,0) = 1 - 4p/5.
P(1,0) = 4p/15.
P(0,1) = 4p/15.
P(1,1) = 4p/15.
So then:
P(undetectable) = (1 - 4p/5)^2 + 3<em>(4p/15)^2 = (1 - 4p/5)^2 + 3</em>(16p^2/225) = (1 - 4p/5)^2 + (48p^2/225).
And (1 - 4p/5)^2 = 1 - 8p/5 + 16p^2/25 = 1 - 8p/5 + (16p^2/25). And 16/25 = (16<em>9)/(25</em>9)=144/225. So that becomes: 1 - 8p/5 + 144p^2/225.
So P(undetectable) = 1 - 8p/5 + 144p^2/225 + 48p^2/225 = 1 - 8p/5 + 192p^2/225.
Simplify 192/225 = divide by 3: 192/3=64, 225/3=75, so = 64p^2/75. So:
P(undetectable) = 1 - (8/5)p + (64/75)p^2.</p>
<p>Now, the good events are those where both pairs are in S. And S is exactly the set of Paulis with (0,0) parity. So:
P(good) = [P(0,0)]^2 = (1 - 4p/5)^2 = 1 - 8p/5 + 16p^2/25 = 1 - 8p/5 + (16/25)p^2. And 16/25 = (16<em>3)/(25</em>3)=48/75. So P(good) = 1 - 8p/5 + (48/75)p^2.</p>
<p>Then the logical fidelity after post-selection is:
F_logical = P(good) / P(undetectable) = [1 - 8p/5 + (48/75)p^2] / [1 - 8p/5 + (64/75)p^2].</p>
<p>We can simplify: Multiply numerator and denominator by 75:
F_logical = [75 - 120p + 48p^2] / [75 - 120p + 64p^2].</p>
<p>That is the logical fidelity.</p>
<p>But wait: Is that the final answer? It says: &ldquo;What is the logical state fidelity &hellip; as a function of the two-qubit gate error rate p?&rdquo; So answer: 
F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2).</p>
<p>We can also simplify by dividing numerator and denominator by? 75,120,48 have common factor? 75,120,48: gcd(75,120)=15, but 48 is not divisible by 15. So maybe factor as? 
= (3(25) - 3(40)p + 48p^2) not simpler.
Alternatively, write as: = 1 - (16p^2/75) / denominator? Actually, 
F = 1 - (16p^2/75) / (1 - 8p/5 + 64p^2/75) = 1 - (16p^2)/(75 - 120p + 64p^2). So that is another form.</p>
<p>But maybe we keep as: 
F_logical = \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}.</p>
<p>I&rsquo;ll check: For small p, F_logical ≈ 1 - (16/75)p^2? That seems plausible.</p>
<p>Thus final answer for Subproblem 2.</p>
<p>I&rsquo;ll now produce the final answer in the required format.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-understand-the-setup">Step 1. Understand the Setup</h3>
<p>We aim to prepare the logical GHZ state  </p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the <span class="arithmatex">\([[4,2,2]]\)</span> code using the circuit:  </p>
<div class="arithmatex">\[
(\text{CNOT}_{03}) (H_0) (\text{CNOT}_{21}) (H_2).
\]</div>
<p>Operations are applied from right to left:</p>
<ol>
<li><span class="arithmatex">\(H_2\)</span> on qubit 2  </li>
<li><span class="arithmatex">\(\text{CNOT}_{21}\)</span> (control: qubit 2, target: qubit 1)  </li>
<li><span class="arithmatex">\(H_0\)</span> on qubit 0  </li>
<li><span class="arithmatex">\(\text{CNOT}_{03}\)</span> (control: qubit 0, target: qubit 3)</li>
</ol>
<p>Starting from <span class="arithmatex">\(|0000\rangle\)</span>, the ideal output is:  </p>
<div class="arithmatex">\[
|\psi\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right).
\]</div>
<p>This factors as:  </p>
<div class="arithmatex">\[
|\psi\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}, \quad \text{where} \quad |\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}.
\]</div>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel:</p>
<ul>
<li>With probability <span class="arithmatex">\(1 - p\)</span>, no error occurs.</li>
<li>With probability <span class="arithmatex">\(p\)</span>, a non-identity two-qubit Pauli error occurs (uniformly among 15 possibilities).</li>
</ul>
<p>Hadamard gates are error-free.</p>
<p>By commuting error channels to the end, the overall effect is equivalent to applying the ideal circuit <span class="arithmatex">\(U\)</span>, followed by independent depolarizing channels on qubit pairs <span class="arithmatex">\(\{0,3\}\)</span> and <span class="arithmatex">\(\{1,2\}\)</span>.</p>
<hr />
<h3 id="step-2-post-selection-and-logical-fidelity">Step 2. Post-Selection and Logical Fidelity</h3>
<p>The code stabilizers are <span class="arithmatex">\(S_1 = XXXX\)</span> and <span class="arithmatex">\(S_2 = ZZZZ\)</span>. Post-selection means we only keep states where both stabilizers measure <span class="arithmatex">\(+1\)</span>, i.e., the state is in the code space.</p>
<p>Let <span class="arithmatex">\(R = Q \otimes P\)</span> be the overall error, where:</p>
<ul>
<li><span class="arithmatex">\(Q\)</span> acts on qubits <span class="arithmatex">\(\{0,3\}\)</span></li>
<li><span class="arithmatex">\(P\)</span> acts on qubits <span class="arithmatex">\(\{1,2\}\)</span></li>
</ul>
<p>We define parity functions for a two-qubit Pauli operator:</p>
<ul>
<li><span class="arithmatex">\(f_X\)</span>: parity of qubits with Pauli in <span class="arithmatex">\(\{X, Y\}\)</span></li>
<li><span class="arithmatex">\(f_Z\)</span>: parity of qubits with Pauli in <span class="arithmatex">\(\{Z, Y\}\)</span></li>
</ul>
<p>Then <span class="arithmatex">\(R\)</span> is undetectable (commutes with both stabilizers) iff:  </p>
<div class="arithmatex">\[
f_X(Q) = f_X(P) \quad \text{and} \quad f_Z(Q) = f_Z(P).
\]</div>
<p>The fidelity is non-zero only if <span class="arithmatex">\(Q\)</span> and <span class="arithmatex">\(P\)</span> are both in the set:  </p>
<div class="arithmatex">\[
S = \{I, X\otimes X, Y\otimes Y, Z\otimes Z\},
\]</div>
<p>which corresponds to <span class="arithmatex">\((f_X, f_Z) = (0,0)\)</span>. In this case,  </p>
<div class="arithmatex">\[
\langle \psi | R | \psi \rangle = \langle \Phi^+ | Q | \Phi^+ \rangle \cdot \langle \Phi^+ | P | \Phi^+ \rangle = \pm 1,
\]</div>
<p>so the fidelity is 1.</p>
<p>Let:</p>
<ul>
<li><span class="arithmatex">\(P(\text{undetectable})\)</span>: probability that <span class="arithmatex">\(R\)</span> is undetectable</li>
<li><span class="arithmatex">\(P(\text{good})\)</span>: probability that <span class="arithmatex">\(R\)</span> is undetectable and fidelity = 1</li>
</ul>
<p>Then the logical fidelity after post-selection is:  </p>
<div class="arithmatex">\[
F_{\text{logical}} = \frac{P(\text{good})}{P(\text{undetectable})}.
\]</div>
<hr />
<h3 id="step-3-compute-probabilities-from-error-channels">Step 3. Compute Probabilities from Error Channels</h3>
<p>On each pair, the error distribution is:</p>
<ul>
<li><span class="arithmatex">\(P(I) = 1 - p\)</span></li>
<li><span class="arithmatex">\(P(\text{non-identity}) = \frac{p}{15}\)</span> for each of the 15 Paulis</li>
</ul>
<p>The 16 Paulis on two qubits are evenly distributed into 4 groups based on <span class="arithmatex">\((f_X, f_Z)\)</span>:</p>
<ul>
<li><span class="arithmatex">\((0,0)\)</span>: <span class="arithmatex">\(I, X\otimes X, Y\otimes Y, Z\otimes Z\)</span>  </li>
</ul>
<div class="arithmatex">\[
  P(0,0) = 1 - p + 3\cdot\frac{p}{15} = 1 - \frac{4}{5}p
\]</div>
<ul>
<li><span class="arithmatex">\((1,0), (0,1), (1,1)\)</span>: 4 Paulis each  </li>
</ul>
<div class="arithmatex">\[
  P(1,0) = P(0,1) = P(1,1) = 4\cdot\frac{p}{15} = \frac{4}{15}p
\]</div>
<p>Since errors on the two pairs are independent:</p>
<div class="arithmatex">\[
\begin{aligned}
P(\text{undetectable}) &amp;= [P(0,0)]^2 + [P(1,0)]^2 + [P(0,1)]^2 + [P(1,1)]^2 \\
&amp;= \left(1 - \frac{4}{5}p\right)^2 + 3\left(\frac{4}{15}p\right)^2 \\
&amp;= 1 - \frac{8}{5}p + \frac{64}{75}p^2
\end{aligned}
\]</div>
<div class="arithmatex">\[
\begin{aligned}
P(\text{good}) &amp;= [P(0,0)]^2 = \left(1 - \frac{4}{5}p\right)^2 \\
&amp;= 1 - \frac{8}{5}p + \frac{16}{25}p^2 = 1 - \frac{8}{5}p + \frac{48}{75}p^2
\end{aligned}
\]</div>
<hr />
<h3 id="step-4-logical-fidelity-after-post-selection">Step 4. Logical Fidelity After Post-Selection</h3>
<div class="arithmatex">\[
\begin{aligned}
F_{\text{logical}} &amp;= \frac{P(\text{good})}{P(\text{undetectable})} \\
&amp;= \frac{1 - \frac{8}{5}p + \frac{48}{75}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2} \\
&amp;= \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}
\end{aligned}
\]</div>
<hr />
<h3 id="final-answer">Final Answer:</h3>
<div class="arithmatex">\[
\boxed{\frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given the expression for the logical fidelity from the previous step:
 F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2)</p>
<p>We will represent this using SymPy.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>To solve this problem, we need to determine the logical state fidelity of the final 2-qubit logical state after preparing a GHZ state using the given circuit, considering post-selection on detectable errors. The logical fidelity is derived by analyzing the probability of undetectable errors that preserve the logical state, normalized by the total probability of undetectable errors.</p>
<h3 id="approach">Approach</h3>
<ol>
<li><strong>Circuit Analysis</strong>: The circuit prepares the logical GHZ state by applying Hadamard and CNOT gates. Each CNOT gate is followed by a depolarizing error channel affecting its qubit pair.</li>
<li><strong>Error Model</strong>: Errors are modeled as Pauli operators applied to qubit pairs {0,3} and {1,2} with probability <span class="arithmatex">\( p \)</span> for non-identity operators.</li>
<li><strong>Post-Selection</strong>: We only consider error patterns that commute with the stabilizers <span class="arithmatex">\( XXXX \)</span> and <span class="arithmatex">\( ZZZZ \)</span>, ensuring the state remains in the code space.</li>
<li><strong>Fidelity Calculation</strong>: The logical fidelity is the ratio of the probability of error patterns that preserve the logical state (fidelity 1) to the probability of all undetectable error patterns.</li>
</ol>
<h3 id="solution-code">Solution Code</h3>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="mi">75</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">48</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="mi">75</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">64</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div>

<h3 id="explanation">Explanation</h3>
<p>The logical fidelity expression is derived by considering the probabilities of error patterns that either preserve or disrupt the logical state. The numerator represents the probability of error patterns that leave the logical state unchanged (fidelity 1), while the denominator represents the probability of all undetectable error patterns. The ratio of these probabilities gives the logical fidelity after post-selection, which is expressed as a function of the error rate <span class="arithmatex">\( p \)</span>. The resulting expression is returned as a SymPy object for further symbolic manipulation or evaluation.</p></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.142574
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>