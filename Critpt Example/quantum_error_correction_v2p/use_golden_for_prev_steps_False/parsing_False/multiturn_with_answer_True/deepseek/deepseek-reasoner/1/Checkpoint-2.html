<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note: This equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?&rdquo;</p>
<p>Interpretation: We have a circuit that prepares a logical state. But then we are adding errors: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; So after each CNOT gate, there is an error channel. Also, are there errors on Hadamard gates? The problem statement: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. It does not mention errors on single-qubit gates. So we assume that Hadamard gates are perfect? Possibly yes. So only errors on CNOT gates.</p>
<p>The circuit: The operations in order (from right to left in the given equation) are:</p>
<ol>
<li>H_2</li>
<li>CNOT_{21}</li>
<li>H_0</li>
<li>CNOT_{03}</li>
</ol>
<p>But careful: The given equation: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). In matrix multiplication order, that means the overall unitary is U = CNOT_{03} * H_0 * CNOT_{21} * H_2. But in quantum circuit, the order is from left to right? Actually, typically: if we write a circuit as gates applied in sequence, then the rightmost gate is applied first. So the circuit: Start with initial state? Possibly initial state is |0000&gt;? But wait: The logical GHZ state: (|00&gt;<em>{AB} + |11&gt;</em>{AB})/√2. That is a logical state. But the circuit is given. Let&rsquo;s check: The circuit: H_2, then CNOT_{21}, then H_0, then CNOT_{03}. Let&rsquo;s compute the state without errors.</p>
<p>Initial state: presumably all qubits are in |0&gt;. So initial state: |0&gt;_0|0&gt;_1|0&gt;_2|0&gt;_3.</p>
<p>Step 1: Apply H_2. H on qubit 2: |0&gt;_2 -&gt; (|0&gt;+|1&gt;)/√2. So state becomes: |0&gt;_0|0&gt;_1 (|0&gt;+|1&gt;)/√2 |0&gt;_3 = (|0000&gt; + |0010&gt;)/√2? But careful: qubits: 0,1,2,3. So state: |q0,q1,q2,q3&gt;. After H_2: state = 1/√2 (|0,0,0,0&gt; + |0,0,1,0&gt;).</p>
<p>Step 2: Apply CNOT_{21}. That is control qubit 2, target qubit 1. So if qubit2 is 1, flip qubit1. So:
|0,0,0,0&gt; -&gt; remains |0,0,0,0&gt;
|0,0,1,0&gt; -&gt; becomes |0,1,1,0&gt;
So state becomes: 1/√2 (|0000&gt; + |0110&gt;).</p>
<p>Step 3: Apply H_0. H on qubit 0. So:
|0000&gt; -&gt; (|0&gt;+|1&gt;)/√2 on qubit0 gives: 1/√2 (|0000&gt; + |1000&gt;)
|0110&gt; -&gt; 1/√2 (|0110&gt; + |1110&gt;)
So state becomes: 1/2 (|0000&gt; + |1000&gt; + |0110&gt; + |1110&gt;).</p>
<p>Step 4: Apply CNOT_{03}. Control qubit 0, target qubit 3.
For each term:
|0000&gt;: control=0 so no flip -&gt; |0000&gt;
|1000&gt;: control=1 so flip qubit3 -&gt; |1001&gt;
|0110&gt;: control=0 -&gt; |0110&gt;
|1110&gt;: control=1 -&gt; |1111&gt;
So final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>Now, what is the logical state? The [[4,2,2]] code: It encodes two logical qubits. The stabilizers are XXXX and ZZZZ. The logical operators: 
X_A = XIXI, X_B = XXII, Z_A = ZZII, Z_B = ZIZI.
We want the logical GHZ state: (|00&gt;<em>{AB} + |11&gt;</em>{AB})/√2.
Check: What are the logical basis states? For the [[4,2,2]] code, the code space is 4-dimensional. The logical states are usually defined. Possibly the state we got is indeed the logical GHZ state? Let&rsquo;s check: 
For logical |00&gt;? Possibly: |00&gt;_{AB} might be: (|0000&gt; + |1111&gt;)/√2? But our state has terms: |0000&gt;, |1001&gt;, |0110&gt;, |1111&gt;. That is not exactly that. Alternatively, maybe the logical states are: 
|00&gt; = (|0000&gt;+|1111&gt;)/√2, 
|01&gt; = (|0011&gt;+|1100&gt;)/√2,
|10&gt; = (|0101&gt;+|1010&gt;)/√2,
|11&gt; = (|0110&gt;+|1001&gt;)/√2.
Then the GHZ state (|00&gt;+|11&gt;)/√2 becomes: 
= 1/√2 [ (|0000&gt;+|1111&gt;)/√2 + (|0110&gt;+|1001&gt;)/√2 ] = 1/2 (|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;). 
That matches our state exactly. So indeed the circuit produces the logical GHZ state.</p>
<p>So without errors, the final state is the ideal state: |ψ_ideal&gt; = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;).</p>
<p>Now, we consider errors. The circuit has two CNOT gates: CNOT_{21} and CNOT_{03}. Each CNOT gate is followed by a depolarizing error channel. That error channel: after the CNOT gate, with probability p, an error occurs. And if an error occurs, it is one of the 15 non-identity two-qubit Paulis on the two qubits involved, each with probability p/15. So overall, after a CNOT gate, the state becomes: 
(1 - p) * (CNOT applied perfectly) + (p/15)*∑<em>{P in non-identity Paulis on that pair} (P applied after CNOT? But careful: The error channel is applied after the gate. So if the gate is U, then the actual operation is: with probability 1-p, we get U; with probability p/15 for each non-identity Pauli, we get (P) U. But wait: The problem says: &ldquo;each CNOT</em>{ij} gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; That means: After the CNOT gate, we apply an error operator that is one of the 15 Paulis (on the two qubits) with probability p/15 each, and with probability 1-p, we apply identity. So the overall channel for that step is: 
ρ -&gt; (1-p) U ρ U† + (p/15) ∑_{P in {non-identity Paulis on qubits i,j}} (P U) ρ (U† P).</p>
<p>But careful: The order: The circuit is: first H_2 (perfect), then CNOT_{21} with error, then H_0 (perfect), then CNOT_{03} with error.
So we want the final state fidelity. The fidelity is between the ideal state (which is pure) and the actual state (which is mixed due to errors). So we want F = &lt;ψ_ideal| ρ_actual |ψ_ideal&gt;.</p>
<p>We need to compute ρ_actual. The initial state is |0000&gt;&lt;0000|. Then we apply operations. Let&rsquo;s denote:
U1 = H_2 (perfect)
U2 = CNOT_{21} (with error channel)
U3 = H_0 (perfect)
U4 = CNOT_{03} (with error channel)</p>
<p>So the overall channel: ρ_final = E_4 ∘ U_4 ∘ E_3 ∘ U_3 ∘ E_2 ∘ U_2 ∘ U_1 (|0&gt;&lt;0|) but careful: Actually, the order: The circuit: first apply U1, then apply the channel for CNOT_{21}? But wait: The error channel is after the CNOT gate. So after U1, we apply the CNOT_{21} gate. But that gate itself is perfect? Actually, the gate is perfect, but then immediately after it, we apply the error channel. So the operation for the step is: ρ -&gt; (1-p) CNOT_{21} ρ CNOT_{21}^† + (p/15) ∑<em>{P in Paulis on qubits 2,1 (non-identity)} (P CNOT</em>{21}) ρ (CNOT_{21}^† P). But careful: The Paulis are on the two qubits that the CNOT acts on. For CNOT_{21}, the qubits are 2 and 1. So the Paulis are operators on qubits 2 and 1. Similarly, for CNOT_{03}, the Paulis are on qubits 0 and 3.</p>
<p>Then after that, we apply H_0 (perfect). Then apply CNOT_{03} with its error channel.</p>
<p>So we want to compute the final density matrix. But we only need the fidelity: F = &lt;ψ_ideal| ρ_final |ψ_ideal&gt;. And since the errors are small, we might compute the probability that no error occurs? But careful: The errors are depolarizing channels. They might produce states that are not orthogonal to the ideal state? Actually, if an error occurs, it might sometimes be a stabilizer of the code? But wait: The state we are preparing is a logical state. The errors that are stabilizers (like XXXX or ZZZZ) actually leave the state invariant? But careful: The state is not necessarily in the code space? Actually, the ideal state is in the code space. And the stabilizers: XXXX and ZZZZ. Do they act trivially on the code space? Yes, because the code space is defined as the +1 eigenspace of these stabilizers. So if an error is a stabilizer, then it will map the code state to itself. But wait: But our errors are applied on physical qubits. For example, if an error is XXXX, then it commutes with the logical operators? Actually, if the state is in the code space, then applying a stabilizer gives the same state. But here, the errors occur during the circuit. They might take the state out of the code space. But then later gates might not correct it. However, we are only interested in the fidelity at the end. The fidelity is the overlap with the ideal state. So if an error is a stabilizer, then it might actually not reduce the fidelity? But careful: The error occurs in the middle of the circuit. For example, if an error happens that is a stabilizer, then after the circuit, the state might still be the ideal state? But not necessarily: because the circuit is not necessarily fault-tolerant? Actually, the circuit is designed to prepare the logical state. If an error occurs that is a stabilizer, then it commutes with all subsequent gates? Possibly? But we need to check: The errors are applied after a CNOT gate. They are Pauli errors. They will propagate through subsequent gates. So we need to compute the overall effect.</p>
<p>Maybe we can compute the probability that the final state is exactly the ideal state. That probability is: (1-p)^2 (if no error occurs) plus contributions from errors that are equivalent to identity on the final state. But careful: Even if an error occurs, if it is such that after the entire circuit, the state is the same as the ideal state, then that error does not reduce fidelity. So we want to compute the fidelity F = probability that the final state is the ideal state. But wait: Is that exactly the fidelity? Actually, if the channel is a Pauli channel (because errors are Pauli and the circuit is Clifford), then the final state will be a mixture of states that are Pauli errors applied to the ideal state. And since the ideal state is a stabilizer state (it is a code state of a stabilizer code), then the fidelity is the sum of probabilities of all Pauli errors that stabilize the state. But careful: The errors occur at different times. But because the circuit is Clifford, we can propagate the errors through the circuit. That is a common technique: Instead of applying errors after gates, we can push them to the end. But careful: The errors are applied after specific gates. But we can use the fact that if we have a Clifford circuit, then if an error occurs at some point, it is equivalent to a Pauli error at the end (maybe with a sign change) if we commute it through the subsequent Clifford gates. But here, the errors are not necessarily Pauli errors on the initial state because they occur after gates. But we can use the idea of &ldquo;error propagation&rdquo;: 
We have a circuit: U = U4 U3 U2 U1. But with errors: Actually, the actual operation is: After U1, we apply CNOT_{21} and then an error E on qubits 2,1. That error E is a Pauli. Then U3 (H_0) and then CNOT_{03} and then an error F on qubits 0,3. So the overall operation is: (F * CNOT_{03}) * (H_0) * (E * CNOT_{21}) * (H_2) on the initial state. But note that H_0 and H_2 are single-qubit gates. But we can combine: Actually, careful: The order: The circuit is: 
Step 1: H_2 (perfect)
Step 2: CNOT_{21} then error on qubits 2,1. So that step is: ρ -&gt; ∑<em>{E in {I} ∪ {non-identity Paulis on {2,1}} with probabilities: (1-p) for I, and p/15 for each non-identity} (E CNOT</em>{21}) ρ (CNOT_{21}^† E†).
Step 3: H_0 (perfect)
Step 4: CNOT_{03} then error on qubits 0,3. So that step: ρ -&gt; ∑<em>{F in {I} ∪ {non-identity Paulis on {0,3}} with probabilities: (1-p) for I, and p/15 for each non-identity} (F CNOT</em>{03}) ρ (CNOT_{03}^† F†).</p>
<p>So overall, if we denote the perfect unitary as U_perfect = CNOT_{03} H_0 CNOT_{21} H_2. Then the actual operation is: 
For each error E on qubits {2,1} and F on qubits {0,3}, we get: 
U_actual = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2.
But note that H_0 and H_2 are Clifford gates. So we can commute E through H_0? But careful: E acts on qubits 2 and 1. H_0 acts on qubit 0. They commute because they act on different qubits. So H_0 * E = E * H_0. Similarly, F acts on qubits 0 and 3. But F does not necessarily commute with H_0? Actually, H_0 acts on qubit 0, and F acts on qubits 0 and 3. They might not commute if F has a Pauli on qubit 0 that is not identity? But we can compute: H_0 Pauli_X on qubit0 H_0 = Pauli_Z, etc. But maybe we can push all errors to the end. Write:
U_actual = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2.
= F * CNOT_{03} * E * H_0 * CNOT_{21} * H_2   (since E commutes with H_0)
= F * (CNOT_{03} E CNOT_{03}^†) * CNOT_{03} * H_0 * CNOT_{21} * H_2
= (F * (CNOT_{03} E CNOT_{03}^†)) * U_perfect.
So then U_actual = G * U_perfect, where G = F * (CNOT_{03} E CNOT_{03}^†). But careful: The order: Actually, U_perfect = CNOT_{03} H_0 CNOT_{21} H_2. And we have: U_actual = F CNOT_{03} H_0 E CNOT_{21} H_2 = F CNOT_{03} E H_0 CNOT_{21} H_2 = F (CNOT_{03} E CNOT_{03}^†) CNOT_{03} H_0 CNOT_{21} H_2 = (F * (CNOT_{03} E CNOT_{03}^†)) U_perfect.
So indeed, the overall effect is that the actual state is obtained by applying some Pauli error G on the perfect state. But wait: Is that always a Pauli? E is a Pauli on qubits {2,1}. CNOT_{03} acts on qubits {0,3}. So CNOT_{03} E CNOT_{03}^† will be a Pauli on qubits? Because CNOT is Clifford. So it maps Pauli to Pauli. But careful: E acts on qubits 2 and 1. CNOT_{03} does not act on qubits 2 and 1, so it commutes with E? Actually, no: CNOT_{03} acts on qubits 0 and 3. E acts on qubits 2 and 1. They act on disjoint sets, so they commute. So actually, CNOT_{03} E CNOT_{03}^† = E. Because E is on qubits 2 and 1, and CNOT_{03} acts on qubits 0 and 3, so they commute. So then G = F * E. So indeed, the overall error is just the product of the two errors: one from the first CNOT (E on qubits 2,1) and the second from the second CNOT (F on qubits 0,3). But wait: Is that always? Check: U_actual = F CNOT_{03} H_0 E CNOT_{21} H_2. And since H_0 commutes with E (different qubits), we get = F CNOT_{03} E H_0 CNOT_{21} H_2. But then CNOT_{03} and E commute because they act on disjoint sets? Actually, careful: CNOT_{03} acts on qubits 0 and 3. E acts on qubits 2 and 1. They are on disjoint sets, so they commute. So then U_actual = F E CNOT_{03} H_0 CNOT_{21} H_2 = (F E) U_perfect. So indeed, the overall effect is that the actual unitary is (F E) U_perfect, where E is a Pauli on qubits {2,1} and F is a Pauli on qubits {0,3}. But wait: There is also the probabilities: The error E occurs with probability: if E = I, probability = 1-p; if E is any non-identity Pauli on qubits {2,1}, probability = p/15 each. Similarly, F: if F = I, probability = 1-p; if F is non-identity on qubits {0,3}, probability = p/15 each.
And these errors are independent? They occur on different gates. So the overall error operator is G = F * E, which is a Pauli on all 4 qubits. But careful: E acts on qubits 2 and 1, F acts on qubits 0 and 3. So G is a Pauli on all qubits. And the probability distribution over G is: 
P(G) = (probability for E) * (probability for F) such that F<em>E = G.
But note: E and F are independent. So we can compute the probability that the overall error is a particular Pauli on the 4 qubits. But then the final state, if the error is G, is: |ψ_actual&gt; = G U_perfect |0000&gt; = G |ψ_ideal&gt;. But wait: Is that always true? Check: U_perfect |0000&gt; = |ψ_ideal&gt;. So indeed, if the errors are Pauli, then the final state is exactly G |ψ_ideal&gt;. But careful: There might be phases? But Pauli operators are either ±1? Actually, Pauli operators can have factors of i, but typically we consider Pauli group elements up to phase? But here, since we are taking the state, if G has a phase, then |ψ&gt; becomes that phase times the state. But fidelity is |&lt;ψ_ideal| G |ψ_ideal&gt;|^2. But if G is not identity, then typically the overlap might be 0 if G changes the state. But there might be cases where G is a stabilizer of the state? But careful: The state |ψ_ideal&gt; is not necessarily a stabilizer state of the full Pauli group? Actually, it is a stabilizer state. The stabilizer of |ψ_ideal&gt;? The ideal state is the logical GHZ state. But it is a code state of the [[4,2,2]] code. Its stabilizer group? The code space is stabilized by XXXX and ZZZZ. But the state |ψ_ideal&gt; is a specific state in that code space. Its stabilizer subgroup (the Paulis that leave it invariant up to a phase) might be larger? Actually, for a stabilizer state, the stabilizer group is generated by the stabilizers of the code and the logical operators that fix that state. For the GHZ state (|00&gt;+|11&gt;)/√2, the stabilizers include also something like X_A X_B? Actually, for a two-qubit GHZ state, the stabilizers are: X⊗X, Z⊗Z? But here it&rsquo;s logical qubits. But we are interested in the physical overlap: &lt;ψ_ideal| G |ψ_ideal&gt;. That is 1 if G is in the stabilizer of |ψ_ideal&gt; (up to phase, but careful: if G gives a phase, then the overlap might be that phase. But fidelity is the square of the absolute value of the overlap. So if G gives a phase factor e^(iθ), then &lt;ψ_ideal| G |ψ_ideal&gt; = e^(iθ) and then |&hellip;|^2 = 1. So indeed, if G is such that G|ψ_ideal&gt; = (phase)</em>|ψ_ideal&gt;, then the fidelity contribution from that error is that the state is actually the ideal state (up to global phase). So we want to compute the probability that the overall error G is such that G|ψ_ideal&gt; is proportional to |ψ_ideal&gt;. That is, G is in the stabilizer group of |ψ_ideal&gt; (the set of Paulis that fix the state, not necessarily exactly +1, but any phase factor, because fidelity is |&lt;ψ_ideal|G|ψ_ideal&gt;|^2, and if G|ψ_ideal&gt; = c|ψ_ideal&gt; with |c|=1, then that equals 1).</p>
<p>So then the fidelity F = probability that the overall error G is in the stabilizer of |ψ_ideal&gt; (i.e., G|ψ_ideal&gt; = (phase)*|ψ_ideal&gt;) plus maybe contributions from errors that are not exactly stabilizers but have nonzero overlap? But wait: If G is not a stabilizer, then typically for a stabilizer state, the overlap &lt;ψ|G|ψ&gt; is 0. Because stabilizer states are eigenstates of stabilizers, and if G is not in the stabilizer group, then it will map to an orthogonal state. But is that always true? For a stabilizer state, if G is a Pauli that is not in the stabilizer group, then either it anticommutes with some stabilizer, so the expectation value is 0. So indeed, for a stabilizer state, &lt;ψ|P|ψ&gt; is either ±1 if P is in the stabilizer group (up to phase) or 0 if not. So then the fidelity is exactly the probability that the overall error G is such that G is in the stabilizer group of |ψ_ideal&gt;. But careful: There is also the possibility that the error occurs but then the state is not exactly G|ψ_ideal&gt; because the errors are applied in the middle? But we already pushed them to the end. But wait: Is it valid to push errors through Hadamard gates? We did: H_0 commutes with E because E acts on qubits 2,1. And H_2? Actually, we had H_2 at the beginning. But then we applied E after CNOT_{21}. But that E is on qubits 2,1. H_2 acts on qubit2. So careful: E acts on qubits 2 and 1. H_2 acts on qubit2. They do not necessarily commute. But we already handled that: We had: U_actual = F CNOT_{03} H_0 E CNOT_{21} H_2. And we argued that H_0 commutes with E because H_0 acts on qubit0 and E on qubits 2,1. But what about H_2? H_2 is at the very right. Actually, the order: U_actual = F CNOT_{03} H_0 E CNOT_{21} H_2. Here, H_2 is applied to the initial state. Then CNOT_{21} is applied. Then E is applied. Then H_0 is applied. Then CNOT_{03} is applied. Then F is applied. So if we want to push E to the end, we need to commute it through H_0 and CNOT_{03}. We already commuted through H_0: H_0 and E commute because they act on different qubits. Then we commute through CNOT_{03}: CNOT_{03} and E commute because they act on disjoint sets? Check: CNOT_{03} acts on qubits 0 and 3. E acts on qubits 2 and 1. So they commute. So then indeed, U_actual = F E CNOT_{03} H_0 CNOT_{21} H_2 = F E U_perfect. So it&rsquo;s valid. But wait: What about the Hadamard H_2? That is inside U_perfect. So it&rsquo;s fine.</p>
<p>So then the final state, given errors E and F, is: |ψ&gt; = (F E) U_perfect |0000&gt; = (F E) |ψ_ideal&gt;. And these errors are independent. So the overall channel is: ρ = ∑<em>{E on {2,1}} ∑</em>{F on {0,3}} P(E) P(F) (F E) |ψ_ideal&gt;&lt;ψ_ideal| (F E)^†.
Then the fidelity is: F = &lt;ψ_ideal| ρ |ψ_ideal&gt; = ∑_{E,F} P(E)P(F) |&lt;ψ_ideal| F E |ψ_ideal&gt;|^2.
And as argued, for a stabilizer state, &lt;ψ_ideal| P |ψ_ideal&gt; is either 0 or 1 (in absolute value squared, it&rsquo;s 1 if P is in the stabilizer group of |ψ_ideal&gt;, and 0 otherwise). So we need to determine: Which Pauli operators G on the 4 qubits (that are of the form F * E, where E is on qubits {2,1} and F is on qubits {0,3}) are in the stabilizer of |ψ_ideal&gt;? But careful: The errors are not arbitrary Paulis on all 4 qubits? They are products of a Pauli on qubits {0,3} and a Pauli on qubits {2,1}. So G = (F_0 ⊗ F_3) ⊗ (E_2 ⊗ E_1) but order: qubits: 0,1,2,3. So G = (F on qubit0) ⊗ (E on qubit1) ⊗ (E on qubit2) ⊗ (F on qubit3)? Actually, careful: E acts on qubits 2 and 1. So let E = E_2 ⊗ E_1. And F acts on qubits 0 and 3, so F = F_0 ⊗ F_3. So then G = F_0 ⊗ E_1 ⊗ E_2 ⊗ F_3.
So the overall error is a Pauli that factorizes between the pair (0,3) and (1,2) but not necessarily: Actually, it is: qubit0 comes from F, qubit1 from E, qubit2 from E, qubit3 from F. So it&rsquo;s not necessarily a product of two independent Paulis on {0,3} and {1,2} because the Pauli on qubit1 and qubit2 are from the same error E, so they can be correlated? But they are independent in the sense that E can be any Pauli on two qubits. So indeed, G is such that the Pauli on qubit0 and qubit3 are from F, and on qubit1 and qubit2 are from E. But note: There is no constraint that the Pauli on qubit0 and qubit3 are the same? They are independent: F can be any two-qubit Pauli. So G is of the form: 
G = (a Pauli on qubit0) ⊗ (a Pauli on qubit1) ⊗ (a Pauli on qubit2) ⊗ (a Pauli on qubit3) with the condition that the Pauli on qubit0 and qubit3 come from the same two-qubit Pauli? Actually, careful: F is a Pauli on qubits 0 and 3. That means F is one of the 16 Paulis on qubits 0 and 3. So it is of the form: F = i^k (X^{b0} Z^{c0})_0 ⊗ (X^{b3} Z^{c3})_3. But the phase factor is not important because we only care about the action on the state up to phase. Similarly, E on qubits 2 and 1: E = i^m (X^{d2} Z^{e2})_2 ⊗ (X^{d1} Z^{e1})_1.
So then G = (from F on qubit0) * (from E on qubit1) * (from E on qubit2) * (from F on qubit3) times a global phase. So indeed, the errors on qubits 0 and 3 are correlated? Actually, they are independent: The probability for a given F is: if F = I (on both qubits) then probability = 1-p; if F is any non-identity on qubits 0 and 3, then probability = p/15. But note: F = I means that on qubit0 and qubit3, the Pauli is identity. But if F is, say, X_0 I_3, that is a non-identity Pauli on the two-qubit system? But careful: The error channel: It produces one of the 15 non-identity two-qubit Paulis. The two-qubit Paulis are operators on two qubits. They are considered non-identity if they are not the identity on both qubits. So for example, X ⊗ I is non-identity because it is not I⊗I. So indeed, F can be such that it acts as identity on one qubit and non-identity on the other. So then G can have, for instance, Pauli X on qubit0 and identity on qubit3. So there is no constraint that the Pauli on qubit0 and qubit3 are the same. They are independent: F is any element of the Pauli group on two qubits except the identity? But wait: The error channel: It says: &ldquo;produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; That means that if F is a Pauli on two qubits that is not the identity (i.e., not I⊗I), then its probability is p/15. And if F = I⊗I, then probability is 1-p. So indeed, F can be, for example, X⊗I, I⊗X, X⊗X, etc. So then G is: on qubit0: from F, on qubit3: from F, on qubit1: from E, on qubit2: from E. And these are independent.</p>
<p>Now, we need to determine: For which such G does G stabilize |ψ_ideal&gt;? That is, G|ψ_ideal&gt; = (phase)|ψ_ideal&gt;. Equivalently, |&lt;ψ_ideal|G|ψ_ideal&gt;|^2 = 1.
Since |ψ_ideal&gt; is a stabilizer state, its stabilizer group is the set of all Paulis that commute with all stabilizers of the state? Actually, for a stabilizer state, the state is the unique simultaneous +1 eigenvector of a set of commuting Paulis. The stabilizer group of the state is the group generated by these. For the logical GHZ state, what is its stabilizer? The state is: |ψ_ideal&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;). Let&rsquo;s find some stabilizers. The code stabilizers: S1 = XXXX, S2 = ZZZZ. Check: XXXX|ψ_ideal&gt; = ? For each term: XXXX|0000&gt; = |1111&gt;, so that gives |1111&gt;; XXXX|1001&gt; = |0110&gt;; XXXX|0110&gt; = |1001&gt;; XXXX|1111&gt; = |0000&gt;. So indeed, XXXX|ψ_ideal&gt; = |ψ_ideal&gt;. Similarly, ZZZZ: ZZZZ|0000&gt; = |0000&gt;; ZZZZ|1001&gt; = (-1)^(1+0+0+1?) Actually, careful: ZZZZ means apply Z on each qubit. For |1001&gt;, the phase is: qubit0: 1 gives -1, qubit1: 0 gives +1, qubit2: 0 gives +1, qubit3: 1 gives -1, so product = (-1)<em>(-1)=+1? Actually, more systematically: ZZZZ|a,b,c,d&gt; = (-1)^(a+b+c+d) |a,b,c,d&gt;. For |0000&gt;, sum=0 -&gt; +1; |1001&gt;: sum=1+0+0+1=2 -&gt; even -&gt; +1; |0110&gt;: 0+1+1+0=2 -&gt; +1; |1111&gt;: sum=4 -&gt; +1. So indeed, ZZZZ stabilizes.
But there are more stabilizers specific to the GHZ state. The logical GHZ state on two qubits: (|00&gt;+|11&gt;)/√2. Its stabilizers include X_A X_B and Z_A Z_B? Actually, for a Bell state, the stabilizers are X⊗X and Z⊗Z (with appropriate signs). Here, the logical qubits A and B. Their logical operators: X_A = XIXI, X_B = XXII, so X_A X_B = (X⊗I⊗X⊗I) * (X⊗X⊗I⊗I) = (X^2 ⊗ X ⊗ X ⊗ I) = (I ⊗ X ⊗ X ⊗ I) but careful: Actually, multiplication: X_A = X on qubit0, I on qubit1, X on qubit2, I on qubit3. X_B = X on qubit0, X on qubit1, I on qubit2, I on qubit3. So product: X_A X_B = (X0 X0) ⊗ (I1 X1) ⊗ (X2 I2) ⊗ (I3 I3) = (I0) ⊗ (X1) ⊗ (X2) ⊗ (I3) = X_1 X_2. So one stabilizer is X_1 X_2. Check: X_1 X_2|ψ_ideal&gt;: For |0000&gt;, becomes |0,1,1,0&gt; = |0110&gt;; for |1001&gt;, becomes |1,1,1,1&gt;? Actually, careful: X_1 X_2|1001&gt; = |1, (1 flip), (1 flip), 1&gt; = |1111&gt;; for |0110&gt;, becomes |0,0,0,0&gt; = |0000&gt;; for |1111&gt;, becomes |1,0,0,1&gt; = |1001&gt;. So indeed, X_1 X_2|ψ_ideal&gt; = |ψ_ideal&gt;. So S3 = X_1 X_2.
Also, what about Z_A Z_B? Z_A = ZZII, Z_B = ZIZI, so product: Z_A Z_B = (Z0 Z0?) Actually: Z_A = Z on qubit0, Z on qubit1, I on qubit2, I on qubit3. Z_B = Z on qubit0, I on qubit1, Z on qubit2, I on qubit3. So product: Z_A Z_B = (Z0 Z0) ⊗ (Z1 I1) ⊗ (I2 Z2) ⊗ (I3 I3) = (I0) ⊗ (Z1) ⊗ (Z2) ⊗ (I3) = Z_1 Z_2. But check: Z_1 Z_2|ψ_ideal&gt;: For |0000&gt;, phase = +1; |1001&gt;: qubit1=0, qubit2=0 so +1; |0110&gt;: qubit1=1, qubit2=1 so (-1)</em>(-1)=+1; |1111&gt;: qubit1=1, qubit2=1 so +1. So Z_1 Z_2 also gives +1. But wait, are these independent? Actually, X_1 X_2 and Z_1 Z_2 commute? They anticommute on qubits 1 and 2? Actually, X and Z on the same qubit anticommute. But here, X_1 X_2 and Z_1 Z_2: On qubit1, X and Z anticommute, on qubit2, X and Z anticommute, so overall they commute because two anticommutations give a sign of (-1)<em>(-1)=+1. So they are independent. But then we have stabilizers: S1 = XXXX, S2 = ZZZZ, S3 = X_1 X_2. That gives 3 generators. The stabilizer group of a 4-qubit state is of size 2^4 = 16 if it is a stabilizer state. Actually, a stabilizer state is defined by a subgroup of the Pauli group of size 2^n. Here n=4, so the stabilizer group should have 16 elements. The generators we have: S1, S2, S3. That gives 2^3 = 8 elements. So there is one more generator. What is the fourth stabilizer? The state is a logical GHZ state. For a Bell state on two qubits, the stabilizers are: X⊗X and Z⊗Z. But here, the logical qubits are encoded. Actually, the state |ψ_ideal&gt; is not a full code space; it&rsquo;s a specific state. Its stabilizer group should be of order 16. Let&rsquo;s find another Pauli that fixes |ψ_ideal&gt;. Consider: X_0 X_3? Check: X_0 X_3|0000&gt; = |1001&gt;; X_0 X_3|1001&gt; = |0000&gt;; X_0 X_3|0110&gt; = |1111&gt;; X_0 X_3|1111&gt; = |0110&gt;. So X_0 X_3 also gives the state. So S4 = X_0 X_3. But are these independent? S1 = XXXX, so S1 * S4 = X_1 X_2, which is S3. So actually, S1, S2, S4 are generators? Then S3 is not independent. Alternatively, we can take S1, S2, S4, and then what is the fourth? Possibly Z_0 Z_3? Check: Z_0 Z_3|0000&gt; = |0000&gt;; Z_0 Z_3|1001&gt; = (-1)</em>|1001&gt;? Actually, careful: Z_0 Z_3|1001&gt;: qubit0=1 gives -1, qubit3=1 gives -1, product = +1? Actually, (-1)<em>(-1)=+1. So Z_0 Z_3 gives +1 on all terms? Check: |0110&gt;: qubit0=0, qubit3=0 so +1; |1111&gt;: qubit0=1, qubit3=1 so (+1) because (-1)</em>(-1)=+1. So Z_0 Z_3 also stabilizes. But then S2 = ZZZZ, and Z_0 Z_3, then product gives Z_1 Z_2, which we already had. So maybe the stabilizer group is generated by: S1 = XXXX, S2 = ZZZZ, S4 = X_0 X_3, and then S5 = Z_0 Z_3? But then S1 * S4 = X_1 X_2, and S2 * S5 = Z_1 Z_2. So then the group has generators: XXXX, ZZZZ, X_0 X_3, Z_0 Z_3. That gives 2^4 = 16 elements. And indeed, these commute? Check: X_0 X_3 and Z_0 Z_3: On qubit0, X and Z anticommute, on qubit3, X and Z anticommute, so overall they commute. So yes, the stabilizer group of |ψ_ideal&gt; is: 
{ I, XXXX, ZZZZ, XXXX ZZZZ, 
X_0 X_3, (X_0 X_3)(XXXX) = X_1 X_2, (X_0 X_3)(ZZZZ) = ? Actually, let&rsquo;s systematically: The generators: 
A = XXXX
B = ZZZZ
C = X_0 X_3
D = Z_0 Z_3
They are independent and commute. So the stabilizer group is all Paulis of the form: A^a B^b C^c D^d, where a,b,c,d in {0,1}. And these Paulis will act as: 
A^a B^b C^c D^d = (X on all qubits)^a (Z on all qubits)^b (X_0 X_3)^c (Z_0 Z_3)^d.
What is the action on qubit1 and qubit2? That becomes: from A: X_1 X_2, from B: Z_1 Z_2, from C: nothing on 1,2, from D: nothing on 1,2. So on qubits 1,2, it&rsquo;s (X_1 X_2)^a (Z_1 Z_2)^b. And on qubits 0,3, it&rsquo;s (X_0 X_3)^(a+c) (Z_0 Z_3)^(b+d) times also from A: X_0 X_3^? Actually, careful: A = X_0 X_1 X_2 X_3, so it gives X on qubit0 and X on qubit3 as well. So indeed, the stabilizer group consists of Paulis that are of the form: 
On qubit0: X^(a+c) Z^(b+d)
On qubit3: X^(a+c) Z^(b+d)
On qubit1: X^a Z^b
On qubit2: X^a Z^b
So the stabilizer group elements are exactly those Paulis that are &ldquo;even&rdquo; in the sense that the Pauli on qubit0 and qubit3 are the same, and the Pauli on qubit1 and qubit2 are the same. And also there is no condition on the relation between the pair (0,3) and (1,2)? Actually, they are independent: a,b,c,d can be arbitrary. So the stabilizer group S consists of all Paulis of the form:
G = (P on qubit0) ⊗ (Q on qubit1) ⊗ (Q on qubit2) ⊗ (P on qubit3) 
where P and Q are Paulis (including identity) but with the additional condition that the phase? Actually, check: If we take a=0,b=0,c=1,d=0, then we get: C = X_0 X_3. So that gives P = X, Q = I. If we take a=1,b=0,c=0,d=0, then A = XXXX gives: on qubit0: X, on qubit1: X, on qubit2: X, on qubit3: X, so that is P = X, Q = X. So indeed, P and Q can be arbitrary Paulis? But wait, are there any restrictions? For a given P and Q, can we always find a,b,c,d such that: On qubit0: X^(a+c) Z^(b+d) = P, and on qubit1: X^a Z^b = Q? That means: if P = X^{p_x} Z^{p_z} and Q = X^{q_x} Z^{q_z} (with p_x, p_z, q_x, q_z in {0,1}), then we need:
a+c = p_x mod 2, b+d = p_z mod 2,
a = q_x, b = q_z.
So then c = p_x - q_x mod 2, d = p_z - q_z mod 2. So indeed, for any P and Q, there is a stabilizer element. So the stabilizer group of |ψ_ideal&gt; is exactly: 
S = { G such that G = P_0 ⊗ Q_1 ⊗ Q_2 ⊗ P_3 } where P and Q are any Paulis (including I) on a single qubit. But wait: Check: What about the phase? For example, if P = I and Q = I, then that&rsquo;s identity. If P = Z and Q = I, then that is Z_0 I_1 I_2 Z_3. Is that in the stabilizer? According to our generators, can we get that? We want: on qubit0: Z, on qubit3: Z, and on qubits 1,2: I. That corresponds to: a+c should give: for qubit0, we want no X part, so a+c=0 mod2; and b+d should give: for qubit0, we want Z, so b+d=1 mod2. And on qubit1: a=0, b=0. Then c=0, d=1 mod2. So that gives D = Z_0 Z_3. So yes.
So the condition for G to be in the stabilizer of |ψ_ideal&gt; is: 
G = (something on qubit0) ⊗ (something on qubit1) ⊗ (something on qubit2) ⊗ (something on qubit3) such that the Pauli on qubit0 and qubit3 are the same, and the Pauli on qubit1 and qubit2 are the same. But careful: Is that sufficient? Check: What if G = X_0 ⊗ I_1 ⊗ I_2 ⊗ I_3? That would mean P = X, Q = I. But then on qubit0: X, on qubit3: I. That is not the same. So that is not in the stabilizer. So indeed, the condition is: The Pauli on qubit0 must equal the Pauli on qubit3, and the Pauli on qubit1 must equal the Pauli on qubit2.</p>
<p>Now, our overall error G is: G = F_0 ⊗ E_1 ⊗ E_2 ⊗ F_3. But careful: F is on qubits 0 and 3. So F gives: on qubit0: some Pauli, and on qubit3: some Pauli. But these are not necessarily the same. Because F is an arbitrary two-qubit Pauli. So F can be, for example, X_0 I_3. Then G would have: qubit0: X, qubit3: I. And E gives: on qubit1 and qubit2, they are from the same Pauli? Actually, E is on qubits 2 and 1. So E gives: on qubit1: some Pauli, and on qubit2: some Pauli. But these are from the same two-qubit Pauli? Actually, careful: E is a Pauli on qubits 2 and 1. That means E = (Pauli on qubit2) ⊗ (Pauli on qubit1) (order: usually we list qubits in order? But here, it&rsquo;s CNOT_{21} so the control is qubit2 and target is qubit1. But the error channel is on the two qubits involved. So E is an operator on the Hilbert space of qubits 2 and 1. So it is of the form: E = (something on qubit2) ⊗ (something on qubit1). So indeed, if E is, say, I_2 ⊗ X_1, then on qubit1 we get X, and on qubit2 we get I. So then G would have: qubit1: X, qubit2: I. So then the condition for G to be in the stabilizer is: The Pauli from F on qubit0 must equal the Pauli from F on qubit3. And the Pauli from E on qubit1 must equal the Pauli from E on qubit2.
But wait: Could there be cases where even if these are not equal, the product might accidentally be a stabilizer? For example, suppose F gives: on qubit0: X, on qubit3: Z. And E gives: on qubit1: X, on qubit2: Z. Then G = X_0 ⊗ X_1 ⊗ Z_2 ⊗ Z_3. Is that in the stabilizer? For it to be in the stabilizer, we need that the Pauli on qubit0 and qubit3 are the same. Here they are X and Z, which are not the same. So it&rsquo;s not. What if F gives: on qubit0: X, on qubit3: X? Then it would be stabilizer if also E gives: on qubit1: something and on qubit2: the same something. So indeed, the condition is: For the error from the first CNOT (on qubits 2,1), we need that the Pauli on qubit2 and qubit1 are the same. And for the error from the second CNOT (on qubits 0,3), we need that the Pauli on qubit0 and qubit3 are the same.</p>
<p>But wait: There is also the possibility that the overall error is a stabilizer even if individually they are not? For example, if F gives: on qubit0: X, on qubit3: I, and E gives: on qubit1: I, on qubit2: X? Then G = X_0 ⊗ I_1 ⊗ X_2 ⊗ I_3. That is not of the form: qubit0 and qubit3 are the same? They are X and I, so no. What if F gives: on qubit0: X, on qubit3: Y? That is not the same. So indeed, the condition is exactly: For the error on the CNOT_{03} gate, the error Pauli F must be such that its action on qubit0 and qubit3 are identical. And for the error on the CNOT_{21} gate, the error Pauli E must be such that its action on qubit2 and qubit1 are identical.</p>
<p>But wait: There is also the possibility that the error is not exactly identity but a phase factor? But as argued, if it is a stabilizer, then the fidelity is 1. So we want the probability that both errors are of that type.</p>
<p>Now, what are the probabilities? For the CNOT_{21} error: E is a Pauli on qubits {2,1}. There are 16 Paulis total. The probability: P(E = I) = 1-p. And for any non-identity Pauli, probability = p/15. Among these, which ones have the property that the Pauli on qubit2 and qubit1 are the same? That means E should be of the form: (P on qubit2) ⊗ (P on qubit1) for some Pauli P (which can be I, X, Y, Z). But careful: If P = I, then that&rsquo;s identity. So the non-identity ones that satisfy this: They are: X⊗X, Y⊗Y, Z⊗Z. Also, what about ones like I⊗X? That is not the same because on qubit2 it&rsquo;s I and on qubit1 it&rsquo;s X. So there are 3 non-identity Paulis that are &ldquo;same on both qubits&rdquo;. But wait: Also, what about ones that are like: i * (X⊗X)? Actually, the Pauli group elements are defined up to phase? But here, the error channel: &ldquo;produces one of the 15 non-identity two-qubit Paulis&rdquo;. Typically, the two-qubit Paulis are considered as the set {I, X, Y, Z}⊗{I, X, Y, Z} excluding the identity. But careful: They are not taken with phases? Actually, the depolarizing channel is usually defined as: With probability p, apply an error from the set of Pauli errors (excluding identity) uniformly. And these Pauli errors are usually taken to be the ones with no phase factors? Actually, the Pauli matrices are Hermitian and square to identity. So the non-identity Paulis on two qubits are: There are 15 of them. They are: For qubits i and j, the set is: {P ⊗ Q} where P, Q ∈ {I, X, Y, Z} but not both I. But note: X⊗Y is different from Y⊗X, etc. So indeed, there are 15. Among these, the ones that are &ldquo;same on both&rdquo; are: X⊗X, Y⊗Y, Z⊗Z. So there are 3.
So for the CNOT_{21} error, the probability that the error is a stabilizer (i.e., that it does not actually cause an error that reduces fidelity) is: P(stab from first) = P(E such that E acts as the same Pauli on both qubits) = P(E = I) + (3/15)<em>p = 1-p + (p/5) = 1 - (4/5)p? Actually, careful: For non-identity, total probability p is distributed over 15 errors, so each specific non-identity error has probability p/15. So the probability that E is one of {X⊗X, Y⊗Y, Z⊗Z} is 3</em>(p/15) = p/5. So overall, probability that the error from the first CNOT is &ldquo;good&rdquo; (i.e., it results in a stabilizer error overall) is: (1-p) + (p/5) = 1 - (4/5)p.</p>
<p>Similarly, for the CNOT_{03} error: F is a Pauli on qubits {0,3}. The condition for it to be &ldquo;good&rdquo; is that F acts as the same Pauli on qubit0 and qubit3. That is: F should be either identity, or one of: X⊗X, Y⊗Y, Z⊗Z. So the probability that F is good is also: 1-p + (p/5) = 1 - (4/5)p.</p>
<p>And these errors are independent. So the overall probability that the final state is exactly the ideal state (up to a phase) is: (1 - (4/5)p)^2? But wait: Is that the fidelity? Because if both errors are good, then G is in the stabilizer, so the state is ideal. But what if one error is good and the other is not? Then G is not in the stabilizer, so the overlap is 0. So then the fidelity F = probability that both errors are good = [1 - (4/5)p]^2 = 1 - (8/5)p + (16/25)p^2.
But wait: Could there be cases where the errors are not individually good but their product is good? For example, suppose from the first CNOT, we get an error E that is not &ldquo;same on both&rdquo; but from the second, we get an error F that is not &ldquo;same on both&rdquo;, but when multiplied, they might become same on both? But careful: G = F E. But F acts on qubits 0 and 3, E acts on qubits 2 and 1. They act on disjoint sets. So the condition for G to be a stabilizer is that on qubits 0 and 3, the Pauli from F must be the same, and on qubits 1 and 2, the Pauli from E must be the same. There is no cross term because they are on different qubits. So if F is not such that its action on qubit0 and qubit3 are the same, then no matter what E is, on qubits 0 and 3, G will have different Paulis. Similarly, if E is not such that its action on qubit1 and qubit2 are the same, then on qubits 1 and 2, G will have different Paulis. So indeed, for G to be in the stabilizer, we need that F is &ldquo;good&rdquo; (i.e., F&rsquo;s Pauli on qubit0 equals its Pauli on qubit3) and E is &ldquo;good&rdquo; (E&rsquo;s Pauli on qubit1 equals its Pauli on qubit2). So the fidelity is exactly the product of the probabilities that each error is good. So F = (1 - (4/5)p)^2.</p>
<p>But wait: There is also the possibility that the error is such that it gives a phase factor? But that is included in &ldquo;good&rdquo; because if it&rsquo;s the same Pauli, it might be, say, X⊗X, and that is in the stabilizer? Check: Is X⊗X on qubits 0 and 3 a stabilizer? Yes, because that is X_0 X_3. And on qubits 1 and 2, if it is X⊗X, that is X_1 X_2, which is also a stabilizer. So indeed.</p>
<p>So then the physical state fidelity is F = (1 - (4/5)p)^2 = 1 - (8/5)p + (16/25)p^2.</p>
<p>But wait: Is that the entire story? There is also the possibility that the error occurs but then the state is not exactly G|ψ_ideal&gt; because the errors are applied after the gates. But we already pushed them to the end. So it seems correct.</p>
<p>However, we should check a specific example: Suppose on the first CNOT, the error is E = X_2 ⊗ I_1 (so on qubit2: X, on qubit1: I). That is not good because the Paulis on qubits 2 and 1 are different. Then the overall error is G = (from F, if F is identity) then G = I_0 ⊗ I_1 ⊗ X_2 ⊗ I_3. Is that a stabilizer? That would require that on qubits 1 and 2, they are the same. But here qubit1 is I, qubit2 is X, so no. So fidelity contribution 0.
What if on the first CNOT, error is E = X_2 ⊗ X_1 (good), and on the second, error is F = X_0 ⊗ I_3 (not good). Then G = X_0 ⊗ X_1 ⊗ X_2 ⊗ I_3. On qubits 0 and 3: X and I are different, so not stabilizer. So indeed.</p>
<p>So then the fidelity is the probability that both errors are of the type that are &ldquo;same on the pair&rdquo;. And that probability is: For each CNOT, probability of no error or error that is one of {X⊗X, Y⊗Y, Z⊗Z} is: (1-p) + 3*(p/15) = 1-p + p/5 = 1 - (4/5)p. And since they are independent, overall probability = (1 - (4/5)p)^2.</p>
<p>But wait: There is also the possibility that the error is such that it is a stabilizer but not necessarily identity? But that is included: if it is a stabilizer, then the state is ideal. So yes.</p>
<p>So the physical state fidelity F = (1 - 4p/5)^2.</p>
<p>But is that the answer? It says &ldquo;physical state fidelity&rdquo;. That is the overlap between the ideal state and the actual state. But careful: The actual state is a mixture. The fidelity is the average of the square of the overlap. And since for each error pattern, the overlap is either 1 or 0, the fidelity is exactly the probability that the error pattern is such that the final state is the ideal state. So that is correct.</p>
<p>But wait: Could there be errors that are not Pauli? But the error channel is depolarizing, so it produces Pauli errors. So it&rsquo;s fine.</p>
<p>Thus, the answer: F = 1 - (8/5)p + (16/25)p^2.</p>
<p>But maybe we need to express it as: F = 1 - (8/5)p + O(p^2). But the problem likely expects an exact expression.</p>
<p>Double-check: The probability that a given CNOT gate error is &ldquo;harmless&rdquo; (i.e., does not cause a logical error) is: The error Pauli on the two qubits must be such that it is either identity or of the form P⊗P. There are 1 + 3 = 4 such Paulis out of the 16 total. But careful: The error channel: With probability 1-p, we get identity. With probability p, we get a non-identity Pauli uniformly among 15. So the probability of a specific non-identity Pauli is p/15. So the probability that the error is harmless is: 1-p + 3*(p/15) = 1-p + p/5 = 1 - (4/5)p. So that is correct.</p>
<p>And since there are two CNOT gates, and they are independent, the overall probability that both are harmless is (1 - 4p/5)^2.</p>
<p>So the fidelity F = (1 - 4p/5)^2.</p>
<p>Thus, the answer: F(p) = 1 - (8/5)p + (16/25)p^2.</p>
<p>But wait: Could there be contributions from errors that are not exactly stabilizers but still have some overlap? For example, if an error occurs that is a logical operator? But logical operators on the code would take the state to an orthogonal logical state. For instance, if we apply X_A, then |00&gt; becomes |10&gt; and |11&gt; becomes |01&gt;, so the state becomes (|10&gt;+|01&gt;)/√2, which is orthogonal to the GHZ state? Actually, for two qubits, the Bell states are orthogonal. So indeed, overlap 0. So no.</p>
<p>Thus, the answer is as above.</p>
<p>So final answer: F = (1 - 4p/5)^2.</p>
<p>But wait: There is also the possibility of errors that are products of stabilizers? But that is already included.</p>
<p>So I&rsquo;ll answer: The physical state fidelity is F = 1 - (8/5)p + (16/25)p^2.</p>
<p>But the problem might want it in a simplified form: F = (5 - 4p)^2/25.</p>
<p>So I&rsquo;ll put: F(p) = \frac{(5-4p)^2}{25}.</p>
<p>I&rsquo;ll check: When p=0, F=1; when p is small, F ≈ 1 - (8/5)p.</p>
<p>That seems plausible.</p>
<p>Thus, final answer.</p>
<p>I&rsquo;ll now write the step-by-step derivation.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-understand-the-circuit-and-the-ideal-state">Step 1. Understand the Circuit and the Ideal State</h3>
<p>The goal is to prepare the logical GHZ state:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>using the [[4,2,2]] code, which encodes two logical qubits (A and B) into four physical qubits (labeled 0, 1, 2, 3). The circuit is:</p>
<div class="arithmatex">\[
\text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2
\]</div>
<p>where the operations are applied from right to left. The initial state is:</p>
<div class="arithmatex">\[
|0000\rangle
\]</div>
<p>Applying the gates in order:</p>
<ol>
<li><strong>Apply <span class="arithmatex">\( H_2 \)</span></strong>:</li>
</ol>
<div class="arithmatex">\[
   H_2 |0\rangle_2 = \frac{|0\rangle + |1\rangle}{\sqrt{2}} \Rightarrow |\psi_1\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)
\]</div>
<ol start="2">
<li><strong>Apply <span class="arithmatex">\( \text{CNOT}_{21} \)</span></strong> (control qubit 2, target qubit 1):</li>
</ol>
<div class="arithmatex">\[
   |0000\rangle \rightarrow |0000\rangle,\quad |0010\rangle \rightarrow |0110\rangle \Rightarrow |\psi_2\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)
\]</div>
<ol start="3">
<li><strong>Apply <span class="arithmatex">\( H_0 \)</span></strong>:</li>
</ol>
<div class="arithmatex">\[
   H_0 |0\rangle_0 = \frac{|0\rangle + |1\rangle}{\sqrt{2}} \Rightarrow |\psi_3\rangle = \frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)
\]</div>
<ol start="4">
<li><strong>Apply <span class="arithmatex">\( \text{CNOT}_{03} \)</span></strong> (control qubit 0, target qubit 3):</li>
</ol>
<div class="arithmatex">\[
   |0000\rangle \rightarrow |0000\rangle,\quad |1000\rangle \rightarrow |1001\rangle,\quad |0110\rangle \rightarrow |0110\rangle,\quad |1110\rangle \rightarrow |1111\rangle
\]</div>
<div class="arithmatex">\[
   \Rightarrow |\psi_{\text{ideal}}\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<p>This matches the logical GHZ state in the [[4,2,2]] code.</p>
<hr />
<h3 id="step-2-model-the-errors">Step 2. Model the Errors</h3>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel:</p>
<ul>
<li>With probability <span class="arithmatex">\( 1 - p \)</span>, the gate is applied perfectly.</li>
<li>With probability <span class="arithmatex">\( p \)</span>, an error occurs: one of the 15 non-identity two-qubit Pauli operators is applied with equal probability <span class="arithmatex">\( p/15 \)</span>.</li>
</ul>
<p>The Hadamard gates are assumed to be perfect.</p>
<p>Let:</p>
<ul>
<li><span class="arithmatex">\( E \)</span>: error on <span class="arithmatex">\( \text{CNOT}_{21} \)</span>, acting on qubits 2 and 1.</li>
<li><span class="arithmatex">\( F \)</span>: error on <span class="arithmatex">\( \text{CNOT}_{03} \)</span>, acting on qubits 0 and 3.</li>
</ul>
<p>The overall operation becomes:</p>
<div class="arithmatex">\[
U_{\text{actual}} = F \cdot \text{CNOT}_{03} \cdot H_0 \cdot E \cdot \text{CNOT}_{21} \cdot H_2
\]</div>
<p>Since <span class="arithmatex">\( E \)</span> and <span class="arithmatex">\( F \)</span> act on disjoint sets of qubits, they commute with <span class="arithmatex">\( H_0 \)</span> and <span class="arithmatex">\( \text{CNOT}_{03} \)</span>, respectively. Thus, we can push them to the end:</p>
<div class="arithmatex">\[
U_{\text{actual}} = F \cdot E \cdot \text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2 = (F E) \cdot U_{\text{perfect}}
\]</div>
<p>where <span class="arithmatex">\( U_{\text{perfect}} = \text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2 \)</span>. Therefore, the final state is:</p>
<div class="arithmatex">\[
|\psi_{\text{actual}}\rangle = G |\psi_{\text{ideal}}\rangle,\quad \text{where } G = F E
\]</div>
<p>Since <span class="arithmatex">\( E \)</span> and <span class="arithmatex">\( F \)</span> are Pauli operators, <span class="arithmatex">\( G \)</span> is also a Pauli operator.</p>
<hr />
<h3 id="step-3-compute-the-fidelity">Step 3. Compute the Fidelity</h3>
<p>The fidelity is:</p>
<div class="arithmatex">\[
F = \langle \psi_{\text{ideal}} | \rho_{\text{actual}} | \psi_{\text{ideal}} \rangle
\]</div>
<p>where <span class="arithmatex">\( \rho_{\text{actual}} \)</span> is the mixed state after averaging over errors.</p>
<p>Since <span class="arithmatex">\( |\psi_{\text{ideal}}\rangle \)</span> is a stabilizer state, for any Pauli operator <span class="arithmatex">\( P \)</span>:</p>
<div class="arithmatex">\[
\langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle = 
\begin{cases}
\pm 1 &amp; \text{if } P \text{ is a stabilizer of } |\psi_{\text{ideal}}\rangle \\
0 &amp; \text{otherwise}
\end{cases}
\]</div>
<p>Thus, the fidelity is the total probability that <span class="arithmatex">\( G \)</span> is a stabilizer of <span class="arithmatex">\( |\psi_{\text{ideal}}\rangle \)</span>.</p>
<p>The stabilizer group of <span class="arithmatex">\( |\psi_{\text{ideal}}\rangle \)</span> is generated by:</p>
<ul>
<li><span class="arithmatex">\( XXXX \)</span></li>
<li><span class="arithmatex">\( ZZZZ \)</span></li>
<li><span class="arithmatex">\( X_0 X_3 \)</span></li>
<li><span class="arithmatex">\( Z_0 Z_3 \)</span></li>
</ul>
<p>A Pauli operator <span class="arithmatex">\( G \)</span> is a stabilizer iff:</p>
<ul>
<li>On qubits 0 and 3: the Pauli is the same.</li>
<li>On qubits 1 and 2: the Pauli is the same.</li>
</ul>
<p>Since <span class="arithmatex">\( G = F E \)</span>, and <span class="arithmatex">\( F \)</span> acts on qubits 0 and 3 while <span class="arithmatex">\( E \)</span> acts on qubits 2 and 1, the condition becomes:</p>
<ul>
<li><span class="arithmatex">\( F \)</span> must act as the same Pauli on qubits 0 and 3.</li>
<li><span class="arithmatex">\( E \)</span> must act as the same Pauli on qubits 2 and 1.</li>
</ul>
<hr />
<h3 id="step-4-probability-that-an-error-is-harmless">Step 4. Probability that an Error is “Harmless”</h3>
<h4 id="for-textcnot_21-error-e">For <span class="arithmatex">\( \text{CNOT}_{21} \)</span> (error <span class="arithmatex">\( E \)</span>):</h4>
<ul>
<li>Probability that <span class="arithmatex">\( E = I \)</span>: <span class="arithmatex">\( 1 - p \)</span></li>
<li>Probability that <span class="arithmatex">\( E \)</span> is a specific non-identity Pauli: <span class="arithmatex">\( p/15 \)</span></li>
</ul>
<p>The “harmless” errors are those where <span class="arithmatex">\( E \)</span> acts as the same Pauli on qubits 2 and 1:</p>
<ul>
<li>Non-identity examples: <span class="arithmatex">\( X \otimes X \)</span>, <span class="arithmatex">\( Y \otimes Y \)</span>, <span class="arithmatex">\( Z \otimes Z \)</span></li>
<li>Total such operators: 3</li>
</ul>
<p>So, the probability that <span class="arithmatex">\( E \)</span> is harmless is:</p>
<div class="arithmatex">\[
P_{\text{good}}(E) = (1 - p) + 3 \cdot \frac{p}{15} = 1 - p + \frac{p}{5} = 1 - \frac{4}{5}p
\]</div>
<h4 id="for-textcnot_03-error-f">For <span class="arithmatex">\( \text{CNOT}_{03} \)</span> (error <span class="arithmatex">\( F \)</span>):</h4>
<p>By symmetry, the probability that <span class="arithmatex">\( F \)</span> is harmless is also:</p>
<div class="arithmatex">\[
P_{\text{good}}(F) = 1 - \frac{4}{5}p
\]</div>
<p>Since the errors are independent, the overall probability that both are harmless is:</p>
<div class="arithmatex">\[
P(G \in \text{Stab}) = \left(1 - \frac{4}{5}p\right)^2
\]</div>
<p>Hence, the fidelity is:</p>
<div class="arithmatex">\[
F(p) = \left(1 - \frac{4}{5}p\right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<hr />
<h3 id="final-answer">Final Answer:</h3>
<div class="arithmatex">\[
F(p) = \frac{(5 - 4p)^2}{25}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?&rdquo;</p>
<p>Interpretation: We have the same circuit as before. But now we are post-selecting on detectable errors. That means we measure the stabilizers? The [[4,2,2]] code has stabilizers: XXXX and ZZZZ. These are detectable errors? Actually, the code distance is 2, so it can detect one error but not correct. So if an error occurs that is not in the stabilizer group, it might be detectable. But careful: &ldquo;post-selected on all detectable errors&rdquo; means that if an error is detected (i.e., the syndrome is non-trivial), we discard the state. So we only keep states that have no detected error. That means that the final state is conditioned on the syndrome measurement yielding +1 for both stabilizers. So we want the fidelity of the logical state after post-selection.</p>
<p>We already computed that the overall error is G = F E, where E is on qubits {2,1} and F is on qubits {0,3}. And the condition for the state to be ideal (fidelity 1) is that G is in the stabilizer of the ideal state. But now, we are post-selecting on detectable errors. Which errors are detectable? The code can detect any error that is not in the stabilizer group? Actually, the [[4,2,2]] code: Its stabilizer group is generated by S1 = XXXX and S2 = ZZZZ. The code space is the +1 eigenspace of these. An error E is detectable if it anticommutes with at least one stabilizer. But note: There are errors that are undetectable? Actually, if an error commutes with all stabilizers, then it might be a logical operator. But wait: The code is a [[4,2,2]] code. That means it encodes 2 logical qubits and has distance 2. So there are weight-1 errors that are detectable? Actually, any single-qubit Pauli error will anticommute with either XXXX or ZZZZ? Check: A single X error on qubit0: It anticommutes with ZZZZ? Actually, ZZZZ commutes with X? No: X and Z anticommute. So a single X error will anticommute with ZZZZ? But careful: ZZZZ is product of Z&rsquo;s. X anticommutes with Z on the same qubit, so yes, it anticommutes. So single errors are detectable. But there are weight-2 errors that are undetectable? For example, X0 X1? Check: X0 X1 commutes with XXXX? Yes, because XXXX involves X on all qubits, so it commutes. And with ZZZZ? ZZZZ: On qubit0, Z anticommutes with X0, on qubit1, Z anticommutes with X1, so overall they commute because two anticommutations give +1. So X0 X1 is undetectable. And indeed, X0 X1 might be a logical operator? Actually, logical operators: X_A = XIXI, so that is X on qubit0 and X on qubit2? Not exactly. But anyway.</p>
<p>So post-selection: We measure the stabilizers S1 and S2. If either measurement gives -1, we discard the state. So we only keep states where the syndrome is (+,+). That means that the error G must commute with both stabilizers? Actually, if G is such that it anticommutes with S1, then the syndrome will be -1. So for the state to be kept, we need that G commutes with S1 and S2. But wait: Is that sufficient? If G is in the stabilizer group, then it gives syndrome +. If G is a logical operator (which commutes with stabilizers) but is not in the stabilizer, then it will also give syndrome +? But then the state is not the ideal state; it is a logically errored state. So post-selection will keep those states as well. So after post-selection, the state is not necessarily ideal. So we want the logical fidelity after post-selection. That is: Given that the syndrome is trivial (+,+), what is the probability that the logical state is correct? That is: F_logical = P(no logical error | syndrome trivial).</p>
<p>Now, our errors are G = F E. And we want to condition on the fact that G commutes with S1 and S2. And then, among those, what is the probability that G is actually in the stabilizer group (so that the state is ideal)? Because if G is a logical operator (but not stabilizer), then it will change the logical state. So we need to compute: 
F_logical = (Probability that G is in the stabilizer group) / (Probability that syndrome is trivial) 
because after post-selection, we only keep states with trivial syndrome. But careful: The fidelity is the overlap with the ideal state. If G is a stabilizer, then the state is ideal. If G is a logical operator that is not a stabilizer, then the state is orthogonal to the ideal state? Actually, for a logical operator L that is not identity on the code space, if the ideal state is a specific state, then L|ψ_ideal&gt; is a different logical state. So fidelity becomes 0. So indeed, the logical fidelity after post-selection is the conditional probability that G is in the stabilizer group given that the syndrome is trivial.</p>
<p>So we need to compute: 
P(G in Stab | G commutes with S1 and S2) = [P(G in Stab)] / [P(G commutes with S1 and S2)] 
because if G is in Stab, it automatically commutes with stabilizers. But careful: There might be errors that commute with stabilizers but are not in Stab? Yes, logical operators. So we need to compute these probabilities.</p>
<p>We have: G = F E, where E is on qubits {2,1} and F is on qubits {0,3}. And these are independent. The probability distribution for E: 
P(E = I) = 1-p
For any non-identity Pauli on {2,1}, probability = p/15.
Similarly for F.</p>
<p>We want to compute: 
P(G commutes with S1 and S2) and P(G in Stab).</p>
<p>But note: S1 = XXXX, S2 = ZZZZ.
A Pauli operator G commutes with S1 if and only if the number of Pauli factors that are X or Y? Actually, careful: S1 = X⊗X⊗X⊗X. A Pauli operator G = ± (P0 ⊗ P1 ⊗ P2 ⊗ P3) commutes with S1 if and only if the number of qubits where P_i is either Y or Z? Actually, simpler: For a single Pauli, X commutes with X, but anticommutes with Z and Y? Actually, X anticommutes with Z and Y? Check: X and Y: iZX? Actually, Y = iXZ, so X Y = i X^2 Z = i Z, and Y X = i Z X^2 = -i Z, so they anticommute. So indeed, X anticommutes with Y and Z. So S1 = XXXX commutes with a Pauli G if and only if on each qubit, if G has a factor that is not X (i.e., Y or Z), then that contributes a sign? Actually, more systematically: G commutes with S1 if and only if the number of qubits where G has a Pauli that is either Y or Z is even? Because each such qubit gives a minus sign? But careful: Actually, S1 is product of X on all qubits. For a given qubit i, if G_i is I or X, then X_i commutes with G_i. If G_i is Y or Z, then X_i anticommutes with G_i. So overall, G commutes with S1 if and only if the number of qubits where G_i is Y or Z is even.
Similarly, S2 = ZZZZ. G commutes with S2 if and only if the number of qubits where G_i is X or Y is even (since Z commutes with Z and I, but anticommutes with X and Y).</p>
<p>But maybe we can compute these probabilities by considering the structure of G. G = F E, where F acts on qubits 0 and 3, and E acts on qubits 1 and 2. And these are independent. So we can compute the probability that G commutes with S1 and S2 by multiplying the probabilities for the two pairs? But careful: S1 involves all qubits. However, because the pairs are independent, we can compute: 
P(G commutes with S1) = P( on qubits 0,3: the number of qubits with Pauli in {Y,Z} is even) * P( on qubits 1,2: the number of qubits with Pauli in {Y,Z} is even) because the condition is that the total number mod 2 is 0. And since the pairs are independent, the probability that the sum mod2 is 0 is: (p0^2 + (1-p0)^2) where p0 is the probability that on that pair, the number is odd. But we need to compute these probabilities from the distribution of F and E.</p>
<p>But maybe there is a simpler approach: We want to condition on the syndrome being trivial. That means that G must commute with both S1 and S2. Which G do that? They are exactly the Paulis that are in the normalizer of the stabilizer group. The normalizer of the stabilizer group for the [[4,2,2]] code is the set of all Paulis that commute with S1 and S2. That set includes the stabilizer group itself (size 16) and the logical operators? Actually, the code encodes 2 qubits, so there are 4 logical Paulis? Actually, the full logical group for 2 qubits has 16 elements. But wait: The normalizer of the stabilizer group in the Pauli group on 4 qubits: The stabilizer group has size 4? Actually, the stabilizer group is generated by S1 and S2, so it has size 4? But earlier we said the stabilizer group of the state |ψ_ideal&gt; is of size 16. That is different: The stabilizer group of the code space is of size 4 (since there are 2 generators, so 2^2=4). But the stabilizer group of the specific state |ψ_ideal&gt; is larger because it also includes logical operators that fix that state. But here, we are talking about the code itself. The code space is the +1 eigenspace of S1 and S2. An operator G will preserve the code space if it commutes with S1 and S2. That set is the normalizer of the stabilizer group. That normalizer has size: |N(S)| = |S| * (number of logical Paulis) = 4 * 16 = 64? Actually, for an [[n,k,d]] code, the normalizer of the stabilizer group in the Pauli group on n qubits is of size 2^(n+k) = 2^(4+2)=2^6=64. So there are 64 Paulis that commute with S1 and S2. Among these, 4 are stabilizers (actually, the stabilizer group itself is of size 4, not 16? Wait, check: The stabilizer group for the code is generated by S1 and S2. That gives 4 elements: I, XXXX, ZZZZ, XXXX ZZZZ. But then there are logical operators. And then there are also Paulis that are not in the normalizer? Actually, the full Pauli group on 4 qubits has 4^4 = 256 elements (ignoring phases). The normalizer condition: G must commute with S1 and S2. That gives conditions mod2. So the number of such Paulis is 256/4 = 64. So indeed, there are 64 Paulis that commute with S1 and S2. Among these, 4 are in the stabilizer group? But wait, then what about the stabilizer group of the state |ψ_ideal&gt;? That state is a specific state in the code space. Its stabilizer group is larger because it is a stabilizer state within the code space. But here we are considering operators on the physical qubits. The condition for being in the code space is that the state is an eigenvector of S1 and S2 with eigenvalue +1. An operator G that is in the normalizer will map the code space to itself. But if G is not in the stabilizer, then it acts as a logical operator. So for the syndrome to be trivial, we need that G is in the normalizer of the stabilizer group. So we want: P(G in N(S)) and P(G in S) (where S here is the stabilizer group of the code, which is of size 4, not the stabilizer group of the state? But careful: Our ideal state is a particular state in the code space. If G is in the stabilizer group of the code, then G|ψ_ideal&gt; = |ψ_ideal&gt; because the code stabilizers act as identity on the code space. But if G is a logical operator that is not a stabilizer, then it will change the logical state. So for the logical fidelity to be 1, we need that G is in the stabilizer group of the code (which is of size 4). But wait, earlier we determined that the stabilizer group of the state |ψ_ideal&gt; is larger (16 elements). That is because |ψ_ideal&gt; is not the entire code space; it&rsquo;s a specific state. The code space is 4-dimensional. The stabilizer group of the code (the operators that fix every state in the code space) is indeed just the group generated by S1 and S2, which has size 4. But then there are logical operators that act nontrivially on the code space. However, some logical operators might fix the particular state |ψ_ideal&gt;. For example, consider the logical operator X_A. Does it fix |ψ_ideal&gt;? |ψ_ideal&gt; = (|00&gt;+|11&gt;)/√2. X_A would map it to (|10&gt;+|01&gt;)/√2, which is orthogonal. So indeed, X_A does not fix |ψ_ideal&gt;. What about Z_A? Z_A|00&gt; = |00&gt;, Z_A|11&gt; = -|11&gt;, so that gives a phase difference, so actually Z_A does not fix |ψ_ideal&gt; either because it gives a relative phase? But wait, if we consider the state (|00&gt;+|11&gt;)/√2, applying Z on the first logical qubit gives (|00&gt; - |11&gt;)/√2, which is different. So indeed, the only operators that fix |ψ_ideal&gt; are those that are in the stabilizer of the state. And we computed that stabilizer group earlier had 16 elements. But those 16 elements are not all in the Pauli group? They are in the Pauli group. But then they would be in the normalizer of the code stabilizer? Actually, if an operator fixes |ψ_ideal&gt;, it must map the code space to itself? Not necessarily: It could map |ψ_ideal&gt; to itself but other states in the code space to something else. But since we are only interested in the fidelity of the state |ψ_ideal&gt;, we care about whether G|ψ_ideal&gt; = |ψ_ideal&gt; (up to phase). That condition is that G is in the stabilizer of |ψ_ideal&gt;. And we determined that condition is: G must be of the form: On qubits 0 and 3, the Pauli is the same; on qubits 1 and 2, the Pauli is the same. That group has size 16. But wait, does that group include the code stabilizers? For example, S1 = XXXX. That satisfies: on qubits 0 and 3: X and X are same; on qubits 1 and 2: X and X are same. So yes. And what about a logical operator like Z_A? Z_A = ZZII. That gives on qubits 0 and 1: Z and Z? But careful: Z_A = Z on qubit0, Z on qubit1, I on qubit2, I on qubit3. That does not satisfy the condition because on qubits 0 and 3, we have Z and I, which are not the same. So indeed, the stabilizer of |ψ_ideal&gt; is larger than the code stabilizer. But wait, are all these 16 operators actually in the normalizer of the code stabilizer? They must commute with S1 and S2 to preserve the code space? Actually, if an operator fixes |ψ_ideal&gt;, it doesn&rsquo;t necessarily commute with the code stabilizers? But if |ψ_ideal&gt; is in the code space, then for any operator G that fixes |ψ_ideal&gt;, we have S1|ψ_ideal&gt; = |ψ_ideal&gt;, so S1 G|ψ_ideal&gt; = G S1|ψ_ideal&gt; if G commutes with S1. But if G does not commute with S1, then S1 G|ψ_ideal&gt; might not equal |ψ_ideal&gt;. But we require that G|ψ_ideal&gt; is in the code space? Actually, if we are post-selecting on the syndrome being trivial, that means that after the error, we measure the stabilizers and get +1. That means that the state is in the code space. So if G does not commute with S1, then G|ψ_ideal&gt; might not be an eigenvector of S1 with eigenvalue +1. So for the state to be kept, we need that G is in the normalizer of the code stabilizer. So indeed, after post-selection, we only keep those G that are in N(S), the normalizer of the code stabilizer. And then among those, the ones that give fidelity 1 are those that actually fix |ψ_ideal&gt;. But careful: Is it possible that G is in N(S) but not in the stabilizer of |ψ_ideal&gt; and yet G|ψ_ideal&gt; = |ψ_ideal&gt;? That would mean that G acts as identity on the code space on that particular state. But since the code space is 4-dimensional, if G is a logical operator, it could have eigenvalue 1 on some states and -1 on others. So it is possible that for a specific state, a logical operator might act as identity if that state is an eigenvector with eigenvalue 1. For example, consider the logical operator Z_A. Z_A|ψ_ideal&gt; =? |ψ_ideal&gt; = (|00&gt;+|11&gt;)/√2. Z_A acts as Z on the first logical qubit. So Z_A|00&gt; = |00&gt;, Z_A|11&gt; = -|11&gt;. So that gives (|00&gt; - |11&gt;)/√2, which is not the same. What about X_A? X_A|00&gt; = |10&gt;, X_A|11&gt; = |01&gt;, so no. What about X_A X_B? X_A X_B|00&gt; = ? X_A X_B = (XIXI)(XXII) = (I⊗X⊗X⊗I) so that gives? Actually, we computed earlier: X_A X_B = X_1 X_2. And we know that X_1 X_2|ψ_ideal&gt; = |ψ_ideal&gt; because that is a stabilizer of |ψ_ideal&gt;. So indeed, X_A X_B is in the stabilizer of |ψ_ideal&gt;. So the stabilizer of |ψ_ideal&gt; is actually the set of all Paulis in N(S) that act trivially on the logical state? Actually, the logical operators on 2 qubits form a group of size 16. The stabilizer of a specific state in that 2-qubit space would be of size 4? Because a stabilizer state on 2 qubits has a stabilizer group of size 4. But here we found 16 Paulis that fix |ψ_ideal&gt;. That is because these are physical Paulis. They are not all independent on the code space. Actually, on the code space, the operators are represented up to the stabilizer of the code. The code stabilizer has size 4. So the number of distinct logical operators is 16/4 = 4. So indeed, the stabilizer of |ψ_ideal&gt; as a logical state should be of size 4. But we found 16 physical Paulis that satisfy the condition. That is because each logical operator has 4 physical representatives (since the code stabilizer has size 4). So the condition for G to fix |ψ_ideal&gt; is that its logical action is the identity. And that group has size 4 * 4 = 16. So it&rsquo;s consistent: The stabilizer of |ψ_ideal&gt; in the physical Pauli group is of size 16. And the normalizer N(S) has size 64. So among the 64 Paulis that commute with S1 and S2, only 16 will actually fix |ψ_ideal&gt;. The other 48 will act as nontrivial logical operators and will change the logical state. So after post-selection, we keep all G in N(S). And the fidelity is the probability that G is in the stabilizer of |ψ_ideal&gt; (i.e., logical identity) given that G is in N(S).</p>
<p>So we need to compute:
P(G in Stab(ψ_ideal)) and P(G in N(S)).</p>
<p>And then F_logical = P(G in Stab(ψ_ideal)) / P(G in N(S)).</p>
<p>But careful: These probabilities are over the error distribution. And G = F E, with F and E independent with the distribution as before.</p>
<p>So we need to compute: 
For a given two-qubit Pauli error on a pair (say on qubits 0 and 3 for F), what is the probability that when combined with the error on the other pair, the overall G is in N(S) and in Stab(ψ_ideal)?</p>
<p>Since the pairs are independent, we can compute the probability that the error on a pair leads to a condition on that pair relative to the normalizer conditions. But careful: The conditions for G to be in N(S) are: 
G commutes with S1 and S2.
S1 = XXXX. This condition factors into conditions on the pair (0,3) and (1,2) separately? Actually, G commutes with S1 if and only if the number of qubits where G has Y or Z is even. But since the pairs are independent, we can compute the probability that on a given pair, the contribution to that parity is 0 mod2? But careful: The condition is on the whole set. However, because the errors on the two pairs are independent, the probability that the total number is even is: 
P(even on pair1)<em>P(even on pair2) + P(odd on pair1)</em>P(odd on pair2).
So if we can compute for a single pair (like qubits 0 and 3) under the distribution of F, what is the probability that the number of qubits with Pauli in {Y,Z} is even? And similarly for the condition from S2: number of qubits with Pauli in {X,Y} is even.
But wait, these conditions must hold simultaneously. So for G to be in N(S), we need that both conditions hold. And these conditions might be correlated on a pair? Actually, for a given pair, the error is a Pauli on two qubits. Let&rsquo;s denote the Pauli on qubit i as either I, X, Y, Z. We want to compute, for a given pair (say qubits 0 and 3 from F), the probability that the pair&rsquo;s contribution makes the overall conditions? But careful: The conditions are global: 
Condition from S1: (indicator on qubit0: 1 if Pauli is Y or Z, 0 otherwise) + (indicator on qubit3: 1 if Pauli is Y or Z) must be even when added to the from the other pair? So actually, it&rsquo;s not independent per pair because the condition is on the sum mod2. But since the two pairs are independent, we can compute the probability that a given pair has a certain &ldquo;parity vector&rdquo; mod2. Let&rsquo;s define for a Pauli on two qubits (say on qubits i and j), define two bits: 
a = (1 if Pauli on i is in {Y,Z}) mod2, and similarly for j. So then the condition from S1 is that the total number of qubits with Pauli in {Y,Z} is even, i.e., (a_i + a_j from pair1) + (from pair2) is even.
Similarly, define b = (1 if Pauli is in {X,Y}) mod2. Then condition from S2 is that the sum of b&rsquo;s over all 4 qubits is even.
So for a given pair, we can compute the probability distribution over the pair&rsquo;s contribution to (sum_a mod2, sum_b mod2). Actually, note that for each qubit, the Pauli can be I, X, Y, Z. Their properties:
I: a=0, b=0.
X: a=0, b=1.
Y: a=1, b=1.
Z: a=1, b=0.
So for a pair, if we have two qubits, we can compute the probability that the pair gives a certain (s_a, s_b) mod2, where s_a = (a1+a2) mod2, and s_b = (b1+b2) mod2.
And then for G to be in N(S), we need that from pair1 (F) and pair2 (E), the total (s_a, s_b) is (0,0) mod2.</p>
<p>And for G to be in Stab(ψ_ideal), we need an additional condition: On pair from F (qubits 0 and 3), we need that the Pauli on qubit0 is the same as on qubit3. And on pair from E (qubits 2 and 1), we need that the Pauli on qubit2 is the same as on qubit1.
But wait: Is that exactly the condition for being in the stabilizer of |ψ_ideal&gt;? We determined that condition earlier: G must be such that on qubits 0 and 3, the Pauli is the same, and on qubits 1 and 2, the Pauli is the same. So yes.</p>
<p>So let&rsquo;s compute these probabilities separately for one pair. Consider the error on a CNOT gate. It acts on two qubits. The distribution: With probability 1-p, the error is I (which is I⊗I). With probability p, it is one of the 15 non-identity Paulis uniformly, so each has probability p/15.
So for a given pair, the probability distribution over Paulis on two qubits is:
P(I⊗I) = 1-p.
For any other Pauli P (non-identity), P(P) = p/15.</p>
<p>Now, we want to compute for such a pair, the probability that it satisfies certain conditions.</p>
<p>Let&rsquo;s denote the pair as two qubits. We will compute two things:
1) The probability that the error on this pair is in the normalizer condition? But careful: The normalizer condition is global over both pairs. But since the pairs are independent, we can compute the probability that a given pair contributes a certain (s_a, s_b) mod2. Then the probability that G is in N(S) is: Sum over all pairs of outcomes that sum to (0,0). So if we compute for one pair, let:
q(0,0) = probability that the pair&rsquo;s (s_a, s_b) = (0,0)
q(0,1) = probability for (0,1)
q(1,0) = probability for (1,0)
q(1,1) = probability for (1,1)
Then for two independent pairs, the probability that the total is (0,0) is: q(0,0)^2 + q(0,1)^2 + q(1,0)^2 + q(1,1)^2? Actually, careful: If pair1 gives (x1,y1) and pair2 gives (x2,y2), then the total mod2 is (x1+x2, y1+y2). We want this to be (0,0). That happens if either both are (0,0), or both are (0,1) because (0,1)+(0,1)=(0,0)? Actually, (0,1)+(0,1) = (0,0) mod2? Yes, because 1+1=2 mod2=0. Similarly, (1,0)+(1,0)=(0,0) and (1,1)+(1,1)=(0,0). So actually, the condition is that the two pairs give the same (s_a,s_b) value. So P(N(S)) = q(0,0)^2 + q(0,1)^2 + q(1,0)^2 + q(1,1)^2.</p>
<p>2) The probability that the error on this pair is such that it is &ldquo;good&rdquo; for the stabilizer of |ψ_ideal&gt;, i.e., the Pauli on the two qubits are the same. Let&rsquo;s call that probability: r = probability that the error on the pair is of the form: P⊗P (including I⊗I). For a given pair, what is that probability? 
The Paulis that are of the form P⊗P: They are: I⊗I, X⊗X, Y⊗Y, Z⊗Z. So there are 4 such Paulis. Their probabilities: 
P(I⊗I) = 1-p.
For each of X⊗X, Y⊗Y, Z⊗Z, probability = p/15.
So total probability that the error on a pair is &ldquo;good&rdquo; (i.e., same on both qubits) is: 
r = 1-p + 3*(p/15) = 1-p + p/5 = 1 - (4/5)p.
And note that if the error is good, then what is its (s_a,s_b)? 
For I⊗I: (0,0)
For X⊗X: On both qubits, X gives: a=0, b=1 so sum mod2: (0+0, 1+1) = (0,0) mod2? Actually, careful: For each qubit, if it is X, then a=0, b=1. So for two X&rsquo;s, the total: s_a = 0+0=0 mod2, s_b = 1+1=0 mod2. So (0,0).
For Y⊗Y: Each Y: a=1, b=1, so sum: (1+1, 1+1) = (0,0).
For Z⊗Z: Each Z: a=1, b=0, so sum: (1+1, 0+0) = (0,0).
So indeed, if the error is good (same on both), then it always gives (0,0) mod2. But wait, are there other errors that give (0,0) mod2? Yes, for example, I⊗X? That gives: qubit1: I: (0,0); qubit2: X: (0,1); so total: (0,1) mod2? Actually, (0+0, 0+1) = (0,1). So that is (0,1). 
What about X⊗Y? X: (0,1); Y: (1,1); sum: (1,0) mod2? Actually, 0+1=1 mod2, and 1+1=0 mod2? So (1,0).
What about X⊗Z? X: (0,1); Z: (1,0); sum: (1,1) mod2.
So indeed, the (s_a,s_b) can be any of the four possibilities. And we want to compute the probabilities q(0,0), q(0,1), q(1,0), q(1,1) for one pair.</p>
<p>Let&rsquo;s compute these for a single pair. The pair has 16 Paulis. Their probabilities: 
I⊗I: probability = 1-p.
The other 15: each probability = p/15.
Now, for each Pauli, we determine its (s_a, s_b) mod2. s_a is the sum mod2 of: for each qubit, 1 if Pauli is Y or Z, 0 otherwise.
s_b is: 1 if Pauli is X or Y, 0 otherwise.
Let&rsquo;s list all two-qubit Paulis (non-identity) and their (s_a,s_b). But careful: The Paulis are products of Paulis on two qubits. They are of the form: P ⊗ Q, where P,Q ∈ {I, X, Y, Z} but not both I.
We can compute by considering the types:
For a given Pauli on two qubits, let the two Paulis be independent. But maybe we can compute by summing over all 16 equally likely if p were distributed? But here the distribution is not uniform over all 16 because the identity has extra probability. But we can compute: 
q(0,0) = P(I⊗I) + (number of non-identity Paulis that give (0,0)) * (p/15)
Similarly for others.</p>
<p>So we need to count: Among the 15 non-identity Paulis, how many yield (s_a,s_b) = (0,0), (0,1), (1,0), (1,1).</p>
<p>Let&rsquo;s do that. Consider two qubits. Label them 1 and 2. For each Pauli P⊗Q (P,Q ∈ {I,X,Y,Z} but not both I). We want to compute the pair (s_a, s_b) where:
s_a = indicator(P in {Y,Z}) + indicator(Q in {Y,Z}) mod2.
s_b = indicator(P in {X,Y}) + indicator(Q in {X,Y}) mod2.</p>
<p>We can list by cases:
Case: Both I: That is identity, but that&rsquo;s not in non-identity? Actually, identity is excluded. So we consider P and Q not both I.</p>
<p>Maybe it&rsquo;s easier: Count for each combination of (P,Q) with P,Q ∈ {I,X,Y,Z} but (P,Q) ≠ (I,I). There are 15.
We can make a table: For P and Q, determine:
For P:
I: (0,0)
X: (0,1)
Y: (1,1)
Z: (1,0)
So then for a pair (P,Q), the mod2 sum is: 
s_a = (a_P + a_Q) mod2, s_b = (b_P + b_Q) mod2.
So we want to count how many pairs (P,Q) (with P,Q ∈ {I,X,Y,Z}, but not both I) give each result.
Let&rsquo;s list all 16 combinations actually and then subtract (I,I):
(I,I): (0,0)
(I,X): (0+0, 0+1) = (0,1)
(I,Y): (0+1, 0+1) = (1,1)
(I,Z): (0+1, 0+0) = (1,0)
(X,I): (0+0, 1+0) = (0,1)
(X,X): (0+0, 1+1) = (0,0) mod2? Actually, 1+1=2 mod2=0, so (0,0)
(X,Y): (0+1, 1+1) = (1,0) because 1+1=2 mod2=0? Wait: (X,Y): a: X=0, Y=1 -&gt; sum=1 mod2; b: X=1, Y=1 -&gt; sum=2 mod2=0, so (1,0)
(X,Z): (0+1, 1+0) = (1,1)
(Y,I): (1+0, 1+0) = (1,1)
(Y,X): (1+0, 1+1) = (1,0) as above
(Y,Y): (1+1, 1+1) = (0,0)
(Y,Z): (1+1, 1+0) = (0,1) because 1+1=2 mod2=0, and 1+0=1 mod2=1, so (0,1)
(Z,I): (1+0, 0+0) = (1,0)
(Z,X): (1+0, 0+1) = (1,1)
(Z,Y): (1+1, 0+1) = (0,1) as above
(Z,Z): (1+1, 0+0) = (0,0)</p>
<p>So now count for non-identity (excluding (I,I)):
(0,0): Which ones? (X,X), (Y,Y), (Z,Z). So count = 3.
(0,1): (I,X), (X,I), (Y,Z), (Z,Y) -&gt; count = 4.
(1,0): (X,Y), (Y,X), (Z,I), (I,Z) -&gt; count = 4.
(1,1): (I,Y), (Y,I), (X,Z), (Z,X) -&gt; count = 4.
Total = 3+4+4+4 = 15. Good.</p>
<p>So for a single pair (from one CNOT error), the probabilities are:
P(identity) = 1-p, and identity gives (0,0).
For non-identity:
P((0,0)) = 3/15 * p = p/5.
P((0,1)) = 4/15 * p = 4p/15.
P((1,0)) = 4/15 * p = 4p/15.
P((1,1)) = 4/15 * p = 4p/15.</p>
<p>So then overall for one pair, the probabilities q:
q(0,0) = (1-p) + p/5 = 1 - p + p/5 = 1 - (4/5)p.
q(0,1) = 4p/15.
q(1,0) = 4p/15.
q(1,1) = 4p/15.</p>
<p>Now, for G to be in N(S), we need that the two pairs (from F and E) have the same (s_a,s_b) value. So:
P(N(S)) = q(0,0)^2 + q(0,1)^2 + q(1,0)^2 + q(1,1)^2.
= (1 - 4p/5)^2 + 3<em>(4p/15)^2
= (1 - 8p/5 + 16p^2/25) + 3</em>(16p^2/225)
= 1 - 8p/5 + 16p^2/25 + 48p^2/225
= 1 - 8p/5 + (16p^2/25 * 9/9) + 48p^2/225 = 1 - 8p/5 + (144p^2/225 + 48p^2/225)
= 1 - 8p/5 + 192p^2/225
Simplify 192/225 = divide by 3: 192/3=64, 225/3=75, so = 64p^2/75.
So P(N(S)) = 1 - 8p/5 + 64p^2/75.</p>
<p>Next, we want P(G in Stab(ψ_ideal)). That requires that on each pair, the error is &ldquo;good&rdquo;, i.e., the Pauli on the two qubits are the same. And as computed, for one pair, the probability of being good is r = 1 - 4p/5. And note that if a pair is good, it always gives (0,0) mod2. And these events on the two pairs are independent. So:
P(G in Stab(ψ_ideal)) = r^2 = (1 - 4p/5)^2 = 1 - 8p/5 + 16p^2/25.</p>
<p>But wait: Is it possible that G is in Stab(ψ_ideal) but not in N(S)? Actually, if it is in Stab(ψ_ideal), then it fixes the state, so it must commute with the stabilizers? Actually, check: If G is in Stab(ψ_ideal), then G|ψ_ideal&gt; = |ψ_ideal&gt;. But if G does not commute with S1, then S1|ψ_ideal&gt; = |ψ_ideal&gt;, but S1 G|ψ_ideal&gt; might not equal G S1|ψ_ideal&gt;. Actually, if G is in the stabilizer of the state, it means that |ψ_ideal&gt; is an eigenvector of G. But G might not commute with S1? But S1 is also a stabilizer of the state? Actually, S1|ψ_ideal&gt; = |ψ_ideal&gt;. So if G does not commute with S1, then G S1|ψ_ideal&gt; = G|ψ_ideal&gt; = |ψ_ideal&gt;, but S1 G|ψ_ideal&gt; would be something else? Actually, if G and S1 anticommute, then S1 G = - G S1. So then S1 G|ψ_ideal&gt; = - G S1|ψ_ideal&gt; = - G|ψ_ideal&gt; = -|ψ_ideal&gt;. So that would mean that |ψ_ideal&gt; is an eigenvector of S1 with eigenvalue -1, which is false. So indeed, if G is in the stabilizer of |ψ_ideal&gt;, then G must commute with S1 and S2. So Stab(ψ_ideal) is a subgroup of N(S). So our computed P(Stab) is correct.</p>
<p>So then the logical fidelity after post-selection is:
F_logical = P(G in Stab(ψ_ideal) | G in N(S)) = P(Stab) / P(N(S))
= [1 - 8p/5 + 16p^2/25] / [1 - 8p/5 + 64p^2/75].</p>
<p>Simplify numerator: 1 - 8p/5 + 16p^2/25 = (25/25) - (40p/25) + (16p^2/25) = (25 - 40p + 16p^2)/25.
Denom: 1 - 8p/5 + 64p^2/75 = (75/75) - (120p/75) + (64p^2/75) = (75 - 120p + 64p^2)/75.
So F_logical = [(25 - 40p + 16p^2)/25] / [(75 - 120p + 64p^2)/75] = (25 - 40p + 16p^2)/25 * 75/(75 - 120p + 64p^2) = (25 - 40p + 16p^2)*3/(75 - 120p + 64p^2) = (75 - 120p + 48p^2)/(75 - 120p + 64p^2).</p>
<p>So F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2).</p>
<p>We can simplify by dividing numerator and denominator by? 75,120,48 have common factor? 75,120,48 divisible by 3? 75/3=25, 120/3=40, 48/3=16, so numerator = 3*(25 - 40p + 16p^2)? Actually, 75/3=25, 120/3=40, 48/3=16, so numerator = 3(25 - 40p + 16p^2). Denom: 75,120,64: 75/ ? 75 and 120 are divisible by 3 but 64 is not. So not simpler.
Maybe factor as: = 1 - (16p^2)/(75 - 120p + 64p^2)? Actually, denominator - numerator = (64-48)p^2 = 16p^2. So F_logical = 1 - (16p^2)/(75 - 120p + 64p^2). That is another form.</p>
<p>But wait, the problem might expect a simpler expression? Alternatively, maybe we can approximate for small p: F_logical ≈ 1 - (16/75)p^2? But the problem asks for a function of p.</p>
<p>I&rsquo;ll check: When p=0, F=1. When p is small, F = 1 - (16/75)p^2 + &hellip; So that is the logical fidelity after post-selection.</p>
<p>But wait, is that the answer? The problem: &ldquo;What is the logical state fidelity &hellip; assuming the state is post-selected on all detectable errors?&rdquo; That means we only keep states that have no detected error. And detectable errors are those that anticommute with at least one stabilizer. So indeed, we keep only G in N(S). And then the fidelity is the probability that G is actually a stabilizer of the ideal state (i.e., acts as identity logically) given that. So that is what we computed.</p>
<p>Thus, the logical fidelity is:
F_logical(p) = (75 - 120p + 48p^2) / (75 - 120p + 64p^2).</p>
<p>We can also simplify by dividing numerator and denominator by? They don&rsquo;t have a common factor. Alternatively, we can write as:
F_logical(p) = 1 - \frac{16p^2}{75 - 120p + 64p^2}.</p>
<p>That is a valid answer.</p>
<p>But wait, the problem might expect a simpler expression? Perhaps it simplifies to something like: 
F_logical = \frac{1 - \frac{8}{5}p + \frac{16}{25}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2} which is what we had.</p>
<p>I&rsquo;ll check: For p=0.1, numerator = 1 - 0.16 + 0.0064 = 0.8464, denominator = 1 - 0.16 + 0.08533&hellip; = 0.92533, ratio = 0.9147. So logical fidelity is higher than physical fidelity? Physical fidelity was (1 - 0.08)^2 = 0.8464. So post-selection improves fidelity.</p>
<p>I&rsquo;ll double-check the counts: For one pair, probability of being good (same on both) is: 1-p + 3<em>(p/15)=1 - p + p/5 = 1 - 4p/5. That seems correct.
And probability that a pair gives (0,0) mod2 is: 1-p + p/5 = 1 - 4p/5. And then the other mod2 outcomes each have probability 4p/15. So then for two independent pairs, the probability that both are good is (1-4p/5)^2.
And the probability that they are both in N(S) is: (1-4p/5)^2 + 3</em>(4p/15)^2 = (1-4p/5)^2 + 3*(16p^2/225) = 1 - 8p/5 + 16p^2/25 + 48p^2/225 = 1 - 8p/5 + (144p^2/225 + 48p^2/225) = 1 - 8p/5 + 192p^2/225 = 1 - 8p/5 + 64p^2/75. Yes.
So then the ratio is as computed.</p>
<p>Thus, the logical fidelity after post-selection is:
F_logical = \frac{(1 - \frac{4}{5}p)^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2} = \frac{1 - \frac{8}{5}p + \frac{16}{25}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2} = \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}.</p>
<p>So I&rsquo;ll answer that.</p>
<p>But wait, the problem statement: &ldquo;What is the logical state fidelity &hellip; ?&rdquo; Possibly they want an expression in terms of p. So I&rsquo;ll give that.</p>
<p>Thus, final answer for Subproblem 2:</p>
<p><strong>Final Answer:</strong> </p>
<div class="arithmatex">\[
F_{\text{logical}}(p) = \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}
\]</div>
<p>I&rsquo;ll put that in a box.</p>
<p>I&rsquo;ll now write the step-by-step derivation.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-circuit-and-error-model">Step 1. Circuit and Error Model</h3>
<p>The goal is to prepare the logical GHZ state  </p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the [[4,2,2]] code using the circuit:  </p>
<div class="arithmatex">\[
\text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2,
\]</div>
<p>where operations are applied from right to left. The initial state is <span class="arithmatex">\(|0000\rangle\)</span>.</p>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel:
- With probability <span class="arithmatex">\(1 - p\)</span>, the gate is applied perfectly.
- With probability <span class="arithmatex">\(p\)</span>, one of the 15 non-identity two-qubit Pauli operators is applied, each with probability <span class="arithmatex">\(p/15\)</span>.</p>
<p>Hadamard gates are perfect.</p>
<p>Let:
- <span class="arithmatex">\(E\)</span>: error on <span class="arithmatex">\(\text{CNOT}_{21}\)</span>, acting on qubits 2 and 1.
- <span class="arithmatex">\(F\)</span>: error on <span class="arithmatex">\(\text{CNOT}_{03}\)</span>, acting on qubits 0 and 3.</p>
<p>The overall operation becomes:  </p>
<div class="arithmatex">\[
U_{\text{actual}} = F \cdot \text{CNOT}_{03} \cdot H_0 \cdot E \cdot \text{CNOT}_{21} \cdot H_2.
\]</div>
<p>Since <span class="arithmatex">\(E\)</span> and <span class="arithmatex">\(F\)</span> act on disjoint sets of qubits, they commute with subsequent gates, so:  </p>
<div class="arithmatex">\[
U_{\text{actual}} = (F E) \cdot U_{\text{perfect}}, \quad \text{where } U_{\text{perfect}} = \text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2.
\]</div>
<p>Thus, the final state is:  </p>
<div class="arithmatex">\[
|\psi_{\text{actual}}\rangle = G |\psi_{\text{ideal}}\rangle, \quad \text{with } G = F E.
\]</div>
<hr />
<h3 id="step-2-post-selection-condition">Step 2. Post-Selection Condition</h3>
<p>The [[4,2,2]] code has stabilizers:  </p>
<div class="arithmatex">\[
S_1 = XXXX, \quad S_2 = ZZZZ.
\]</div>
<p>An error <span class="arithmatex">\(G\)</span> is detectable if it anticommutes with at least one stabilizer. Post-selection keeps only states with syndrome <span class="arithmatex">\((+1, +1)\)</span>, i.e., where <span class="arithmatex">\(G\)</span> commutes with both <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>. This means <span class="arithmatex">\(G\)</span> must be in the normalizer <span class="arithmatex">\(N(S)\)</span> of the stabilizer group.</p>
<p>The logical fidelity is the probability that <span class="arithmatex">\(G\)</span> acts as the identity on the logical state (i.e., <span class="arithmatex">\(G \in \text{Stab}(|\psi_{\text{ideal}}\rangle)\)</span>), given that <span class="arithmatex">\(G \in N(S)\)</span>.</p>
<hr />
<h3 id="step-3-probability-that-g-in-ns">Step 3. Probability that <span class="arithmatex">\(G \in N(S)\)</span></h3>
<p>Since <span class="arithmatex">\(G = F E\)</span> and <span class="arithmatex">\(F\)</span>, <span class="arithmatex">\(E\)</span> are independent, we compute the probability that <span class="arithmatex">\(G\)</span> commutes with <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>.</p>
<p>Define for each Pauli operator:
- <span class="arithmatex">\(a = 1\)</span> if the Pauli is <span class="arithmatex">\(Y\)</span> or <span class="arithmatex">\(Z\)</span>, else <span class="arithmatex">\(0\)</span>,
- <span class="arithmatex">\(b = 1\)</span> if the Pauli is <span class="arithmatex">\(X\)</span> or <span class="arithmatex">\(Y\)</span>, else <span class="arithmatex">\(0\)</span>.</p>
<p>Then <span class="arithmatex">\(G\)</span> commutes with:
- <span class="arithmatex">\(S_1\)</span> if the total number of qubits with <span class="arithmatex">\(a = 1\)</span> is even,
- <span class="arithmatex">\(S_2\)</span> if the total number of qubits with <span class="arithmatex">\(b = 1\)</span> is even.</p>
<p>For a single pair (e.g., qubits 0 and 3 from <span class="arithmatex">\(F\)</span>), the probability distribution over Pauli errors is:
- <span class="arithmatex">\(P(I \otimes I) = 1 - p\)</span>,
- <span class="arithmatex">\(P(\text{non-identity}) = p/15\)</span> for each of the 15 non-identity Paulis.</p>
<p>Let <span class="arithmatex">\(q(s_a, s_b)\)</span> be the probability that a pair contributes <span class="arithmatex">\((s_a, s_b) \mod 2\)</span>. Then:</p>
<div class="arithmatex">\[
\begin{aligned}
q(0,0) &amp;= 1 - p + \frac{p}{5} = 1 - \frac{4}{5}p, \\
q(0,1) &amp;= \frac{4p}{15}, \\
q(1,0) &amp;= \frac{4p}{15}, \\
q(1,1) &amp;= \frac{4p}{15}.
\end{aligned}
\]</div>
<p>For <span class="arithmatex">\(G = F E\)</span> to be in <span class="arithmatex">\(N(S)\)</span>, the two pairs must contribute the same <span class="arithmatex">\((s_a, s_b)\)</span>. Thus:</p>
<div class="arithmatex">\[
\begin{aligned}
P(G \in N(S)) &amp;= q(0,0)^2 + q(0,1)^2 + q(1,0)^2 + q(1,1)^2 \\
&amp;= \left(1 - \frac{4}{5}p\right)^2 + 3 \left(\frac{4p}{15}\right)^2 \\
&amp;= 1 - \frac{8}{5}p + \frac{16}{25}p^2 + \frac{48}{225}p^2 \\
&amp;= 1 - \frac{8}{5}p + \frac{64}{75}p^2.
\end{aligned}
\]</div>
<hr />
<h3 id="step-4-probability-that-g-in-textstabpsi_textidealrangle">Step 4. Probability that <span class="arithmatex">\(G \in \text{Stab}(|\psi_{\text{ideal}}\rangle)\)</span></h3>
<p>The stabilizer of <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> requires:
- On qubits 0 and 3: the Pauli is the same,
- On qubits 1 and 2: the Pauli is the same.</p>
<p>For a single pair, the “good” Paulis are <span class="arithmatex">\(I \otimes I\)</span>, <span class="arithmatex">\(X \otimes X\)</span>, <span class="arithmatex">\(Y \otimes Y\)</span>, <span class="arithmatex">\(Z \otimes Z\)</span>. Their total probability is:</p>
<div class="arithmatex">\[
r = 1 - p + 3 \cdot \frac{p}{15} = 1 - \frac{4}{5}p.
\]</div>
<p>Since the pairs are independent:</p>
<div class="arithmatex">\[
P(G \in \text{Stab}(|\psi_{\text{ideal}}\rangle)) = r^2 = \left(1 - \frac{4}{5}p\right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2.
\]</div>
<hr />
<h3 id="step-5-logical-fidelity-after-post-selection">Step 5. Logical Fidelity After Post-Selection</h3>
<p>The logical fidelity is the conditional probability:</p>
<div class="arithmatex">\[
\begin{aligned}
F_{\text{logical}}(p) &amp;= \frac{P(G \in \text{Stab}(|\psi_{\text{ideal}}\rangle))}{P(G \in N(S))} \\
&amp;= \frac{1 - \frac{8}{5}p + \frac{16}{25}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2}.
\end{aligned}
\]</div>
<p>Multiply numerator and denominator by 75:</p>
<div class="arithmatex">\[
\begin{aligned}
F_{\text{logical}}(p) &amp;= \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}.
\end{aligned}
\]</div>
<hr />
<h3 id="final-answer">Final Answer:</h3>
<div class="arithmatex">\[
\boxed{\dfrac{75 - 120p + 48p^{2}}{75 - 120p + 64p^{2}}}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given the expression for the logical fidelity after post-selection:
 F_logical(p) = (75 - 120p + 48p^2) / (75 - 120p + 64p^2)</p>
<p>We&rsquo;ll represent this in SymPy.
 Note: The expression can be simplified by factoring out common factors? 
 But the problem does not require simplification beyond the derived expression.</p>
<p>However, note that 75, 120, 48, and 64 have a common factor? 
 75, 120, 48, 64 are all divisible by 1? Actually, 75 and 120 are divisible by 5, but 48 and 64 are not.
 So we leave it as is.</p>
<p>Alternatively, we can write it in a factored form if desired, but the problem does not specify.</p>
<p>Since the problem says &ldquo;return the expression&rdquo;, we return the expression as derived.</p>
<p>Let&rsquo;s write it in SymPy:</p>
                      </div>
                    </details>
<div class="content markdown-body"><p><strong>Final Answer:</strong></p>
<p>The logical state fidelity after post-selection is given by the expression:</p>
<div class="arithmatex">\[
F_{\text{logical}}(p) = \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}
\]</div>
<p>This is implemented in the code template below.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">75</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">48</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">75</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">64</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.147468
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>