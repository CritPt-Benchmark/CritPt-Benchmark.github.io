<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ğŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note: This equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?&rdquo;</p>
<p>Interpretation: We have a circuit that prepares a logical state. But then we are adding errors: Each CNOT gate is followed by a two-qubit depolarizing error channel that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15. So there are two CNOT gates: CNOT_{21} and CNOT_{03}. Also there are Hadamard gates: H_0 and H_2. But note: The problem says: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. So only CNOT gates get errors? Possibly the Hadamard gates are error-free? The problem statement: &ldquo;As a simple model of quantum errors in hardware, we will suppose that each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; So only CNOT gates have errors. So H gates are perfect.</p>
<p>So circuit: The operations in order (from right to left as per note: &ldquo;the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation)&rdquo;. So the circuit order is:
Step 1: H_2
Step 2: CNOT_{21}
Step 3: H_0
Step 4: CNOT_{03}</p>
<p>But careful: The equation is: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). That is matrix multiplication order. So the actual circuit order: first apply H_2, then CNOT_{21}, then H_0, then CNOT_{03}. So that is the order.</p>
<p>We want: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; That means: The ideal final state (without errors) is some state. But due to errors on CNOT gates, the actual state becomes a mixture. The fidelity is the overlap between the ideal state and the actual state. But careful: &ldquo;physical state fidelity&rdquo; likely means the fidelity of the output state relative to the ideal state. But the output state is a density matrix due to errors. And we want the average fidelity? Possibly: The circuit is applied to initial state? Usually initial state is |0000&gt;? But not explicitly stated. But likely: The initial state is |0000&gt;? Because we are preparing a state. So initial state: |0&gt; on all qubits? Typically yes.
So initial state: |0\rangle^{\otimes 4}.</p>
<p>Then ideal circuit: 
H_2 on qubit 2: becomes: |0\rangle on qubits 0,1,3 and on qubit 2: H|0&gt; = |+&gt; = (|0&gt;+|1&gt;)/âˆš2.
So state: |0&gt;<em>0 |0&gt;_1 (|0&gt;+|1&gt;)_2/âˆš2 |0&gt;_3.
Then CNOT</em>{21}: control qubit 2, target qubit 1. So then state: 
If qubit2 is 0, then qubit1 remains 0; if qubit2 is 1, then qubit1 flips. So state becomes: 
|0&gt;<em>0 (|00&gt;+|11&gt;)_21/âˆš2 |0&gt;_3? But careful: Actually: 
State: |0&gt;_0 âŠ— (|0&gt;_1|0&gt;_2 + |0&gt;_1|1&gt;_2? Actually: Initially: |0&gt;_1 and |+&gt;_2 = (|0&gt;+|1&gt;)/âˆš2. So state = |0&gt;_0 âŠ— |0&gt;_1 âŠ— (|0&gt;_2+|1&gt;_2)/âˆš2 âŠ— |0&gt;_3.
After CNOT</em>{21} (control=2, target=1): 
When qubit2=0, then qubit1 remains 0; when qubit2=1, then qubit1 becomes 1. So state becomes: 
|0&gt;<em>0 âŠ— (|0&gt;_1|0&gt;_2 + |1&gt;_1|1&gt;_2)/âˆš2 âŠ— |0&gt;_3.
So state: (|0000&gt; + |0110&gt;)? Actually careful: qubits: 0,1,2,3. So:
|0&gt;_0, then qubit1 and qubit2: |00&gt; and |11&gt;, and qubit3: |0&gt;. So state = (|0&gt;_0|00&gt;_12|0&gt;_3 + |0&gt;_0|11&gt;_12|0&gt;_3)/âˆš2 = (|0000&gt; + |0110&gt;)/âˆš2? But wait: labeling: qubit0, qubit1, qubit2, qubit3. So |0000&gt; means qubit0=0, qubit1=0, qubit2=0, qubit3=0. And |0110&gt; means qubit0=0, qubit1=1, qubit2=1, qubit3=0. So that is state.
Then H_0: Hadamard on qubit0. So H|0&gt; = |+&gt; = (|0&gt;+|1&gt;)/âˆš2. So state becomes:
H_0 applied: 
State = (1/âˆš2) * [ (|0&gt;_0+|1&gt;_0)/âˆš2 |00&gt;_12|0&gt;_3 + (|0&gt;_0+|1&gt;_0)/âˆš2 |11&gt;_12|0&gt;_3 ]? Actually careful: H_0 acts on qubit0. So:
Before: |Ïˆ&gt; = (|0&gt;_0|00&gt;_12|0&gt;_3 + |0&gt;_0|11&gt;_12|0&gt;_3)/âˆš2.
After H_0: becomes: (H|0&gt;_0|00&gt;_12|0&gt;_3 + H|0&gt;_0|11&gt;_12|0&gt;_3)/âˆš2 = (|+&gt;_0|00&gt;_12|0&gt;_3 + |+&gt;_0|11&gt;_12|0&gt;_3)/âˆš2 = (1/âˆš2)[ (|0&gt;+|1&gt;)_0/âˆš2 (|00&gt;_12|0&gt;_3 + |11&gt;_12|0&gt;_3) ] = (1/2)[ |0&gt;_0(|00&gt;_12+|11&gt;_12)|0&gt;_3 + |1&gt;_0(|00&gt;_12+|11&gt;_12)|0&gt;_3 ].
So state = (|0&gt;_0 + |1&gt;_0)/2 * (|00&gt;_12+|11&gt;_12)|0&gt;_3? Actually careful: It is: 
= 1/2 [ |0&gt;_0|00&gt;_12|0&gt;_3 + |0&gt;_0|11&gt;_12|0&gt;_3 + |1&gt;_0|00&gt;_12|0&gt;_3 + |1&gt;_0|11&gt;_12|0&gt;_3 ].
So state = (|0000&gt; + |0110&gt; + |1000&gt; + |1110&gt;)/2.
Then CNOT</em>{03}: control qubit 0, target qubit 3.
So apply CNOT_{03}: 
For terms: 
|0000&gt;: control=0 so target qubit3 flips? Actually control: if qubit0=1 then flip qubit3. So:
|0000&gt; -&gt; |0000&gt; because qubit0=0.
|0110&gt; -&gt; |0110&gt; because qubit0=0.
|1000&gt; -&gt; qubit0=1 so flip qubit3: becomes |1001&gt;.
|1110&gt; -&gt; becomes |1111&gt;.
So final ideal state: 
|Ïˆ_ideal&gt; = (|0000&gt; + |0110&gt; + |1001&gt; + |1111&gt;)/2.
But wait: Is that the logical GHZ state? The logical GHZ state for two qubits A and B is (|00&gt;_AB + |11&gt;_AB)/âˆš2. But here we have 4 physical qubits. And the code is [[4,2,2]]. And the logical operators are given: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI. So what are the logical basis states? They are encoded such that they are stabilized by XXXX and ZZZZ. So the code space is the subspace of 4 qubits that are +1 eigenvectors of XXXX and ZZZZ. Our state: |Ïˆ_ideal&gt; = (|0000&gt;+|0110&gt;+|1001&gt;+|1111&gt;)/2. Check: Apply XXXX: 
XXXX|0000&gt; = |1111&gt;? Actually XXXX on |0000&gt; gives |1111&gt; because flip all bits. So that is not an eigenvector unless coefficients match. But here: XXXX|Ïˆ&gt; = (|1111&gt;+|1001&gt;+|0110&gt;+|0000&gt;)/2 = same as |Ïˆ&gt;? Actually order: 
|Ïˆ&gt; = (|0000&gt; + |0110&gt; + |1001&gt; + |1111&gt;)/2.
XXXX|Ïˆ&gt; = (XXXX|0000&gt; + XXXX|0110&gt; + XXXX|1001&gt; + XXXX|1111&gt;)/2 = (|1111&gt; + |1001&gt; + |0110&gt; + |0000&gt;)/2 = same. So it is symmetric. And ZZZZ: ZZZZ|Ïˆ&gt; = (1 +? Actually ZZZZ on each basis: 
|0000&gt;: all zeros, so eigenvalue +1.
|0110&gt;: qubits: 0,1,1,0. Z on each: gives phases: qubit0: +1, qubit1: -1, qubit2: -1, qubit3: +1, product = +1.
|1001&gt;: qubits: 1,0,0,1: phases: -1, +1, +1, -1 = +1.
|1111&gt;: all ones: product of -1&rsquo;s: (-1)^4 = +1.
So indeed it is in the code space. And then what are the logical states? The logical operators: 
X_A = XIXI. Apply X_A to |Ïˆ&gt;: 
X_A|0000&gt; = |0100&gt;? That is not in the basis. But maybe we don&rsquo;t need to check. But the problem says: &ldquo;logical two-qubit GHZ state (|00&gt;_AB+|11&gt;_AB)/âˆš2&rdquo;. So that state is indeed an entangled state between the two logical qubits. So it&rsquo;s fine.</p>
<p>So ideal state: |Ïˆ_ideal&gt; = (|0000&gt;+|0110&gt;+|1001&gt;+|1111&gt;)/2.</p>
<p>Now, we have errors on CNOT gates. There are two CNOT gates: CNOT_{21} and CNOT_{03}. Each CNOT gate is followed by a depolarizing error channel on the two qubits involved. That error channel: With probability 1-p, no error. With probability p, an error occurs. And if an error occurs, it is uniformly distributed among the 15 non-identity two-qubit Pauli operators on those two qubits. So each CNOT gate&rsquo;s error channel: 
After applying CNOT, then apply with probability p/15 each of the 15 Paulis on the two qubits (the ones that are involved in the CNOT). But careful: The error channel is applied after the CNOT gate. So the overall circuit with errors: 
Start with |0000&gt;.
Apply H_2 (perfect).
Then apply CNOT_{21} (perfect) followed by error channel on qubits 2 and 1. That error channel: It applies a Pauli error E from the set {I, X, Y, Z} âŠ— {I, X, Y, Z} minus identity? Actually: &ldquo;produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; So actually it is: With probability 1-p, no error (IâŠ—I). With probability p, an error from the set of 15 Paulis (all Pauli strings on two qubits except IâŠ—I) each with probability p/15.
Then apply H_0 (perfect).
Then apply CNOT_{03} (perfect) followed by error channel on qubits 0 and 3.</p>
<p>So the final state is a mixture. We want the physical state fidelity. That is: F = âŸ¨Ïˆ_ideal| Ï_final |Ïˆ_idealâŸ©, where Ï_final is the density matrix after the circuit with errors.
Since errors are independent on the two CNOT gates, we can compute the effect of each error channel on the ideal state preparation. But careful: The errors occur in the middle of the circuit. So the final state is not simply the ideal state with some Pauli errors applied? But we can compute the entire process as a quantum channel. Alternatively, we can compute the fidelity as: The probability that no error occurs that takes the state out of the ideal state? But careful: Some errors might be correctable? But here we are not correcting errors; we are just computing the fidelity of the output state relative to the ideal state. And the errors are Pauli errors. And the circuit is Clifford? Actually, the circuit consists of Hadamard and CNOT. So it is a Clifford circuit. And the initial state is |0&gt;^4. So the entire process is a Clifford circuit. And the errors are Pauli errors. So the final state is a mixture of states that are Pauli errors applied to the ideal state? But careful: The errors occur at different times. But because the circuit is Clifford, the effect of a Pauli error at some point can be propagated through the subsequent gates. That is a common technique: Instead of applying errors on the state, we can push them to the end as Pauli errors on the initial state? But here the errors are applied after gates. But we can use the fact that if we have a Clifford circuit U, and an error E occurs after some gate, then U E = (U E U^\dagger) U. So the overall effect is that the error becomes a Pauli error at the beginning? But careful: The errors are applied in between gates. So let&rsquo;s denote the circuit as: 
U = U4 * U3 * U2 * U1, where:
U1 = H_2
U2 = CNOT_{21}
U3 = H_0
U4 = CNOT_{03}
But then errors: After U2, we have error channel on qubits {2,1}. After U4, we have error channel on qubits {0,3}.
So the actual operation is: 
Ï = E_{03} âˆ˜ U4 âˆ˜ E_{21} âˆ˜ U2 âˆ˜ U1 (|0&gt;&lt;0|) but careful: There is also U3 = H_0 in between. Actually order: 
Step 1: U1 = H_2
Step 2: U2 = CNOT_{21}
Step 3: Error channel on qubits {2,1} (call it E_{21})
Step 4: U3 = H_0
Step 5: U4 = CNOT_{03}
Step 6: Error channel on qubits {0,3} (call it E_{03})
So overall: Ï = (E_{03} âˆ˜ U4 âˆ˜ U3 âˆ˜ E_{21} âˆ˜ U2 âˆ˜ U1)(|0&gt;&lt;0|) but careful: The error channel E_{21} is applied after U2, so it is: U2 then E_{21} then U3 then U4 then E_{03}. So overall unitary part: U = U4 U3 U2 U1. And then errors: They are not necessarily at the end because they are conjugated by subsequent gates. But we can push them to the end. Specifically, if we have an error E acting on some qubits after a unitary V, then the overall effect is: V E = (V E V^\dagger) V. So if we have a sequence: &hellip; V, then error E, then W, then we can write: W (V E) = W V E = (W V E V^\dagger W^\dagger) W V. So indeed, we can push errors to the end. So let&rsquo;s do that.
We have: U_total = U4 U3 U2 U1.
But errors: After U2, we have error E (on qubits 1,2). Then U3 and U4 follow. So that error becomes: U4 U3 E U3^\dagger U4^\dagger? Actually careful: The circuit is: U4 * U3 * (error E on qubits {1,2}) * U2 * U1.
So that is equivalent to: (U4 U3 E U3^\dagger U4^\dagger) * (U4 U3 U2 U1) = E&rsquo; * U_total, where E&rsquo; = U4 U3 E U3^\dagger U4^\dagger.
And then after U4, we have error F on qubits {0,3}. That is already at the end? Actually: The circuit: U4, then error F on {0,3}. So that is: F * U4. But then combined with the previous part: Actually careful: The full circuit with errors: 
Ï = (F âˆ˜ U4) âˆ˜ (U3) âˆ˜ (E âˆ˜ U2) âˆ˜ (U1) (|0&gt;&lt;0|). But note: U3 is a unitary that does not have an error after it? Actually, the error after U2 is applied before U3. So it is: U4 * (error F on {0,3})? Actually, wait: The order is: 
Start: |Ïˆ0&gt; = |0000&gt;.
Apply U1 = H_2.
Apply U2 = CNOT_{21}.
Then apply error channel on qubits {2,1} (call it E_{21}).
Then apply U3 = H_0.
Then apply U4 = CNOT_{03}.
Then apply error channel on qubits {0,3} (call it E_{03}).
So if we denote the perfect unitary as U = U4 U3 U2 U1, then the actual operation is: 
Ï = E_{03} ( U4 ( U3 ( E_{21} ( U2 ( U1 (|0&gt;&lt;0|) U1^\dagger ) U2^\dagger ) U3^\dagger ) U4^\dagger ) ) 
But we can push the error E_{21} through U3 and U4. As said: U4 U3 E_{21} = (U4 U3 E_{21} U3^\dagger U4^\dagger) U4 U3. So then the overall becomes: 
Ï = E_{03} ( (U4 U3 E_{21} U3^\dagger U4^\dagger) U4 U3 U2 U1 (|0&gt;&lt;0|) &hellip; ) but careful with order: Actually, let&rsquo;s do it step by step:
We have: Ï = E_{03} âˆ˜ (U4) âˆ˜ (U3) âˆ˜ (E_{21}) âˆ˜ (U2) âˆ˜ (U1) (Ï0).
Define V = U3 U2 U1. Then Ï = E_{03} âˆ˜ (U4) âˆ˜ (E_{21}) âˆ˜ (V) (Ï0)? Not exactly because U3 is after E_{21}? Actually: The order is: U1, then U2, then E_{21}, then U3, then U4, then E_{03}. So if we combine U3 U2 U1 = V, then careful: That would be if E_{21} was after U3? Actually, no: It is: U1, U2, E_{21}, U3, U4, E_{03}. So if I define V = U3 U2 U1, then the order is: U1, U2, then E_{21}, then U3, then U4, then E_{03} = (U4 U3) (E_{21}) (U2 U1) but then that is not simply V because V = U3 U2 U1, so U4 U3 = U4 * U3, and U2 U1 is part of V but then U3 is separate. Actually, it&rsquo;s easier: Push E_{21} through U3 and U4. Write the entire unitary part as U = U4 U3 U2 U1. Then note that:
U4 U3 E_{21} U2 U1 = U4 U3 E_{21} (U3^\dagger U4^\dagger) (U4 U3 U2 U1) = (U4 U3 E_{21} U3^\dagger U4^\dagger) U.
So indeed, the effect of the error E_{21} (which acts on qubits 1,2) becomes, after pushing through U3 and U4, an error E&rsquo; = U4 U3 E_{21} U3^\dagger U4^\dagger that acts on the state at the end (after U). But careful: There is also the error E_{03} at the very end. So overall, the actual state is: 
Ï = (E_{03} âˆ˜ (E&rsquo;))( U Ï0 U^\dagger ) where E&rsquo; is the channel that applies the error E (from the set of Paulis on qubits {1,2}) transformed by U4 U3. But wait: But then note: E_{21} is a probabilistic application of Paulis on qubits 1 and 2. And then E&rsquo; will be some Pauli on some qubits? Since U4 and U3 are Clifford gates, they map Paulis to Paulis. So E&rsquo; will be a Pauli operator on some set of qubits. Let&rsquo;s compute that transformation.
We have: U3 = H_0. U4 = CNOT_{03}.
And E is a Pauli on qubits {1,2}? Actually, careful: E_{21} acts on qubits 2 and 1. But note: qubits are labeled: 0,1,2,3. So E_{21} acts on qubit2 and qubit1. Under U3 = H_0, that does nothing to qubits 1,2 because H_0 only acts on qubit0. So U3 E_{21} U3^\dagger = E_{21} because E_{21} commutes with H_0? Actually, check: H_0 acts on qubit0. E_{21} acts on qubits 1 and 2. They act on different qubits, so they commute. So then U4 U3 E_{21} U3^\dagger U4^\dagger = U4 E_{21} U4^\dagger. And U4 = CNOT_{03}. That acts on qubits 0 and 3. So it will commute with operators on qubits 1 and 2? Actually, careful: CNOT_{03} acts on qubit0 and qubit3. Operators on qubits 1 and 2 commute with CNOT_{03} if they are Paulis? Actually, Pauli operators on qubits 1 and 2 commute with CNOT_{03} because they act on different qubits. So indeed, U4 E_{21} U4^\dagger = E_{21} because E_{21} acts on qubits 1 and 2, and CNOT_{03} acts on qubits 0 and 3, so they commute. Wait, check: For example, if E_{21} = X_2, then CNOT_{03} X_2 = X_2 CNOT_{03} because CNOT_{03} only involves qubits 0 and 3. So yes, they commute. So actually, E&rsquo; = E_{21} itself. That is interesting: The error on the first CNOT (on qubits 1,2), when pushed through the subsequent gates (H_0 and CNOT_{03}), remains as the same Pauli error on qubits 1 and 2. So then the overall effect is: The actual state is as if we applied the perfect unitary U, and then we apply two independent error channels: one on qubits {1,2} from the first CNOT error, and one on qubits {0,3} from the second CNOT error. But wait: Is that correct? Let&rsquo;s check manually: The circuit: H_2, then CNOT_{21}, then error on {1,2}, then H_0, then CNOT_{03}, then error on {0,3}. If we push the error on {1,2} through H_0 and CNOT_{03}, since these gates act on qubits 0 and 3, they commute with any operator on qubits 1 and 2. So indeed, we can move that error to after the CNOT_{03} gate. So then the circuit becomes: H_2, CNOT_{21}, H_0, CNOT_{03}, then error on {1,2} (from first CNOT error) and then error on {0,3} (from second CNOT error). And note that the order of these two errors doesn&rsquo;t matter because they act on disjoint sets of qubits. So indeed, the overall process is: 
Ideal unitary U (which prepares the ideal state |Ïˆ_ideal&gt;) and then two independent error channels: one on qubits {1,2} and one on qubits {0,3}. And these error channels are: 
For qubits {1,2}: With probability 1-p, identity; with probability p, a random non-identity Pauli on qubits 1 and 2 (each of the 15 equally likely).
For qubits {0,3}: Similarly.</p>
<p>So then the final state Ï is: 
Ï = (E_{03} âŠ— E_{21}) ( |Ïˆ_ideal&gt;&lt;Ïˆ_ideal| ) where E_{03} and E_{21} are the depolarizing channels on those pairs. But careful: The error channels are applied independently. So the overall channel is: 
Ï = (1-p)^2 |Ïˆ_ideal&gt;&lt;Ïˆ_ideal| 
+ (1-p)<em>p/15 * (sum over non-identity Paulis on {0,3}) applied to |Ïˆ_ideal&gt;&lt;Ïˆ_ideal| 
+ p</em>(1-p)/15 * (sum over non-identity Paulis on {1,2}) 
+ (p/15)^2 * (sum over pairs of non-identity Paulis on both sets) applied.</p>
<p>But wait: There is also possibility that both errors occur? But that is included: probability p^2 that both errors occur, but then each error is one of 15, so total probability for a specific pair is p^2/225.</p>
<p>So then the fidelity F = &lt;Ïˆ_ideal| Ï |Ïˆ_ideal&gt;.
That equals: 
F = (1-p)^2 * 1 
+ (1-p)*p/15 * (sum over E on {0,3} non-identity: &lt;Ïˆ_ideal| E |Ïˆ_ideal&gt;? But careful: The channel: For a given Pauli error E (on a specific set), the state becomes: with probability (p/15), we get E |Ïˆ_ideal&gt;&lt;Ïˆ_ideal| E^\dagger. So then the overlap with |Ïˆ_ideal&gt; is |&lt;Ïˆ_ideal| E |Ïˆ_ideal&gt;|^2. But note: |Ïˆ_ideal&gt; is a state. And E is a Pauli operator. So &lt;Ïˆ_ideal| E |Ïˆ_ideal&gt; is either 0 or 1? Actually, Pauli operators are Hermitian and unitary. And |Ïˆ_ideal&gt; is a specific state. It might be an eigenvector of some Paulis? Let&rsquo;s check: 
|Ïˆ_ideal&gt; = (|0000&gt;+|0110&gt;+|1001&gt;+|1111&gt;)/2.
We want to compute for a Pauli operator acting on qubits {0,3} (say) what is &lt;Ïˆ_ideal| P |Ïˆ_ideal&gt;? And similarly for Paulis on {1,2}.</p>
<p>So we need to compute: For each non-identity Pauli on qubits {0,3}, what is the expectation value? And for each non-identity Pauli on qubits {1,2}, what is the expectation value?
And then also for products from both sets? But careful: The errors are independent. But note: The errors on {0,3} and on {1,2} act on disjoint qubits. So if we have an error E on {0,3} and F on {1,2}, then the overall error is EâŠ—F. And then the fidelity contribution is |&lt;Ïˆ_ideal| (EâŠ—F) |Ïˆ_ideal&gt;|^2. And then we sum over all such errors weighted by their probabilities.</p>
<p>So let&rsquo;s compute these overlaps.</p>
<p>Let |Ïˆ&gt; = (|0000&gt; + |0110&gt; + |1001&gt; + |1111&gt;)/2.
We want to compute for a Pauli operator P (which is a tensor product of Paulis on the four qubits, but restricted to act nontrivially only on a subset? Actually, careful: The errors are on specific sets: 
For the error from the first CNOT, it acts on qubits 1 and 2. So those Paulis are of the form: I âŠ— (something on qubit1) âŠ— (something on qubit2) âŠ— I. But wait: Actually, the error channel on the first CNOT is on qubits 2 and 1. But order: qubits: 0,1,2,3. So on qubits 1 and 2, the Pauli operators are: I_0 âŠ— A_1 âŠ— B_2 âŠ— I_3, where A,B âˆˆ {I, X, Y, Z} but not both I? Actually, the error set is all Paulis on qubits {1,2} except the identity. So there are 15 such operators.
Similarly, the error from the second CNOT is on qubits {0,3}. So those are: C_0 âŠ— I_1 âŠ— I_2 âŠ— D_3, with C,D âˆˆ {I,X,Y,Z} and not both I.</p>
<p>And then also there is possibility of both errors simultaneously: That gives operators: (C_0 âŠ— I_1 âŠ— I_2 âŠ— D_3) * (I_0 âŠ— A_1 âŠ— B_2 âŠ— I_3) = C_0 âŠ— A_1 âŠ— B_2 âŠ— D_3. But note: These are not all Paulis on all 4 qubits? They are a subset of the 4-qubit Paulis that act nontrivially only on these pairs. But careful: There is also possibility that the errors from the two channels are applied? But they are independent. So indeed, the overall error channel is: 
With probability (1-p)^2: no error.
With probability p(1-p): error only on {0,3} (15 possibilities, each probability p(1-p)/15)
With probability (1-p)p: error only on {1,2} (15 possibilities, each probability p(1-p)/15)
With probability p^2: error on both sets (225 possibilities, each probability p^2/225)</p>
<p>But wait: There is also possibility that the error from one channel is identity? But that is already included: The error channel on each CNOT gives identity with probability 1-p. So indeed.</p>
<p>So then fidelity F = &lt;Ïˆ| Ï |Ïˆ&gt; = 
(1-p)^2 * 1 
+ (1-p)p/15 * [ sum_{E in Paulis on {0,3} non-identity } |&lt;Ïˆ| E |Ïˆ&gt;|^2 ]
+ p(1-p)/15 * [ sum_{F in Paulis on {1,2} non-identity } |&lt;Ïˆ| F |Ïˆ&gt;|^2 ]
+ p^2/225 * [ sum_{E on {0,3} non-identity, F on {1,2} non-identity } |&lt;Ïˆ| E F |Ïˆ&gt;|^2 ]</p>
<p>And note: |&lt;Ïˆ| P |Ïˆ&gt;|^2 is either 0 or 1? Actually, careful: For a Pauli operator P, if |Ïˆ&gt; is an eigenvector of P, then &lt;Ïˆ|P|Ïˆ&gt; = Â±1, so squared is 1. If not, then it could be 0? But wait: For a Pauli operator, itè¦ä¹ˆ commutes with the state&rsquo;s projector? Actually, if |Ïˆ&gt; is a stabilizer state, then it is an eigenvector of some Paulis. But here |Ïˆ&gt; is not necessarily a stabilizer state of the full Pauli group? But it is a state in the code space. Actually, |Ïˆ&gt; is a specific state. Let&rsquo;s compute these overlaps explicitly.</p>
<p>We have |Ïˆ&gt; = (|0000&gt; + |0110&gt; + |1001&gt; + |1111&gt;)/2.
Let&rsquo;s denote basis states by |a b c d&gt; where a=qubit0, b=qubit1, c=qubit2, d=qubit3.
So |Ïˆ&gt; = (|0000&gt; + |0110&gt; + |1001&gt; + |1111&gt;)/2.</p>
<p>Now, consider an operator on {0,3}: That is of the form P = P_0 âŠ— I_1 âŠ— I_2 âŠ— P_3, where P_0 and P_3 are Paulis (X, Y, Z) but not both I? Actually, non-identity means that (P_0, P_3) is not (I,I). So there are 15 such operators.
We want to compute &lt;Ïˆ| P |Ïˆ&gt;. 
P acts on qubits 0 and 3. So it will map each basis state to another basis state up to a phase. Let&rsquo;s list the basis states in |Ïˆ&gt;: 
1: |0000&gt;
2: |0110&gt;
3: |1001&gt;
4: |1111&gt;
Under P, what happens? 
For a given P = (Ïƒ, Ï„) on qubits 0 and 3, where Ïƒ, Ï„ âˆˆ {X, Y, Z} (and not both identity, but we include all combinations? But careful: The set is: Ïƒ and Ï„ can be I? But then it would be identity? Actually, the error set on {0,3} is non-identity Paulis. So Ïƒ and Ï„ are such that they are not both I. But we can compute for each possibility separately.</p>
<p>Let&rsquo;s compute for each type: 
We want &lt;Ïˆ| P |Ïˆ&gt; = (1/4)[ &lt;0000| P |0000&gt; + &lt;0110| P |0110&gt; + &lt;1001| P |1001&gt; + &lt;1111| P |1111&gt; ] plus cross terms? Actually careful: 
&lt;Ïˆ| P |Ïˆ&gt; = sum_{i,j} (1/4) <i| P |j> where i,j are the four basis states. But since P is a Pauli operator, it will map each computational basis state to another computational basis state (possibly with a phase). So the matrix elements are diagonal only if P maps the state to itself. So we need to check: For each basis state in the support of |Ïˆ&gt;, what is P|state&gt;? 
For state |0000&gt;: 
P|0000&gt; = (Ïƒ|0&gt;_0) âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|0&gt;_3). 
Ïƒ|0&gt;: 
If Ïƒ = I, then |0&gt;.
If Ïƒ = X, then |1&gt;.
If Ïƒ = Y, then i? Actually Y|0&gt; = i|1&gt;? But careful: Pauli Y is usually defined as iÏƒ_y, so Y = [[0, -i],[i, 0]]? Actually, there are conventions. But Pauli matrices are Hermitian. Typically, Pauli Y is defined as: Y = (0 -i; i 0). So then Y|0&gt; = i|1&gt;. But then the phase matters. But when we compute &lt;Ïˆ| P |Ïˆ&gt;, we are taking expectation value. That will be a complex number. But then we square it to get fidelity contribution? Actually, careful: The fidelity is &lt;Ïˆ| Ï |Ïˆ&gt;. And Ï is a mixture of states that are P|Ïˆ&gt; with some probabilities. But then &lt;Ïˆ| (P|Ïˆ&gt;&lt;Ïˆ|P^\dagger) |Ïˆ&gt; = |&lt;Ïˆ|P|Ïˆ&gt;|^2. So we need the magnitude squared. So we want |&lt;Ïˆ|P|Ïˆ&gt;|^2. So we can compute the phase factors. But maybe we can determine which Paulis leave |Ïˆ&gt; invariant (up to a phase) and which do not. Because if P|Ïˆ&gt; is orthogonal to |Ïˆ&gt;, then &lt;Ïˆ|P|Ïˆ&gt; = 0. And if P|Ïˆ&gt; is proportional to |Ïˆ&gt;, then |&lt;Ïˆ|P|Ïˆ&gt;|^2 = 1.
So we want to know: For a given Pauli P on {0,3} (non-identity), does it stabilize |Ïˆ&gt;? That is, is |Ïˆ&gt; an eigenvector of P? 
Similarly for Paulis on {1,2}.</p>
<p>Let&rsquo;s check for Paulis on {0,3}:
P = Ïƒ_0 âŠ— I_1 âŠ— I_2 âŠ— Ï„_3.
We want to see if P|Ïˆ&gt; = Î»|Ïˆ&gt; for some Î».
|Ïˆ&gt; = (|0000&gt; + |0110&gt; + |1001&gt; + |1111&gt;)/2.
Apply P:
P|0000&gt; = (Ïƒ|0&gt;)_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|0&gt;)_3.
P|0110&gt; = (Ïƒ|0&gt;)_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|0&gt;)_3? Actually careful: |0110&gt; means: qubit0=0, qubit1=1, qubit2=1, qubit3=0.
So P|0110&gt; = (Ïƒ|0&gt;)_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|0&gt;)_3.
P|1001&gt; = (Ïƒ|1&gt;)_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|1&gt;)_3.
P|1111&gt; = (Ïƒ|1&gt;)_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|1&gt;)_3.
For P to map |Ïˆ&gt; to a scalar multiple of itself, the images of these basis states must be exactly the four basis states that appear in |Ïˆ&gt; (which are: |0000&gt;, |0110&gt;, |1001&gt;, |1111&gt;). So we need that:
For each basis state, P maps it to one of these four, and the phases must be consistent.
Let&rsquo;s consider different cases:</p>
<p>Case: Ïƒ = I, Ï„ is non-identity? But then P is on {0,3} but if Ïƒ=I and Ï„ is non-identity, then that is a valid error? Yes, because it&rsquo;s non-identity on the pair? Actually, careful: The error set on {0,3} is all Paulis on qubits 0 and 3 that are not IâŠ—I. So if Ïƒ=I and Ï„ is X, Y, or Z, that is included.
So subcase: Ïƒ = I.
Then P = I_0 âŠ— I_1 âŠ— I_2 âŠ— Ï„_3.
Then:
P|0000&gt; = |0&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|0&gt;)_3.
P|0110&gt; = |0&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|0&gt;)_3.
P|1001&gt; = |1&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|1&gt;)_3.
P|1111&gt; = |1&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|1&gt;)_3.
For these to be among {|0000&gt;, |0110&gt;, |1001&gt;, |1111&gt;}, we need that Ï„|0&gt; is either |0&gt; or |1&gt;? Actually, if Ï„|0&gt; = |0&gt; then that&rsquo;s fine. If Ï„|0&gt; = |1&gt; then that would give states: |0001&gt;, |0111&gt;, which are not in our set. So we require that Ï„|0&gt; is proportional to |0&gt;. That means that |0&gt; is an eigenvector of Ï„. For Pauli operators: 
I: but Ï„ is not I because we are in non-identity? Actually, here Ïƒ=I, so Ï„ must be non-identity. So for Ï„ = X: X|0&gt; = |1&gt;, so that gives states like |0001&gt; etc. So then the images would be: 
P|0000&gt; = |0001&gt; (if Ï„=X, then X|0&gt;=|1&gt;)
P|0110&gt; = |0111&gt;
P|1001&gt; = |1000&gt;? Because Ï„|1&gt; = X|1&gt; = |0&gt;, so |1001&gt; -&gt; |1000&gt;
P|1111&gt; = |1110&gt;
None of these are in the support of |Ïˆ&gt;. So then &lt;Ïˆ|P|Ïˆ&gt; would be 0. So for Ïƒ=I and Ï„ non-identity, we get |&lt;Ïˆ|P|Ïˆ&gt;|^2 = 0.
What about Ï„ = Y? Y|0&gt; = i|1&gt;, so similar: gives states like |0001&gt; etc. So again 0.
What about Ï„ = Z? Z|0&gt; = |0&gt;, and Z|1&gt; = -|1&gt;. So then:
P|0000&gt; = |0000&gt;
P|0110&gt; = |0110&gt;
P|1001&gt; = |1001&gt; but with a phase? Actually, careful: Z|1&gt; = -|1&gt;, so:
P|1001&gt; = |1&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Z|1&gt;)_3 = |1001&gt; * (-1) because qubit3 becomes -|1&gt;.
P|1111&gt; = |1111&gt; * (-1) because qubit3: Z|1&gt; = -|1&gt;.
So then P|Ïˆ&gt; = (1/2)[ |0000&gt; + |0110&gt; + (-1)|1001&gt; + (-1)|1111&gt; ] = (1/2)[ (|0000&gt;+|0110&gt;) - (|1001&gt;+|1111&gt;) ].
That is not a scalar multiple of |Ïˆ&gt; because |Ïˆ&gt; = (|0000&gt;+|0110&gt;+|1001&gt;+|1111&gt;)/2. So then &lt;Ïˆ|P|Ïˆ&gt; = (1/4)[1+1 + (-1)+(-1)] = 0. So actually, for Ïƒ=I, Ï„=Z, we get &lt;Ïˆ|P|Ïˆ&gt; = 0. But wait, check: 
&lt;Ïˆ|P|Ïˆ&gt; = (1/4)[&lt;0000|P|0000&gt; + &lt;0110|P|0110&gt; + &lt;1001|P|1001&gt; + &lt;1111|P|1111&gt;] because cross terms? Actually, careful: Since P is diagonal in the computational basis? But here P is not diagonal because it acts on qubit3. But the states are computational basis states. Actually, because P maps each computational basis state to another computational basis state (up to phase), the matrix elements <i|P|j> are zero if iâ‰ j. So indeed, &lt;Ïˆ|P|Ïˆ&gt; = (1/4)[&lt;0000|P|0000&gt; + &lt;0110|P|0110&gt; + &lt;1001|P|1001&gt; + &lt;1111|P|1111&gt;]. And for Ïƒ=I, Ï„=Z, we computed: 
&lt;0000|P|0000&gt; = 1 (since P|0000&gt;=|0000&gt;)
&lt;0110|P|0110&gt; = 1
&lt;1001|P|1001&gt; = -1
&lt;1111|P|1111&gt; = -1
So sum = 0. So indeed, |&lt;Ïˆ|P|Ïˆ&gt;|^2 = 0.
So for Paulis on {0,3} with Ïƒ=I, all non-identity Ï„ give 0.</p>
<p>Now consider Ïƒ non-identity. Let&rsquo;s try Ïƒ = X.
So P = X_0 âŠ— I_1 âŠ— I_2 âŠ— Ï„_3.
Then:
P|0000&gt; = (X|0&gt;)_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|0&gt;)_3 = |1&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|0&gt;)_3. For this to be one of our basis states, we need Ï„|0&gt; to be |0&gt; or |1&gt;? Actually, our basis states have qubit0 either 0 or 1. Here qubit0 becomes 1. So we want the resulting state to be either |1001&gt; or |1111&gt;? Actually, our basis states: They are: |0000&gt;, |0110&gt;, |1001&gt;, |1111&gt;. So if qubit0=1, then the state must be either |1001&gt; or |1111&gt;. That means that qubit1 and qubit2 should be 0 and 0 for |1001&gt; or 1 and 1 for |1111&gt;. But here from |0000&gt;, qubit1 and qubit2 are 0,0. So we need the result to be |1001&gt;. That requires that Ï„|0&gt; gives |1&gt;? Because then qubit3 becomes 1. But wait: |1001&gt; has qubit3=1. So we need Ï„|0&gt; = |1&gt; (up to phase). But if Ï„|0&gt; = |1&gt;, then check next:
P|0110&gt; = (X|0&gt;)_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|0&gt;)_3 = |1&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|0&gt;)_3. For this to be in our set, if qubit0=1, then we need qubit1,2 to be 1,1 so that gives |1111&gt;. That requires Ï„|0&gt; gives |1&gt; as well? But |1111&gt; has qubit3=1. So that works.
Next: P|1001&gt; = (X|1&gt;)_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|1&gt;)_3 = |0&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|1&gt;)_3. For this to be in our set, if qubit0=0, then we need qubit1,2 to be 0,0 so that gives |0000&gt;. That requires Ï„|1&gt; gives |0&gt;? Because |0000&gt; has qubit3=0.
Next: P|1111&gt; = (X|1&gt;)_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|1&gt;)_3 = |0&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|1&gt;)_3. That should become |0110&gt; which has qubit3=0. So we need Ï„|1&gt; gives |0&gt;.
So if we choose Ï„ such that Ï„|0&gt; = |1&gt; and Ï„|1&gt; = |0&gt;, then that is exactly the Pauli X on qubit3. So if Ïƒ = X and Ï„ = X, then:
P = X_0 âŠ— I_1 âŠ— I_2 âŠ— X_3.
Then check phases: 
X|0&gt; = |1&gt; (no phase, real)
X|1&gt; = |0&gt; (no phase)
So then:
P|0000&gt; = |1001&gt;
P|0110&gt; = |1111&gt;
P|1001&gt; = |0000&gt;
P|1111&gt; = |0110&gt;
So then P|Ïˆ&gt; = (1/2)[ |1001&gt; + |1111&gt; + |0000&gt; + |0110&gt; ] = |Ïˆ&gt;. So &lt;Ïˆ|P|Ïˆ&gt; = 1. So for P = X_0 X_3, we get |&lt;Ïˆ|P|Ïˆ&gt;|^2 = 1.
What if Ïƒ = X and Ï„ = Y? Then:
Ï„|0&gt; = Y|0&gt; = i|1&gt;
Ï„|1&gt; = Y|1&gt; = -i|0&gt; (since Y = [[0,-i],[i,0]] so Y|1&gt; = -i|0&gt;)
Then:
P|0000&gt; = |1&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (i|1&gt;)_3 = i |1001&gt;
P|0110&gt; = |1&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (i|1&gt;)_3 = i |1111&gt;
P|1001&gt; = |0&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (-i|0&gt;)_3 = -i |0000&gt;
P|1111&gt; = |0&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (-i|0&gt;)_3 = -i |0110&gt;
So then P|Ïˆ&gt; = (1/2)[ i(|1001&gt;+|1111&gt;) + (-i)(|0000&gt;+|0110&gt;) ] = -i (|0000&gt;+|0110&gt;) + i (|1001&gt;+|1111&gt;) all divided by 2? Actually careful: 
= (1/2)[ -i|0000&gt; - i|0110&gt; + i|1001&gt; + i|1111&gt; ] = (i/2)[ -|0000&gt;-|0110&gt;+|1001&gt;+|1111&gt; ]. That is not a scalar multiple of |Ïˆ&gt; because |Ïˆ&gt; = (|0000&gt;+|0110&gt;+|1001&gt;+|1111&gt;)/2. So then &lt;Ïˆ|P|Ïˆ&gt; = (1/4)[ -i - i + i + i] = 0. So for Ïƒ=X, Ï„=Y, we get 0.
What if Ïƒ = X and Ï„ = Z? Then:
Ï„|0&gt; = Z|0&gt; = |0&gt;
Ï„|1&gt; = Z|1&gt; = -|1&gt;
Then:
P|0000&gt; = |1&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (|0&gt;)_3 = |1000&gt; but that is not in our set because qubit1,2 are 0,0 but qubit3=0 gives |1000&gt; but our set has |1001&gt; for qubit0=1? Actually, wait: Our set: when qubit0=1, the only states are |1001&gt; and |1111&gt;. So |1000&gt; is not in the support. So then automatically, the image of |0000&gt; is not in the support, so &lt;Ïˆ|P|Ïˆ&gt; will be 0. So for Ïƒ=X, Ï„=Z, we get 0.
So from the pattern: For Paulis on {0,3}, it seems that the only one that might give nonzero overlap is if the Pauli is exactly X_0 X_3? But wait, what about Ïƒ = Y? Let&rsquo;s check Ïƒ = Y.
P = Y_0 âŠ— I_1 âŠ— I_2 âŠ— Ï„_3.
Then:
P|0000&gt; = (Y|0&gt;)_0 âŠ— &hellip; = (i|1&gt;)_0 âŠ— &hellip; so that gives i|1&gt;_0. For this to be in our set, we need the result to be either |1001&gt; or |1111&gt;. For |0000&gt;, qubit1,2 are 0,0 so we need result to be |1001&gt;. That requires Ï„|0&gt; should give |1&gt;? But then phase: Y|0&gt; = i|1&gt;, so then P|0000&gt; = i |1001&gt;. 
Next: P|0110&gt; = Y|0&gt; (but careful: |0110&gt; has qubit0=0) so Y|0&gt; = i|1&gt; so gives i|1&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|0&gt;)_3. For that to be |1111&gt;, we need Ï„|0&gt; gives |1&gt; so then becomes i|1111&gt;.
Next: P|1001&gt; = Y|1&gt; = -i|0&gt; so gives -i|0&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Ï„|1&gt;)_3. For that to be |0000&gt;, we need Ï„|1&gt; gives |0&gt; so becomes -i|0000&gt;.
Next: P|1111&gt; = Y|1&gt; = -i|0&gt; so gives -i|0&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Ï„|1&gt;)_3. For that to be |0110&gt;, we need Ï„|1&gt; gives |0&gt; so becomes -i|0110&gt;.
So then if we choose Ï„ such that Ï„|0&gt; = |1&gt; and Ï„|1&gt; = |0&gt;, that is Ï„ = X. But then we get phases: 
P|0000&gt; = i|1001&gt;
P|0110&gt; = i|1111&gt;
P|1001&gt; = -i|0000&gt;
P|1111&gt; = -i|0110&gt;
So then P|Ïˆ&gt; = (1/2)[ i(|1001&gt;+|1111&gt;) + (-i)(|0000&gt;+|0110&gt;) ] = similar to before, which is not a scalar multiple of |Ïˆ&gt; because the phases on the two groups are opposite. Actually, wait: Could it be that P|Ïˆ&gt; = -i (|0000&gt;+|0110&gt;) + i (|1001&gt;+|1111&gt;) divided by 2? That is actually i times ( - (|0000&gt;+|0110&gt;) + (|1001&gt;+|1111&gt;) )/2. That is not proportional to (|0000&gt;+|0110&gt;+|1001&gt;+|1111&gt;) unless the coefficients are all the same. So then &lt;Ïˆ|P|Ïˆ&gt; = 0. So for Ïƒ=Y, even if Ï„=X, we get 0.
What if Ïƒ=Y and Ï„=Y? 
Then:
P|0000&gt; = Y|0&gt; âŠ— &hellip; âŠ— Y|0&gt; = (i|1&gt;) âŠ— &hellip; âŠ— (i|0&gt;?) Actually, careful: Y|0&gt; = i|1&gt;, Y|0&gt; = i|0&gt;? Wait, careful: On qubit3, Ï„=Y, so Y|0&gt; = i|1&gt;? Actually, Y|0&gt; = i|1&gt;? Check: Y = [[0, -i],[i, 0]]. So Y|0&gt; = i|1&gt;. And Y|1&gt; = -i|0&gt;. So:
P|0000&gt; = (Y|0&gt;)_0 âŠ— (Y|0&gt;)_3? Actually, careful: P = Y_0 âŠ— I_1 âŠ— I_2 âŠ— Y_3.
So:
P|0000&gt; = (Y|0&gt;)_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Y|0&gt;)_3 = (i|1&gt;)_0 âŠ— &hellip; âŠ— (i|1&gt;)_3 = i<em>i |1&gt;_0|0&gt;_1|0&gt;_2|1&gt;_3 = -|1001&gt;.
P|0110&gt; = (Y|0&gt;)_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Y|0&gt;)_3 = (i|1&gt;)_0 âŠ— &hellip; âŠ— (i|1&gt;)_3 = -|1111&gt;.
P|1001&gt; = (Y|1&gt;)_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— (Y|1&gt;)_3 = (-i|0&gt;)_0 âŠ— &hellip; âŠ— (-i|0&gt;)_3 = (-i)</em>(-i) |0&gt;_0|0&gt;_1|0&gt;_2|0&gt;_3 = -|0000&gt;.
P|1111&gt; = (Y|1&gt;)_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— (Y|1&gt;)_3 = (-i|0&gt;)_0 âŠ— &hellip; âŠ— (-i|0&gt;)_3 = (-i)<em>(-i) |0&gt;_0|1&gt;_1|1&gt;_2|0&gt;_3 = -|0110&gt;.
So then P|Ïˆ&gt; = (1/2)[ -|1001&gt; - |1111&gt; - |0000&gt; - |0110&gt; ] = -|Ïˆ&gt;. So then &lt;Ïˆ|P|Ïˆ&gt; = -1, so |&lt;Ïˆ|P|Ïˆ&gt;|^2 = 1. So for P = Y_0 Y_3, we get fidelity contribution 1.
What if Ïƒ=Y and Ï„=Z? 
Then:
P|0000&gt; = (Y|0&gt;)_0 âŠ— (Z|0&gt;)_3 = (i|1&gt;)_0 âŠ— (|0&gt;)_3 = i|1000&gt; -&gt; not in support.
So that gives 0.
So for Paulis on {0,3}, it appears that the only ones that yield nonzero overlap are those that are either X_0 X_3 or Y_0 Y_3? What about Ïƒ=Z? 
Consider Ïƒ=Z, Ï„ something?
P = Z_0 âŠ— I_1 âŠ— I_2 âŠ— Ï„_3.
Then:
P|0000&gt; = (Z|0&gt;)_0 âŠ— (Ï„|0&gt;)_3 = |0&gt;_0 âŠ— (Ï„|0&gt;)_3. For this to be in support, since qubit0=0, we need the state to be either |0000&gt; or |0110&gt;. So we need Ï„|0&gt; to give |0&gt;? That means Ï„ must have |0&gt; as eigenvector. For non-identity, that is only Z? But then:
If Ï„=Z, then:
P|0000&gt; = |0000&gt; (since Z|0&gt;=|0&gt;)
P|0110&gt; = |0110&gt; (Z|0&gt;=|0&gt;)
P|1001&gt; = (Z|1&gt;)_0 âŠ— (Z|1&gt;)_3 = (-|1&gt;)_0 âŠ— (-|1&gt;)_3 = |1001&gt; (because (-1)</em>(-1)=1)
P|1111&gt; = (Z|1&gt;)_0 âŠ— (Z|1&gt;)_3 = (-|1&gt;)_0 âŠ— (-|1&gt;)_3 = |1111&gt;
So then P|Ïˆ&gt; = |Ïˆ&gt;. So for P = Z_0 Z_3, we get &lt;Ïˆ|P|Ïˆ&gt; = 1.
What if Ï„ is something else? If Ï„ = X, then:
P|0000&gt; = |0&gt;_0 âŠ— (X|0&gt;)_3 = |0001&gt; -&gt; not in support.
So indeed, for Ïƒ=Z, the only possibility is Ï„=Z.
What about Ïƒ=Z, Ï„=Y? Then:
P|0000&gt; = |0&gt;_0 âŠ— (Y|0&gt;)_3 = |0&gt;_0 âŠ— (i|1&gt;)_3 = i|0001&gt; -&gt; not in support.
So for Paulis on {0,3}, the ones that give nonzero overlap are: 
X_0 X_3, Y_0 Y_3, Z_0 Z_3. Also what about? Check: Could there be something like X_0 I_3? That we already did: Ïƒ=X, Ï„=I is not allowed because that is identity on the pair? Actually, wait: The error set on {0,3} is all Paulis that are not IâŠ—I. So XâŠ—I is allowed. But we already considered Ïƒ=X, Ï„=I? That would be: P = X_0 I_3. Then:
P|0000&gt; = |1000&gt; -&gt; not in support.
So indeed, the only ones that give nonzero are when the Pauli on qubit0 and qubit3 are the same type? Actually, we found: 
X_0 X_3 gives 1,
Y_0 Y_3 gives 1,
Z_0 Z_3 gives 1.
What about X_0 Y_3? That gives 0 as we computed.
So there are 3 Paulis on {0,3} that yield |&lt;Ïˆ|P|Ïˆ&gt;|^2 = 1. And the total number of non-identity Paulis on {0,3} is 15. So for the error channel on {0,3}, out of the 15 errors, 3 will have overlap 1, and the remaining 12 will have overlap 0.</p>
<p>But wait: Check: What about I_0 X_3? That we already did: gives 0.
So summary for errors on {0,3}: 
Number of errors that commute with |Ïˆ&gt; (i.e., leave it invariant up to phase) = 3. So their contribution to fidelity: each gives |&lt;Ïˆ|P|Ïˆ&gt;|^2 = 1.</p>
<p>Now, similarly, consider errors on {1,2}. 
P on {1,2} is of the form: I_0 âŠ— A_1 âŠ— B_2 âŠ— I_3, where (A,B) is not (I,I).
We want to compute &lt;Ïˆ| P |Ïˆ&gt; for such P.
|Ïˆ&gt; = (|0000&gt; + |0110&gt; + |1001&gt; + |1111&gt;)/2.
Let&rsquo;s denote P = I_0 âŠ— A_1 âŠ— B_2 âŠ— I_3.
Then:
P|0000&gt; = |0&gt;_0 âŠ— (A|0&gt;)_1 âŠ— (B|0&gt;)_2 âŠ— |0&gt;_3.
For this to be in the support, since qubit0=0 and qubit3=0, we need the state to be either |0000&gt; or |0110&gt;. So if A|0&gt; and B|0&gt; are such that the resulting state is |00&gt; on qubits 1,2 or |11&gt;? Actually, careful: The support states: 
|0000&gt;: qubits1,2 = 00.
|0110&gt;: qubits1,2 = 11.
So for |0000&gt;, we need A|0&gt; and B|0&gt; to be either both |0&gt; or both |1&gt;? But if they are both |1&gt;, then that gives |0110&gt;? Actually, |0000&gt; becomes: if A|0&gt;=|1&gt; and B|0&gt;=|1&gt;, then we get |0&gt;_0, |1&gt;_1, |1&gt;_2, |0&gt;_3 = |0110&gt;. So that is in the support. But then the phase: 
If A|0&gt; = |0&gt; and B|0&gt; = |0&gt;, then P|0000&gt; = |0000&gt;.
If A|0&gt; = |1&gt; and B|0&gt; = |1&gt;, then P|0000&gt; = |0110&gt;.
But careful: They are different basis states. For the expectation &lt;Ïˆ|P|Ïˆ&gt;, we need to compute the matrix elements. Actually, since P is a Pauli, it will map each computational basis state to another computational basis state. So we need to check for each basis state in the support, what is P|state&gt; and then see if P|Ïˆ&gt; is proportional to |Ïˆ&gt;.
Let&rsquo;s do it systematically:
We want to know for which Paulis on {1,2} does P|Ïˆ&gt; = Î»|Ïˆ&gt;.
Write P = A_1 âŠ— B_2 (acting on qubits 1 and 2, with identity on 0 and 3).
Then:
P|0000&gt; = |0&gt;_0 âŠ— (A|0&gt;)_1 âŠ— (B|0&gt;)_2 âŠ— |0&gt;_3.
P|0110&gt; = |0&gt;_0 âŠ— (A|1&gt;)_1 âŠ— (B|1&gt;)_2 âŠ— |0&gt;_3.
P|1001&gt; = |1&gt;_0 âŠ— (A|0&gt;)_1 âŠ— (B|0&gt;)_2 âŠ— |1&gt;_3.
P|1111&gt; = |1&gt;_0 âŠ— (A|1&gt;)_1 âŠ— (B|1&gt;)_2 âŠ— |1&gt;_3.
For P|Ïˆ&gt; to be proportional to |Ïˆ&gt;, the images of these four states must be exactly the four states in the support (possibly with phases). Notice that the support states have the property that qubits 0 and 3 are the same: either both 0 or both 1. And qubits 1 and 2 are either both 0 or both 1. So we need that A|0&gt; and B|0&gt; are either both |0&gt; or both |1&gt;? Actually, if they are both |0&gt;, then P|0000&gt; = |0000&gt;. If they are both |1&gt;, then P|0000&gt; = |0110&gt;. Similarly, for P|0110&gt;: A|1&gt; and B|1&gt; should be either both |0&gt; or both |1&gt;. But careful: For consistency, if P|0000&gt; becomes |0110&gt;, then we need that P|0110&gt; becomes |0000&gt;? Because then overall, P would swap the two terms? But then P|Ïˆ&gt; would be (|0110&gt;+|0000&gt;+&hellip;)? That could still be |Ïˆ&gt; if the phases work out. Let&rsquo;s check: Suppose A and B are such that A|0&gt; = |1&gt;, B|0&gt; = |1&gt; and A|1&gt; = |0&gt;, B|1&gt; = |0&gt;. That is exactly the Pauli X on both qubits? Actually, if A = X and B = X, then:
P|0000&gt; = |0110&gt;
P|0110&gt; = |0000&gt;
P|1001&gt; = |1111&gt;? Check: P|1001&gt; = |1&gt;_0 âŠ— (X|0&gt;)_1 âŠ— (X|0&gt;)_2 âŠ— |1&gt;_3 = |1&gt;_0 âŠ— |1&gt;_1 âŠ— |1&gt;_2 âŠ— |1&gt;_3 = |1111&gt;
P|1111&gt; = |1&gt;_0 âŠ— (X|1&gt;)_1 âŠ— (X|1&gt;)_2 âŠ— |1&gt;_3 = |1&gt;_0 âŠ— |0&gt;_1 âŠ— |0&gt;_2 âŠ— |1&gt;_3 = |1001&gt;
So then P|Ïˆ&gt; = (1/2)[ |0110&gt; + |0000&gt; + |1111&gt; + |1001&gt; ] = |Ïˆ&gt;. So that works. So for P = X_1 X_2, we get &lt;Ïˆ|P|Ïˆ&gt; = 1.
What about if A and B are such that A|0&gt; = |0&gt;, B|0&gt; = |0&gt; and A|1&gt; = |1&gt;, B|1&gt; = |1&gt;? That is identity, but that&rsquo;s not allowed because we are considering non-identity. So next: What if A = Z and B = Z? Then:
P|0000&gt; = Z|0&gt;=|0&gt;, so |0000&gt;
P|0110&gt; = Z|1&gt; = -|1&gt;, so P|0110&gt; = -|0110&gt;? Actually careful: P|0110&gt; = |0&gt;_0 âŠ— (Z|1&gt;)_1 âŠ— (Z|1&gt;)_2 âŠ— |0&gt;_3 = |0&gt;_0 âŠ— (-|1&gt;)_1 âŠ— (-|1&gt;)_2 âŠ— |0&gt;_3 = (-1)<em>(-1)|0110&gt; = |0110&gt;.
P|1001&gt; = |1&gt;_0 âŠ— (Z|0&gt;)_1 âŠ— (Z|0&gt;)_2 âŠ— |1&gt;_3 = |1001&gt;
P|1111&gt; = |1&gt;_0 âŠ— (Z|1&gt;)_1 âŠ— (Z|1&gt;)_2 âŠ— |1&gt;_3 = (-1)</em>(-1)|1111&gt; = |1111&gt;
So actually, Z_1 Z_2 gives P|Ïˆ&gt; = |Ïˆ&gt;. So that works. So P = Z_1 Z_2 gives overlap 1.
What about A = Y and B = Y? 
Then:
P|0000&gt; = Y|0&gt; = i|1&gt;, so becomes i|1&gt; on qubit1 and similarly on qubit2: i|1&gt; so product i<em>i = -1, so P|0000&gt; = -|0110&gt;? Actually careful: P|0000&gt; = |0&gt;_0 âŠ— (Y|0&gt;)_1 âŠ— (Y|0&gt;)_2 âŠ— |0&gt;_3 = |0&gt;_0 âŠ— (i|1&gt;)_1 âŠ— (i|1&gt;)_2 âŠ— |0&gt;_3 = (i</em>i) |0110&gt; = -|0110&gt;.
P|0110&gt; = |0&gt;_0 âŠ— (Y|1&gt;)_1 âŠ— (Y|1&gt;)_2 âŠ— |0&gt;_3 = |0&gt;_0 âŠ— (-i|0&gt;)_1 âŠ— (-i|0&gt;)_2 âŠ— |0&gt;_3 = (-i)<em>(-i) |0000&gt; = -|0000&gt;.
P|1001&gt; = |1&gt;_0 âŠ— (Y|0&gt;)_1 âŠ— (Y|0&gt;)_2 âŠ— |1&gt;_3 = |1&gt;_0 âŠ— (i|1&gt;)_1 âŠ— (i|1&gt;)_2 âŠ— |1&gt;_3 = (i</em>i) |1111&gt; = -|1111&gt;.
P|1111&gt; = |1&gt;_0 âŠ— (Y|1&gt;)_1 âŠ— (Y|1&gt;)_2 âŠ— |1&gt;_3 = |1&gt;_0 âŠ— (-i|0&gt;)_1 âŠ— (-i|0&gt;)_2 âŠ— |1&gt;_3 = (-i)*(-i) |1001&gt; = -|1001&gt;.
So then P|Ïˆ&gt; = (1/2)[ -|0110&gt; - |0000&gt; - |1111&gt; - |1001&gt; ] = -|Ïˆ&gt;. So that gives &lt;Ïˆ|P|Ïˆ&gt; = -1, so squared is 1.
So again, we get that for Paulis on {1,2}, the ones that yield nonzero are: X_1 X_2, Y_1 Y_2, Z_1 Z_2. But wait: What about Paulis like X_1 I_2? 
Check: P = X_1 I_2.
Then:
P|0000&gt; = |0&gt;_0 âŠ— (X|0&gt;)_1 âŠ— |0&gt;_2 âŠ— |0&gt;_3 = |0100&gt; which is not in support.
So indeed, the pattern is: For errors on a pair of qubits that are either {0,3} or {1,2}, the only errors that do not destroy the state (i.e., yield overlap 1) are those that are the same Pauli on both qubits? But careful: For {0,3}, we found: X_0 X_3, Y_0 Y_3, Z_0 Z_3. For {1,2}, we found: X_1 X_2, Y_1 Y_2, Z_1 Z_2.
But wait: Could there be something like X_0 Z_3? That we already checked: gives 0.
So indeed, for each pair, out of 15 non-identity Paulis, exactly 3 give overlap 1, and the other 12 give overlap 0.</p>
<p>Now, what about errors that are products from both channels? That is, errors on both {0,3} and {1,2} simultaneously. Then the error is of the form: P = (Ïƒ_0 âŠ— Ï„_3) * (Î±_1 âŠ— Î²_2) with Ïƒ,Ï„ not both I? Actually, careful: They come from independent channels. So the error is: E on {0,3} and F on {1,2}. And we want |&lt;Ïˆ| (E F) |Ïˆ&gt;|^2. Since E and F act on disjoint sets, and we already determined that for E to give nonzero, E must be one of the 3 types: X_0 X_3, Y_0 Y_3, Z_0 Z_3. And for F to give nonzero, F must be one of: X_1 X_2, Y_1 Y_2, Z_1 Z_2. But then what is the combined effect? Let&rsquo;s check: Suppose E = X_0 X_3 and F = X_1 X_2. Then overall, P = X_0 X_1 X_2 X_3. Then 
P|Ïˆ&gt; = ? 
|Ïˆ&gt; = (|0000&gt;+|0110&gt;+|1001&gt;+|1111&gt;)/2.
Apply X on all qubits: That sends |0000&gt; -&gt; |1111&gt;, |0110&gt; -&gt; |1001&gt;, |1001&gt; -&gt; |0110&gt;, |1111&gt; -&gt; |0000&gt;. So indeed, P|Ïˆ&gt; = |Ïˆ&gt;. So overlap = 1.
What if E = X_0 X_3 and F = Y_1 Y_2? Then P = X_0 Y_1 Y_2 X_3. 
Compute:
P|0000&gt; = X_0|0&gt; = |1&gt;_0, Y_1|0&gt; = i|1&gt;_1, Y_2|0&gt; = i|1&gt;_2, X_3|0&gt; = |1&gt;_3, so product phase: i<em>i = -1, so P|0000&gt; = -|1111&gt;.
P|0110&gt; = X_0|0&gt; = |1&gt;_0, Y_1|1&gt; = -i|0&gt;_1, Y_2|1&gt; = -i|0&gt;_2, X_3|0&gt; = |1&gt;_3, product phase: (-i)</em>(-i)= -1, so P|0110&gt; = -|1001&gt;? Actually careful: |0110&gt; becomes: qubit0: becomes 1, qubit1: from 1 to 0, qubit2: from 1 to 0, qubit3: from 0 to 1, so that gives |1001&gt; indeed. So P|0110&gt; = -|1001&gt;.
P|1001&gt; = X_0|1&gt; = |0&gt;_0, Y_1|0&gt; = i|1&gt;_1, Y_2|0&gt; = i|1&gt;_2, X_3|1&gt; = |0&gt;_3, product phase: i<em>i = -1, so P|1001&gt; = -|0110&gt;.
P|1111&gt; = X_0|1&gt; = |0&gt;_0, Y_1|1&gt; = -i|0&gt;_1, Y_2|1&gt; = -i|0&gt;_2, X_3|1&gt; = |0&gt;_3, product phase: (-i)</em>(-i)= -1, so P|1111&gt; = -|0000&gt;.
So then P|Ïˆ&gt; = (1/2)[ -|1111&gt; - |1001&gt; - |0110&gt; - |0000&gt; ] = -|Ïˆ&gt;. So overlap = -1, so squared is 1.
So it seems that if both E and F are among the ones that individually give overlap 1, then their product also gives overlap 1? But wait, check: What if E = X_0 X_3 and F = Z_1 Z_2? Then P = X_0 Z_1 Z_2 X_3.
Compute:
P|0000&gt; = X_0|0&gt; = |1&gt;_0, Z_1|0&gt; = |0&gt;_1, Z_2|0&gt; = |0&gt;_2, X_3|0&gt; = |1&gt;_3, so P|0000&gt; = |1001&gt;.
P|0110&gt; = X_0|0&gt; = |1&gt;_0, Z_1|1&gt; = -|1&gt;_1, Z_2|1&gt; = -|1&gt;_2, X_3|0&gt; = |1&gt;_3, so product phase: (-1)<em>(-1)=1, so P|0110&gt; = |1111&gt;.
P|1001&gt; = X_0|1&gt; = |0&gt;_0, Z_1|0&gt; = |0&gt;_1, Z_2|0&gt; = |0&gt;_2, X_3|1&gt; = |0&gt;_3? Actually, careful: X_3|1&gt; = |0&gt;_3, so P|1001&gt; = |0000&gt;.
P|1111&gt; = X_0|1&gt; = |0&gt;_0, Z_1|1&gt; = -|1&gt;_1, Z_2|1&gt; = -|1&gt;_2, X_3|1&gt; = |0&gt;_3, so product phase: (-1)</em>(-1)=1, so P|1111&gt; = |0110&gt;.
So then P|Ïˆ&gt; = |Ïˆ&gt;. So indeed, if E and F are both from the set of 3 that give overlap 1, then the combined error E F also gives overlap 1. But wait: Is that always true? Let&rsquo;s check a potential counter: E = Y_0 Y_3 and F = Y_1 Y_2 we already did: that gave -|Ïˆ&gt; so squared is 1.
So it appears that if an error on {0,3} is one of the 3 (which are: X_0X_3, Y_0Y_3, Z_0Z_3) and an error on {1,2} is one of the 3 (X_1X_2, Y_1Y_2, Z_1Z_2), then the combined error is a Pauli that acts as the same Pauli on all four qubits? Actually, note: The product of, say, X_0X_3 and X_1X_2 gives X on all qubits. And the product of X_0X_3 and Y_1Y_2 gives X_0 Y_1 Y_2 X_3. That is not necessarily a tensor product of the same Pauli on each qubit? But we computed it and it gave -|Ïˆ&gt;. So indeed, it seems that if both errors are from these sets, then the overall error is actually a stabilizer of |Ïˆ&gt;? But wait, is that true? Check: The stabilizers of the code are XXXX and ZZZZ. Our state |Ïˆ&gt; is in the code space. But is it stabilized by, say, X_0 Y_1 Y_2 X_3? That operator, if we multiply it by XXXX, we get? XXXX * (X_0 Y_1 Y_2 X_3) = (X_0X_0) (X_1Y_1) (X_2Y_2) (X_3X_3) = I * (iZ_1) * (iZ_2) * I = - Z_1 Z_2. That is not necessarily identity. So it&rsquo;s not a stabilizer. But it might still leave |Ïˆ&gt; invariant? Actually, we computed explicitly that X_0 Y_1 Y_2 X_3 |Ïˆ&gt; = -|Ïˆ&gt;. So it is an eigenvector with eigenvalue -1. So it&rsquo;s not a stabilizer (which would require eigenvalue +1), but it is still a logical operator? Actually, logical operators on the code space can have eigenvalues Â±1. So indeed, these errors are actually logical operators. And since our state is a specific logical state (the GHZ state), it might be an eigenvector of some logical operators. So it seems that if an error on {0,3} is from the set of 3 and an error on {1,2} is from the set of 3, then the combined error gives overlap 1. But wait: What if one error is from the set and the other is not? Then the overall error will have zero overlap because it will map some basis state outside the support. So indeed, for the combined errors, the only ones that yield nonzero fidelity are those where both the error on {0,3} is one of the 3 and the error on {1,2} is one of the 3. That gives 3*3 = 9 combinations out of 225. But careful: There is also the possibility that both errors are identity? But that&rsquo;s already counted in the no-error case. So for the double error case (both CNOTs have an error), the contribution to fidelity is: probability p^2/225 * (number of pairs that yield overlap 1) = p^2/225 * 9 = p^2/25.</p>
<p>But wait: Also consider the case where only one error occurs. For error on {0,3} only: That gives: probability: p(1-p)/15 * (number of errors that yield overlap 1) = p(1-p)/15 * 3 = p(1-p)/5.
Similarly, for error on {1,2} only: p(1-p)/15 * 3 = p(1-p)/5.
And no error: (1-p)^2.</p>
<p>So then the total fidelity F = (1-p)^2 + 2 * [p(1-p)/5] + [p^2/25] = (1-p)^2 + (2p(1-p))/5 + p^2/25.
Let&rsquo;s simplify: (1-p)^2 = 1 - 2p + p^2.
So F = 1 - 2p + p^2 + (2p/5 - 2p^2/5) + p^2/25 = 1 - 2p + p^2 + 0.4p - 0.4p^2 + 0.04p^2 = 1 - (2 - 0.4)p + (1 - 0.4 + 0.04)p^2 = 1 - 1.6p + (0.64)p^2 = 1 - (8/5)p + (16/25)p^2? Because 1.6 = 8/5, and 0.64 = 16/25. And indeed, (1 - (4/5)p)^2 = 1 - (8/5)p + (16/25)p^2. So F = (1 - 4p/5)^2.
So the physical state fidelity is F = (1 - 4p/5)^2.</p>
<p>But wait: Is that the final answer? The problem asks: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; That would be F = 1 - (8/5)p + (16/25)p^2, or equivalently (1 - 4p/5)^2.
But wait: Could there be contributions from errors that are not Pauli? But we assumed that the error channel is depolarizing on the two qubits. And we computed the average fidelity. So yes.</p>
<p>But wait: There is also the possibility that the errors might occur on the Hadamard gates? The problem statement says: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. So only CNOT gates get errors. So our analysis is correct.</p>
<p>Thus the answer for Subproblem 1 is: F = (1 - 4p/5)^2.</p>
<p>But let&rsquo;s double-check: The probability that no error occurs on either CNOT is (1-p)^2. That gives fidelity 1.
The probability that exactly one CNOT has an error: 2p(1-p). Out of these, only 3/15 = 1/5 of the errors on that CNOT will actually not disturb the state? But wait: Is it exactly 1/5? That would give fidelity contribution: 2p(1-p)<em>(1/5) = 2p(1-p)/5.
The probability that both CNOTs have errors: p^2. And then the fraction of error pairs that leave the state invariant is: (3/15)</em>(3/15) = 9/225 = 1/25. So then fidelity from that is p^2/25.
So total fidelity = (1-p)^2 + 2p(1-p)/5 + p^2/25 = 1 - 2p + p^2 + 0.4p - 0.4p^2 + 0.04p^2 = 1 - 1.6p + 0.64p^2 = (1 - 0.8p)^2 = (1 - 4p/5)^2. Yes.</p>
<p>So answer: F = 1 - \frac{8}{5}p + \frac{16}{25}p^2, or simpler: \left(1 - \frac{4p}{5}\right)^2.</p>
<p>Thus final answer for Subproblem 1: 
<strong>Final Answer:</strong> </p>
<div class="arithmatex">\[
F = \left(1 - \frac{4p}{5}\right)^2
\]</div>
<p>I&rsquo;ll put that in a box.</p>
<p>But wait: The problem might expect an expression in terms of p. So I&rsquo;ll give: 
\boxed{\left(1 - \frac{4p}{5}\right)^2}</p>
<p>I&rsquo;ll now produce the step-by-step derivation.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-understand-the-circuit-and-error-model">Step 1. Understand the Circuit and Error Model</h3>
<p>We wish to prepare the logical GHZ state  </p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the <span class="arithmatex">\([[4,2,2]]\)</span> code, using the circuit:  </p>
<div class="arithmatex">\[
(\text{CNOT}_{03}) (H_0) (\text{CNOT}_{21}) (H_2).
\]</div>
<p>Operations are applied from right to left:  </p>
<ol>
<li><span class="arithmatex">\(H_2\)</span>  </li>
<li><span class="arithmatex">\(\text{CNOT}_{21}\)</span>  </li>
<li><span class="arithmatex">\(H_0\)</span>  </li>
<li><span class="arithmatex">\(\text{CNOT}_{03}\)</span></li>
</ol>
<p>Each <span class="arithmatex">\(\text{CNOT}\)</span> gate is followed by a two-qubit depolarizing error channel acting on its target and control qubits. The error channel applies one of the 15 non-identity two-qubit Pauli operators with probability <span class="arithmatex">\(p/15\)</span>, and identity with probability <span class="arithmatex">\(1 - p\)</span>. Hadamard gates are error-free.</p>
<p>The initial state is <span class="arithmatex">\(|0000\rangle\)</span>.</p>
<hr />
<h3 id="step-2-ideal-state-preparation">Step 2. Ideal State Preparation</h3>
<p>Apply the circuit without errors:</p>
<ul>
<li><strong>Apply <span class="arithmatex">\(H_2\)</span>:</strong>  </li>
</ul>
<div class="arithmatex">\[
  H_2|0\rangle_2 = \frac{|0\rangle + |1\rangle}{\sqrt{2}} \Rightarrow |\psi_1\rangle = |0\rangle_0 |0\rangle_1 \left( \frac{|0\rangle + |1\rangle}{\sqrt{2}} \right)_2 |0\rangle_3
\]</div>
<ul>
<li><strong>Apply <span class="arithmatex">\(\text{CNOT}_{21}\)</span>:</strong><br />
  Control qubit 2, target qubit 1:  </li>
</ul>
<div class="arithmatex">\[
  |\psi_2\rangle = \frac{1}{\sqrt{2}} \left( |0\rangle_0 |00\rangle_{12} |0\rangle_3 + |0\rangle_0 |11\rangle_{12} |0\rangle_3 \right)
\]</div>
<ul>
<li><strong>Apply <span class="arithmatex">\(H_0\)</span>:</strong>  </li>
</ul>
<div class="arithmatex">\[
  H_0|0\rangle_0 = \frac{|0\rangle + |1\rangle}{\sqrt{2}} \Rightarrow |\psi_3\rangle = \frac{1}{2} \left( |0000\rangle + |0110\rangle + |1000\rangle + |1110\rangle \right)
\]</div>
<ul>
<li><strong>Apply <span class="arithmatex">\(\text{CNOT}_{03}\)</span>:</strong><br />
  Control qubit 0, target qubit 3:  </li>
</ul>
<div class="arithmatex">\[
  |\psi_{\text{ideal}}\rangle = \frac{1}{2} \left( |0000\rangle + |0110\rangle + |1001\rangle + |1111\rangle \right)
\]</div>
<p>This is the desired logical GHZ state.</p>
<hr />
<h3 id="step-3-incorporating-errors">Step 3. Incorporating Errors</h3>
<p>The actual circuit includes error channels after each <span class="arithmatex">\(\text{CNOT}\)</span>:</p>
<ul>
<li>After <span class="arithmatex">\(\text{CNOT}_{21}\)</span>: error channel on qubits <span class="arithmatex">\(\{1,2\}\)</span></li>
<li>After <span class="arithmatex">\(\text{CNOT}_{03}\)</span>: error channel on qubits <span class="arithmatex">\(\{0,3\}\)</span></li>
</ul>
<p>Since subsequent gates (<span class="arithmatex">\(H_0\)</span> and <span class="arithmatex">\(\text{CNOT}_{03}\)</span>) act on disjoint qubits, the errors commute with them. Thus, the errors can be pushed to the end of the circuit. The final state is equivalent to applying the ideal unitary <span class="arithmatex">\(U\)</span>, followed by independent error channels on qubit pairs <span class="arithmatex">\(\{0,3\}\)</span> and <span class="arithmatex">\(\{1,2\}\)</span>.</p>
<p>Each error channel applies:</p>
<ul>
<li>Identity with probability <span class="arithmatex">\(1 - p\)</span></li>
<li>One of the 15 non-identity two-qubit Pauli operators with probability <span class="arithmatex">\(p/15\)</span></li>
</ul>
<hr />
<h3 id="step-4-computing-the-fidelity">Step 4. Computing the Fidelity</h3>
<p>The fidelity is  </p>
<div class="arithmatex">\[
F = \langle \psi_{\text{ideal}} | \rho | \psi_{\text{ideal}} \rangle,
\]</div>
<p>where <span class="arithmatex">\(\rho\)</span> is the final density matrix.</p>
<p>Let <span class="arithmatex">\(P\)</span> be a Pauli error. Then  </p>
<div class="arithmatex">\[
\langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle = 
\begin{cases}
\pm1 &amp; \text{if } P|\psi_{\text{ideal}}\rangle = \pm|\psi_{\text{ideal}}\rangle \\
0 &amp; \text{otherwise}
\end{cases}
\]</div>
<p>So, <span class="arithmatex">\(| \langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle |^2 = 1\)</span> if <span class="arithmatex">\(P\)</span> preserves the state (up to a phase), and 0 otherwise.</p>
<h4 id="a-errors-on-03">(a) Errors on <span class="arithmatex">\(\{0,3\}\)</span></h4>
<p>There are 15 non-identity Pauli operators on qubits <span class="arithmatex">\(\{0,3\}\)</span>. Only the following 3 preserve the state:</p>
<ul>
<li><span class="arithmatex">\(X_0 X_3\)</span></li>
<li><span class="arithmatex">\(Y_0 Y_3\)</span></li>
<li><span class="arithmatex">\(Z_0 Z_3\)</span></li>
</ul>
<p>Each gives <span class="arithmatex">\(| \langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle |^2 = 1\)</span>. The other 12 give 0.</p>
<h4 id="b-errors-on-12">(b) Errors on <span class="arithmatex">\(\{1,2\}\)</span></h4>
<p>Similarly, only 3 operators preserve the state:</p>
<ul>
<li><span class="arithmatex">\(X_1 X_2\)</span></li>
<li><span class="arithmatex">\(Y_1 Y_2\)</span></li>
<li><span class="arithmatex">\(Z_1 Z_2\)</span></li>
</ul>
<p>Each gives <span class="arithmatex">\(| \langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle |^2 = 1\)</span>. The other 12 give 0.</p>
<h4 id="c-combined-errors">(c) Combined Errors</h4>
<p>If errors occur on both pairs, the combined operator <span class="arithmatex">\(P = P_{\{0,3\}} \otimes P_{\{1,2\}}\)</span> preserves the state only if both individual errors are among the 3 preserving ones. There are <span class="arithmatex">\(3 \times 3 = 9\)</span> such combinations, each with <span class="arithmatex">\(| \langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle |^2 = 1\)</span>.</p>
<hr />
<h3 id="step-5-summing-contributions">Step 5. Summing Contributions</h3>
<p>Let <span class="arithmatex">\(F\)</span> be the fidelity. Then:</p>
<ul>
<li>
<p><strong>No error:</strong> probability <span class="arithmatex">\((1 - p)^2\)</span>, fidelity = 1<br />
  â†’ Contribution: <span class="arithmatex">\((1 - p)^2\)</span></p>
</li>
<li>
<p><strong>Error on <span class="arithmatex">\(\{0,3\}\)</span> only:</strong> probability <span class="arithmatex">\(p(1 - p)\)</span>, fraction preserving = <span class="arithmatex">\(3/15 = 1/5\)</span><br />
  â†’ Contribution: <span class="arithmatex">\(p(1 - p) \cdot \frac{1}{5}\)</span></p>
</li>
<li>
<p><strong>Error on <span class="arithmatex">\(\{1,2\}\)</span> only:</strong> probability <span class="arithmatex">\(p(1 - p)\)</span>, fraction preserving = <span class="arithmatex">\(1/5\)</span><br />
  â†’ Contribution: <span class="arithmatex">\(p(1 - p) \cdot \frac{1}{5}\)</span></p>
</li>
<li>
<p><strong>Errors on both pairs:</strong> probability <span class="arithmatex">\(p^2\)</span>, fraction preserving = <span class="arithmatex">\(\frac{3}{15} \cdot \frac{3}{15} = \frac{1}{25}\)</span><br />
  â†’ Contribution: <span class="arithmatex">\(p^2 \cdot \frac{1}{25}\)</span></p>
</li>
</ul>
<p>Total fidelity:</p>
<div class="arithmatex">\[
\begin{aligned}
F &amp;= (1 - p)^2 + 2 \cdot \frac{p(1 - p)}{5} + \frac{p^2}{25} \\
&amp;= 1 - 2p + p^2 + \frac{2p}{5} - \frac{2p^2}{5} + \frac{p^2}{25} \\
&amp;= 1 - \left(2 - \frac{2}{5}\right)p + \left(1 - \frac{2}{5} + \frac{1}{25}\right)p^2 \\
&amp;= 1 - \frac{8}{5}p + \frac{16}{25}p^2 \\
&amp;= \left(1 - \frac{4p}{5} \right)^2
\end{aligned}
\]</div>
<hr />
<h3 id="final-answer">Final Answer</h3>
<div class="arithmatex">\[
\boxed{\left(1 - \frac{4p}{5}\right)^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given that the fidelity is (1 - 4p/5)^2.
 We can write this as a SymPy expression.
 Note: We are to return a SymPy expression in terms of p.</p>
                      </div>
                    </details>
<div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.444544
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>