<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note: This equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>We want: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?&rdquo;</p>
<p>Interpretation: We have a circuit that ideally prepares the logical GHZ state. But each CNOT gate is followed by a two-qubit depolarizing error channel. The error channel: After each CNOT, there is an error that applies one of the 15 non-identity two-qubit Paulis (on the two qubits involved) with probability p/15 each, and with probability 1-p, no error. The Hadamard gates are assumed perfect? The problem says: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. So only CNOT gates have errors. The Hadamard gates are error-free.</p>
<p>The circuit: The operations in order (from right to left in the given equation) are:</p>
<ol>
<li>H_2</li>
<li>CNOT_{21}</li>
<li>H_0</li>
<li>CNOT_{03}</li>
</ol>
<p>But careful: The given equation: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). In matrix multiplication order, the rightmost operation is applied first. So the actual circuit order is: Start with initial state? Typically, we start with all qubits in |0&gt;. So initial state: |0000&gt;.
Then apply H_2: That gives: H_2 on qubit 2: |0&gt;2 -&gt; (|0&gt;+|1&gt;)/√2. So state becomes: |00&gt; on qubits 0,1,3 and on qubit2: (|0&gt;+|1&gt;)/√2. So state: 1/√2 (|0000&gt; + |0010&gt;) but careful: labeling: qubits: 0,1,2,3. So state: |q0 q1 q2 q3&gt;. After H_2: state = 1/√2 (|0,0,0,0&gt; + |0,0,1,0&gt;).</p>
<p>Then apply CNOT_{21}: Control qubit 2, target qubit 1. So if qubit2 is 1, flip qubit1. So state becomes: 1/√2 (|0,0,0,0&gt; + |0,1,1,0&gt;).</p>
<p>Then apply H_0: Hadamard on qubit0. So state becomes: H_0 on first qubit: 
|0&gt; -&gt; (|0&gt;+|1&gt;)/√2, |1&gt; -&gt; (|0&gt;-|1&gt;)/√2.
But here, qubit0 is always 0? Actually, from previous: state = 1/√2 (|0000&gt; + |0110&gt;). So after H_0: 
For first term: |0000&gt; -&gt; 1/√2 (|0000&gt; + |1000&gt;)
For second term: |0110&gt; -&gt; 1/√2 (|0110&gt; + (-1)? Actually careful: H|0&gt; = (|0&gt;+|1&gt;)/√2, H|1&gt; = (|0&gt;-|1&gt;)/√2. But here qubit0 is 0 in both? Actually, in second term, qubit0 is 0? Actually, |0110&gt;: qubit0=0, qubit1=1, qubit2=1, qubit3=0. So H_0 on that gives: (|0&gt;+|1&gt;)/√2 on qubit0? But careful: H applied to |0&gt; gives (|0&gt;+|1&gt;)/√2. So it&rsquo;s the same: Actually, wait: There is no phase difference because qubit0 is always 0. So then state becomes: 
1/√2 * [1/√2 (|0000&gt; + |1000&gt;) + 1/√2 (|0110&gt; + |1110&gt;)] = 1/2 (|0000&gt; + |1000&gt; + |0110&gt; + |1110&gt;).</p>
<p>Then apply CNOT_{03}: Control qubit 0, target qubit 3. So:
For each basis state, if control (qubit0) is 1, then flip qubit3.
So:
|0000&gt;: control=0 -&gt; remains |0000&gt;
|1000&gt;: control=1 -&gt; becomes |1001&gt;? Actually careful: target is qubit3. So |1000&gt; becomes |1001&gt;.
|0110&gt;: control=0 -&gt; remains |0110&gt;
|1110&gt;: control=1 -&gt; becomes |1111&gt;.
So final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>That is the physical state. But is that the logical GHZ state? The logical GHZ state is (|00&gt;_AB + |11&gt;_AB)/√2. But what are the logical states? The code is [[4,2,2]]. The logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI.
We need to check: The state we got: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;). 
Maybe it is indeed the logical GHZ state? Let&rsquo;s check: The logical basis states? For the [[4,2,2]] code, the code space is 4-dimensional. The stabilizers are XXXX and ZZZZ. So the code space is the subspace of 4 qubits that are +1 eigenvectors of XXXX and ZZZZ. Our state: Check XXXX on |0000&gt;: XXXX|0000&gt; = |1111&gt;, so not an eigenvector. So these states are not in the code space? But wait: The circuit is supposed to prepare a logical GHZ state. But the logical GHZ state is a state on two logical qubits. That state is encoded into 4 physical qubits. So it should be in the code space? Actually, the code space is the space of states that are stabilized by XXXX and ZZZZ. Our state: 
For |0000&gt;: XXXX|0000&gt; = |1111&gt;, so it&rsquo;s not in the code space. But maybe the state is a superposition that is in the code space? Check: |0000&gt; + |1111&gt; is an eigenvector of XXXX? XXXX(|0000&gt;+|1111&gt;) = |1111&gt;+|0000&gt; = same, so that part is good. But then we also have |1001&gt; and |0110&gt;. Check XXXX on |1001&gt;: XXXX|1001&gt; = |0110&gt;? Because flip all: 1-&gt;0,0-&gt;1,0-&gt;1,1-&gt;0 gives: 0,1,1,0 = |0110&gt;. So |1001&gt; and |0110&gt; are swapped by XXXX. So the state 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;) is not an eigenvector of XXXX because applying XXXX gives 1/2 (|1111&gt;+|0110&gt;+|1001&gt;+|0000&gt;) which is the same actually? Because order: |0000&gt; becomes |1111&gt;; |1001&gt; becomes |0110&gt;; |0110&gt; becomes |1001&gt;; |1111&gt; becomes |0000&gt;. So indeed the state is symmetric. So it is an eigenvector of XXXX with eigenvalue 1. Now check ZZZZ: ZZZZ on |0000&gt; gives +1; on |1001&gt;: Z on qubit0: -1, on qubit1: +1, on qubit2: +1, on qubit3: -1? Actually careful: ZZZZ means apply Z on each qubit. So for |1001&gt;, the phase: qubit0: 1 -&gt; phase -1; qubit1: 0 -&gt; phase +1; qubit2: 0 -&gt; phase +1; qubit3: 1 -&gt; phase -1; so product = (-1)<em>(+1)</em>(+1)<em>(-1)= +1. For |0110&gt;: qubit0:0 -&gt; +1; qubit1:1 -&gt; -1; qubit2:1 -&gt; -1; qubit3:0 -&gt; +1; product = (+1)</em>(-1)<em>(-1)</em>(+1)= +1. For |1111&gt;: all ones: (-1)^4=+1. So indeed the state is in the code space. So it is a valid encoded state. And it is the GHZ state? The logical GHZ state is (|00&gt;_AB + |11&gt;_AB)/√2. We need to check what are the logical basis states. The logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI.
Let&rsquo;s find the logical basis states. The code space is 4-dimensional. We want states that are eigenvectors of Z_A and Z_B. Z_A = ZZII. So its eigenvalues: For a state in the code space, Z_A gives ±1. Similarly Z_B = ZIZI.
Our state: 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). Compute Z_A on this state: Z_A = Z on qubit0 and qubit1. 
For |0000&gt;: Z_A gives +1.
|1001&gt;: qubit0:1 -&gt; -1, qubit1:0 -&gt; +1, so product -1.
|0110&gt;: qubit0:0 -&gt; +1, qubit1:1 -&gt; -1, so product -1.
|1111&gt;: qubit0:1 -&gt; -1, qubit1:1 -&gt; -1, product +1.
So the state is not an eigenvector of Z_A. But it is the GHZ state which is a superposition of |00&gt; and |11&gt; logical. So it should be that if we measure Z_A and Z_B, we get either both +1 or both -1. Check Z_B = ZIZI: 
|0000&gt;: Z on qubit0: +1, Z on qubit2: +1, so +1.
|1001&gt;: qubit0: -1, qubit2: 0 -&gt; +1, so -1.
|0110&gt;: qubit0: 0 -&gt; +1, qubit2: 1 -&gt; -1, so -1.
|1111&gt;: qubit0: -1, qubit2: -1, so +1.
So indeed, the state is such that Z_A and Z_B are correlated: They are both +1 for the first and last terms, and both -1 for the middle two terms. So if we define logical |00&gt; as the state that is +1 eigenvector of Z_A and Z_B, and |11&gt; as the state that is -1 eigenvector of Z_A and Z_B, then our state is (|00&gt; + |11&gt;)/√2. So it is the GHZ state. So the circuit indeed prepares the logical GHZ state.</p>
<p>Now, we want: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; 
Interpretation: The circuit has two CNOT gates: CNOT_{21} and CNOT_{03}. Each CNOT gate is followed by a depolarizing error channel. So the actual process is: 
Start with |0000&gt;.
Apply H_2 (perfect).
Then apply CNOT_{21} but then followed by error channel on qubits {2,1}? Actually careful: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. So after CNOT_{21}, we apply an error operation on qubits 2 and 1. That error is: with probability 1-p, identity; with probability p, one of the 15 Pauli errors (non-identity two-qubit Paulis) chosen uniformly. So that error is applied to the state.
Then apply H_0 (perfect).
Then apply CNOT_{03} followed by error channel on qubits {0,3}.</p>
<p>We want the fidelity of the final state (after these operations, including errors) to the ideal state (which is the state we computed without errors). Fidelity is defined as F = &lt;ψ_ideal| ρ |ψ_ideal&gt; where ρ is the actual density matrix.</p>
<p>We assume that the errors are stochastic and independent. So we can compute the evolution as: The circuit is a sequence of operations. The errors occur after each CNOT. So we can compute the effect of errors on the state. Since the errors are Pauli errors, and the circuit is Clifford (Hadamard and CNOT are Clifford), the entire process will map Pauli errors to Pauli errors. But careful: The errors occur after the gates. So we can compute the overall effect as: The ideal circuit U = U_4 U_3 U_2 U_1, where U_1 = H_2, U_2 = CNOT_{21}, U_3 = H_0, U_4 = CNOT_{03}. But then after U_2, we have an error E2 on qubits {2,1} chosen from the set of 15 Paulis (including identity with probability 1-p, and each of the 15 with probability p/15). And after U_4, we have an error E4 on qubits {0,3} similarly.</p>
<p>So the actual final state is: ρ = average over E2 and E4 of [U_4 E4 U_3 U_2 E2 U_1 |0&gt;&lt;0| U_1^\dagger E2^\dagger U_2^\dagger U_3^\dagger E4^\dagger U_4^\dagger]. But since the errors are Pauli, they are unitary. So the final state is a mixture of states of the form U_ideal * (some Pauli error propagated through the circuit) applied to |0&gt;. But careful: The order: Actually, the circuit is: 
State after step1: |ψ1&gt; = H_2 |0&gt;.
Then step2: Apply CNOT_{21} to get |ψ2&gt; = CNOT_{21} |ψ1&gt;.
Then error E2 on qubits {2,1} gives: |ψ2&rsquo;&gt; = E2 |ψ2&gt;.
Then step3: Apply H_0: |ψ3&gt; = H_0 |ψ2&rsquo;&gt;.
Then step4: Apply CNOT_{03}: |ψ4&gt; = CNOT_{03} |ψ3&gt;.
Then error E4 on qubits {0,3} gives: |ψ_f&gt; = E4 |ψ4&gt;.</p>
<p>So the overall transformation is: |ψ_f&gt; = E4 * CNOT_{03} * H_0 * E2 * CNOT_{21} * H_2 |0&gt;.
And U_ideal = CNOT_{03} * H_0 * CNOT_{21} * H_2.
So if there were no errors, we get |ψ_ideal&gt;.
With errors, we get: |ψ_f&gt; = (E4) * (CNOT_{03} H_0) * E2 * (CNOT_{21} H_2) |0&gt;? But careful: The order: Actually, it&rsquo;s: 
U_ideal = CNOT_{03} * H_0 * CNOT_{21} * H_2.
And with errors: 
Actual = E4 * CNOT_{03} * H_0 * E2 * CNOT_{21} * H_2.
So if we define V = CNOT_{03} * H_0, then actual = E4 * V * E2 * V^{-1} * (V * CNOT_{21} * H_2) = E4 * V * E2 * V^{-1} * U_ideal? Not exactly: Because V * CNOT_{21} * H_2 = CNOT_{03} * H_0 * CNOT_{21} * H_2 = U_ideal. So indeed, actual = E4 * (CNOT_{03} H_0) * E2 * (H_0^\dagger CNOT_{03}^\dagger) * U_ideal. So the error becomes: overall error operator = E4 * (CNOT_{03} H_0) * E2 * (H_0^\dagger CNOT_{03}^\dagger). Let&rsquo;s denote that as O = E4 * U_{mid} * E2 * U_{mid}^\dagger, where U_{mid} = CNOT_{03} H_0? But careful: Actually, check: 
We have: actual = E4 * CNOT_{03} * H_0 * E2 * CNOT_{21} * H_2.
And U_ideal = CNOT_{03} * H_0 * CNOT_{21} * H_2.
So if we multiply U_ideal by something from the left? Actually, note that CNOT_{21} * H_2 is not necessarily the inverse of something? Alternatively, we can compute the effect of errors by propagating them through the subsequent gates. That might be easier: 
We have two error locations: after CNOT_{21} and after CNOT_{03}. 
Let&rsquo;s denote the Pauli errors: 
E2 is on qubits {2,1}. It is one of the 15 Pauli operators on these two qubits (excluding identity). But note: The Pauli group on two qubits: They are of the form P = σ_a ⊗ σ_b, where σ_a, σ_b ∈ {I, X, Y, Z} but not both I. So there are 15.
Similarly, E4 is on qubits {0,3}.</p>
<p>We want the fidelity F = average over E2 and E4 of |&lt;ψ_ideal| ψ_actual&gt;|^2. But careful: The actual state is pure if we fix E2 and E4. But then we average the fidelity? Actually, fidelity is defined as F = &lt;ψ_ideal| ρ |ψ_ideal&gt; where ρ is the mixed state from the process. And ρ = sum_{E2, E4} (probability) |ψ(E2,E4)&gt;&lt;ψ(E2,E4)|. So then F = sum_{E2,E4} p(E2) p(E4) |&lt;ψ_ideal|ψ(E2,E4)&gt;|^2.
So we need to compute for each possible error pattern, the overlap between the ideal state and the state obtained with that error. And then average.</p>
<p>Since the circuit is Clifford, the effect of a Pauli error propagated through the subsequent Clifford gates becomes another Pauli operator on the final state. Specifically, if we have an error E inserted at some point, then the overall state becomes U_ideal * (U_ideal^\dagger * (error propagated) * U_ideal) |0&gt;? Actually, let&rsquo;s do it step by step.</p>
<p>We have: |ψ_ideal&gt; = U |0&gt; where U = CNOT_{03} H_0 CNOT_{21} H_2.
And |ψ_actual&gt; = E4 * CNOT_{03} * H_0 * E2 * CNOT_{21} * H_2 |0&gt;.
So |ψ_actual&gt; = E4 * (CNOT_{03} H_0) * E2 * (CNOT_{03} H_0)^\dagger * U |0&gt;? Check: U = CNOT_{03} H_0 CNOT_{21} H_2. So CNOT_{21} H_2 = (H_0^\dagger CNOT_{03}^\dagger) U? That would be if CNOT_{03} H_0 is invertible? Actually, note: U = (CNOT_{03} H_0) (CNOT_{21} H_2). So then CNOT_{21} H_2 = (CNOT_{03} H_0)^\dagger U. So then 
|ψ_actual&gt; = E4 * (CNOT_{03} H_0) * E2 * (CNOT_{03} H_0)^\dagger U |0&gt; = E4 * U_{mid} * E2 * U_{mid}^\dagger * U |0&gt;, where U_{mid} = CNOT_{03} H_0.
So then |ψ_actual&gt; = (E4 * U_{mid} * E2 * U_{mid}^\dagger) |ψ_ideal&gt;.
So the error operator on the ideal state is O = E4 * (U_{mid} E2 U_{mid}^\dagger). And note that U_{mid} is a Clifford operation (it is a product of H on qubit0 and CNOT on qubits 0 and 3). So it will map Pauli operators to Pauli operators. So let F = U_{mid} E2 U_{mid}^\dagger. Then F is a Pauli operator on the 4 qubits? But careful: E2 acts on qubits {2,1} only. U_{mid} = CNOT_{03} H_0. That acts on qubits 0 and 3? Actually, CNOT_{03} acts on qubits 0 and 3. H_0 acts on qubit0. So U_{mid} does not act on qubits 1 and 2. So then U_{mid} E2 U_{mid}^\dagger = E2 itself? Because E2 acts on qubits 1 and 2, and U_{mid} acts on qubits 0 and 3, so they commute? Actually, check: U_{mid} = CNOT_{03} H_0. This operator acts on qubits 0 and 3. E2 acts on qubits 2 and 1. These are on disjoint sets, so they commute. So indeed, U_{mid} E2 U_{mid}^\dagger = E2. So then O = E4 * E2. So the overall error is simply the product of the two errors? But wait, is that correct? Let&rsquo;s check carefully:
We have: |ψ_actual&gt; = E4 * CNOT_{03} * H_0 * E2 * CNOT_{21} * H_2 |0&gt;.
And |ψ_ideal&gt; = CNOT_{03} * H_0 * CNOT_{21} * H_2 |0&gt;.
So if E2 and E4 commute with the subsequent operations? Actually, careful: E2 acts on qubits 1 and 2. After E2, we apply H_0. H_0 acts on qubit0, so it commutes with E2 because they act on different qubits. Then we apply CNOT_{03}. That acts on qubits 0 and 3. That also commutes with E2 because E2 acts on qubits 1 and 2. So indeed, we can move E2 to the right through H_0 and CNOT_{03}? But careful: The order: Actually, we have: CNOT_{03} * H_0 * E2. Since E2 commutes with H_0 and CNOT_{03} (because they act on disjoint sets), we have CNOT_{03} * H_0 * E2 = E2 * CNOT_{03} * H_0. So then 
|ψ_actual&gt; = E4 * E2 * CNOT_{03} * H_0 * CNOT_{21} * H_2 |0&gt; = E4 * E2 * |ψ_ideal&gt;.
So indeed, the overall effect is that the final state is simply the ideal state acted upon by the product of the two errors: E_total = E4 * E2. But wait: Check: E2 is applied after CNOT_{21} but before H_0. And we argued that E2 commutes with H_0 and CNOT_{03} because they act on different qubits. That is true if E2 acts only on qubits 1 and 2. And E4 acts on qubits 0 and 3. So indeed, they commute with each other? Actually, E2 and E4 act on disjoint sets, so they commute. So then the final state is: |ψ_actual&gt; = E4 E2 |ψ_ideal&gt;. 
But wait: Is that always true? Check with a specific basis: For example, suppose E2 = X on qubit2. Then after CNOT_{21}, we have state: 1/√2 (|0000&gt; + |0110&gt;). Then E2 (X on qubit2) gives: 1/√2 (|0010&gt; + |0100&gt;). Then H_0: gives: 1/√2 (1/√2(|0010&gt;+|1010&gt;) + 1/√2(|0100&gt;+|1100&gt;)) = 1/2 (|0010&gt;+|1010&gt;+|0100&gt;+|1100&gt;). Then CNOT_{03}: control qubit0, target qubit3. 
For |0010&gt;: control=0 -&gt; remains |0010&gt;
|1010&gt;: control=1 -&gt; becomes |1011&gt;
|0100&gt;: control=0 -&gt; remains |0100&gt;
|1100&gt;: control=1 -&gt; becomes |1101&gt;
So state becomes: 1/2 (|0010&gt;+|1011&gt;+|0100&gt;+|1101&gt;).
Then E4: say E4 = I? Then that is the state. 
Now, if we instead take E2 and move it to the end: E2 = X on qubit2. And then apply that to the ideal state? The ideal state is: 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). Applying X on qubit2 gives: 1/2 (|0010&gt;+|1011&gt;+|0100&gt;+|1101&gt;). That matches. So indeed, the errors simply multiply at the end. So the overall effect is that the final state is: 
|ψ_f&gt; = E_total |ψ_ideal&gt;, where E_total = E4 * E2, and E2 and E4 are independent Pauli errors on their respective pairs. But careful: There is also the possibility that E2 or E4 is identity. So overall, the error is a Pauli operator on the 4 qubits that is a product of an operator on qubits {1,2} and an operator on qubits {0,3}. And these errors occur with probabilities: 
For E2: probability of identity: 1-p; probability of each non-identity Pauli on qubits {2,1}: p/15.
For E4: similarly.
And they are independent.</p>
<p>So then the fidelity F = average over E2, E4 of |&lt;ψ_ideal| E_total |ψ_ideal&gt;|^2.
But careful: That is if the state is pure. But note: E_total is a Pauli operator. So we need to compute: For each Pauli operator P on the 4 qubits (which is a product of a Pauli on qubits {1,2} and a Pauli on qubits {0,3}), what is |&lt;ψ_ideal| P |ψ_ideal&gt;|^2? And then average over the distribution of P.</p>
<p>So we need to compute: For a given Pauli operator P (which acts on the 4 qubits), what is the overlap &lt;ψ_ideal| P |ψ_ideal&gt;? Since |ψ_ideal&gt; is a specific state. But note: |ψ_ideal&gt; is not necessarily a stabilizer state of the Pauli group? Actually, it is a stabilizer state? It is the GHZ state in the code. But it is a state in the code space. The code space is stabilized by XXXX and ZZZZ. So any Pauli operator that is in the stabilizer will act as identity on |ψ_ideal&gt;. Also, Pauli operators that are logical operators? But careful: The state is not necessarily an eigenvector of all logical operators? Actually, the GHZ state is (|00&gt;+|11&gt;)/√2. That state is not an eigenvector of, say, Z_A alone? But it is an eigenvector of Z_A Z_B? Actually, check: Z_A Z_B? For our state, Z_A and Z_B are correlated: They are both +1 or both -1. So Z_A Z_B gives +1. But individually, they are not fixed. So we need to compute the expectation values.</p>
<p>Maybe we can compute directly: 
|ψ_ideal&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
We want &lt;ψ_ideal| P |ψ_ideal&gt; for a Pauli operator P. P is a tensor product of Paulis on each qubit: P = P0 ⊗ P1 ⊗ P2 ⊗ P3, where each P_i is I, X, Y, Z. But note: Our errors come from two independent sets: qubits {1,2} and qubits {0,3}. But anyway.</p>
<p>We can compute: 
&lt;ψ_ideal| P |ψ_ideal&gt; = (1/4) * [ &lt;0000|P|0000&gt; + &lt;0000|P|1001&gt; + &hellip; actually careful: It is sum_{a,b,c,d} where a,b,c,d are the four basis states? Actually, it&rsquo;s easier: 
|ψ_ideal&gt; = 1/2 (|A&gt; + |B&gt; + |C&gt; + |D&gt;) where 
A = |0000&gt;, B = |1001&gt;, C = |0110&gt;, D = |1111&gt;.
So &lt;ψ_ideal| P |ψ_ideal&gt; = 1/4 [ <A|P|A> + <A|P|B> + &hellip; + <D|P|D> ].
But note: P is a Pauli operator. It will map computational basis states to other computational basis states up to a phase. So the matrix elements are zero unless P maps one basis state to another exactly. So we need to consider for each P, which pairs of these basis states are connected by P. And then sum the phases.</p>
<p>Alternatively, we can note that the ideal state is a stabilizer state? Actually, what is the stabilizer of |ψ_ideal&gt;? It is the code stabilizer plus something that distinguishes the GHZ state from other states in the code. The code stabilizer is generated by XXXX and ZZZZ. So these stabilize |ψ_ideal&gt;? Check: XXXX|ψ_ideal&gt; = |ψ_ideal&gt; as we computed. ZZZZ|ψ_ideal&gt; = |ψ_ideal&gt; as computed. So these are stabilizers. Also, what about Z_A? That is ZZII. That does not stabilize because it gives different phases on different terms? Actually, check: ZZII on |0000&gt; gives +1, on |1001&gt; gives? qubit0:1 -&gt; -1, qubit1:0 -&gt; +1, so -1. So not stabilizer. But maybe there is another operator? The GHZ state is stabilized by X_A X_B? That is XIXI * XXII = XXXI? That is not a Pauli? Actually, X_A X_B = (XIXI)(XXII) = X_{0}? Let&rsquo;s compute: X_A = XIXI, so on qubits: qubit0: X, qubit1: I, qubit2: X, qubit3: I. X_B = XXII, so on qubits: qubit0: X, qubit1: X, qubit2: I, qubit3: I. Their product: qubit0: X<em>X = I, qubit1: I</em>X = X, qubit2: X<em>I = X, qubit3: I</em>I = I. So X_A X_B = IXXI. That applied to |ψ_ideal&gt;? For |0000&gt;, IXXI gives |0110&gt;? That is not an eigenvector. So maybe it&rsquo;s not a stabilizer state in the usual sense? But it is a Clifford state because it is prepared by a Clifford circuit. So it is a stabilizer state of some subgroup of the Pauli group. The stabilizer of |ψ_ideal&gt; should have 4 generators (for 4 qubits, stabilizer states have stabilizer group of size 2^4=16). So we can find the stabilizers. They are: 
S1 = XXXX
S2 = ZZZZ
S3 = ? 
Maybe we can find them by: The circuit: U = CNOT_{03} H_0 CNOT_{21} H_2. And initial state is |0000&gt;. So the stabilizers of the initial state are: Z0, Z1, Z2, Z3. Then conjugated by U, we get the stabilizers of the final state. So:
For initial stabilizer: Z0 -&gt; U Z0 U^\dagger. But that might be messy.</p>
<p>Maybe it&rsquo;s easier to compute the overlap directly. 
We want: F(P) = |&lt;ψ_ideal| P |ψ_ideal&gt;|^2.
Since P is a Pauli, it will either commute or anticommute with the stabilizers? But careful: The state is not necessarily an eigenvector of all Paulis? But if P is in the stabilizer group of |ψ_ideal&gt;, then P|ψ_ideal&gt; = |ψ_ideal&gt;, so overlap = 1.
If P is not in the stabilizer, then it might send |ψ_ideal&gt; to an orthogonal state? But not necessarily: For example, consider a GHZ state on two qubits: (|00&gt;+|11&gt;)/√2. Then the Pauli X on one qubit: X1 gives (|10&gt;+|01&gt;)/√2, which is orthogonal to the original. But what about Z1? Z1 gives (|00&gt; - |11&gt;)/√2, which is also orthogonal. So for the two-qubit GHZ, any Pauli that is not identity and not a stabilizer? Actually, the stabilizers of the two-qubit GHZ are XX and ZZ? Actually, for two qubits, the GHZ state is stabilized by XX and -ZZ? Actually, check: (|00&gt;+|11&gt;)/√2: XX gives (|11&gt;+|00&gt;)= same, so stabilizer. ZZ gives (|00&gt; + (-1)<em>(-1)? Actually, ZZ: on |00&gt; gives +1, on |11&gt; gives (+1)</em>(+1)=1? Wait, careful: Z⊗Z: |00&gt; -&gt; 1, |11&gt; -&gt; (1<em>1)=1, so actually ZZ also stabilizes? But then what about Z⊗I? That gives (|00&gt; - |11&gt;)/√2, which is orthogonal. So indeed, for the two-qubit GHZ, any Pauli that is not in the stabilizer group gives zero overlap. But is that true for our 4-qubit state? Possibly yes because it is a Clifford state. In fact, for any stabilizer state, if a Pauli operator is not in the stabilizer group, then its expectation value is 0. But wait: There is also the possibility that the Pauli operator is a logical operator? But then it might have expectation value ±1? For example, in a logical state, if the state is an eigenvector of a logical operator, then that logical operator will have expectation value ±1. But careful: The stabilizer group of a state is the set of Paulis that act as identity on the state. For a logical state, say |0&gt;_L, the stabilizer group is the code stabilizer plus maybe something like Z_L? Actually, for a logical state, the stabilizer group is only the code stabilizer. Because Z_L does not stabilize |0&gt;_L? Actually, if |0&gt;_L is defined as the +1 eigenvector of Z_L, then Z_L|0&gt;_L = |0&gt;_L, so it is a stabilizer. But then the stabilizer group of a logical state is larger than the code stabilizer? Actually, the code space is 2^k dimensional. A specific state in that code space is not stabilized by all logical operators. For example, for a single qubit code, the code space is 2-dimensional. The stabilizer of a state in that code space is not the whole code stabilizer because the code stabilizer is only the operators that fix every state in the code. For a logical state, say |0&gt;_L, it is an eigenvector of Z_L, but Z_L is not in the stabilizer of the code because it acts as -1 on |1&gt;_L. So the stabilizer group of the state |0&gt;_L is actually the code stabilizer itself? Actually, check: For a stabilizer code, the stabilizer group S is a subgroup of the Pauli group. The code space is the common +1 eigenspace of S. But if we take a particular state |ψ&gt; in the code space, it might be an eigenvector of some Pauli operator that is not in S, but that operator will not necessarily act as identity on all states in the code. So the stabilizer of the state |ψ&gt; is actually larger than S if |ψ&gt; is a stabilizer state? Actually, consider a single qubit: The state |0&gt; has stabilizer {I, Z}. But if we encode |0&gt; into a code, say the repetition code for 3 qubits: |0&gt;_L = |000&gt;, then the stabilizer of the code is {ZZI, IZZ}. But the state |000&gt; is also stabilized by ZZZ? Actually, ZZZ|000&gt; = |000&gt;, so ZZZ is in the stabilizer of the state? But ZZZ is not in the stabilizer of the code because it is not generated by ZZI and IZZ? Actually, for the repetition code, the stabilizer is indeed generated by ZZI and IZZ, and then ZZZ = (ZZI)(IZZ) so it is in the group. So actually, the stabilizer of the state |000&gt; is the whole stabilizer group of the code? But then what about logical X? X_L = XXX. That does not stabilize |000&gt; because XXX|000&gt; = |111&gt;. So indeed, for a logical basis state, the stabilizer is the code stabilizer. But our state is a superposition: (|00&gt;_L + |11&gt;_L)/√2. That state is not stabilized by Z_A or Z_B individually. But it might be stabilized by some other operators. Let&rsquo;s try to find the stabilizers of |ψ_ideal&gt;. 
We know that XXXX and ZZZZ stabilize it. What else? 
Consider the operator: Z_A Z_B = (ZZII)(ZIZI) =? Actually, careful: Z_A = ZZII, Z_B = ZIZI. Their product: On qubit0: Z</em>Z = I, qubit1: Z<em>I = Z, qubit2: I</em>Z = Z, qubit3: I*I = I. So Z_A Z_B = IZZI. Does that stabilize? Apply IZZI to |ψ_ideal&gt;: 
|0000&gt; -&gt; IZZI gives: qubit1: Z on 0 -&gt; +1, qubit2: Z on 0 -&gt; +1, so remains.
|1001&gt; -&gt; qubit1: Z on 0 -&gt; +1, qubit2: Z on 0 -&gt; +1, so remains.
|0110&gt; -&gt; qubit1: Z on 1 -&gt; -1, qubit2: Z on 1 -&gt; -1, product = +1, so remains.
|1111&gt; -&gt; qubit1: Z on 1 -&gt; -1, qubit2: Z on 1 -&gt; -1, product = +1, so remains.
So IZZI stabilizes. So that is a stabilizer. 
Next, what about X_A X_B? We computed X_A X_B = (XIXI)(XXII) =? Let&rsquo;s do carefully:
X_A = σ_X on qubit0, I on qubit1, σ_X on qubit2, I on qubit3.
X_B = σ_X on qubit0, σ_X on qubit1, I on qubit2, I on qubit3.
Their product: qubit0: X * X = I, qubit1: I * X = X, qubit2: X * I = X, qubit3: I * I = I. So X_A X_B = IXXI. Check on |ψ_ideal&gt;:
IXXI on |0000&gt; gives: qubit1: X on 0 -&gt; |1&gt;, qubit2: X on 0 -&gt; |1&gt;, so becomes |0110&gt;.
|0110&gt; becomes: qubit1: X on 1 -&gt; |0&gt;, qubit2: X on 1 -&gt; |0&gt;, so becomes |0000&gt;.
Similarly, |1001&gt; becomes? IXXI on |1001&gt;: qubit1: X on 0 -&gt; |1&gt;, qubit2: X on 0 -&gt; |1&gt;, so becomes |1111&gt;.
|1111&gt; becomes: qubit1: X on 1 -&gt; |0&gt;, qubit2: X on 1 -&gt; |0&gt;, so becomes |1001&gt;.
So IXXI actually swaps the first and third terms and swaps the second and fourth terms. So IXXI does not stabilize individually, but it might be that the state is an eigenvector if the coefficients are the same? Actually, |ψ_ideal&gt; = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). Under IXXI, it becomes 1/2 (|0110&gt;+|1111&gt;+|0000&gt;+|1001&gt;) = same. So IXXI also stabilizes. So we have stabilizers: S1 = XXXX, S2 = ZZZZ, S3 = IZZI, S4 = IXXI. Check if these are independent? They are all commuting? 
XXXX commutes with IZZI? X and Z anticommute on same qubit? But here IZZI acts on qubits 1 and 2. XXXX acts on all qubits. On qubit1, X and Z anticommute, so overall: sign = (-1)^(number of qubits where both are non-I? Actually, careful: XXXX and IZZI: On qubit1: X and Z anticommute, so product gives a minus sign. On qubit2: X and Z anticommute, so another minus sign. So overall, they commute because two minuses give plus. So yes.
So the stabilizer group of |ψ_ideal&gt; is generated by these 4. That group has 16 elements. So indeed, |ψ_ideal&gt; is a stabilizer state. So then for any Pauli operator P, if P is in the stabilizer group, then &lt;ψ_ideal| P |ψ_ideal&gt; = 1. If P is not in the stabilizer group, then it will map |ψ_ideal&gt; to an orthogonal state, so the overlap is 0. But wait: There is also the possibility that P is exactly the negative of a stabilizer? But Pauli operators are Hermitian and have eigenvalues ±1. But if P = -S for some stabilizer S, then P|ψ_ideal&gt; = -|ψ_ideal&gt;, so then overlap = -1, but the fidelity squared is still 1? Actually, fidelity is |&lt;ψ_ideal|P|ψ_ideal&gt;|^2. So if P = -S, then that gives 1 as well. So actually, if P is in the set of Paulis that are ±1 times a stabilizer, then the overlap magnitude is 1. But careful: The stabilizer group itself is a subgroup of the Pauli group. But note: If S is a stabilizer, then -S is not in the stabilizer group because stabilizer group is defined as those operators that act as +1. But if we consider the set of operators that leave the state invariant up to a phase, that set is actually the stabilizer group multiplied by phases? Actually, for a stabilizer state, the state is an eigenvector of all elements of the stabilizer group. But if we take a Pauli operator that is exactly -S, then it will give -1. But then the overlap is -1, so the fidelity squared is 1. So indeed, if P is such that P|ψ_ideal&gt; = ±|ψ_ideal&gt;, then |&lt;ψ_ideal|P|ψ_ideal&gt;|^2 = 1. And if P is not in that set, then the state P|ψ_ideal&gt; is orthogonal to |ψ_ideal&gt;, so overlap = 0.
So we need to determine: For a given Pauli error E_total = E4 * E2, when does it act as ±1 on |ψ_ideal&gt;? That is equivalent to: E_total must be in the normalizer of the stabilizer group? Actually, it must commute with all stabilizers? Not exactly: For a stabilizer state, a Pauli operator will either commute or anticommute with each stabilizer generator. If it anticommutes with some generator, then it will map the state to an orthogonal state. So the condition for E_total to have nonzero overlap is that it commutes with all stabilizers. But wait: Check: For a stabilizer state with stabilizers S_i, if a Pauli P anticommutes with some S_i, then S_i P|ψ&gt; = - P S_i|ψ&gt; = - P|ψ&gt;, so P|ψ&gt; is an eigenvector of S_i with eigenvalue -1, so it is orthogonal to |ψ&gt; which is eigenvalue +1. So indeed, for P to have nonzero overlap, it must commute with all stabilizers. But is that sufficient? If P commutes with all stabilizers, then P maps the stabilizer group to itself. But then P|ψ&gt; is also a stabilizer state? Actually, if P commutes with all stabilizers, then P|ψ&gt; is in the code space? But not necessarily: For a stabilizer state, the stabilizer group is maximal. So if P commutes with all stabilizers, then P is actually an element of the stabilizer group itself? Is that true? For a stabilizer state, the stabilizer group is a maximal abelian subgroup of the Pauli group. So if a Pauli operator commutes with all elements of that maximal abelian subgroup, then it must be in that subgroup. Actually, that is a property: For a maximal abelian subgroup, the centralizer is the subgroup itself. So indeed, if P commutes with all stabilizers, then P is in the stabilizer group. But wait: There is a nuance: The stabilizer group of a state is defined as the set of Paulis that stabilize the state. But if P commutes with all stabilizers, then P|ψ&gt; is an eigenvector of each stabilizer with eigenvalue +1, so P|ψ&gt; is in the same eigenspace. But since the stabilizer group is maximal, that eigenspace is 1-dimensional. So P|ψ&gt; must be proportional to |ψ&gt;. So indeed, if P commutes with all stabilizers, then P is in the stabilizer group (up to a phase). But careful: What if P is itself a stabilizer? Then it&rsquo;s fine. So indeed, the condition for &lt;ψ_ideal| P |ψ_ideal&gt; to be nonzero is that P is an element of the stabilizer group of |ψ_ideal&gt;. And then the overlap is ±1, so fidelity squared is 1.</p>
<p>But wait: Is it possible that P is not in the stabilizer group but still gives a nonzero overlap? For example, if the state is a superposition of two stabilizer states? But here it is a stabilizer state. So yes, it&rsquo;s exactly that: For a stabilizer state, any Pauli operator either leaves the state invariant (up to a phase) or maps it to an orthogonal state. So then the fidelity for a given error pattern E_total is: 
If E_total is in the stabilizer group of |ψ_ideal&gt;, then fidelity = 1.
Otherwise, fidelity = 0.</p>
<p>So then the overall fidelity F = probability that E_total is in the stabilizer group.</p>
<p>Now, E_total = E4 * E2, where E2 is a Pauli on qubits {1,2} and E4 is a Pauli on qubits {0,3}. And these are chosen independently from the set of Paulis on two qubits, with probability: For each, probability of identity = 1-p, and probability of each non-identity Pauli = p/15.
And we want the average fidelity: F = sum_{E2, E4} Prob(E2)<em>Prob(E4) * [1 if E4</em>E2 is in Stabilizer, else 0].</p>
<p>So we need to determine: What are the elements of the stabilizer group of |ψ_ideal&gt;? We have generators: 
S1 = XXXX
S2 = ZZZZ
S3 = IZZI
S4 = IXXI
But careful: These generators act on all 4 qubits. But note: Our errors E2 act only on qubits 1 and 2. And E4 act only on qubits 0 and 3. So E_total is a product of an operator on {0,3} and an operator on {1,2}. So it is of the form: P_{03} ⊗ P_{12}. And we want this to be in the stabilizer group. The stabilizer group consists of products of these generators. Let&rsquo;s list the stabilizer group elements? They are all of the form: 
S = (XXXX)^a (ZZZZ)^b (IZZI)^c (IXXI)^d, where a,b,c,d ∈ {0,1}. But careful: These generators might not be independent? Actually, they are 4 generators, so there are 16 elements. But we want to know which ones are of the form (operator on qubits 0,3) ⊗ (operator on qubits 1,2). That is, they factorize as: (A ⊗ B) where A acts on qubits 0 and 3, and B acts on qubits 1 and 2. Because our error E_total is of that form. So we want to find all stabilizer elements that are factorized as such. Let&rsquo;s compute:
S1 = XXXX = (X on qubit0)(X on qubit1)(X on qubit2)(X on qubit3) = (X0 X3) ⊗ (X1 X2)? Actually, careful: XXXX = (X0 ⊗ X1 ⊗ X2 ⊗ X3). That can be written as (X0 ⊗ X3) ⊗ (X1 ⊗ X2) if we reorder? But careful: The tensor product order: qubits: 0,1,2,3. So if we group qubits 0 and 3 together and qubits 1 and 2 together, then XXXX becomes: On the group {0,3}, we have X0 ⊗ X3. On the group {1,2}, we have X1 ⊗ X2. So S1 = (X0 X3) ⊗ (X1 X2). But note: X0 X3 means Pauli X on qubit0 and Pauli X on qubit3. So that is a Pauli on two qubits? But careful: The Pauli group on two qubits: elements are of the form σ ⊗ σ&rsquo; where σ, σ&rsquo; ∈ {I,X,Y,Z} but with a possible phase. Here X0 X3 is actually X ⊗ X. So S1 = (X⊗X) on {0,3} ⊗ (X⊗X) on {1,2}.</p>
<p>S2 = ZZZZ = (Z0 Z1 Z2 Z3) = (Z0 Z3) ⊗ (Z1 Z2) because qubits 1 and 2 are together? Actually, careful: ZZZZ = Z0 ⊗ Z1 ⊗ Z2 ⊗ Z3. Grouping: {0,3} and {1,2}: That gives (Z0 ⊗ Z3) ⊗ (Z1 ⊗ Z2). So S2 = (Z⊗Z) on {0,3} ⊗ (Z⊗Z) on {1,2}.</p>
<p>S3 = IZZI = on qubits: 0: I, 1: Z, 2: Z, 3: I. So that is: on {0,3}: I⊗I = I, on {1,2}: Z⊗Z. So S3 = I ⊗ (Z⊗Z) on {1,2}? But careful: S3 = I_{0} ⊗ Z_{1} ⊗ Z_{2} ⊗ I_{3} = (I0 ⊗ I3) ⊗ (Z1 ⊗ Z2) = I ⊗ (Z⊗Z).</p>
<p>S4 = IXXI = on qubits: 0: I, 1: X, 2: X, 3: I. So S4 = I ⊗ (X⊗X).</p>
<p>So the stabilizer generators in the factored form (grouping qubits as: group A = {0,3} and group B = {1,2}) are:
S1 = (X⊗X)_A ⊗ (X⊗X)_B
S2 = (Z⊗Z)_A ⊗ (Z⊗Z)_B
S3 = I_A ⊗ (Z⊗Z)_B
S4 = I_A ⊗ (X⊗X)_B</p>
<p>Now, note that S3 and S4 only act on group B. And S1 and S2 act on both groups.
So any stabilizer element is of the form: 
S = (S1)^a (S2)^b (S3)^c (S4)^d, with a,b,c,d ∈ {0,1}.
Let&rsquo;s compute what that gives on group A and group B.
On group A: 
From S1: gives (X⊗X)^a.
From S2: gives (Z⊗Z)^b.
From S3 and S4: give I.
So on group A, the operator is: (X⊗X)^a (Z⊗Z)^b. But careful: These might not commute? Actually, they are Pauli operators. But note: (X⊗X) and (Z⊗Z) commute? Check: On two qubits, X⊗X and Z⊗Z: On the same qubit, X and Z anticommute, so on qubit0: X and Z anticommute, on qubit3: X and Z anticommute, so overall they commute because two anticommutations give a factor of (-1)<em>(-1)=1. So yes, they commute. So on group A, the operator is: (X⊗X)^a (Z⊗Z)^b. That can be: if a=0,b=0: I⊗I.
a=1,b=0: X⊗X.
a=0,b=1: Z⊗Z.
a=1,b=1: (X⊗X)(Z⊗Z) = (XZ)⊗(XZ) = (iY)⊗(iY) = - Y⊗Y? Actually, careful: XZ = -iY, so XZ ⊗ XZ = (-iY)⊗(-iY) = (-i)</em>(-i) (Y⊗Y) = -1 * (Y⊗Y) = - Y⊗Y. But since we allow phases ±1, ±i? But Pauli group elements are defined up to phases? But here we are interested in the action on the state. The phase might matter. But note: The stabilizer group is defined as operators that stabilize the state. So if an operator has a phase, it might not be in the stabilizer group if that phase is not 1. But wait: The stabilizer group is usually defined as a subgroup of the Pauli group modulo phases? Actually, in quantum error correction, the stabilizer group is a set of operators that have eigenvalue +1 on the code space. They are usually taken to be Hermitian. So we want the operators that are actually in the Pauli group with phase ±1? Actually, Pauli operators are Hermitian if they are products of Pauli matrices with real coefficients. But if we have iY, that is not Hermitian? Actually, Y is Hermitian, so iY is not Hermitian because (iY)^† = -i Y. So typically, we take the Pauli group to be {I, X, Y, Z} with possible factors of ±1, ±i. But for stabilizers, we usually choose them to be Hermitian and with eigenvalue +1. So we want the stabilizer elements to be such that when applied to the state, they give +1. So if an operator has a phase of -1, then it would give -1 on the state? But then it would not be a stabilizer. So we need to be careful: The generators we listed: S1 = XXXX. That is Hermitian and gives +1. S2 = ZZZZ gives +1. S3 = IZZI gives +1. S4 = IXXI gives +1. So these generators are chosen with +1 eigenvalue. Then any product of these will also have eigenvalue +1 if the product does not introduce a phase? But careful: When multiplying Pauli operators, sometimes there can be a phase factor. For example, S1 * S2 = (XXXX)(ZZZZ) = (XZ)(XZ)(XZ)(XZ) on each qubit? Actually, better: S1 and S2 commute. So S1 * S2 is just the product. But what is the phase? Each Pauli matrix is Hermitian. X and Z anticommute on the same qubit, but since we have four qubits, the product S1S2 = (X0Z0)(X1Z1)(X2Z2)(X3Z3). On each qubit, XZ = -iY. So S1S2 = (-iY0)(-iY1)(-iY2)(-iY3) = (-i)^4 (Y0Y1Y2Y3) = (1)<em>(Y0Y1Y2Y3) = YYYY. So S1S2 = YYYY. And that should stabilize the state? Check: YYYY on |0000&gt; gives? Y|0&gt; = i|1&gt;, so YYYY|0000&gt; = i^4 |1111&gt; = |1111&gt;. But |1111&gt; is part of the state, but wait, the state is 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). So YYYY applied to the state: It will map |0000&gt; to |1111&gt;, |1001&gt; to ? Actually, we want to check if YYYY is in the stabilizer. Let&rsquo;s check directly: YYYY|ψ_ideal&gt; = ? 
For |0000&gt;, YYYY gives: Y|0&gt;= i|1&gt;, so overall: i^4 |1111&gt; = |1111&gt;.
For |1001&gt;, Y on qubit0: Y|1&gt; = -i|0&gt;, on qubit1: Y|0&gt;= i|1&gt;, on qubit2: Y|0&gt;= i|1&gt;, on qubit3: Y|1&gt; = -i|0&gt;; product phase: (-i)</em>(i)<em>(i)</em>(-i) = (-i * i = 1) (i * -i = 1) actually careful: (-i)<em>(i) = 1, (i)</em>(-i) = 1, so total 1, so |1001&gt; goes to |0110&gt;? Actually, careful: 
Y|1&gt; = -i|0&gt;, so qubit0: from 1 to 0 with factor -i.
qubit1: from 0 to 1 with factor i.
qubit2: from 0 to 1 with factor i.
qubit3: from 1 to 0 with factor -i.
So product phase = (-i)<em>(i)</em>(i)*(-i) = (-i * i = 1) then (1 * i = i) then (i * -i = 1) so actually, let&rsquo;s do step: 
Phase = (-i) * (i) = 1, then 1 * (i) = i, then i * (-i) = 1. So phase = 1. And the state becomes: |0,1,1,0&gt; = |0110&gt;.
Similarly, |0110&gt; goes to |1001&gt; and |1111&gt; goes to |0000&gt;. So indeed, YYYY permutes the terms, so it gives the same state. So S1S2 is indeed a stabilizer. So it&rsquo;s fine.</p>
<p>But when we factor into groups A and B, we need to be careful with phases. Let&rsquo;s compute the group A part from S1^a S2^b. 
For group A (qubits 0 and 3):
S1 gives: on A: X0 X3.
S2 gives: on A: Z0 Z3.
So S1^a S2^b on A gives: (X0X3)^a (Z0Z3)^b. 
For a=1,b=0:那就是 X0X3.
For a=0,b=1: Z0Z3.
For a=1,b=1: (X0X3)(Z0Z3) = (X0Z0)(X3Z3) = (-iY0)<em>(-iY3) = (-i)</em>(-i) Y0Y3 = (-1) Y0Y3? Actually, (-i)<em>(-i) = i^2 = -1. So that gives - Y0Y3. So the operator on A from S1S2 is - Y0Y3. But wait, we computed S1S2 overall is YYYY. On group A, that would be Y0Y3, and on group B, Y1Y2. So there is a discrepancy: S1S2 should be (Y0Y3) ⊗ (Y1Y2). But our factorization from S1^1 S2^1 gives: on A: (X0X3)(Z0Z3) =? Let&rsquo;s compute carefully: 
On qubit0: from S1: X, from S2: Z, so product = XZ = -iY.
On qubit3: similarly, XZ = -iY.
So the product on A is (-iY0)</em>(-iY3) = (i^2) (Y0Y3) = (-1) Y0Y3.
On group B: from S1: X1X2, from S2: Z1Z2, so product = (-iY1)<em>(-iY2) = (-1) Y1Y2.
So overall, S1S2 would be (-1)^2 Y0Y3 Y1Y2 = Y0Y3 Y1Y2. So it&rsquo;s consistent: Actually, careful: (-1) from group A and (-1) from group B multiply to give +1. So indeed, when we factor, we get: 
On A: S1^a S2^b gives: 
If (a,b) = (0,0): I
(1,0): X0X3
(0,1): Z0Z3
(1,1): (X0X3)(Z0Z3) =? As computed, on qubit0: XZ = -iY, on qubit3: XZ = -iY, so product = (-i)</em>(-i) Y0Y3 = (-1) Y0Y3. So it is - Y0Y3. But note that -Y0Y3 is not exactly the same as Y0Y3. But when combined with the group B part, we get the overall phase. So we want to know: For an element to be in the stabilizer, it must act as +1 on the state. That means that the overall operator (on both groups) must be exactly one of the stabilizers. But since our errors are separate on groups A and B, we want to know: For a given Pauli on group A (qubits 0,3) and a Pauli on group B (qubits 1,2), when is their product in the stabilizer group? That is equivalent to: There exist a,b,c,d such that:
On group A: The operator is the part from S1^a S2^b (which gives either I, X⊗X, Z⊗Z, or -Y⊗Y) and on group B: The operator is from S1^a S2^b S3^c S4^d? Actually, careful: The full stabilizer element is: 
S = (S1)^a (S2)^b (S3)^c (S4)^d.
On group A, that gives: (X⊗X)^a (Z⊗Z)^b. 
On group B, that gives: (X⊗X)^a (Z⊗Z)^b (Z⊗Z)^c (X⊗X)^d = (X⊗X)^(a+d) (Z⊗Z)^(b+c).
So the stabilizer elements are exactly those operators that on group A are of the form: 
A = (X⊗X)^a (Z⊗Z)^b, with a,b ∈ {0,1} but note: For (a,b)=(1,1), we get (X⊗X)(Z⊗Z) =? As computed, that equals? Let&rsquo;s compute explicitly: 
On two qubits, label them 0 and 3. 
(X⊗X) means: X on qubit0 and X on qubit3.
(Z⊗Z) means: Z on qubit0 and Z on qubit3.
Their product: On qubit0: XZ = -iY, on qubit3: XZ = -iY, so the product is (-iY)⊗(-iY) = (i^2) (Y⊗Y) = (-1) (Y⊗Y). So indeed, (X⊗X)(Z⊗Z) = - Y⊗Y.
But wait, could it be that -Y⊗Y is actually the same as Y⊗Y up to a phase? No, because Y⊗Y is Hermitian and its eigenvalues are ±1. The phase -1 means that if we apply -Y⊗Y to a state, it gives the negative of what Y⊗Y gives. So they are different operators. But are both in the stabilizer? Let&rsquo;s check: Is Y⊗Y on group A part of a stabilizer? That would require that there is a stabilizer element that on group A is Y⊗Y. For that, we need (X⊗X)^a (Z⊗Z)^b = Y⊗Y. That would require that on each qubit, we have: from a and b, we want the Pauli to be Y. But X^a Z^b: if a=1,b=1, then XZ = -iY, so that gives -iY, not Y. If we take a=1,b=1 and then multiply by a phase? But the stabilizer group is defined as the set of operators that are products of the generators. Those products are determined up to a phase? Actually, the generators are specific operators. So if we compute S1S2, we get: S1S2 = (XXXX)(ZZZZ) =? Let&rsquo;s compute S1S2 explicitly on each qubit:
On qubit0: X from S1 and Z from S2 gives: XZ = -iY.
On qubit1: X and Z gives -iY.
On qubit2: X and Z gives -iY.
On qubit3: X and Z gives -iY.
So S1S2 = (-i)^4 (Y0Y1Y2Y3) = (1)(Y0Y1Y2Y3) = YYYY. So S1S2 is actually YYYY, not -YYYY. So that means that (X⊗X)(Z⊗Z) as computed from the group factorization: On group A, from S1 and S2, we get: (X0X3)(Z0Z3) =? But careful: S1 is X0X1X2X3. When we factor into groups A and B, we write S1 = (X0X3) ⊗ (X1X2). But note: (X0X3) is not exactly the same as X0 ⊗ X3? Actually, it is: X0X3 means the operator that acts as X on qubit0 and X on qubit3. So that is indeed X0 ⊗ X3. So then (X0X3)(Z0Z3) = (X0Z0) ⊗ (X3Z3) because they act on different qubits, so it&rsquo;s a tensor product. And X0Z0 = -iY0, X3Z3 = -iY3, so product = (-i)<em>(-i) (Y0⊗Y3) = (-1)(Y0⊗Y3). So that suggests that the group A part of S1S2 is -Y0Y3. But then the group B part from S1S2 would be (X1X2)(Z1Z2) = similarly -Y1Y2. Then overall, S1S2 would be (-Y0Y3) ⊗ (-Y1Y2) = (Y0Y3)(Y1Y2) because (-1)</em>(-1)=1. So indeed, it is consistent: The group A part of S1S2 is -Y0Y3, but when combined with the group B part which is also -Y1Y2, the overall phase is (+1). So when we talk about the stabilizer element itself, it is not factorable into independent conditions on group A and group B because the phase might come from both. So we need to determine: For a given error E_total = E_A ⊗ E_B (where E_A acts on qubits 0,3 and E_B acts on qubits 1,2), when is E_A ⊗ E_B in the stabilizer group? That means there exist a,b,c,d such that:
E_A ⊗ E_B = (S1)^a (S2)^b (S3)^c (S4)^d.
And as computed, the right side is: 
On A: (X⊗X)^a (Z⊗Z)^b.
On B: (X⊗X)^(a+d) (Z⊗Z)^(b+c).
And also there is an overall phase that might be ±1? But note: The generators are chosen to have +1 eigenvalue. So they are specific operators. So we want exactly that operator (not up to a phase). So we need to compute the actual Pauli operator (including the phase) that results from the product. Let&rsquo;s compute the stabilizer elements explicitly in terms of their action on groups A and B. We have:
S1 = X0X1X2X3. Write as: (X0X3) ⊗ (X1X2). But careful: (X0X3) is actually X0 ⊗ X3. So S1 = (X0 ⊗ X3) ⊗ (X1 ⊗ X2). There is no phase here.
S2 = Z0Z1Z2Z3 = (Z0⊗Z3) ⊗ (Z1⊗Z2).
S3 = I0 Z1 Z2 I3 = (I0⊗I3) ⊗ (Z1⊗Z2).
S4 = I0 X1 X2 I3 = (I0⊗I3) ⊗ (X1⊗X2).</p>
<p>Now, any stabilizer element is: S = S1^a S2^b S3^c S4^d. But careful: When multiplying these, we have to take into account that they commute? They do commute. So we can write:
S = (S1^a S2^b) (S3^c S4^d). And note that S3 and S4 only act on group B, and they commute with S1 and S2? They do because they act on different qubits? Actually, S1 and S2 act on both groups, but since S3 and S4 act only on group B, they commute with the group B part of S1 and S2? But careful: S1 has a group B part: X1X2. That commutes with S3? S3 is Z1Z2, and X and Z anticommute on each qubit, so X1X2 and Z1Z2: on qubit1, X and Z anticommute, on qubit2, X and Z anticommute, so they commute overall because (-1)*(-1)=1. So yes, they commute. So we can write:
S = (S1^a S2^b) (S3^c S4^d) = [ (X0X3)^a (Z0Z3)^b ]_A ⊗ [ (X1X2)^a (Z1Z2)^b ]_B * [ I_A ] ⊗ [ (Z1Z2)^c (X1X2)^d ]_B.
So then overall, on group A, we have: A = (X0X3)^a (Z0Z3)^b.
On group B, we have: B = (X1X2)^a (Z1Z2)^b (Z1Z2)^c (X1X2)^d = (X1X2)^(a+d) (Z1Z2)^(b+c).</p>
<p>Now, what are the possible outcomes on group A? 
For a,b ∈ {0,1}:
If (a,b)=(0,0): A = I.
(1,0): A = X0X3.
(0,1): A = Z0Z3.
(1,1): A = (X0X3)(Z0Z3). As computed, on qubit0: XZ = -iY, on qubit3: XZ = -iY, so this product is (-iY0)<em>(-iY3) = (i^2)(Y0Y3) = (-1) Y0Y3. So A = - Y0Y3.
So on group A, the stabilizer elements can be: I, X0X3, Z0Z3, and -Y0Y3.
On group B, we have: Let u = a+d mod 2, and v = b+c mod 2. So u,v ∈ {0,1}. Then B = (X1X2)^u (Z1Z2)^v.
Now, if (u,v)=(0,0): B = I.
(1,0): B = X1X2.
(0,1): B = Z1Z2.
(1,1): B = (X1X2)(Z1Z2) = similarly, = - Y1Y2.
So the stabilizer elements are: S = (A) ⊗ (B) with the following possibilities:
A can be: I, X0X3, Z0Z3, -Y0Y3.
B can be: I, X1X2, Z1Z2, -Y1Y2.
But wait, are all these 16 combinations actually stabilizer elements? They come from a,b,c,d with a,b ∈ {0,1} and then u = a+d mod 2, v = b+c mod 2 can be any independent? For example, can we have A = I and B = -Y1Y2? That would require a=0,b=0 so that A=I, and then we need u=1,v=1, so a+d=1 mod2 means d=1, and b+c=1 mod2 means c=1. So yes, that gives S = I ⊗ (-Y1Y2) = - I0I3 ⊗ Y1Y2. But is that actually a stabilizer? Check: -Y1Y2 on group B. But wait, our generators S3 and S4 give on group B: S3 gives Z1Z2, S4 gives X1X2. Their product S3S4 gives Z1Z2 X1X2 =? That would be? Actually, careful: S3S4 = (IZZI)(IXXI) = I (Z X)(Z X) I = on qubits 1 and 2: ZX on qubit1 gives -iY, on qubit2: ZX gives -iY, so product = (-iY1)</em>(-iY2) = (-1) Y1Y2. So S3S4 = - I0I3 ⊗ Y1Y2. So indeed, that is a stabilizer. So yes.</p>
<p>So the stabilizer group consists of all operators of the form:
On group A: either I, X0X3, Z0Z3, or -Y0Y3.
On group B: either I, X1X2, Z1Z2, or -Y1Y2.
But wait: Could there be a stabilizer element that has, say, A = Y0Y3 (without the minus sign)? That would require (a,b)=(1,1) but then we would need an overall phase factor of -1 to turn -Y0Y3 into Y0Y3. But then that would be -S1S2, which is not in the stabilizer because -S1S2 would give -1 times the state? Actually, check: -S1S2|ψ_ideal&gt; = -|ψ_ideal&gt;, so that is not a stabilizer. So indeed, the stabilizer elements are exactly those.</p>
<p>So, for an error E_total = E_A ⊗ E_B to be in the stabilizer, we need:
E_A must be one of: I, X0X3, Z0Z3, -Y0Y3.
E_B must be one of: I, X1X2, Z1Z2, -Y1Y2.
But careful: Is it sufficient that E_A and E_B are individually these? Because if E_A is, say, X0X3 and E_B is I, then the product is X0X3 ⊗ I, which is indeed a stabilizer (S1 with a=1,b=0,c=0,d=0 gives that). So yes.</p>
<p>So then the condition for fidelity to be 1 is that:
E4 (which acts on group A: qubits 0 and 3) is such that E4 is in the set {I, X0X3, Z0Z3, -Y0Y3}? But wait: E4 is a Pauli error on qubits 0 and 3. But note: E4 is applied as an error after CNOT_{03}. But we determined that the overall effect is that the final state is E4 E2 |ψ_ideal&gt;. And E4 acts on group A and E2 acts on group B. So we need E4 to be one of these four operators on two qubits? But careful: The set of Pauli operators on two qubits (ignoring phases) has 16 elements. But here we are not ignoring phases: The stabilizer condition requires that the actual operator (including phase) is exactly one of these. So for group A, the allowed operators are: </p>
<ol>
<li>I (which is identity on both qubits)</li>
<li>X0X3 (that is, Pauli X on qubit0 and Pauli X on qubit3)</li>
<li>Z0Z3</li>
<li>-Y0Y3 (that is, the operator that is -1 * (Y0 ⊗ Y3))</li>
</ol>
<p>Similarly, for group B, the allowed operators are:</p>
<ol>
<li>I</li>
<li>X1X2</li>
<li>Z1Z2</li>
<li>-Y1Y2</li>
</ol>
<p>So then the fidelity is 1 if and only if E4 is in that set and E2 is in that set? But wait: Is it that both must be in these sets independently? Because if E4 is in that set and E2 is in that set, then E4⊗E2 is in the stabilizer. Conversely, if E4⊗E2 is in the stabilizer, then necessarily E4 must be one of these and E2 must be one of these? Could it be that E4 is not in that set but E2 is such that the product becomes something? For example, suppose E4 = Y0Y3 (without the minus sign). And suppose E2 = ? For the product to be in the stabilizer, we would need E2 such that Y0Y3 ⊗ E2 is in the stabilizer. That would require that on group A, we have Y0Y3, but the stabilizer only has -Y0Y3 on group A. So we would need E2 to contribute a factor of -1. But E2 is a Pauli on group B. The Pauli operators on group B are of the form ± (something). But can they contribute a factor of -1? For example, if E2 = -I (the operator that is -1 times identity on group B), then E4⊗E2 = -Y0Y3 ⊗ I, which is in the stabilizer? Because stabilizer has -Y0Y3 ⊗ I? Check: Is -Y0Y3 ⊗ I a stabilizer? That would be if we take a=1,b=1 gives A = -Y0Y3, and then we want B = I. That requires u=0,v=0, so a+d=0 mod2 means d=1 mod2? Actually, if a=1, then d must be 1 to get u=0? Because u = a+d mod2, so if a=1, then to have u=0, we need d=1. And v = b+c, with b=1, to have v=0, we need c=1. So that gives S = S1 S2 S3 S4. Let&rsquo;s compute S1S2S3S4: 
S1S2S3S4 = (XXXX)(ZZZZ)(IZZI)(IXXI) =? We already computed S1S2 = YYYY. And S3S4 = - I⊗Y1Y2? Actually, S3S4 = - I0I3 ⊗ Y1Y2. So product = YYYY * (- I⊗Y1Y2) = - YYYY * (I⊗Y1Y2) but careful: YYYY acts on all qubits: on group A: Y0Y3, on group B: Y1Y2. So product = - (Y0Y3)(Y1Y2) * (I⊗Y1Y2) = - Y0Y3 ⊗ (Y1Y2 * Y1Y2) = - Y0Y3 ⊗ (Y1^2 Y2^2) = - Y0Y3 ⊗ (I) because Y^2=I. So indeed, S1S2S3S4 = - Y0Y3 ⊗ I. So that is a stabilizer. So wait, that means that if E4 = Y0Y3 (which is not in our list because our list requires -Y0Y3) and if E2 = -I (on group B), then the product is -Y0Y3 ⊗ (-I) = Y0Y3 ⊗ I? That would be positive? Actually, careful: E2 = -I means the operator is -1 times the identity on qubits 1 and 2. So then E4⊗E2 = (Y0Y3) ⊗ (-I) = - (Y0Y3 ⊗ I). And that is exactly the stabilizer we just found: S1S2S3S4 = -Y0Y3 ⊗ I. So indeed, if E4 = Y0Y3 and E2 = -I, then the overall error is in the stabilizer. So our condition is not that E4 and E2 are individually in those sets, but rather that the combined operator E4 ⊗ E2 is in the stabilizer group. And the stabilizer group consists of operators of the form: 
On group A: either I, X0X3, Z0Z3, or -Y0Y3.
On group B: either I, X1X2, Z1Z2, or -Y1Y2.
But wait, could there be a stabilizer element that has, say, on group A: Y0Y3? As we just saw, if we take S1S2S3S4, we got -Y0Y3 ⊗ I. So that gives group A = -Y0Y3, not Y0Y3. What about something that gives group A = Y0Y3? That would require an overall minus sign relative to that. For instance, if we take -S1S2S3S4, that would be Y0Y3 ⊗ I, but that is not in the stabilizer because it would give -1 times the state? Actually, check: -S1S2S3S4|ψ_ideal&gt; = - (stabilizer action) = -|ψ_ideal&gt;, so that is not a stabilizer. So indeed, the stabilizer group does not contain any operator that has a positive Y0Y3 on group A. So the condition is: E4 ⊗ E2 must be one of the 16 stabilizer elements. That means that if we write E4 as a Pauli on two qubits (qubits 0 and 3), it can be any Pauli up to a phase? But careful: The Pauli group on two qubits has 16 elements if we consider the operators themselves (like I, X, Y, Z on each qubit independently) but then multiplied by phases ±1, ±i. However, when we talk about errors, they are physical operations. The error channel says: &ldquo;produces one of the 15 non-identity two-qubit Paulis with equal probability p/15&rdquo;. What does &ldquo;non-identity two-qubit Paulis&rdquo; mean? Typically, it means the set of operators of the form σ_i ⊗ σ_j where (i,j) is not (0,0) if we label I=0, X=1, Y=2, Z=3. But also, these operators are usually taken to be Hermitian? Actually, the depolarizing channel is usually defined as: With probability p, an error occurs, and the error is chosen uniformly from the set {I,X,Y,Z}⊗{I,X,Y,Z} excluding the identity. But note: That set has 15 elements. But these 15 elements are not all Hermitian? Actually, they are Hermitian because X, Y, Z are Hermitian. But wait: What about phases? For example, iI is not included because that&rsquo;s not a Pauli matrix. So the errors are exactly the Pauli matrices (tensor products) with no additional phases. So that means that for a two-qubit error, the possible errors are: 
On two qubits, the operators are: 
I⊗I, I⊗X, I⊗Y, I⊗Z, 
X⊗I, X⊗X, X⊗Y, X⊗Z,
Y⊗I, Y⊗X, Y⊗Y, Y⊗Z,
Z⊗I, Z⊗X, Z⊗Y, Z⊗Z.
And the error channel says: with probability 1-p, no error (which is I⊗I). With probability p, one of the other 15 occurs, each with probability p/15.
So for E4, which acts on qubits 0 and 3, the possible errors are these 16 operators (including identity). But note: They are defined without any additional phase factors. So for example, Y⊗Y is one of them. But our stabilizer condition requires that on group A, the operator should be -Y0Y3, not Y0Y3. So if E4 = Y0Y3 (i.e., Y on qubit0 and Y on qubit3), then that is not a stabilizer element by itself. But it could become a stabilizer if combined with an E2 that gives a factor of -1. But wait, can E2 give a factor of -1? E2 is also a Pauli on two qubits (qubits 1 and 2) from the set of 16 operators (I⊗I, I⊗X, &hellip;, Z⊗Z). These operators are also defined without any phase factors. So for example, if E2 = I⊗I, that is identity, so no phase. If E2 = something else, could it contribute a phase? For instance, consider E2 = -I? But -I is not in the set of Pauli errors because the Pauli errors are taken to be the matrices themselves, not multiplied by -1. Because the Pauli group has phases ±1, ±i, but the depolarizing channel usually considers the set of Pauli operators that are Hermitian and square to identity? Actually, wait: The Pauli matrices X, Y, Z are Hermitian and square to I. But what about -X? That is also Hermitian and squares to I. So could -X be considered as an error? Typically, the depolarizing channel is defined as: ρ -&gt; (1-p)ρ + (p/15) sum_{P in Pauli, P≠I} P ρ P. Here the sum is over all Pauli operators that are not identity. But note: If P is a Pauli operator, then -P is also a Pauli operator. But are they considered distinct? For example, on one qubit, the Pauli operators are usually taken as {I, X, Y, Z}. But what about -X? That is not included because it is just a phase times X. However, sometimes the depolarizing channel is defined as: ρ -&gt; (1-p)ρ + (p/3)(XρX + YρY + ZρZ). That does not include -X because -Xρ(-X) = XρX. So indeed, the errors are considered up to a phase? Actually, careful: The depolarizing channel on a single qubit is: ρ -&gt; (1-p)ρ + (p/3)(XρX + YρY + ZρZ). So if an error occurs, it is equally likely to be X, Y, or Z. But what about -X? That would give the same effect because (-X)ρ(-X) = XρX. So actually, the error is not sensitive to overall phases. But wait, our analysis here: We are computing the fidelity &lt;ψ|E|ψ&gt;^2. If E and -E are different operators, they could give different results because &lt;ψ|(-E)|ψ&gt; = -&lt;ψ|E|ψ&gt;. But then the fidelity squared is the same. However, if the error channel is defined as: with probability p/15, we apply one of the 15 non-identity Pauli operators, then those 15 are具体哪些? They are typically: {I⊗I, I⊗X, I⊗Y, I⊗Z, X⊗I, X⊗X, X⊗Y, X⊗Z, Y⊗I, Y⊗X, Y⊗Y, Y⊗Z, Z⊗I, Z⊗X, Z⊗Y, Z⊗Z} but excluding I⊗I. So that set does not include any operators with a minus sign. So for example, -X⊗X is not in that set. So then, for E4, the possible outcomes are exactly these 16 operators (with identity having probability 1-p, and each of the 15 others having probability p/15). And these operators are defined without any extra minus signs. So then, for group A, the possible E4 are: 
I, X0I3? But careful: E4 acts on qubits 0 and 3. So its possible forms are: 
I0I3,
I0X3, I0Y3, I0Z3,
X0I3, X0X3, X0Y3, X0Z3,
Y0I3, Y0X3, Y0Y3, Y0Z3,
Z0I3, Z0X3, Z0Y3, Z0Z3.
But wait: Is that correct? The error is on two specific qubits. So yes, there are 16 operators. But note: They are not all products that act on both qubits necessarily? They can act on only one qubit as well. For example, X0I3 is an error that only affects qubit0.
Similarly, for E2 on qubits 1 and 2, the possible outcomes are the same set: 
I1I2,
I1X2, I1Y2, I1Z2,
X1I2, X1X2, X1Y2, X1Z2,
Y1I2, Y1X2, Y1Y2, Y1Z2,
Z1I2, Z1X2, Z1Y2, Z1Z2.</p>
<p>Now, the stabilizer elements we found are:
On group A, they are: I, X0X3, Z0Z3, and -Y0Y3.
On group B, they are: I, X1X2, Z1Z2, and -Y1Y2.
But note: In the list of possible E4, do we have -Y0Y3? No, because -Y0Y3 is not one of the 16. The 16 are: Y0Y3 is there, but not -Y0Y3. So that means that if E4 alone is considered, it can never be exactly -Y0Y3 because that would require a minus sign. However, could it be that E4 is something that when combined with E2 gives an overall minus? For example, if E4 = Y0Y3 and E2 = ? We want E4⊗E2 to be in the stabilizer. That requires that on group A, we need the operator to be either I, X0X3, Z0Z3, or -Y0Y3. So if E4 = Y0Y3, then to have the product be in the stabilizer, we would need that on group B, E2 contributes a factor of -1. But can E2 contribute a factor of -1? E2 is one of the 16 operators without any inherent minus signs. But wait: What are the actual operators? They are matrices. For example, consider E2 = I1I2. That is identity, so it gives +1. What about E2 = something like? Is there an operator that is actually equal to -I? No, because -I is not in the set because that would be -I1I2, but that is not listed because the listed ones are I1I2 itself. So it seems that the errors are taken from the set of Pauli matrices that are exactly these 16 for each two-qubit pair. They do not include overall minus signs. So then, for E4, the only possibilities that can be part of a stabilizer are those that themselves are exactly one of: I, X0X3, Z0Z3. Because the fourth possibility would be -Y0Y3, but that is not available because available is Y0Y3 itself. What about the possibility of getting a stabilizer element that has, say, on group A: something like X0I3? That is not in the stabilizer because stabilizer elements on group A always involve both qubits simultaneously? Check: Could X0I3 be a stabilizer? That would mean that there is a stabilizer that acts as X on qubit0 and I on qubit3. Is that possible? The stabilizer generators act on both qubits 0 and 3 together because S1 and S2 involve both. So likely not. So for E4 to contribute to a stabilizer, E4 must be either:
E4 = I (identity on both qubits)
E4 = X0X3 (i.e., X on qubit0 and X on qubit3)
E4 = Z0Z3
Or what about E4 = Y0Y3? That would give Y0Y3, but the stabilizer requires -Y0Y3. So if E4 = Y0Y3, then even if E2 is identity, the product is Y0Y3 ⊗ I, which is not a stabilizer because the stabilizer has -Y0Y3 ⊗ I. What if E2 is something that could multiply to give a minus sign? But as argued, E2 is one of the 16 operators without any minus signs. However, could it be that E2 itself is such that its matrix is actually - something? For example, consider E2 = X1X2. That is listed as X1X2. But wait, could it be that X1X2 is actually equal to - something? No, because X1X2 is defined as the Pauli operator that has X on qubit1 and X on qubit2. There is no minus sign. What about E2 = Y1Y2? That is Y1Y2, not -Y1Y2. So it seems that the errors are exactly these 16 operators for each pair. Therefore, for the product E4⊗E2 to be in the stabilizer, we need that:
E4 must be one of: I, X0X3, Z0Z3. And then, independently, E2 must be such that the product on group B is one of: I, X1X2, Z1Z2, or -Y1Y2. But wait, could there be a case where E4 is not in {I, X0X3, Z0Z3} but E2 is something that gives an overall phase? For instance, if E4 = Y0Y3, then for the product to be stabilizer, we need E4⊗E2 to be -Y0Y3 ⊗ (something). That would require that on group B, E2 actually is such that when combined with the phase from group A? But group A gives Y0Y3. To turn that into -Y0Y3, we need an overall factor of -1. That overall factor would have to come from group B if group B&rsquo;s operator is actually -I ( identity times -1). But is -I available as an error? The errors are taken from the set of Pauli matrices on two qubits. That set does not include -I because -I is not one of the 16? Actually, wait: The set of Pauli matrices on n qubits is usually defined as {I, X, Y, Z}⊗n times phases ±1, ±i. But when we say &ldquo;non-identity two-qubit Paulis&rdquo;, we usually mean the set of all Pauli operators that are not the identity operator. But careful: There is a difference between the Pauli group and the set of Pauli errors in a depolarizing channel. The depolarizing channel is often defined as: ρ -&gt; (1-p)ρ + (p/15) Σ_{P in {I,X,Y,Z}⊗2 \ {I⊗I}} P ρ P. In that sum, if P and -P are both included, then they would appear twice. But are they considered distinct? For example, on one qubit, the depolarizing channel is: ρ -&gt; (1-p)ρ + (p/3)(XρX + YρY + ZρZ). Notice that -X is not included because (-X)ρ(-X) = XρX. So indeed, the errors are taken to be the Pauli matrices themselves, not their negatives. So the set is actually: {I, X, Y, Z} for one qubit, but wait, that set has 4 elements. For two qubits, the set is {I,X,Y,Z}⊗{I,X,Y,Z} which has 16 elements. But then the depolarizing channel is: ρ -&gt; (1-p)ρ + (p/15) Σ_{P ≠ I⊗I} P ρ P. In that sum, if P appears, then -P does not appear because if P is, say, X⊗X, then -X⊗X is a different operator? But does it matter? Consider: (-X⊗X) ρ (-X⊗X) = (X⊗X) ρ (X⊗X) because the minus signs cancel. So actually, the map ρ -&gt; P ρ P is the same for P and -P. So wait: This is important: The error channel is not that we apply the operator P itself, but rather the quantum operation: ρ -&gt; P ρ P. So if P and -P are different operators, they actually give the same quantum operation because (-P)ρ(-P) = PρP. So when we talk about the depolarizing channel, the errors are usually considered up to a phase. That is, the set of errors is actually the set of Pauli operators modulo the phase factor of ±1. Because if you have an operator P and -P, they produce the same effect on the density matrix. So then, should we consider that the errors are actually from the set of 15 distinct Pauli error types? But careful: The problem statement: &ldquo;each CNOT_{ij} gate has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; The phrase &ldquo;non-identity two-qubit Paulis&rdquo; likely means that the errors are taken from the set of Pauli operators on two qubits that are not the identity, but note that if an operator has a overall minus sign, it is still a Pauli operator. However, typically, the depolarizing channel is defined such that the errors are equally likely among the Pauli operators that are not the identity, but since P and -P give the same map, they are usually grouped together. Actually, wait: There are 15 non-identity Pauli operators on two qubits if we consider them up to phase? Let&rsquo;s check: On one qubit, the non-identity Paulis are usually considered as X, Y, Z. That is 3. On two qubits, the number of Pauli operators that are not the identity (and not considering phases) is actually 4^2 - 1 = 15. But careful: That count comes from: The Pauli group on n qubits has 4^n elements if we ignore phases? Actually, the Pauli group modulo phases is of size 4^n. So for n=2, that is 16. So the non-identity ones are 15. So indeed, the errors are taken from the set of Pauli operators modulo phase. That means that when we say an error occurs, it is actually that we apply some Pauli operator that is representative of its equivalence class under multiplication by ±1. So then, for example, both X⊗X and -X⊗X are actually the same error type because they give the same effect on the state? But careful: When we compute fidelity, we are computing &lt;ψ|P|ψ&gt;. If P is replaced by -P, then that changes the sign. But wait: The fidelity is |&lt;ψ|P|ψ&gt;|^2. So that is the same. However, if the error channel is defined as: with probability p/15, we apply one of the 15 Pauli errors (where each error is considered as an operator that is not the identity up to phase), then does that mean that if the actual error is -P, it is considered the same as P? But then the probability distribution might be such that actually, the chance to get an error that acts as P is p/15, but could it be that sometimes it is P and sometimes -P? However, the depolarizing channel is usually defined as: ρ -&gt; (1-p)ρ + (p/15) Σ_{P in Pauli, P≠I} P ρ P. In that sum, if P and -P are both included, then they would appear twice, but they are actually the same because PρP = (-P)ρ(-P). So actually, the sum should be over a set of representatives that are not related by phase. Typically, the representatives are chosen such that they are Hermitian and square to I. And for Pauli matrices, we usually take I, X, Y, Z. So then on two qubits, the errors are: all operators of the form σ_a ⊗ σ_b where (a,b) runs over {0,1,2,3} with (0,0) excluded, and where σ_0=I, σ_1=X, σ_2=Y, σ_3=Z. So then indeed, the errors are these 15. And note that these representatives are chosen to be exactly these matrices. So then, for example, the error corresponding to Y⊗Y is actually the operator Y⊗Y itself, not -Y⊗Y. So then, for group A, the possible errors E4 are: 
I⊗I,
I⊗X, I⊗Y, I⊗Z,
X⊗I, X⊗X, X⊗Y, X⊗Z,
Y⊗I, Y⊗X, Y⊗Y, Y⊗Z,
Z⊗I, Z⊗X, Z⊗Y, Z⊗Z.
And these are the 16. And the non-identity ones are the ones where not both are I.
Now, what are the stabilizer elements? They are determined by the generators which are specific operators. Those generators are: S1 = X⊗X⊗X⊗X. But careful: S1 acting on qubits 0 and 3 gives X⊗X. So that representative is X⊗X. S2 gives Z⊗Z on group A. S3 and S4 act only on group B. And then products like S1S2 give: On group A, that would be (X⊗X)(Z⊗Z) =? As computed, that equals (-iY)⊗(-iY) = (-1) Y⊗Y. But wait, our representative for Y⊗Y is Y⊗Y itself. So S1S2 actually gives -Y⊗Y on group A. So that means that the stabilizer element S1S2 is not represented by the error type Y⊗Y because it has a minus sign. So indeed, for group A, the stabilizer requires that if the Pauli is Y⊗Y, it must be actually -Y⊗Y to be in the stabilizer. But since our errors are taken as the representatives (Y⊗Y itself), that means that if an error occurs that is of type Y⊗Y on group A, then that error operator is Y⊗Y, not -Y⊗Y. So then, could it be that if we also have an error on group B that is of a certain type, the combined phase might become such that the overall operator becomes a stabilizer? For instance, suppose E4 = Y⊗Y (on group A) and suppose E2 = ? We want E4⊗E2 to be in the stabilizer. That requires that on group A, we need the operator to be either I, X⊗X, Z⊗Z, or -Y⊗Y. So if E4 = Y⊗Y, then to get -Y⊗Y overall, we would need that E2 contributes a factor of -1. Can E2 contribute a factor of -1? E2 is also one of the representatives. Is it possible that an error representative is actually equal to -I? No, because the representative for I is I itself. What about other errors? For example, consider E2 = X⊗X. That is X⊗X itself. That does not have a minus sign. What about E2 = something like? Actually, note that all representatives are chosen to be exactly the Pauli matrices without any additional minus signs. So then, it seems that for the product E4⊗E2 to be in the stabilizer, we need that individually, E4 must be such that its representative is actually one of: I, X⊗X, Z⊗Z. Because if E4 is Y⊗Y, then no matter what E2 is (since E2 will be one of the 16 representatives), the product will be (Y⊗Y) ⊗ (something). But could that something ever introduce a overall minus sign? For that to happen, we would need that something is actually -I (on group B). But -I is not one of the representatives because the representative for I is I itself. What if E2 is something like? wait, could it be that the error channel actually includes the possibility of applying -I? But -I is not included because that would be considered the same as I? Actually, careful: The depolarizing channel is defined as: with probability 1-p, no error; with probability p, an error occurs, and the error is chosen uniformly from the set of 15 non-identity Pauli operators. That set does not include -I because -I is not non-identity? Actually, -I is non-identity? But wait, -I is different from I. However, usually, the depolarizing channel is defined as: ρ -&gt; (1-p)ρ + (p/3)(XρX+YρY+ZρZ) for a single qubit. That does not include -X because -X would give the same map as XρX. So they are not considered distinct errors. So the errors are taken to be the ones that are Hermitian and square to I. Those are: I, X, Y, Z. So for two qubits, the errors are taken to be: σ_a ⊗ σ_b where σ_a is in {I,X,Y,Z} and (a,b) ≠ (0,0). So indeed, there is no overall minus sign. Therefore, I conclude that for E4 to contribute to a stabilizer outcome, E4 must be either:
E4 = I (identity)
E4 = X0X3 (i.e., Pauli X on both qubits 0 and 3)
E4 = Z0Z3
What about E4 = something like X0I3? That would not be in the stabilizer because stabilizer requires that on qubit3 also something happens? Let&rsquo;s check: Could X0I3 be a stabilizer? That would mean that there is a stabilizer element that acts as X on qubit0 and I on qubit3. Is that possible? The stabilizer generators involve both qubits together. So likely not. So yes.</p>
<p>Similarly, for E2, for the product to be in the stabilizer, we need that on group B, the operator must be one of: I, X1X2, Z1Z2, or -Y1Y2. But careful: The representatives for errors on group B are also taken as: I, X, Y, Z on each qubit. So that means that if an error on group B is of the type Y1Y2, its representative is Y1Y2 itself. But the stabilizer requires -Y1Y2. So that means that if E2 = Y1Y2, then that alone would not be okay. However, could it be that if E4 is something that contributes a phase? For instance, if E4 is something that itself has a phase factor? But as argued, E4 is from the set of representatives, so they don&rsquo;t have an overall minus sign. What if E4 = I? Then E2 must be such that its representative is actually -Y1Y2 to be in the stabilizer. But -Y1Y2 is not available because the available representative is Y1Y2. So it seems that for E2, the errors that are in the stabilizer set are actually: 
E2 = I,
E2 = X1X2,
E2 = Z1Z2.
What about E2 = Y1Y2? That would give Y1Y2, but the stabilizer requires -Y1Y2. So that is not included.
But wait, could there be a case where both E4 and E2 are not individually in these sets but their product becomes a stabilizer? For example, if E4 = Y0Y3 and E2 = Y1Y2, then the product is Y0Y3 ⊗ Y1Y2. Is that a stabilizer? Let&rsquo;s check: Is YYYY a stabilizer? We determined that S1S2 = YYYY actually. But careful: S1S2 = (XXXX)(ZZZZ) gave YYYY. So YYYY is a stabilizer. So wait: If E4 = Y0Y3 and E2 = Y1Y2, then the product is Y0Y3 ⊗ Y1Y2 = YYYY. And that is a stabilizer because S1S2 is YYYY. But then that means that if both errors are of the type Y⊗Y on their respective groups, the overall error is actually in the stabilizer. But wait, check phases: E4 is representative: Y0Y3 means the operator that is Y on qubit0 and Y on qubit3. E2 is Y1Y2. Their product is Y0Y1Y2Y3. And we computed S1S2 = Y0Y1Y2Y3 (because S1S2 came out as YYYY without any minus sign). So indeed, if E4 = Y0Y3 and E2 = Y1Y2, then the overall error is exactly S1S2, which is a stabilizer. So that means that for E2, it is not that only I, X1X2, Z1Z2 are allowed. Because if E2 = Y1Y2, then if E4 is also Y0Y3, the product is stabilizer. But if E2 = Y1Y2 and E4 is something else, then it might not be. So we need to consider the combined conditions.</p>
<p>Let&rsquo;s determine systematically: We want E_total = E4 ⊗ E2 to be in the stabilizer group. The stabilizer group consists of operators of the form:
S = (S1)^a (S2)^b (S3)^c (S4)^d.
And as computed, that gives:
On group A: A = (X0X3)^a (Z0Z3)^b. But careful with phases: 
For (a,b)=(0,0): A = I.
(1,0): A = X0X3.
(0,1): A = Z0Z3.
(1,1): A = (X0X3)(Z0Z3) =? Let&rsquo;s compute this carefully with phases:
S1 on group A is: X0X3. S2 on group A is: Z0Z3.
When we multiply these, we get: (X0X3)(Z0Z3) = (X0Z0)(X3Z3) because they act on different qubits so it&rsquo;s a tensor product. Now, X0Z0 = -i Y0 (since XZ = -iY). So that gives (-iY0)<em>(-iY3) = (i^2)(Y0Y3) = (-1) Y0Y3. So indeed, S1S2 gives on group A: -Y0Y3.
So the stabilizer elements on group A are:
I,
X0X3,
Z0Z3,
-Y0Y3.
On group B, we have: B = (X1X2)^(a+d) (Z1Z2)^(b+c), but careful with phases? Let&rsquo;s compute similarly: 
On group B, S1 gives: X1X2.
S2 gives: Z1Z2.
So (X1X2)(Z1Z2) = (-iY1)</em>(-iY2) = (-1) Y1Y2.
Also, S3 gives: Z1Z2.
S4 gives: X1X2.
So indeed, any stabilizer element on group B will be of the form: 
I,
X1X2,
Z1Z2,
or -Y1Y2.
But wait, could there be a stabilizer element that has on group B something like Y1Y2 itself? What if we take S1S2S3S4? That gave: On group A, we had -Y0Y3 (from S1S2) and on group B, from S3S4, we get? S3S4 = (Z1Z2)(X1X2) =同样 (-1)Y1Y2. So then overall, S1S2S3S4 = (-Y0Y3)⊗(-Y1Y2) = (Y0Y3)(Y1Y2) because (-1)<em>(-1)=1. So that would give YYYY. But wait, that seems to suggest that YYYY is also a stabilizer. But then that would mean that there is a stabilizer element that has on group A: Y0Y3 and on group B: Y1Y2? But careful: S1S2S3S4, let&rsquo;s compute it explicitly without grouping:
S1 = X0X1X2X3
S2 = Z0Z1Z2Z3
S3 = I0Z1Z2I3
S4 = I0X1X2I3
Then S1S2 = (X0Z0)(X1Z1)(X2Z2)(X3Z3) = (-iY0)(-iY1)(-iY2)(-iY3) = ( (-i)^4 ) (Y0Y1Y2Y3) = (1)(Y0Y1Y2Y3) = Y0Y1Y2Y3. So actually, S1S2 = YYYY. I earlier got a phase of -1 when computing separately on groups? I need to be very careful with phases when products involve operators on different qubits that commute. Let&rsquo;s compute S1S2 carefully:
S1 = X0 ⊗ X1 ⊗ X2 ⊗ X3.
S2 = Z0 ⊗ Z1 ⊗ Z2 ⊗ Z3.
These operators commute because on each qubit, X and Z anticommute but there are an even number of anticommutations? Actually, they commute because S1S2 = (X0Z0)⊗(X1Z1)⊗(X2Z2)⊗(X3Z3). Now, X_iZ_i = -iY_i. So this product = (-iY0)⊗(-iY1)⊗(-iY2)⊗(-iY3) = (-i)^4 (Y0⊗Y1⊗Y2⊗Y3) = (1)(YYYY) = YYYY. So S1S2 = YYYY. 
Now, if I try to separate into groups A and B, I must be careful because the tensor product is over all qubits. When I write S1 = (X0X3) ⊗ (X1X2), that is fine because X0X3 means X0⊗X3 and X1X2 means X1⊗X2. So S1 = (X0⊗X3) ⊗ (X1⊗X2). Similarly, S2 = (Z0⊗Z3) ⊗ (Z1⊗Z2). Then S1S2 = [(X0⊗X3)(Z0⊗Z3)] ⊗ [(X1⊗X2)(Z1⊗Z2)]. Now, (X0⊗X3)(Z0⊗Z3) is not simply the product of independent terms because these operators act on different qubits? Actually, they do act on different qubits so they commute. So (X0⊗X3)(Z0⊗Z3) = (X0Z0)⊗(X3Z3) because X0 and Z3 commute etc. So that gives (-iY0)⊗(-iY3) = (-i)^2 (Y0⊗Y3) = (-1)(Y0⊗Y3). So that suggests that the group A part of S1S2 is -Y0Y3. And similarly, the group B part is -Y1Y2. Then overall, S1S2 would be (-Y0Y3)⊗(-Y1Y2) = (-1)</em>(-1) (Y0Y3⊗Y1Y2) = YYYY. So it is consistent if we remember that the tensor product of phases multiplies. So when I say the group A part is -Y0Y3, that means that there is a factor of -1 associated with that group. And the group B part is -Y1Y2, which gives another factor of -1. When combined, (-1)*(-1)=1. So it is better to not separate the phases between groups because they multiply. So let&rsquo;s instead determine the condition for E_total to be in the stabilizer by looking at its effect on the state |ψ_ideal&gt;. Maybe it&rsquo;s easier to compute the fidelity for each type of error directly from the state expression.</p>
<p>We have |ψ_ideal&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
And E_total = E4 ⊗ E2. But careful: E4 acts on qubits 0 and 3. E2 acts on qubits 1 and 2.
So let&rsquo;s denote E4 by its action on qubits 0 and 3. It will map basis states to basis states with a phase. Similarly for E2.
We want to compute &lt;ψ_ideal| E_total |ψ_ideal&gt;. This will be zero unless E_total maps each term to itself or to another term in the superposition with the same phase relations? Actually, because |ψ_ideal&gt; is a superposition of four states. E_total will permute these states and multiply by phases. So &lt;ψ_ideal|E_total|ψ_ideal&gt; = (1/4) times the sum over the four states of the phase factors when that state is mapped to itself or to another state that is also in the superposition, but careful with cross terms.</p>
<p>Maybe we can do this by brute force for each type of error? But there are 16*16 = 256 combinations. But wait, the errors are independent and we only need the average fidelity. And fidelity is |&lt;ψ|E|ψ&gt;|^2. And because |ψ&gt; is a stabilizer state, this will be either 1 or 0. Is that true? For a stabilizer state, any Pauli operator either leaves it invariant (up to a phase) or maps it to an orthogonal state. So indeed, for each E_total, the fidelity is either 1 or 0. So we just need to count the number of error pairs (E4, E2) such that E_total is in the stabilizer group of |ψ_ideal&gt;. And then the fidelity will be that probability.</p>
<p>So then the problem reduces to: Given that E4 is chosen uniformly from the 16 Pauli operators on qubits {0,3} with probability: P(E4=I) = 1-p, and for each of the 15 non-identity, probability = p/15.
Similarly, E2 is chosen from the 16 on qubits {1,2} with P(I)=1-p, and others p/15 each.</p>
<p>And we want the probability that E4 ⊗ E2 is in the stabilizer group of |ψ_ideal&gt;. And the stabilizer group has 16 elements. But careful: The stabilizer group is a subgroup of the Pauli group on 4 qubits. But wait, is it true that if a Pauli operator is in the stabilizer group, then it will have fidelity 1? Yes.
So we need to know: How many Pauli operators on 4 qubits are in the stabilizer group? There are 16. But these 16 are specific operators. They are determined by the conditions we derived earlier but with careful phase issues. Let&rsquo;s list the stabilizer group elements explicitly in terms of their action on qubits 0,3 and 1,2. They are given by:
S = (S1)^a (S2)^b (S3)^c (S4)^d, with a,b,c,d ∈ {0,1}.
Let&rsquo;s compute these 16 explicitly and write them in the form ( operator on qubits 0,3 ) ⊗ ( operator on qubits 1,2 ) including the overall phase factor that makes sure that S|ψ_ideal&gt; = |ψ_ideal&gt;. But careful: The stabilizer condition is that S|ψ_ideal&gt; = |ψ_ideal&gt;. So these S are determined up to an overall phase? Actually, they are specific operators. Let&rsquo;s compute them by taking specific values of a,b,c,d.</p>
<p>We have:
S1 = X0 X1 X2 X3.
S2 = Z0 Z1 Z2 Z3.
S3 = I0 Z1 Z2 I3.
S4 = I0 X1 X2 I3.</p>
<p>I will compute S = product for each combination. It might be easier to compute the action on group A and group separately but keeping track of phases carefully. Let&rsquo;s do that:</p>
<p>S = (S1)^a (S2)^b (S3)^c (S4)^d.
Group A (qubits 0 and 3): 
From S1: contributes: (X0X3)^a.
From S2: contributes: (Z0Z3)^b.
From S3 and S4: nothing on group A.
So on group A, the operator is: A = (X0X3)^a (Z0Z3)^b. But careful with phases when both a and b are 1. Let&rsquo;s compute that carefully:
If a=0,b=0: A = I.
If a=1,b=0: A = X0X3.
If a=0,b=1: A = Z0Z3.
If a=1,b=1: A = (X0X3)(Z0Z3). Now, (X0X3)(Z0Z3) = (X0Z0)(X3Z3) because these act on different qubits so they commute. Now, X0Z0 = -i Y0. So that gives (-iY0)*(-iY3) = (i^2)(Y0Y3) = (-1)(Y0Y3). So A = - Y0Y3.
So on group A, the possible outcomes are: I, X0X3, Z0Z3, -Y0Y3.</p>
<p>Group B (qubits 1 and 2):
From S1: contributes: (X1X2)^a.
From S2: contributes: (Z1Z2)^b.
From S3: contributes: (Z1Z2)^c.
From S4: contributes: (X1X2)^d.
So on group B, the operator is: B = (X1X2)^(a+d) (Z1Z2)^(b+c). But careful with phases when both (a+d) and (b+c) are 1 mod something? Let&rsquo;s do it similarly:
Let u = a+d mod 2, and v = b+c mod 2. Then B = (X1X2)^u (Z1Z2)^v.
If u=0,v=0: B = I.
If u=1,v=0: B = X1X2.
If u=0,v=1: B = Z1Z2.
If u=1,v=1: B = (X1X2)(Z1Z2) = similarly = (-1) Y1Y2.
So then overall, S = A ⊗ B. But wait, there could be an additional phase coming from the fact that these operators commute? They should commute because they act on different groups. So then the overall S is simply the tensor product. So then the stabilizer elements are:
For any a,b,c,d, we get:
A = determined by (a,b): 
(0,0): I
(1,0): X0X3
(0,1): Z0Z3
(1,1): -Y0Y3
B = determined by (u,v) where u=a+d, v=b+c:
(0,0): I
(1,0): X1X2
(0,1): Z1Z2
(1,1): -Y1Y2
So then S = A ⊗ B.
Now, note that these 16 are all distinct? Let&rsquo;s check: If (a,b,c,d) = (1,1,1,1), then A = -Y0Y3, B = since u=1+1=0 mod2? Actually, careful: u = a+d mod2, so if a=1,d=1, then u=0 mod2. v = b+c, if b=1,c=1, then v=0 mod2. So that gives B = I. So S = (-Y0Y3) ⊗ I = -Y0Y3 I1I2. 
If (a,b,c,d) = (1,1,0,0), then A = -Y0Y3, and u=1+0=1, v=1+0=1, so B = -Y1Y2. Then S = (-Y0Y3)⊗(-Y1Y2) = (Y0Y3)(Y1Y2) because (-1)<em>(-1)=1. So that gives S = Y0Y3 Y1Y2 = YYYY. 
So these are different.
So the stabilizer group consists of these 16 operators. Now, we want to know when does an error E_total = E4 ⊗ E2 become one of these stabilizer elements. E4 is one of the 16 Pauli operators on qubits 0 and 3. But careful: The Pauli operators on two qubits are usually taken as: I, X, Y, Z on each qubit independently. So they are of the form: 
E4 = ( phase ) * (σ_{0} ⊗ σ_{3}) where σ_{0} and σ_{3} are in {I,X,Y,Z} and the phase is such that the operator is Hermitian and squares to I. Actually, the standard Pauli matrices are defined without any phase factors. So for two qubits, the set is: 
{ I⊗I, 
 I⊗X, I⊗Y, I⊗Z,
 X⊗I, X⊗X, X⊗Y, X⊗Z,
 Y⊗I, Y⊗X, Y⊗Y, Y⊗Z,
 Z⊗I, Z⊗X, Z⊗Y, Z⊗Z }.
So for example, what is X⊗X? That is clear.
What is Y⊗Y? That is the operator that acts as Y on both qubits.
Now, compare with our stabilizer elements on group A. They are: 
I, X0X3, Z0Z3, and -Y0Y3.
Notice that -Y0Y3 is not the same as Y0Y3. So if an error E4 is actually Y0Y3 (i.e., Y⊗Y), then that is not equal to any stabilizer element on group A because the stabilizer requires -Y0Y3. However, could it be that when combined with an appropriate E2, the overall product becomes a stabilizer? For that to happen, we would need that E2 contributes a factor of -1 to cancel the phase difference. But wait, look at the stabilizer elements: They are of the form A⊗B. If E4 = Y0Y3, then for E4⊗E2 to be a stabilizer, we need that there is some stabilizer element S such that its group A part is Y0Y3. But from our list, the group A parts are only I, X0X3, Z0Z3, and -Y0Y3. There is no stabilizer element with group A part = Y0Y3. What about if both E4 and E2 have phases? For instance, if E4 = Y0Y3 and E2 = something that itself has a phase such that overall the product becomes something like? But wait, the stabilizer elements are determined. They are specific operators. For example, is there a stabilizer element that is Y0Y3 ⊗ (-I) maybe? That would be -Y0Y3 ⊗ I, which is actually a stabilizer? because that is when (a,b,c,d) = (1,1,1,1) gave -Y0Y3 ⊗ I. What about Y0Y3 ⊗ (-I) would be -Y0Y3 ⊗ I if that makes sense? Actually, careful: Y0Y3 ⊗ (-I) means take the operator that is Y on qubit0 and Y on qubit3, and on group B, take the operator that is - times identity. But -I is not one of the standard Pauli representatives because the representative for identity is I itself. So that is not available.
What if E4 = Y0Y3 and E2 = something that is not identity but gives an overall multiplication? For the product to be in the stabilizer, it must equal one of the 16 stabilizer elements exactly. The stabilizer elements have determined phases. So for example, consider the stabilizer element that is S1S2S3S4. We computed that earlier: S1S2S3S4 = ? Let&rsquo;s compute that carefully without splitting groups:
S1 = X0X1X2X3
S2 = Z0Z1Z2Z3
S3 = I0Z1Z2I3
S4 = I0X1X2I3
Then S1S2 = (X0Z0)(X1Z1)(X2Z2)(X3Z3) = (-iY0)(-iY1)(-iY2)(-iY3) = (-i)^4 (Y0Y1Y2Y3) = Y0Y1Y2Y3.
Then S1S2S3 = Y0Y1Y2Y3 * (I0Z1Z2I3) = Y0 (Y1Z1)(Y2Z2) Y3. Now, Y1Z1 =? Y Z = i X? Actually, careful: Y Z = i X because YZ = iσ_y σ_z = i (-i σ_x) wait, let&rsquo;s do properly: Pauli matrices: X,Y,Z. They satisfy: XY = iZ, YZ = iX, ZX = iY. So Y Z = i X. So Y1Z1 = i X1. Similarly, Y2Z2 = i X2. So then S1S2S3 = Y0 (iX1)(iX2) Y3 = Y0 (-1) X1X2 Y3 = - Y0 X1X2 Y3.
Then S1S2S3S4 = - Y0 X1X2 Y3 * (I0X1X2I3) = - Y0 (X1X2 X1X2) Y3 = - Y0 (X1^2 X2^2) Y3 = - Y0 I1I2 Y3 = - Y0Y3.
So S1S2S3S4 = - Y0Y3 I1I2? But wait, that acts only on qubits 0 and 3? Actually, it acts on all qubits: it is - Y0 I1 I2 Y3 = - Y0Y3 on qubits 0 and 3 and identity on qubits 1 and 2. So that stabilizer element is -Y0Y3 ⊗ I. So that is one stabilizer element.
What about S1S2 itself? S1S2 = Y0Y1Y2Y3, so that is Y0Y3 ⊗ Y1Y2. So that is a stabilizer element. So indeed, there is a stabilizer element that has group A part = Y0Y3? Because S1S2 gives: On group A: from qubits 0 and 3, that is Y0Y3. On group B: Y1Y2. So that means that if E4 = Y0Y3 and E2 = Y1Y2, then the product is Y0Y3 ⊗ Y1Y2, which is exactly S1S2. But wait, check phases: S1S2 we computed as Y0Y1Y2Y3. And that is indeed Y0Y3 ⊗ Y1Y2 because these are tensor products. So yes, that works. So then, for group A, if E4 = Y0Y3, it can be part of a stabilizer if and only if E2 is also Y1Y2. Because then the product becomes Y0Y3 ⊗ Y1Y2, which is a stabilizer (S1S2). What if E4 = Y0Y3 and E2 is something else? Then the product would be Y0Y3 ⊗ (something). Look at the stabilizer elements: Those that have group A part = Y0Y3. Do any stabilizer elements have group A part = Y0Y3? From our list, when does A become Y0Y3? A = (X0X3)^a (Z0Z3)^b. For this to be Y0Y3, we need that on each qubit, the Pauli is Y. For qubit0, X^a Z^b gives Y if a=1,b=1 would give XZ which is -iY, so to get Y, we would need a phase of i. So actually, wait: (X0X3)(Z0Z3) gave -Y0Y3. To get Y0Y3, we would need -1 times that, so that would be actually (Z0Z3)(X0X3) is the same order? They commute so it&rsquo;s the same. So it seems that no matter what, (X0X3)(Z0Z3) always gives -Y0Y3 because X0Z0 = -iY0, so product = (-iY0)</em>(-iY3)= (-1)Y0Y3. So indeed, there is no way to get a stabilizer element with group A part = Y0Y3 from S1 and S2 alone. What about including S3 and S4? They don&rsquo;t affect group A. So indeed, any stabilizer element will have group A part that is either I, X0X3, Z0Z3, or -Y0Y3. So wait, then how did S1S2 become Y0Y3 ⊗ Y1Y2? Let&rsquo;s recompute S1S2 very carefully without any group separation issues:
S1 = X0 X1 X2 X3.
S2 = Z0 Z1 Z2 Z3.
Now, these operators commute because on each qubit, X and Z anticommute but there are an even number of anticommutations? Actually, they commute because S1S2 = (X0Z0)(X1Z1)(X2Z2)(X3Z3). Now, careful: X0Z0 is not simply -iY0 because that is true if we consider the order: X0Z0. But wait, careful: S1 and S2 are operators. They commute because for each qubit, X_i and Z_i anticommute, but since there are two terms per qubit? Actually, check: S1S2 |ψ&gt; = X0X1X2X3 Z0Z1Z2Z3 |ψ&gt;. I can commute Z0 through X1X2X3 because they act on different qubits. So S1S2 = (X0Z0) (X1Z1) (X2Z2) (X3Z3). Now, X0Z0: since X0 and Z0 anticommute, X0Z0 = - Z0X0? That doesn&rsquo;t help. Let&rsquo;s actually compute the product on a basis state. Maybe it&rsquo;s easier to determine the stabilizer conditions directly from the state itself. </p>
<p>Maybe I should compute the fidelity for each error type by actually computing &lt;ψ_ideal|E|ψ_ideal&gt; for Pauli errors that are products of errors on these two groups. Because |ψ_ideal&gt; is given explicitly. And since errors are Pauli, they will either leave the state invariant or map it to an orthogonal state. So I can determine for each Pauli operator on 4 qubits whether it is in the stabilizer of |ψ_0&gt; by checking if it commutes with all stabilizer generators? But careful: That requires knowing the stabilizer generators of |ψ_ideal&gt;. I already know that XXXX, ZZZZ, IZZI, IXXI stabilize |ψ_ideal&gt;. So for E_total to be in the stabilizer, it must commute with these generators? Actually, for a stabilizer state, if an operator commutes with all stabilizers, then it is in the stabilizer group. So I can use that condition. So E_total is in the stabilizer if and only if it commutes with S1=XXXX, S2=ZZZZ, S3=IZZI, S4=IXXI.
Now, E_total = E4 ⊗ E2, where E4 acts on qubits 0 and 3, and E2 acts on qubits 1 and 2.
Let&rsquo;s write E4 as something like: E4 = Pauli on qubit0 times Pauli on qubit3. So let E4 = P0 ⊗ P3, where P0, P3 ∈ {I,X,Y,Z}. Similarly, E2 = Q1 ⊗ Q2, with Q1,Q2 ∈ {I,X,Y,Z}.
Then E_total = P0 ⊗ Q1 ⊗ Q2 ⊗ P3. wait careful with order: qubits: 0,1,2,3. So E_total = (P0) on qubit0, (Q1) on qubit1, (Q2) on qubit2, (P3) on qubit3.</p>
<p>Now, commute with S1= XXXX means that E_total must commute with X0X1X2X3. commute with S2= ZZZZ means commute with Z0Z1Z2Z3.
 commute with S3= IZZI means commute with I0 Z1 Z2 I3.
 commute with S4= IXXI means commute with I0 X1 X2 I3.</p>
<p>because these stabilizers commute with each other, E_total will be in the stabilizer if it commutes with each. actually wait: For a stabilizer state, if an operator commutes with all stabilizers, then it is in the stabilizer group. So conditions:
[E_total, X0X1X2X3] = 0.
[E_total, Z0Z1Z2Z3] = 0.
[E_total, I0Z1Z2I3] = 0.
[E_total, I0X1X2I3] = 0.</p>
<p>Let&rsquo;s do these conditions one by one.</p>
<p>Condition from S3: [E_total, I0Z1Z2I3] = 0.
E_total = P0 ⊗ Q1 ⊗ Q2 ⊗ P3.
S3 = I0 ⊗ Z1 ⊗ Z2 ⊗ I3.
These act on different qubits for qubits 0 and 3 clearly commute. So the commutativity condition is that [Q1, Z1] and [Q2, Z2] must be such that overall they commute. Actually, since these are tensor products, [E_total, S3] = 0 if and only if [Q1, Z1]=0 and [Q2, Z2]=0. Because if either anticommutes, then overall they will anticommute because signs multiply? Let&rsquo;s check: If Q1 anticommutes with Z1 but Q2 commutes with Z2, then E_total S3 = (P0)⊗(Q1Z1)⊗(Q2Z2)⊗(P3) and S3 E_total = (P0)⊗(Z1Q1)⊗(Z2Q2)⊗(P3) = (P0)⊗(-Q1Z1)⊗(Q2Z2)⊗(P3) = - E_total S3. So indeed, we need [Q1, Z1]=0 and [Q2, Z2]=0. So that means that Q1 must commute with Z1, so Q1 cannot be X or Y? Actually, X anticommutes with Z, Y anticommutes with Z. So Q1 must be either I or Z. Similarly, Q2 must be either I or Z.
So condition from S3: Q1 ∈ {I, Z} and Q2 ∈ {I, Z}.</p>
<p>Next, condition from S4: [E_total, I0X1X2I3] = 0.
Similarly, this gives that [Q1, X1]=0 and [Q2, X2]=0. So Q1 must commute with X1, so Q1 cannot be Z or Y? Actually, Z anticommutes with X, Y anticommutes with X. So Q1 must be either I or X.
Combining with S3 condition, Q1 must be such that it commutes with both Z and X. The only Pauli that commutes with both X and Z is I (because X and Z themselves do not commute with each other). So Q1 must be I.
Similarly, Q2 must be I.
So conditions from S3 and S4 together force that Q1 = I and Q2 = I.
That is very strong! That would mean that E2 must be the identity on qubits 1 and 2. But wait, is that true? Let&rsquo;s check with an example. Consider E_total = X0X1X2X3 itself. That is S1. That commutes with all stabilizers. In that case, Q1 would be X and Q2 would be X. But that violates the condition because X does not commute with Z? But wait, check S3: S3 = IZZI. X and Z anticommute on each qubit. But then overall, would that cause anticommutation? For E_total = X0X1X2X3 and S3 = I0Z1Z2I3, they actually commute because on qubits 1 and 2, we have X1X2 and Z1Z2. And X1 anticommutes with Z1 gives a factor -1, X2 anticommutes with Z2 gives another -1, product (-1)<em>(-1)=1. So wait, my earlier reasoning about conditions from S3 needs to be careful. When we have operators that act on multiple qubits, the commutativity condition is that the operators commute if they anticommute on an even number of qubits. So for S3, we need that the number of qubits among {1,2} for which Q anticommutes with Z should be even. So condition from S3: For qubits 1 and 2, we need that the product of the signs from anticommutation is +1. That is: if Q1 anticommutes with Z1, that gives a factor -1; if Q2 anticommutes with Z2, that gives a factor -1; so overall, if both anticommute, then (-1)</em>(-1)=+1. So actually, the condition from S3 is that Q1 and Q2 must either both commute with Z or both anticommute with Z. Because if one commutes and the other anticommutes, then overall they anticommute. So from S3: either (Q1 commutes with Z1 and Q2 commutes with Z2) OR (Q1 anticommutes with Z1 and Q2 anticommutes with Z2).
Similarly, from S4: either (Q1 commutes with X1 and Q2 commutes with X2) OR (Q1 anticommutes with X1 and Q2 anticommutes with X2).</p>
<p>Now, what Paulis commute with Z? I and Z commute with Z. X and Y anticommute with Z.
What Paulis commute with X? I and X commute with X. Z and Y anticommute with X.
So for the first case from S3: both commute with Z means Q1,Q2 ∈ {I, Z}.
For the second case from S3: both anticommute with Z means Q1,Q2 ∈ {X, Y}.</p>
<p>Now from S4: first case: both commute with X means Q1,Q2 ∈ {I, X}.
Second case: both anticommute with X means Q1,Q2 ∈ {Z,}.</p>
<p>So combining S3 and S4 conditions:
We need that either:
Case 1: (Q1,Q2 both commute with Z) and (Q1,Q2 both commute with X). The only possibility for that is Q1,Q2 must be I because Z does not commute with X. So that gives Q1=Q2=I.
Case 2: (Q1,Q2 both commute with Z) and (Q1,Q2 both anticommute with X). For anticommute with X, that means Q1,Q2 ∈ {Z, Y} actually wait: anticommute with X means: I and X commute with X, so they are out. Z anticommutes with X, Y anticommutes with X. So that set is {Z, Y}. But wait, also they must commute with Z from case 2 of S3? Case 2 of S3 would be both anticommute with Z, not commute with Z. So careful:</p>
<p>Let&rsquo;s do it systematically:</p>
<p>S3 gives two possibilities:
A: Q1 and Q2 are such that they both commute with Z. So that means Q1,Q2 ∈ {I, Z}.
B: Q1 and Q2 are such that they both anticommute with Z. So that means Q1,Q2 ∈ {X, Y}.</p>
<p>S4 gives two possibilities:
C: Q1 and Q2 are such that they both commute with X. So that means Q1,Q2 ∈ {I, X}.
D: Q1 and Q2 are such that they both anticommute with X. So that means Q1,Q2 ∈ {Z, Y}.</p>
<p>So the conditions are that ( from S3 and S4 ) must be</p>
                      </div>
                    </details>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>First, I need to find the physical state fidelity of the final state after the circuit with errors. The circuit has two CNOT gates, each followed by a depolarizing error channel with error probability p. The errors are on specific qubit pairs: after CNOT_{21}, error on qubits {2,1}, and after CNOT_{03}, error on qubits {0,3}.</p>
<p>From my earlier reasoning, the overall effect is that the final state is acted upon by the product of the two errors: E_total = E4 * E2, where E4 is on {0,3} and E2 is on {1,2}. The ideal state is |ψ_ideal⟩, and the actual state is E_total |ψ_ideal⟩ for a specific error pattern.</p>
<p>The fidelity F is the average over all error patterns of |⟨ψ_ideal| E_total |ψ_ideal⟩|^2. Since |ψ_ideal⟩ is a stabilizer state, |⟨ψ_ideal| P |ψ_ideal⟩|^2 is 1 if P is in the stabilizer group of |ψ_ideal⟩, and 0 otherwise.</p>
<p>So, I need to find the probability that E_total is in the stabilizer group of |ψ_ideal⟩.</p>
<p>The stabilizer group of |ψ_ideal⟩ has 16 elements. I need to determine for which pairs (E4, E2) the product E4 ⊗ E2 is in this stabilizer group.</p>
<p>E4 is a Pauli operator on qubits {0,3}, and E2 is a Pauli operator on qubits {1,2}. Each can be one of 16 possible Pauli operators (including identity). The probability distribution is: for each error location, with probability 1-p, no error (identity), and with probability p, one of the 15 non-identity Pauli errors, each with probability p/15.</p>
<p>So, for E4, P(E4 = I) = 1-p, and for each non-identity, P(E4 = P) = p/15 for P in the set of 15 non-identity Paulis on two qubits.</p>
<p>Similarly for E2.</p>
<p>Now, I need to find how many pairs (E4, E2) make E4 ⊗ E2 a stabilizer element.</p>
<p>From the stabilizer generators, I found that the stabilizer elements can be written as products of S1, S2, S3, S4. After some work, I recall that for the [[4,2,2]] code, the stabilizer group includes operators that are products of XXXX and ZZZZ, but also other combinations.</p>
<p>From the conditions using commutativity with stabilizers, I derived that for E_total to be in the stabilizer, E2 must be such that it acts equally on both qubits 1 and 2 in terms of Pauli type. Specifically, from S3 and S4, I need that Q1 and Q2 are both I, both X, both Z, or both Y. Because if they are both X or both Y, they anticommute with Z together, commute with X together? Let&rsquo;s see.</p>
<p>From S3: [E_total, IZZI] = 0 requires that the number of qubits where Q anticommutes with Z is even, so Q1 and Q2 must both commute with Z or both anticommute with Z. Similarly for S4 with X.</p>
<p>So for qubits 1 and 2, E2 must be such that Q1 and Q2 are both I or both Z (commute with Z) or both X or both Y (anticommute with Z). But for S4, they must both commute with X or both anticommute with X.</p>
<p>Now, if both commute with X, that means both are I or X. If both anticommute with X, that means both are Z or Y.</p>
<p>Similarly for Z: both commute with Z means both are I or Z; both anticommute with Z means both are X or Y.</p>
<p>So to satisfy both, we need that the choice for (Q1,Q2) must be such that they are both in the set that satisfies both conditions simultaneously.</p>
<p>Case 1: both commute with X and both commute with Z. The only Pauli that commutes with both X and Z is I. So both must be I. So E2 = I ⊗ I.</p>
<p>Case 2: both commute with X and both anticommute with Z. Commute with X means I or X, anticommute with Z means X or Y. Intersection is X. So both must be X. So E2 = X ⊗ X.</p>
<p>Case 3: both anticommute with X and both commute with Z. Anticommute with X means Z or Y, commute with Z means I or Z. Intersection is Z. So both must be Z. So E2 = Z ⊗ Z.</p>
<p>Case 4: both anticommute with X and both anticommute with Z. Anticommute with X means Z or Y, anticommute with Z means X or Y. Intersection is Y. So both must be Y. So E2 = Y ⊗ Y.</p>
<p>Therefore, for E2 to satisfy the conditions with S3 and S4, it must be that E2 is one of: I⊗I, X⊗X, Z⊗Z, or Y⊗Y. That is, E2 must be identity or the same Pauli on both qubits.</p>
<p>Now, similarly for E4? But wait, E4 acts on qubits 0 and 3, and the stabilizer conditions involve S1 and S2, which are XXXX and ZZZZ, so they involve all qubits. But from S1 and S2, we can derive conditions for E4.</p>
<p>Consider S1 = XXXX. For E_total to commute with S1, since E_total = E4 ⊗ E2, and S1 = X⊗X⊗X⊗X, which is X on all qubits. So [E_total, S1] = 0 requires that the number of qubits where P anticommutes with X is even. Since E4 acts on qubits 0 and 3, and E2 acts on 1 and 2, we need that the total number from both groups where the Pauli anticommutes with X is even.</p>
<p>Similarly for S2 = ZZZZ, need even number of anticommutes with Z.</p>
<p>But we already have conditions on E2 from S3 and S4, which force E2 to be one of the four types: II, XX, ZZ, YY.</p>
<p>Now, for each type of E2, what must E4 be for E_total to commute with S1 and S2?</p>
<p>Let&rsquo;s denote E2 type. Since E2 is fixed to one of these, we can compute the contribution to the anticommutation with X and Z.</p>
<p>First, recall that for S1, we need that the product of signs from anticommutation with X is positive.</p>
<p>For a Pauli operator, it anticommutes with X if it is Z or Y, and commutes if it is I or X.</p>
<p>Similarly for Z: anticommutes with Z if it is X or Y, commutes if I or Z.</p>
<p>Now, for E2:</p>
<ul>
<li>
<p>If E2 = I⊗I, then on qubits 1 and 2, both commute with X and both commute with Z. So no anticommutation with X or Z from E2.</p>
</li>
<li>
<p>If E2 = X⊗X, then on qubits 1 and 2, both commute with X (since X commutes with X), and both anticommute with Z (since X anticommutes with Z). So for S1, since they commute with X, no issue. For S2, they anticommute with Z, so that contributes a factor of (-1) for each, so (-1)<em>(-1)=1, so overall commute with Z? Wait, for S2, we need commute with ZZZZ, which means the product of signs should be +1. Since each anticommutation gives -1, two anticommutations give (-1)</em>(-1)=1, so yes, they commute with ZZZZ because even number.</p>
</li>
</ul>
<p>Similarly, if E2 = Z⊗Z, then on qubits 1 and 2, both anticommute with X (Z anticommutes with X), and both commute with Z. So for S1, they anticommute with X, so two anticommutations give (-1)*(-1)=1, so commute with XXXX. For S2, they commute with Z, so no issue.</p>
<p>If E2 = Y⊗Y, then on qubits 1 and 2, both anticommute with X (Y anticommutes with X) and both anticommute with Z (Y anticommutes with Z). So for S1, two anticommutations with X give (-1)<em>(-1)=1, so commute. For S2, two anticommutations with Z give (-1)</em>(-1)=1, so commute.</p>
<p>So, for any of these four types of E2, E2 alone commutes with S1 and S2? Let&rsquo;s check explicitly:</p>
<p>S1 = XXXX, so with E2=X⊗X, then S1 E2 = X⊗X⊗X⊗X * X⊗X on qubits 1,2? Actually, careful: E2 acts on qubits 1 and 2, so S1 acts on all, so [S1, E2] = [X1X2, E2] since other terms commute. E2=X⊗X, so [X1, X1]=0, [X2,X2]=0, so commute. Similarly for Z⊗Z: [Z1Z2, Z⊗Z]=0. For Y⊗Y: Y anticommutes with X? X1 and Y1 anticommute, so [X1, Y1] = -2Y1X1? Actually, better: X1 Y1 = -Y1 X1, so for two qubits, X1X2 and Y1Y2: X1X2 Y1Y2 = X1 Y1 X2 Y2 = (-Y1X1)(-Y2X2) = Y1X1 Y2X2? Let&rsquo;s compute product: S1 E2 = (X0X1X2X3)(Y1Y2) but E2 acts only on 1 and2, so on qubit1, X1 Y1 = -Y1 X1, on qubit2, X2 Y2 = -Y2 X2, so S1 E2 = X0 X3 (X1Y1)(X2Y2) = X0X3 (-Y1X1)(-Y2X2) = X0X3 Y1X1 Y2X2 = Y1Y2 X0X1X2X3? Actually, since X0 and X3 commute with Y1 and Y2, we have S1 E2 = X0X3 (-Y1X1)(-Y2X2) = X0X3 (Y1X1)(Y2X2) = Y1Y2 X0X1X2X3 = E2 S1? Because E2 S1 = Y1Y2 X0X1X2X3, so yes, they commute. Similarly for S2. So indeed, for E2 being II, XX, ZZ, YY, it commutes with S1 and S2.</p>
<p>Therefore, the only conditions for E_total to be in the stabilizer come from E2必须 be one of these four types, and then E4 must be such that it also allows commutation with S1 and S2, but since E2 already commutes, we need E4 to commute with S1 and S2 on its own? Not necessarily, because S1 and S2 involve all qubits, but since E2 commutes, the commutation of E_total with S1 depends on both E4 and E2.</p>
<p>But from above, since E2 commutes with S1 and S2 for these types, then for E_total to commute with S1, we need that E4 commutes with the part of S1 on qubits 0 and 3? S1 = X0 X1 X2 X3, but when commuting with E_total = E4 ⊗ E2, since E2 commutes with X1X2? Actually, let&rsquo;s think carefully.</p>
<p>We need [E_total, S1] = 0. Since E_total = E4 ⊗ E2 and S1 = X0 X1 X2 X3, and E2 commutes with X1X2 (as we saw for these types), then [E_total, S1] = [E4, X0X3] ⊗ [E2, X1X2] but since [E2, X1X2]=0 for these E2, then [E_total, S1] = [E4, X0X3] ⊗ something that is zero only if [E4, X0X3]=0. Similarly for S2, we need [E4, Z0Z3]=0.</p>
<p>Therefore, for E_total to commute with S1 and S2, we need that E4 commutes with X0X3 and with Z0Z3.</p>
<p>Now, what does it mean for E4 to commute with X0X3? E4 is a Pauli on qubits 0 and 3. X0X3 means X on both qubits. So [E4, X0X3] = 0 if E4 has an even number of anticommutations with X on qubits 0 and 3. Similarly, [E4, Z0Z3] = 0 if even number of anticommutations with Z on qubits 0 and 3.</p>
<p>But since E4 is a two-qubit Pauli, let&rsquo;s see when it commutes with X0X3.</p>
<p>X0X3 acts as X on both qubits. So for E4 to commute with X0X3, the Pauli on each qu must commute with X on that qu? Not exactly, because it&rsquo;s a tensor product. Actually, since X0X3 = X0 ⊗ X3, and E4 = P0 ⊗ P3, then [E4, X0X3] = [P0, X0] ⊗ [P3, X3] wait no, because they act on different qubits, so [P0 ⊗ P3, X0 ⊗ X3] = [P0, X0] ⊗ P3 X3 + X0 P0 ⊗ [P3, X3]? Better to think that for commute, we need that the operators commute on each qubit independently? No, because they are tensor products, they commute if and only if [P0, X0] = 0 and [P3, X3] = 0, or if both anticommute, then overall they commute because (-1)*(-1)=1.</p>
<p>Actually, for two qubits, [P0 ⊗ P3, X0 ⊗ X3] = P0 X0 ⊗ P3 X3 - X0 P0 ⊗ X3 P3 = [P0, X0] ⊗ P3 X3 + X0 P0 ⊗ [P3, X3]? This is messy.</p>
<p>easier: since the operators act on different qubits, the commutator is zero if for each qubit, the operators commute, or if for each qubit, they anticommute, but since it&rsquo;s a product, the overall commutator is zero if the number of qubits where they anticommute is even.</p>
<p>So [E4, X0X3] = 0 if the number of qubits where P anticommutes with X is even. Since there are two qubits, that means either both commute with X or both anticommute with X.</p>
<p>Similarly for [E4, Z0Z3], need both commute with Z or both anticommute with Z.</p>
<p>So for E4 to commute with X0X3 and Z0Z3, we need that on qubits 0 and 3, the Paulis are such that they are both in the set that commutes with X or both anticommute with X, and both commute with Z or both anticommute with Z.</p>
<p>But this is exactly the same condition as for E2 with S3 and S4? So similarly, for E4 to commute with X0X3 and Z0Z3, it must be that E4 is one of: I⊗I, X⊗X, Z⊗Z, or Y⊗Y.</p>
<p>But wait, is that sufficient? Let&rsquo;s verify.</p>
<p>If E4 = I⊗I, then it commutes with X0X3 and Z0Z3 obviously.</p>
<p>If E4 = X⊗X, then with X0X3: X commutes with X, so both commute, so commute. With Z0Z3: X anticommutes with Z, so both anticommute, so (-1)*(-1)=1, so commute.</p>
<p>If E4 = Z⊗Z, then with X0X3: Z anticommutes with X, so both anticommute, so commute. With Z0Z3: Z commutes with Z, so commute.</p>
<p>If E4 = Y⊗Y, then with X0X3: Y anticommutes with X, so both anticommute, so commute. With Z0Z3: Y anticommutes with Z, so both anticommute, so commute.</p>
<p>So yes, for E4 to commute with X0X3 and Z0Z3, it must be that E4 is one of these four types: II, XX, ZZ, YY on qubits 0 and 3.</p>
<p>Therefore, for E_total to be in the stabilizer, we need that both E4 and E2 are one of these four types: identity, same X on both, same Z on both, or same Y on both.</p>
<p>But is this also sufficient for commutation with S3 and S4? S3 and S4 only involve qubits 1 and 2, and we already have that E2 is one of these types, which ensures commutation with S3 and S4, as we saw earlier.</p>
<p>So, in summary, E_total is in the stabilizer if and only if E4 is in { I⊗I, X⊗X, Z⊗Z, Y⊗Y } on {0,3} and E2 is in { I⊗I, X⊗X, Z⊗Z, Y⊗Y } on {1,2}.</p>
<p>Now, we need to find the probability that this happens.</p>
<p>First, for E4: it is a Pauli on two qubits. The probability that E4 is identity is P(E4 = I) = 1-p.</p>
<p>The probability that E4 is one of the specific Pauli errors that are in the set {X⊗X, Z⊗Z, Y⊗Y}. But note that there are 15 non-identity Pauli errors, but only some of them are these.</p>
<p>How many Pauli errors are there that are of the form same Pauli on both qubits? That is, for Pauli being X, Y, Z, we have X⊗X, Y⊗Y, Z⊗Z. So there are 3 such errors.</p>
<p>But wait, are there others? What about I⊗X? That is not the same on both. So only these three non-identity errors are of the form same Pauli on both qubits.</p>
<p>Similarly for E2.</p>
<p>So, for E4, the probability that it is in the desired set is: P(E4 = I) + P(E4 = X⊗X) + P(E4 = Z⊗Z) + P(E4 = Y⊗Y)</p>
<p>P(E4 = I) = 1-p</p>
<p>P(E4 = X⊗X) = probability of error being X⊗X. Since errors are equally likely among 15 non-identity, P(specific non-identity) = p/15. So P(X⊗X) = p/15</p>
<p>Similarly, P(Z⊗Z) = p/15</p>
<p>P(Y⊗Y) = p/15</p>
<p>So total P(E4 desired) = (1-p) + 3*(p/15) = 1-p + 3p/15 = 1-p + p/5 = 1 - (4/5)p</p>
<p>Similarly for E2, P(E2 desired) = 1 - (4/5)p</p>
<p>Since E4 and E2 are independent, the probability that both are desired is the product.</p>
<p>Therefore, P(E_total in stabilizer) = [1 - (4/5)p] * [1 - (4/5)p] = [1 - (4/5)p]^2</p>
<p>And since fidelity F is this probability, because when E_total is in stabilizer, fidelity is 1, else 0.</p>
<p>So F = [1 - (4/5)p]^2</p>
<p>But is this correct? Let me verify with a small example.</p>
<p>If p=0, no errors, then F=1, good.</p>
<p>If p=1, always errors, then F=[1-4/5]^2 = (1/5)^2 = 1/25. But is that right? If p=1, then each CNOT has an error, and errors are random among 15 options. The probability that both errors are in the desired sets would be (3/15) for E4 and similarly for E2, so (3/15)<em>(3/15) = (1/5)</em>(1/5)=1/25, yes.</p>
<p>So seems correct.</p>
<p>Therefore, the physical state fidelity is F = (1 - 4p/5)^2</p>
<p>Now, I need to write this in SymPy for the code.</p>
<p>So, in the function, I should return (1 - 4<em>p/5)</em>*2</p>
<p>But let&rsquo;s write it properly.</p>
<p>F_physical = (1 - (4/5)<em>p)</em>*2</p>
<p>In SymPy, I can use symbols.</p>
<p>So, in the code template:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div>

<p>But wait, I need to make sure that this is correct for the problem. The problem asks for the physical state fidelity, and I think I have it.</p>
<p>Also, note that the errors are applied after each CNOT, and I used the fact that they commute to the end, which seems valid.</p>
<p>So, I think this is the answer.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>The physical state fidelity of the final state is derived based on the probability that the combined errors from both CNOT gates result in an operator that lies within the stabilizer group of the ideal state. The errors are independent and each CNOT gate has a depolarizing error channel with error probability <span class="arithmatex">\(p\)</span>. The fidelity is given by <span class="arithmatex">\(F = \left(1 - \frac{4}{5}p\right)^2\)</span>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.448981
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>