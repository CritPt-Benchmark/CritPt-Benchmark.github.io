<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># We&#39;ll enumerate all possible two-qubit Pauli errors inserted after each of 5 CNOT gates</span>
<span class="c1"># and compute the exact analytic (symbolic-by-counting) fidelity under post-selection.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="c1"># Qubits: 0,1,2,3 are data; 4 is ancilla</span>
<span class="n">nq</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Represent Paulis by (X_bits, Z_bits), each a list of 0/1 of length nq. Phase ignored.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_id</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>

<span class="c1"># Multiply two Paulis modulo phase: XOR X and Z bits</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_mul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">X1</span><span class="p">,</span> <span class="n">Z1</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">X2</span><span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">q</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x1</span> <span class="o">^</span> <span class="n">x2</span> <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">)],</span> <span class="p">[</span><span class="n">z1</span> <span class="o">^</span> <span class="n">z2</span> <span class="k">for</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Z1</span><span class="p">,</span> <span class="n">Z2</span><span class="p">)]</span>

<span class="c1"># Conjugate Pauli by CNOT(control -&gt; target)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_cnot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">p</span>
    <span class="c1"># Copy to avoid in-place hazards</span>
    <span class="n">Xc</span><span class="p">,</span> <span class="n">Xt</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="n">Zc</span><span class="p">,</span> <span class="n">Zt</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="c1"># Mapping (Aaronson-Gottesman):</span>
    <span class="c1"># X_c -&gt; X_c, X_t -&gt; X_t ^ X_c</span>
    <span class="c1"># Z_c -&gt; Z_c ^ Z_t, Z_t -&gt; Z_t</span>
    <span class="n">X</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xt</span> <span class="o">^</span> <span class="n">Xc</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zc</span> <span class="o">^</span> <span class="n">Zt</span>
    <span class="c1"># X[c] and Z[t] unchanged otherwise</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>

<span class="c1"># Build single-qubit Pauli given symbol: &#39;I&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39; on a given qubit</span>

<span class="k">def</span><span class="w"> </span><span class="nf">single_pauli</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>
    <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
        <span class="n">X</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>
    <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
        <span class="n">Z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>
    <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span>
        <span class="n">X</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad sym&#39;</span><span class="p">)</span>

<span class="c1"># Build two-qubit Pauli on qubits (qa, qb) as tensor product Pa*Pb</span>

<span class="k">def</span><span class="w"> </span><span class="nf">twoq_pauli</span><span class="p">(</span><span class="n">sym_a</span><span class="p">,</span> <span class="n">qa</span><span class="p">,</span> <span class="n">sym_b</span><span class="p">,</span> <span class="n">qb</span><span class="p">):</span>
    <span class="n">Xa</span><span class="p">,</span> <span class="n">Za</span> <span class="o">=</span> <span class="n">single_pauli</span><span class="p">(</span><span class="n">sym_a</span><span class="p">,</span> <span class="n">qa</span><span class="p">)</span>
    <span class="n">Xb</span><span class="p">,</span> <span class="n">Zb</span> <span class="o">=</span> <span class="n">single_pauli</span><span class="p">(</span><span class="n">sym_b</span><span class="p">,</span> <span class="n">qb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pauli_mul</span><span class="p">((</span><span class="n">Xa</span><span class="p">,</span> <span class="n">Za</span><span class="p">),</span> <span class="p">(</span><span class="n">Xb</span><span class="p">,</span> <span class="n">Zb</span><span class="p">))</span>

<span class="c1"># CNOT gates sequence indices and their qubits in time order after H_1</span>
<span class="c1"># Gate list: C1: (1-&gt;2), C2: (1-&gt;0), C3: (2-&gt;3), C4: (3-&gt;4), C5: (0-&gt;4)</span>
<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">ng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnots</span><span class="p">)</span>

<span class="c1"># Build the list of 16 two-qubit Paulis for a given pair of qubits: identity + 15 non-identity.</span>
<span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">twoq_pauli_list</span><span class="p">(</span><span class="n">qa</span><span class="p">,</span> <span class="n">qb</span><span class="p">):</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">twoq_pauli</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">qa</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">qb</span><span class="p">))</span>
    <span class="c1"># identity as index 0 separately</span>
    <span class="k">return</span> <span class="n">plist</span>

<span class="c1"># Precompute for each gate i, the 16 possibilities (0=identity, 1..15 non-identity) propagated to the end</span>
<span class="n">precomp</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
    <span class="c1"># Build 16 entries</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># idx 0: identity</span>
    <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pauli_id</span><span class="p">())</span>
    <span class="c1"># 15 non-identity two-qubit Paulis on qubits c,t</span>
    <span class="n">nonids</span> <span class="o">=</span> <span class="n">twoq_pauli_list</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">nonids</span><span class="p">:</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">P</span><span class="p">]</span>
        <span class="c1"># Conjugate by subsequent CNOTs j&gt;i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ng</span><span class="p">):</span>
            <span class="n">cj</span><span class="p">,</span> <span class="n">tj</span> <span class="o">=</span> <span class="n">cnots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">conj_cnot</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">),</span> <span class="n">cj</span><span class="p">,</span> <span class="n">tj</span><span class="p">)</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span>
    <span class="n">precomp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="c1"># Helper: compute commutation of Pauli P with Q given by (XQ,ZQ): returns 0 if commute, 1 if anticommute</span>
<span class="c1"># Using symplectic product over all qubits.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">commutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
    <span class="n">XP</span><span class="p">,</span> <span class="n">ZP</span> <span class="o">=</span> <span class="n">P</span>
    <span class="n">XQ</span><span class="p">,</span> <span class="n">ZQ</span> <span class="o">=</span> <span class="n">Q</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nq</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">^=</span> <span class="p">(</span><span class="n">XP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ZQ</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">^</span> <span class="p">(</span><span class="n">ZP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">XQ</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Build stabilizers and logical operators on data only, promoted to 5 qubits (ancilla idle)</span>
<span class="c1"># Sx = XXXX on qubits 0..3</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Sz</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># Z_A = ZZII (qubits 0,1)</span>
<span class="n">ZA</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># Z_B = ZIZI (qubits 0,2)</span>
<span class="n">ZB</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Acceptance and correctness counters by number of faulty gates k</span>
<span class="n">c_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ng</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c_cor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ng</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Enumerate over all 16 choices per gate: 0=identity, 1..15 non-identity</span>
<span class="c1"># To speed up, we&#39;ll do 5 nested loops but with integers; Should be fine.</span>

<span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ng</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">build_total</span><span class="p">(</span><span class="n">idx_tuple</span><span class="p">):</span>
    <span class="c1"># XOR the contributions</span>
    <span class="n">Xtot</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">Ztot</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_tuple</span><span class="p">):</span>
        <span class="n">Xp</span><span class="p">,</span> <span class="n">Zp</span> <span class="o">=</span> <span class="n">precomp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">Xtot</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Xtot</span><span class="p">,</span> <span class="n">Xp</span><span class="p">)]</span>
        <span class="n">Ztot</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ztot</span><span class="p">,</span> <span class="n">Zp</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Xtot</span><span class="p">,</span> <span class="n">Ztot</span><span class="p">)</span>

<span class="c1"># We&#39;ll iterate and count.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="k">for</span> <span class="n">idx_tuple</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">choices</span><span class="p">):</span>
    <span class="c1"># Count faulty gates</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx_tuple</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Quickly skip if too many? No, count all.</span>
    <span class="n">Xtot</span><span class="p">,</span> <span class="n">Ztot</span> <span class="o">=</span> <span class="n">build_total</span><span class="p">(</span><span class="n">idx_tuple</span><span class="p">)</span>
    <span class="n">Ptot</span> <span class="o">=</span> <span class="p">(</span><span class="n">Xtot</span><span class="p">,</span> <span class="n">Ztot</span><span class="p">)</span>
    <span class="c1"># Ancilla acceptance: X bit on qubit 4 must be 0 (no X/Y on ancilla)</span>
    <span class="k">if</span> <span class="n">Xtot</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="c1"># Data acceptance: commute with Sx and Sz</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span> <span class="n">Sx</span><span class="p">):</span>
        <span class="k">continue</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span> <span class="n">Sz</span><span class="p">):</span>
        <span class="k">continue</span>
    <span class="c1"># Accepted</span>
    <span class="n">c_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Correct if commute with ZA and ZB as well</span>
    <span class="k">if</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span> <span class="n">ZA</span><span class="p">)</span> <span class="ow">and</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span> <span class="n">ZB</span><span class="p">):</span>
        <span class="n">c_cor</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">c_acc</span><span class="p">,</span> <span class="n">c_cor</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>&#39;&#39;
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing...&#39;</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="n">nq</span><span class="o">=</span><span class="mi">5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_id</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_mul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">X1</span><span class="p">,</span> <span class="n">Z1</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">X2</span><span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">q</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x1</span> <span class="o">^</span> <span class="n">x2</span> <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">)],</span> <span class="p">[</span><span class="n">z1</span> <span class="o">^</span> <span class="n">z2</span> <span class="k">for</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Z1</span><span class="p">,</span> <span class="n">Z2</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_cnot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">Xc</span><span class="p">,</span> <span class="n">Xt</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="n">Zc</span><span class="p">,</span> <span class="n">Zt</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="n">X</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xt</span> <span class="o">^</span> <span class="n">Xc</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zc</span> <span class="o">^</span> <span class="n">Zt</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>

<span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">single_pauli</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>
    <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
        <span class="n">X</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
        <span class="n">Z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span>
        <span class="n">X</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Z</span>

<span class="k">def</span><span class="w"> </span><span class="nf">twoq_pauli</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">qa</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">qb</span><span class="p">):</span>
    <span class="n">Xa</span><span class="p">,</span> <span class="n">Za</span> <span class="o">=</span> <span class="n">single_pauli</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">qa</span><span class="p">)</span>
    <span class="n">Xb</span><span class="p">,</span> <span class="n">Zb</span> <span class="o">=</span> <span class="n">single_pauli</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">qb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pauli_mul</span><span class="p">((</span><span class="n">Xa</span><span class="p">,</span> <span class="n">Za</span><span class="p">),</span> <span class="p">(</span><span class="n">Xb</span><span class="p">,</span> <span class="n">Zb</span><span class="p">))</span>

<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">ng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnots</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">twoq_pauli_list</span><span class="p">(</span><span class="n">qa</span><span class="p">,</span> <span class="n">qb</span><span class="p">):</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">twoq_pauli</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">qa</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">qb</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">plist</span>

<span class="n">precomp</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pauli_id</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">twoq_pauli_list</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="n">X</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">P</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ng</span><span class="p">):</span>
            <span class="n">cj</span><span class="p">,</span> <span class="n">tj</span> <span class="o">=</span> <span class="n">cnots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">X</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">conj_cnot</span><span class="p">((</span><span class="n">X</span><span class="p">,</span><span class="n">Z</span><span class="p">),</span> <span class="n">cj</span><span class="p">,</span> <span class="n">tj</span><span class="p">)</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span>
    <span class="n">precomp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="c1"># Build operators</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Sz</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ZA</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ZB</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">commutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">XP</span><span class="p">,</span><span class="n">ZP</span> <span class="o">=</span> <span class="n">P</span>
    <span class="n">XQ</span><span class="p">,</span><span class="n">ZQ</span> <span class="o">=</span> <span class="n">Q</span>
    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nq</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">^=</span> <span class="p">(</span><span class="n">XP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ZQ</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">^</span> <span class="p">(</span><span class="n">ZP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">XQ</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="n">c_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ng</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c_cor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ng</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">idx_tuple</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)]</span><span class="o">*</span><span class="n">ng</span><span class="p">)):</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx_tuple</span> <span class="k">if</span> <span class="n">idx</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Build total</span>
    <span class="n">Xtot</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">Ztot</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_tuple</span><span class="p">):</span>
        <span class="n">Xp</span><span class="p">,</span><span class="n">Zp</span> <span class="o">=</span> <span class="n">precomp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">Xtot</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Xtot</span><span class="p">,</span><span class="n">Xp</span><span class="p">)]</span>
        <span class="n">Ztot</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ztot</span><span class="p">,</span><span class="n">Zp</span><span class="p">)]</span>
    <span class="c1"># acceptance checks</span>
    <span class="k">if</span> <span class="n">Xtot</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="n">Ptot</span><span class="o">=</span><span class="p">(</span><span class="n">Xtot</span><span class="p">,</span><span class="n">Ztot</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span><span class="n">Sx</span><span class="p">):</span>
        <span class="k">continue</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span><span class="n">Sz</span><span class="p">):</span>
        <span class="k">continue</span>
    <span class="n">c_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span><span class="n">ZA</span><span class="p">)</span> <span class="ow">and</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span><span class="n">ZB</span><span class="p">):</span>
        <span class="n">c_cor</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;c_acc:&#39;</span><span class="p">,</span> <span class="n">c_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;c_cor:&#39;</span><span class="p">,</span> <span class="n">c_cor</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Computing...
c_acc: [1, 7, 282, 4222, 31637, 94923]
c_cor: [1, 7, 138, 1198, 7397, 24027]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="n">c_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">282</span><span class="p">,</span> <span class="mi">4222</span><span class="p">,</span> <span class="mi">31637</span><span class="p">,</span> <span class="mi">94923</span><span class="p">]</span>
<span class="n">c_cor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">138</span><span class="p">,</span> <span class="mi">1198</span><span class="p">,</span> <span class="mi">7397</span><span class="p">,</span> <span class="mi">24027</span><span class="p">]</span>

<span class="c1"># Build polynomials N(p), D(p) as lists of coefficients for p^0..p^5</span>
<span class="c1"># N(p) = sum_k c_cor[k]*(p/15)^k*(1-p)^{5-k}</span>
<span class="c1"># (1-p)^{5-k} = sum_{j=0}^{5-k} binom(5-k,j) * (1)^{5-k-j} * (-p)^j</span>
<span class="c1"># So the coefficient for p^{k+j} accumulates c_cor[k]*(1/15)^k * binom(5-k,j) * (-1)^j</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="k">def</span><span class="w"> </span><span class="nf">poly_from_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ck</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="o">-</span><span class="n">k</span><span class="p">):</span>
            <span class="n">deg</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">j</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">deg</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">ck</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">j</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coeffs</span>

<span class="n">N</span> <span class="o">=</span> <span class="n">poly_from_counts</span><span class="p">(</span><span class="n">c_cor</span><span class="p">)</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">poly_from_counts</span><span class="p">(</span><span class="n">c_acc</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N coefficients (p^0..p^5):&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">N</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;D coefficients (p^0..p^5):&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">D</span><span class="p">])</span>

<span class="c1"># Small-p expansion of F(p) up to p^2 or p^3 by series division</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">decimal</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># Let&#39;s also compute numeric coefficients rational to show maybe exact</span>

<span class="c1"># Series division to degree 3</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="c1"># We&#39;ll compute F such that N = D * F modulo p^5; standard power series division</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="c1"># compute F[m]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">-=</span> <span class="n">D</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">F</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">/</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series F coeffs (p^0..p^5):&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="p">])</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>N coefficients (p^0..p^5):
[&#39;1&#39;, &#39;-68/15&#39;, &#39;656/75&#39;, &#39;-29312/3375&#39;, &#39;223232/50625&#39;, &#39;-229376/253125&#39;]
D coefficients (p^0..p^5):
[&#39;1&#39;, &#39;-68/15&#39;, &#39;704/75&#39;, &#39;-32768/3375&#39;, &#39;253952/50625&#39;, &#39;-262144/253125&#39;]
Series F coeffs (p^0..p^5): [&#39;1&#39;, &#39;0&#39;, &#39;-16/25&#39;, &#39;-704/375&#39;, &#39;-10496/3375&#39;, &#39;-216064/84375&#39;]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">decimal</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">50</span>

<span class="n">c_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">282</span><span class="p">,</span> <span class="mi">4222</span><span class="p">,</span> <span class="mi">31637</span><span class="p">,</span> <span class="mi">94923</span><span class="p">]</span>
<span class="n">c_cor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">138</span><span class="p">,</span> <span class="mi">1198</span><span class="p">,</span> <span class="mi">7397</span><span class="p">,</span> <span class="mi">24027</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Acc</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>
    <span class="c1"># direct formula using counts</span>
    <span class="n">res_acc</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">res_cor</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">Decimal</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
        <span class="n">res_acc</span> <span class="o">+=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">c_acc</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span>
        <span class="n">res_cor</span> <span class="o">+=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">c_cor</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span>
    <span class="k">return</span> <span class="n">res_acc</span><span class="p">,</span> <span class="n">res_cor</span><span class="p">,</span> <span class="p">(</span><span class="n">res_cor</span><span class="o">/</span><span class="n">res_acc</span> <span class="k">if</span> <span class="n">res_acc</span><span class="o">!=</span><span class="mi">0</span> <span class="k">else</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.001&#39;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.01&#39;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.05&#39;</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.1&#39;</span><span class="p">)]:</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">Acc</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;p=&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="s1">&#39; Acc=&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39; Cor=&#39;</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="s1">&#39; F=&#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>p= 0.001  Acc= 0.99547604362931159646814814814814814814814814814815  Cor= 0.99547540465270491110716049382716049382716049382716  F= 0.99999935811955418256290517755535495085330744739973
p= 0.01  Acc= 0.95559567435609125925925925925925925925925925925926  Cor= 0.95553269230088849382716049382716049382716049382716  F= 0.99993409131404324887607192865156309294818434670800
p= 0.05  Acc= 0.79561739883456790123456790123456790123456790123457  Cor= 0.79414164669629629629629629629629629629629629629629  F= 0.99814514848414161325117237535713156764181060054879
p= 0.1  Acc= 0.63131557357037037037037037037037037037037037037037  Cor= 0.62588018662716049382716049382716049382716049382716  F= 0.99139038038857437686446388414422675785669421125535
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Code and logical operators</li>
<li>Physical qubits: 0,1,2,3 (data) and 4 (ancilla).</li>
<li>Stabilizers: Sx = XXXX and Sz = ZZZZ on data qubits 0–3.</li>
<li>
<p>Logical operators (up to stabilizers):</p>
<ul>
<li>X_A = X I X I, X_B = X X I I</li>
<li>Z_A = Z Z I I, Z_B = Z I Z I</li>
</ul>
</li>
<li>
<p>Ideal, noiseless state preparation</p>
</li>
<li>Initial state: |00000⟩ (qubits 0–4).</li>
<li>Circuit (right-to-left):
    1) H on qubit 1 creates |+⟩ on qubit 1.
    2) CNOT12 and CNOT10 build a 3-qubit GHZ on 1–2–0.
    3) CNOT23 extends it to a 4-qubit GHZ on 0–1–2–3:
       |ψ_data⟩ = (|0000⟩ + |1111⟩)/√2.
    4) CNOT34 and CNOT04 compute ancilla parity q4 = q3 ⊕ q0. Since GHZ has q0 = q3, q4 = 0 deterministically.</li>
<li>
<p>Thus, in the absence of errors, ancilla measurement M4 in the Z basis yields |0⟩ with certainty and the data are in the code space stabilized by XXXX and ZZZZ, corresponding to the logical state |00⟩AB.</p>
</li>
<li>
<p>Noise model</p>
</li>
<li>After each CNOT gate, a two-qubit depolarizing error occurs with probability p: one of the 15 non-identity two-qubit Paulis is applied uniformly with probability p/15; with probability 1 − p, the identity is applied.</li>
<li>
<p>Only the five CNOTs are noisy; H and the measurement are ideal.</p>
</li>
<li>
<p>Pauli propagation and acceptance criteria</p>
</li>
<li>Because the circuit is Clifford and the noise is Pauli, all faults can be pushed to the end of the circuit by conjugation. For a given error pattern, the net effect is a single 5-qubit Pauli Ptot applied right before the ancilla measurement to the ideal state |ψ_data⟩ ⊗ |0⟩4.</li>
<li>Acceptance consists of:
    1) Ancilla post-selection M4 = |0⟩: since the ideal ancilla is |0⟩ and Ptot acts at the end, this is accepted if and only if the ancilla Pauli is I or Z (i.e., no X or Y on qubit 4).
    2) “All detectable code errors” are post-selected away by (conceptually) measuring Sx = XXXX and Sz = ZZZZ on the data and keeping only +1 outcomes. Since Ptot acts at the end on |ψ_data⟩, this acceptance is deterministic: keep the event if and only if Pdata (the restriction of Ptot to qubits 0–3) commutes with both Sx and Sz. Equivalently, in symplectic terms,<ul>
<li>commute with Sx iff the number of Z or Y on data is even,</li>
<li>commute with Sz iff the number of X or Y on data is even.</li>
</ul>
</li>
<li>
<p>Logical correctness among accepted events:</p>
<ul>
<li>Within the normalizer N(S) (commuting with both stabilizers), the final logical state equals a logical Pauli acting on |00⟩AB. This final state is correct iff the applied logical Pauli has no X component on A or B, i.e., iff Pdata commutes with Z_A and Z_B. Equivalently, Pdata ∈ S × ⟨Z_A, Z_B⟩.</li>
</ul>
</li>
<li>
<p>Exact counting by exhaustive Pauli propagation</p>
</li>
<li>We enumerated all 16^5 error choices (16 per CNOT: identity + 15 Paulis) and, for each choice:<ul>
<li>Pushed each two-qubit Pauli through the subsequent CNOTs by conjugation,</li>
<li>Multiplied all contributions to obtain Ptot on the 5 qubits,</li>
<li>Applied the acceptance rules above,</li>
<li>Tested logical correctness by commutation with Z_A and Z_B.</li>
</ul>
</li>
<li>Let c_acc[k] be the number of accepted error patterns with exactly k non-identity gate errors, and c_cor[k] the number of those that are also logically correct. The exact counts are:<ul>
<li>c_acc = [1, 7, 282, 4222, 31637, 94923]</li>
<li>c_cor = [1, 7, 138, 1198, 7397, 24027]</li>
</ul>
</li>
<li>
<p>Interpretation:</p>
<ul>
<li>There are 5 × 15 = 75 single-fault possibilities; of these, 68 are rejected (by the ancilla flag or by stabilizer checks) and the remaining 7 are accepted but benign (make no logical error on |00⟩AB). Hence all first-order faults are either caught or harmless: this is the hallmark of fault-tolerant, distance-2 state preparation.</li>
</ul>
</li>
<li>
<p>Exact fidelity as a function of p</p>
</li>
<li>The total acceptance probability is</li>
</ul>
<div class="arithmatex">\[
D(p) \equiv \sum_{k=0}^{5} c_{\mathrm{acc}}[k] \left(\frac{p}{15}\right)^k (1-p)^{5-k}.
\]</div>
<ul>
<li>The accepted-and-correct weight is</li>
</ul>
<div class="arithmatex">\[
N(p) \equiv \sum_{k=0}^{5} c_{\mathrm{cor}}[k] \left(\frac{p}{15}\right)^k (1-p)^{5-k}.
\]</div>
<ul>
<li>The post-selected logical state fidelity is the ratio</li>
</ul>
<div class="arithmatex">\[
F(p) = \frac{N(p)}{D(p)}.
\]</div>
<ul>
<li>Expanding both polynomials gives the closed forms</li>
</ul>
<div class="arithmatex">\[
    N(p) &amp;= 1 - \frac{68}{15} p + \frac{656}{75} p^2 - \frac{29312}{3375} p^3 + \frac{223232}{50625} p^4 - \frac{229376}{253125} p^5, \\\\
    D(p) &amp;= 1 - \frac{68}{15} p + \frac{704}{75} p^2 - \frac{32768}{3375} p^3 + \frac{253952}{50625} p^4 - \frac{262144}{253125} p^5.
\]</div>
<ul>
<li>Therefore</li>
</ul>
<div class="arithmatex">\[
F(p) = \frac{1 - \frac{68}{15} p + \frac{656}{75} p^2 - \frac{29312}{3375} p^3 + \frac{223232}{50625} p^4 - \frac{229376}{253125} p^5}{1 - \frac{68}{15} p + \frac{704}{75} p^2 - \frac{32768}{3375} p^3 + \frac{253952}{50625} p^4 - \frac{262144}{253125} p^5}.
\]</div>
<ul>
<li>Small-p expansion (logical infidelity scaling)</li>
<li>Series division yields</li>
</ul>
<div class="arithmatex">\[
F(p) = 1 - \frac{16}{25} p^2 - \frac{704}{375} p^3 - \frac{10496}{3375} p^4 - \frac{216064}{84375} p^5.
\]</div>
<ul>
<li>Hence, to leading order, the post-selected logical infidelity is</li>
</ul>
<div class="arithmatex">\[
1 - F(p) = \frac{16}{25}\,p^2 + O(p^3),
\]</div>
<div class="codehilite"><pre><span></span><code>showing second-order suppression of logical error due to fault-tolerant, flagged state preparation.
</code></pre></div>

<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Included in-line and display equations above.</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Conventions follow the problem statement: [4,2,2] code with given stabilizers and logical operators, two-qubit depolarizing error with probability p per CNOT, ideal single-qubit operations, post-selection on ancilla M4 = 0 and stabilizer +1 outcomes.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = [1 − (68/15) p + (656/75) p^2 − (29312/3375) p^3 + (223232/50625) p^4 − (229376/253125) p^5] / [1 − (68/15) p + (704/75) p^2 − (32768/3375) p^3 + (253952/50625) p^4 − (262144/253125) p^5].</li>
</ol>
<p>Equivalently, for small p,
F(p) = 1 − (16/25) p^2 − (704/375) p^3 + O(p^4),
so the leading-order logical infidelity is 1 − F(p) = (16/25) p^2 + O(p^3).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">656</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">29312</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">223232</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">229376</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">262144</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.737106
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>