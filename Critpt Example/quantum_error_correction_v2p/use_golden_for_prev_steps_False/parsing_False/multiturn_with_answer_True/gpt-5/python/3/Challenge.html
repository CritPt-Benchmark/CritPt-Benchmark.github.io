<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>

<span class="c1"># Define Pauli matrices</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">Z</span><span class="p">}</span>

<span class="c1"># Single-qubit gates</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="c1"># Tensor utility: build n-qubit operator from list of single-qubit ops (leftmost is qubit 0)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="c1"># n-qubit identity</span>
<span class="k">def</span><span class="w"> </span><span class="nf">In</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="n">nq</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># qubits 0..4 (4 data + ancilla)</span>

<span class="c1"># Build CNOT for arbitrary control c, target t on nq qubits</span>
<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="c1"># Using projector method: |0&gt;&lt;0|_c âŠ— I + |1&gt;&lt;1|_c âŠ— X_t</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ops0</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops1</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops0</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">P0</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">P1</span>
    <span class="n">term0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops0</span><span class="p">)</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
    <span class="n">term1</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span> <span class="o">+</span> <span class="n">term1</span>

<span class="c1"># Projectors for ancilla measurement on qubit 4</span>
<span class="n">Pi_a0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>
<span class="n">Pi_a1</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>

<span class="c1"># Code states on data qubits 0..3</span>
<span class="c1"># |00&gt;_L = (|0000&gt; + |1111&gt;)/sqrt2</span>
<span class="n">basis_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">ket0000</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0000</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">ket1111</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket1111</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">ketGHZp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ket0000</span> <span class="o">+</span> <span class="n">ket1111</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Logical X operators per problem</span>
<span class="c1"># X_A = X I X I on qubits 0..3</span>
<span class="c1"># X_B = X X I I on qubits 0..3</span>
<span class="n">XA</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">XB</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>

<span class="c1"># Generate code basis |00&gt;, |10&gt;=XA|00&gt;, |01&gt;=XB|00&gt;, |11&gt;=XA XB |00&gt;</span>
<span class="n">ket00</span> <span class="o">=</span> <span class="n">ketGHZp</span>
<span class="n">ket10</span> <span class="o">=</span> <span class="n">XA</span> <span class="o">@</span> <span class="n">ket00</span>
<span class="n">ket01</span> <span class="o">=</span> <span class="n">XB</span> <span class="o">@</span> <span class="n">ket00</span>
<span class="n">ket11</span> <span class="o">=</span> <span class="n">XA</span> <span class="o">@</span> <span class="n">ket01</span>

<span class="c1"># Normalize (should be normalized already)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">k</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

<span class="c1"># Projector onto code space P_code = sum |ij&gt;&lt;ij|</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">P_code</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">@</span> <span class="n">k</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># Projector onto |00&gt; logical</span>
<span class="n">P_00</span> <span class="o">=</span> <span class="n">ket00</span> <span class="o">@</span> <span class="n">ket00</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># Expand to 5-qubit operators by tensoring with ancilla identity where necessary</span>
<span class="c1"># We&#39;ll need to apply gates and errors on full 5-qubit space; For code projectors we act only on 0..3</span>
<span class="c1"># So to compute probabilities after ancilla projection, we will extract the data state by partial projection.</span>

<span class="c1"># Build the noiseless unitary for the circuit (up to just before measuring ancilla)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="c1"># Apply H on qubit 1</span>
<span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">@</span> <span class="n">U</span>
<span class="c1"># Apply CNOTs in order: 1-&gt;2, 1-&gt;0, 2-&gt;3, 3-&gt;4, 0-&gt;4</span>
<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">CNOTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>

<span class="c1"># We&#39;ll build functions to apply errors after each CNOT</span>

<span class="c1"># List all two-qubit Pauli pairs (including II); return as 5-qubit operator placed on the two qubits of given pair</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">pauli_pairs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># tuples (label_c, label_t, matrix 4x4)</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">pauli_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">])))</span>

<span class="c1"># Map location index -&gt; pair of qubit indices</span>
<span class="n">loc_qubits</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">cnots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>

<span class="c1"># For each pair (a,b), build the 5-qubit operator at location i</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>

<span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">loc_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q2</span><span class="p">]</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="c1"># Initial state |00000&gt;</span>
<span class="n">ket0_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0_5</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Build a function to apply the circuit with a specified error pattern up to 2 faults</span>
<span class="c1"># error_pattern: dict mapping location index i (0..4) -&gt; (a, b) Pauli labels (non-identity permitted; &#39;I&#39;,&#39;I&#39; means no error at that site)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run_with_errors</span><span class="p">(</span><span class="n">error_pattern</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">ket0_5</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># H</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># For each CNOT + error after it</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">state</span>
        <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">error_pattern</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">state</span>

<span class="c1"># Build projection operators for data (0..3) only</span>
<span class="c1"># To compute &lt;Ïˆ| Î _a0 âŠ— P_code |Ïˆ&gt; etc, we&#39;ll expand them into full 5-qubit space by tensoring with ancilla projectors.</span>
<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span>  <span class="c1"># placeholder</span>
<span class="c1"># Build tensored operators conveniently</span>

<span class="k">def</span><span class="w"> </span><span class="nf">lift_data_op_to_5</span><span class="p">(</span><span class="n">op4</span><span class="p">):</span>
    <span class="c1"># op4 acts on qubits 0..3, ancilla identity on qubit 4</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">op4</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">lift_data_op_to_5</span><span class="p">(</span><span class="n">P_code</span><span class="p">)</span>
<span class="n">P_00_5</span>   <span class="o">=</span> <span class="n">lift_data_op_to_5</span><span class="p">(</span><span class="n">P_00</span><span class="p">)</span>

<span class="c1"># Now enumerate 0,1,2 faults, compute contributions to numerator and denominator as functions of p</span>

<span class="c1"># Two-qubit non-identity pairs</span>
<span class="n">nonid_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pauli_pairs</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="c1"># For clarity, precompute the weights coefficients for each k when expanding to O(p^2)</span>
<span class="c1"># For a given pattern with k faults, its weight = (1-p)^(5-k) * (p/15)^k.</span>
<span class="c1"># We&#39;ll accumulate contributions for polynomial up to p^2: we represent as coeffs [c0, c1, c2] such that sum = c0 + c1 p + c2 p^2</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">num_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>  <span class="c1"># numerator coefficients up to p^2</span>
 <span class="n">den_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>  <span class="c1"># denominator coefficients up to p^2</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>  File &quot;&lt;stdin&gt;&quot;, line 159
    den_coeff = np.array([0.0, 0.0, 0.0])  # denominator coefficients up to p^2
IndentationError: unexpected indent
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>

<span class="c1"># Define Pauli matrices</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">Z</span><span class="p">}</span>

<span class="c1"># Single-qubit gates</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="c1"># Tensor utility: build n-qubit operator from list of single-qubit ops (leftmost is qubit 0)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="c1"># n-qubit identity</span>
<span class="k">def</span><span class="w"> </span><span class="nf">In</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="n">nq</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># qubits 0..4 (4 data + ancilla)</span>

<span class="c1"># Build CNOT for arbitrary control c, target t on nq qubits</span>
<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="c1"># Using projector method: |0&gt;&lt;0|_c âŠ— I + |1&gt;&lt;1|_c âŠ— X_t</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ops0</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops1</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops0</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">P0</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">P1</span>
    <span class="n">term0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops0</span><span class="p">)</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
    <span class="n">term1</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span> <span class="o">+</span> <span class="n">term1</span>

<span class="c1"># Projectors for ancilla measurement on qubit 4</span>
<span class="n">Pi_a0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>
<span class="n">Pi_a1</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>

<span class="c1"># Code states on data qubits 0..3</span>
<span class="c1"># |00&gt;_L = (|0000&gt; + |1111&gt;)/sqrt2</span>
<span class="n">ket0000</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0000</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">ket1111</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket1111</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">ketGHZp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ket0000</span> <span class="o">+</span> <span class="n">ket1111</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Logical X operators per problem</span>
<span class="n">XA</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">XB</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>

<span class="n">ket00</span> <span class="o">=</span> <span class="n">ketGHZp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">ket10</span> <span class="o">=</span> <span class="n">XA</span> <span class="o">@</span> <span class="n">ket00</span>
<span class="n">ket01</span> <span class="o">=</span> <span class="n">XB</span> <span class="o">@</span> <span class="n">ket00</span>
<span class="n">ket11</span> <span class="o">=</span> <span class="n">XA</span> <span class="o">@</span> <span class="n">ket01</span>

<span class="c1"># Normalize</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">k</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

<span class="c1"># Projector onto code space P_code = sum |ij&gt;&lt;ij|</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">P_code</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">@</span> <span class="n">k</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># Projector onto |00&gt; logical</span>
<span class="n">P_00</span> <span class="o">=</span> <span class="n">ket00</span> <span class="o">@</span> <span class="n">ket00</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># Build the noiseless unitary for the circuit (up to just before measuring ancilla)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="c1"># Apply H on qubit 1</span>
<span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">@</span> <span class="n">U</span>
<span class="c1"># Apply CNOTs in order: 1-&gt;2, 1-&gt;0, 2-&gt;3, 3-&gt;4, 0-&gt;4</span>
<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">CNOTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>

<span class="c1"># Build list of Pauli pairs</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">pauli_pairs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># tuples (label_c, label_t, matrix 4x4)</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">pauli_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">])))</span>

<span class="c1"># Map location index -&gt; pair of qubit indices</span>
<span class="n">loc_qubits</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">cnots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>

<span class="c1"># For each pair (a,b), build the 5-qubit operator at location i</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>

<span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">loc_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q2</span><span class="p">]</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="c1"># Initial state |00000&gt;</span>
<span class="n">ket0_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0_5</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Function to run circuit with specified error pattern (dictionary loc-&gt;(a,b))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">run_with_errors</span><span class="p">(</span><span class="n">error_pattern</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">ket0_5</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># H on qubit 1</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># For each CNOT + error after it</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">state</span>
        <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">error_pattern</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">state</span>

<span class="c1"># Lift 4-qubit data operators to 5-qubit by tensoring ancilla identity</span>
<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_code</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">P_00_5</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_00</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

<span class="c1"># Two-qubit non-identity pairs</span>
<span class="n">nonid_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pauli_pairs</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="c1"># We&#39;ll accumulate contributions to numerator and denominator polynomials up to O(p^2)</span>
<span class="n">num_c0</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">num_c1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">num_c2</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">den_c0</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">den_c1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">den_c2</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="c1"># Helper: For a given final pure state |psi&gt;, compute probabilities:</span>
<span class="c1"># p_anc0 = &lt;psi|Pi_a0|psi&gt;</span>
<span class="c1"># After projecting ancilla=0, unnormalized data state is (âŸ¨0|_a psi). We compute acceptance for code P_code and for |00&gt;.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="c1"># Probability ancilla=0</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
    <span class="c1"># Unnormalized post-selected state (data+ancilla) after ancilla=0 projection</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># Now compute overlap with code projector on data</span>
    <span class="c1"># But P_code_5 acts only on data; ancilla projector already applied</span>
    <span class="n">w_code</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_code_5</span> <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="n">w_00</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_00_5</span>   <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span>

<span class="c1"># 0 faults</span>
<span class="n">state0</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({})</span>
<span class="n">w_code0</span><span class="p">,</span> <span class="n">w_000</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state0</span><span class="p">)</span>
<span class="c1"># Weight polynomial for 0 faults: (1-p)^5 = 1 - 5p + 10 p^2 + O(p^3)</span>
<span class="n">num_c0</span> <span class="o">+=</span> <span class="n">w_000</span>
<span class="n">num_c1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">w_000</span>
<span class="n">num_c2</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">*</span><span class="n">w_000</span>

<span class="n">den_c0</span> <span class="o">+=</span> <span class="n">w_code0</span>
<span class="n">den_c1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">w_code0</span>
<span class="n">den_c2</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">*</span><span class="n">w_code0</span>

<span class="c1"># 1 fault patterns</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)})</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># Weight factor: (1-p)^4 * (p/15) = (p/15) - 4 (p^2/15) + O(p^3)</span>
        <span class="n">num_c1</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">w_00</span>
        <span class="n">num_c2</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">w_00</span>
        <span class="n">den_c1</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">w_code</span>
        <span class="n">den_c2</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">w_code</span>

<span class="c1"># 2 fault patterns (i&lt;j)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">),</span> <span class="n">j</span><span class="p">:(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)})</span>
            <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="c1"># Weight: (1-p)^3 * (p/15)^2 = (p^2/225) + O(p^3)</span>
            <span class="n">num_c2</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">225</span><span class="p">)</span><span class="o">*</span><span class="n">w_00</span>
            <span class="n">den_c2</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">225</span><span class="p">)</span><span class="o">*</span><span class="n">w_code</span>

<span class="c1"># Compile polynomial coefficients for fidelity: F(p) = (N0 + N1 p + N2 p^2) / (D0 + D1 p + D2 p^2)</span>
<span class="n">num_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">num_c0</span><span class="p">,</span> <span class="n">num_c1</span><span class="p">,</span> <span class="n">num_c2</span><span class="p">])</span>
<span class="n">den_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">den_c0</span><span class="p">,</span> <span class="n">den_c1</span><span class="p">,</span> <span class="n">den_c2</span><span class="p">])</span>

<span class="n">num_coeffs</span><span class="p">,</span> <span class="n">den_coeffs</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>&#39;&#39;
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num_coeffs:&#39;</span><span class="p">,</span> <span class="n">num_coeffs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;den_coeffs:&#39;</span><span class="p">,</span> <span class="n">den_coeffs</span><span class="p">)</span>

<span class="c1"># Let&#39;s also compute the series expansion for F up to O(p^2):</span>
<span class="c1"># F = (N0 + N1 p + N2 p^2) / (D0 + D1 p + D2 p^2)</span>
<span class="c1"># Expand: Let D = D0(1 + d1 p + d2 p^2), with d1=D1/D0, d2=D2/D0.</span>
<span class="c1"># N = N0(1 + n1 p + n2 p^2), with n1=N1/N0, n2=N2/N0.</span>
<span class="c1"># Then F = (N0/D0) * (1 + n1 p + n2 p^2) * (1 - d1 p + (d1^2 - d2) p^2) + O(p^3).</span>
<span class="c1"># Multiply out: F = (N0/D0) * [1 + (n1 - d1) p + (n2 - d2 + d1^2 - d1*n1) p^2]</span>

<span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span> <span class="o">=</span> <span class="n">num_coeffs</span>
<span class="n">D0</span><span class="p">,</span> <span class="n">D1</span><span class="p">,</span> <span class="n">D2</span> <span class="o">=</span> <span class="n">den_coeffs</span>
<span class="n">n1</span> <span class="o">=</span> <span class="n">N1</span><span class="o">/</span><span class="n">N0</span><span class="p">;</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">N2</span><span class="o">/</span><span class="n">N0</span>
<span class="n">d1</span> <span class="o">=</span> <span class="n">D1</span><span class="o">/</span><span class="n">D0</span><span class="p">;</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">D2</span><span class="o">/</span><span class="n">D0</span>
<span class="n">c0</span> <span class="o">=</span> <span class="n">N0</span><span class="o">/</span><span class="n">D0</span>
<span class="n">c1</span> <span class="o">=</span> <span class="n">c0</span><span class="o">*</span><span class="p">(</span><span class="n">n1</span> <span class="o">-</span> <span class="n">d1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">c0</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span> <span class="o">-</span> <span class="n">d2</span> <span class="o">+</span> <span class="n">d1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">d1</span><span class="o">*</span><span class="n">n1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series F(p) â‰ˆ c0 + c1 p + c2 p^2&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;c0, c1, c2 =&#39;</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
NameError: name &#39;num_coeffs&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="c1"># Recreate variables from previous cell (since state not persistent?)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>

<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">Z</span><span class="p">}</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span><span class="w"> </span><span class="nf">In</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="n">nq</span><span class="o">=</span><span class="mi">5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ops0</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">ops1</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops0</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P0</span><span class="p">;</span> <span class="n">ops1</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P1</span>
    <span class="n">term0</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops0</span><span class="p">)</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">X</span>
    <span class="n">term1</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span><span class="o">+</span><span class="n">term1</span>

<span class="n">Pi_a0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>

<span class="n">ket0000</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0000</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ket1111</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket1111</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ketGHZp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ket0000</span> <span class="o">+</span> <span class="n">ket1111</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">XA</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">XB</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">ket00</span> <span class="o">=</span> <span class="n">ketGHZp</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">ket10</span> <span class="o">=</span> <span class="n">XA</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket01</span> <span class="o">=</span> <span class="n">XB</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket11</span> <span class="o">=</span> <span class="n">XA</span><span class="nd">@ket01</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">k</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">P_code</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">@</span> <span class="n">k</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
<span class="n">P_00</span> <span class="o">=</span> <span class="n">ket00</span> <span class="o">@</span> <span class="n">ket00</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">CNOTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>
<span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">pauli_pairs</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
<span class="n">loc_qubits</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">cnots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>
<span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">q1</span><span class="p">,</span><span class="n">q2</span> <span class="o">=</span> <span class="n">loc_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">];</span> <span class="n">ops</span><span class="p">[</span><span class="n">q2</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>
<span class="n">ket0_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0_5</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run_with_errors</span><span class="p">(</span><span class="n">error_pattern</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">ket0_5</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">H</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">state</span>
        <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">error_pattern</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">state</span>

<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_code</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">P_00_5</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_00</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">nonid_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pauli_pairs</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span>
    <span class="n">w_code</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_code_5</span> <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="n">w_00</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_00_5</span>   <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span>

<span class="n">num_c0</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">num_c1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">num_c2</span> <span class="o">=</span> <span class="mf">0.0</span>
 <span class="n">den_c0</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">den_c1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">den_c2</span> <span class="o">=</span> <span class="mf">0.0</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>  File &quot;&lt;stdin&gt;&quot;, line 90
    den_c0 = 0.0; den_c1 = 0.0; den_c2 = 0.0
IndentationError: unexpected indent
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>

<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">Z</span><span class="p">}</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span><span class="w"> </span><span class="nf">In</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="n">nq</span><span class="o">=</span><span class="mi">5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ops0</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">ops1</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops0</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P0</span><span class="p">;</span> <span class="n">ops1</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P1</span>
    <span class="n">term0</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops0</span><span class="p">)</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">X</span>
    <span class="n">term1</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span><span class="o">+</span><span class="n">term1</span>

<span class="n">Pi_a0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>

<span class="n">ket0000</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0000</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ket1111</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket1111</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ketGHZp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ket0000</span> <span class="o">+</span> <span class="n">ket1111</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">XA</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">XB</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">ket00</span> <span class="o">=</span> <span class="n">ketGHZp</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">ket10</span> <span class="o">=</span> <span class="n">XA</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket01</span> <span class="o">=</span> <span class="n">XB</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket11</span> <span class="o">=</span> <span class="n">XA</span><span class="nd">@ket01</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">k</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">P_code</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">@</span> <span class="n">k</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
<span class="n">P_00</span> <span class="o">=</span> <span class="n">ket00</span> <span class="o">@</span> <span class="n">ket00</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">CNOTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>
<span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">pauli_pairs</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
<span class="n">loc_qubits</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">cnots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>
<span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">q1</span><span class="p">,</span><span class="n">q2</span> <span class="o">=</span> <span class="n">loc_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">];</span> <span class="n">ops</span><span class="p">[</span><span class="n">q2</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>
<span class="n">ket0_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0_5</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run_with_errors</span><span class="p">(</span><span class="n">error_pattern</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">ket0_5</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">H</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">state</span>
        <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">error_pattern</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">state</span>

<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_code</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">P_00_5</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_00</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">nonid_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pauli_pairs</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span>
    <span class="n">w_code</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_code_5</span> <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="n">w_00</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_00_5</span>   <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span>

<span class="n">num_c0</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">num_c1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">num_c2</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="c1"># den coefficients for denominator</span>
 <span class="n">den_c0</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">den_c1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">den_c2</span> <span class="o">=</span> <span class="mf">0.0</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>  File &quot;&lt;stdin&gt;&quot;, line 90
    den_c0 = 0.0; den_c1 = 0.0; den_c2 = 0.0
IndentationError: unexpected indent
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>

<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">Z</span><span class="p">}</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span><span class="w"> </span><span class="nf">In</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="n">nq</span><span class="o">=</span><span class="mi">5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ops0</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">ops1</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops0</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P0</span><span class="p">;</span> <span class="n">ops1</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P1</span>
    <span class="n">term0</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops0</span><span class="p">)</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">X</span>
    <span class="n">term1</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span><span class="o">+</span><span class="n">term1</span>

<span class="n">Pi_a0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>

<span class="n">ket0000</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0000</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ket1111</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket1111</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ketGHZp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ket0000</span> <span class="o">+</span> <span class="n">ket1111</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">XA</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">XB</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">ket00</span> <span class="o">=</span> <span class="n">ketGHZp</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">ket10</span> <span class="o">=</span> <span class="n">XA</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket01</span> <span class="o">=</span> <span class="n">XB</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket11</span> <span class="o">=</span> <span class="n">XA</span><span class="nd">@ket01</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">k</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">P_code</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">@</span> <span class="n">k</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
<span class="n">P_00</span> <span class="o">=</span> <span class="n">ket00</span> <span class="o">@</span> <span class="n">ket00</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">CNOTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>
<span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">pauli_pairs</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
<span class="n">loc_qubits</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">cnots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>
<span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">q1</span><span class="p">,</span><span class="n">q2</span> <span class="o">=</span> <span class="n">loc_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">];</span> <span class="n">ops</span><span class="p">[</span><span class="n">q2</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>
<span class="n">ket0_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0_5</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run_with_errors</span><span class="p">(</span><span class="n">error_pattern</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">ket0_5</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">H</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">state</span>
        <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">error_pattern</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">state</span>

<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_code</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">P_00_5</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_00</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">nonid_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pauli_pairs</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span>
    <span class="n">w_code</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_code_5</span> <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="n">w_00</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_00_5</span>   <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span>

<span class="n">num_c0</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">num_c1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">num_c2</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="c1"># denominator coefficients</span>

<span class="n">den_c0</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">den_c1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">den_c2</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="c1"># 0 faults</span>
<span class="n">state0</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({})</span>
<span class="n">w_code0</span><span class="p">,</span> <span class="n">w_000</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state0</span><span class="p">)</span>
<span class="c1"># (1-p)^5 = 1 - 5p + 10 p^2</span>
<span class="n">num_c0</span> <span class="o">+=</span> <span class="n">w_000</span>
<span class="n">num_c1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">w_000</span>
<span class="n">num_c2</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">*</span><span class="n">w_000</span>

<span class="n">den_c0</span> <span class="o">+=</span> <span class="n">w_code0</span>

<span class="n">den_c1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">w_code0</span>

<span class="n">den_c2</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">*</span><span class="n">w_code0</span>

<span class="c1"># 1 fault patterns</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)})</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">num_c1</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">w_00</span>
        <span class="n">num_c2</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">w_00</span>
        <span class="n">den_c1</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">w_code</span>
        <span class="n">den_c2</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">w_code</span>

<span class="c1"># 2 fault patterns</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">),</span> <span class="n">j</span><span class="p">:(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)})</span>
            <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">num_c2</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">225</span><span class="p">)</span><span class="o">*</span><span class="n">w_00</span>
            <span class="n">den_c2</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">225</span><span class="p">)</span><span class="o">*</span><span class="n">w_code</span>

<span class="n">num_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">num_c0</span><span class="p">,</span> <span class="n">num_c1</span><span class="p">,</span> <span class="n">num_c2</span><span class="p">])</span>
<span class="n">den_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">den_c0</span><span class="p">,</span> <span class="n">den_c1</span><span class="p">,</span> <span class="n">den_c2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num_coeffs:&#39;</span><span class="p">,</span> <span class="n">num_coeffs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;den_coeffs:&#39;</span><span class="p">,</span> <span class="n">den_coeffs</span><span class="p">)</span>

<span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span> <span class="o">=</span> <span class="n">num_coeffs</span>
<span class="n">D0</span><span class="p">,</span> <span class="n">D1</span><span class="p">,</span> <span class="n">D2</span> <span class="o">=</span> <span class="n">den_coeffs</span>
<span class="n">n1</span> <span class="o">=</span> <span class="n">N1</span><span class="o">/</span><span class="n">N0</span><span class="p">;</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">N2</span><span class="o">/</span><span class="n">N0</span>
<span class="n">d1</span> <span class="o">=</span> <span class="n">D1</span><span class="o">/</span><span class="n">D0</span><span class="p">;</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">D2</span><span class="o">/</span><span class="n">D0</span>
<span class="n">c0</span> <span class="o">=</span> <span class="n">N0</span><span class="o">/</span><span class="n">D0</span>
<span class="n">c1</span> <span class="o">=</span> <span class="n">c0</span><span class="o">*</span><span class="p">(</span><span class="n">n1</span> <span class="o">-</span> <span class="n">d1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">c0</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span> <span class="o">-</span> <span class="n">d2</span> <span class="o">+</span> <span class="n">d1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">d1</span><span class="o">*</span><span class="n">n1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series F(p) â‰ˆ c0 + c1 p + c2 p^2&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;c0, c1, c2 =&#39;</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#13</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>num_coeffs: [ 1.         -4.53333333  8.74666667]
den_coeffs: [ 1.         -4.53333333  9.38666667]
Series F(p) â‰ˆ c0 + c1 p + c2 p^2
c0, c1, c2 = 1.0 0.0 -0.6400000000001
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#14</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># Let&#39;s compute raw sums over double-fault patterns</span>
<span class="n">S2_den</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">S2_num</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">),</span> <span class="n">j</span><span class="p">:(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)})</span>
            <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">S2_den</span> <span class="o">+=</span> <span class="n">w_code</span>
            <span class="n">S2_num</span> <span class="o">+=</span> <span class="n">w_00</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Raw sums over double faults: S2_den, S2_num =&#39;</span><span class="p">,</span> <span class="n">S2_den</span><span class="p">,</span> <span class="n">S2_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total # double-fault patterns =&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">15</span><span class="o">*</span><span class="mi">15</span><span class="p">)</span>

<span class="c1"># Similarly sums over single faults for acceptance weights</span>
<span class="n">S1_den</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">S1_num</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)})</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">S1_den</span> <span class="o">+=</span> <span class="n">w_code</span>
        <span class="n">S1_num</span> <span class="o">+=</span> <span class="n">w_00</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Raw sums over single faults: S1_den, S1_num =&#39;</span><span class="p">,</span> <span class="n">S1_den</span><span class="p">,</span> <span class="n">S1_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total # single-fault patterns =&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="mi">15</span><span class="p">)</span>

<span class="c1"># And zero-fault acceptance weights</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Zero-fault acceptance weights: w_code0, w_000 =&#39;</span><span class="p">,</span> <span class="n">w_code0</span><span class="p">,</span> <span class="n">w_000</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#15</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 4, in &lt;module&gt;
NameError: name &#39;combinations&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#16</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
<span class="c1"># Reuse earlier defined variables</span>
<span class="n">S2_den</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">S2_num</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">),</span> <span class="n">j</span><span class="p">:(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)})</span>
            <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">S2_den</span> <span class="o">+=</span> <span class="n">w_code</span>
            <span class="n">S2_num</span> <span class="o">+=</span> <span class="n">w_00</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Raw sums over double faults: S2_den, S2_num =&#39;</span><span class="p">,</span> <span class="n">S2_den</span><span class="p">,</span> <span class="n">S2_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total # double-fault patterns =&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">15</span><span class="o">*</span><span class="mi">15</span><span class="p">)</span>

<span class="n">S1_den</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">S1_num</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)})</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">S1_den</span> <span class="o">+=</span> <span class="n">w_code</span>
        <span class="n">S1_num</span> <span class="o">+=</span> <span class="n">w_00</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Raw sums over single faults: S1_den, S1_num =&#39;</span><span class="p">,</span> <span class="n">S1_den</span><span class="p">,</span> <span class="n">S1_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total # single-fault patterns =&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="mi">15</span><span class="p">)</span>

<span class="c1"># Zero-fault acceptance weights should be 1</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Zero-fault acceptance weights (den,num):&#39;</span><span class="p">,</span> <span class="n">w_code0</span><span class="p">,</span> <span class="n">w_000</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#17</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 6, in &lt;module&gt;
NameError: name &#39;nonid_pairs&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#18</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="c1"># Rebuild nonid_pairs if not present</span>
<span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">nonid_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>

<span class="n">S2_den</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">S2_num</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">),</span> <span class="n">j</span><span class="p">:(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)})</span>
            <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">S2_den</span> <span class="o">+=</span> <span class="n">w_code</span>
            <span class="n">S2_num</span> <span class="o">+=</span> <span class="n">w_00</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Raw sums over double faults: S2_den, S2_num =&#39;</span><span class="p">,</span> <span class="n">S2_den</span><span class="p">,</span> <span class="n">S2_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total # double-fault patterns =&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">15</span><span class="o">*</span><span class="mi">15</span><span class="p">)</span>

<span class="n">S1_den</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">S1_num</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)})</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">S1_den</span> <span class="o">+=</span> <span class="n">w_code</span>
        <span class="n">S1_num</span> <span class="o">+=</span> <span class="n">w_00</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Raw sums over single faults: S1_den, S1_num =&#39;</span><span class="p">,</span> <span class="n">S1_den</span><span class="p">,</span> <span class="n">S1_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total # single-fault patterns =&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="mi">15</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Zero-fault acceptance weights (den,num):&#39;</span><span class="p">,</span> <span class="n">w_code0</span><span class="p">,</span> <span class="n">w_000</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#19</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 11, in &lt;module&gt;
NameError: name &#39;run_with_errors&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#20</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="c1"># Unfortunately variable got lost; Reconstruct minimal functions quickly</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">Z</span><span class="p">}</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ops0</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">ops1</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops0</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P0</span><span class="p">;</span> <span class="n">ops1</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P1</span>
    <span class="n">term0</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops0</span><span class="p">)</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">X</span>
    <span class="n">term1</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span><span class="o">+</span><span class="n">term1</span>

<span class="n">nq</span><span class="o">=</span><span class="mi">5</span>
<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">CNOTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>
<span class="n">Pi_a0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>

<span class="n">ket0000</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0000</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ket1111</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket1111</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ketGHZp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ket0000</span> <span class="o">+</span> <span class="n">ket1111</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">XA</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">XB</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">ket00</span> <span class="o">=</span> <span class="n">ketGHZp</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">ket10</span> <span class="o">=</span> <span class="n">XA</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket01</span> <span class="o">=</span> <span class="n">XB</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket11</span> <span class="o">=</span> <span class="n">XA</span><span class="nd">@ket01</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">k</span><span class="o">/=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span> <span class="n">ket10</span><span class="p">,</span> <span class="n">ket01</span><span class="p">,</span> <span class="n">ket11</span><span class="p">]:</span>
    <span class="n">P_code</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">@</span> <span class="n">k</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
<span class="n">P_00</span> <span class="o">=</span> <span class="n">ket00</span> <span class="o">@</span> <span class="n">ket00</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_code</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">P_00_5</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_00</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>
<span class="n">loc_qubits</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">cnots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>
<span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="o">=</span><span class="n">loc_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">];</span> <span class="n">ops</span><span class="p">[</span><span class="n">q2</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="n">ket0_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0_5</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run_with_errors</span><span class="p">(</span><span class="n">error_pattern</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">ket0_5</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">H</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">state</span>
        <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">error_pattern</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">state</span>

<span class="k">def</span><span class="w"> </span><span class="nf">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span><span class="p">))</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span>
    <span class="n">w_code</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_code_5</span> <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="n">w_00</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_00_5</span>   <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span>

<span class="n">nonid_pairs</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="n">S2_den</span><span class="o">=</span><span class="n">S2_num</span><span class="o">=</span><span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
            <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">),</span> <span class="n">j</span><span class="p">:(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)}))</span>
            <span class="n">S2_den</span> <span class="o">+=</span> <span class="n">w_code</span><span class="p">;</span> <span class="n">S2_num</span> <span class="o">+=</span> <span class="n">w_00</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S2_den, S2_num =&#39;</span><span class="p">,</span> <span class="n">S2_den</span><span class="p">,</span> <span class="n">S2_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total double patterns =&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">15</span><span class="o">*</span><span class="mi">15</span><span class="p">)</span>

<span class="n">S1_den</span><span class="o">=</span><span class="n">S1_num</span><span class="o">=</span><span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)}))</span>
        <span class="n">S1_den</span> <span class="o">+=</span> <span class="n">w_code</span><span class="p">;</span> <span class="n">S1_num</span> <span class="o">+=</span> <span class="n">w_00</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S1_den, S1_num =&#39;</span><span class="p">,</span> <span class="n">S1_den</span><span class="p">,</span> <span class="n">S1_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total single patterns =&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="mi">15</span><span class="p">)</span>

<span class="n">w_code0</span><span class="p">,</span> <span class="n">w_000</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">run_with_errors</span><span class="p">({}))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Zero-fault weights (den,num):&#39;</span><span class="p">,</span> <span class="n">w_code0</span><span class="p">,</span> <span class="n">w_000</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#21</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>S2_den, S2_num = 282.0 138.0
Total double patterns = 2250
S1_den, S1_num = 7.0 7.0
Total single patterns = 75
Zero-fault weights (den,num): 1.0 1.0
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#22</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># Enumerate single-fault patterns that are accepted (w_code&gt;0) and whether they preserve |00&gt;</span>
<span class="n">accepted_single</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)}))</span>
        <span class="k">if</span> <span class="n">w_code</span> <span class="o">&gt;</span> <span class="mf">1e-9</span><span class="p">:</span>  <span class="c1"># accepted by code+ancilla=0 with some probability (here deterministic in this sim)</span>
            <span class="n">accepted_single</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">w_code</span><span class="p">,</span><span class="n">w_00</span><span class="p">))</span>

<span class="nb">len</span><span class="p">(</span><span class="n">accepted_single</span><span class="p">),</span> <span class="n">accepted_single</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#23</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 4, in &lt;module&gt;
NameError: name &#39;nonid_pairs&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#24</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="c1"># Build nonid_pairs again</span>
<span class="n">nonid_pairs</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>
<span class="n">accepted_single</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)}))</span>
        <span class="k">if</span> <span class="n">w_code</span> <span class="o">&gt;</span> <span class="mf">1e-9</span><span class="p">:</span>
            <span class="n">accepted_single</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">w_code</span><span class="p">,</span><span class="n">w_00</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number accepted single faults:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">accepted_single</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;List:</span>
<span class="s1">&#39;, accepted_single)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#25</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>  File &quot;&lt;stdin&gt;&quot;, line 11
    print(&#39;List:
          ^
SyntaxError: unterminated string literal (detected at line 11)
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#26</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="n">nonid_pairs</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>
<span class="n">accepted_single</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)}))</span>
        <span class="k">if</span> <span class="n">w_code</span> <span class="o">&gt;</span> <span class="mf">1e-9</span><span class="p">:</span>
            <span class="n">accepted_single</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">w_code</span><span class="p">,</span><span class="n">w_00</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number accepted single faults:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">accepted_single</span><span class="p">))</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">accepted_single</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#27</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 5, in &lt;module&gt;
NameError: name &#39;contributions_for_state&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#28</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="c1"># Recreate contributions_for_state quickly</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">Pi_a0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>
<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_code</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">P_00_5</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_00</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span><span class="p">))</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span>
    <span class="n">w_code</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_code_5</span> <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="n">w_00</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_00_5</span>   <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span>

<span class="n">nonid_pairs</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>
<span class="n">accepted_single</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)}))</span>
        <span class="k">if</span> <span class="n">w_code</span> <span class="o">&gt;</span> <span class="mf">1e-9</span><span class="p">:</span>
            <span class="n">accepted_single</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">w_code</span><span class="p">,</span><span class="n">w_00</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number accepted single faults:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">accepted_single</span><span class="p">))</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">accepted_single</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#29</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 3, in &lt;module&gt;
NameError: name &#39;kronN&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#30</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="c1"># Ok, reconstruct all necessary bits in one go to avoid state issues</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>

<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">paulis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="n">I</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">X</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="n">Y</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">:</span><span class="n">Z</span><span class="p">}</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">P0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ops0</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">ops1</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops0</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P0</span><span class="p">;</span> <span class="n">ops1</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">P1</span>
    <span class="n">term0</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops0</span><span class="p">)</span>
    <span class="n">ops1</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">X</span>
    <span class="n">term1</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span><span class="o">+</span><span class="n">term1</span>

<span class="n">nq</span><span class="o">=</span><span class="mi">5</span>
<span class="n">cnots</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">CNOTs</span><span class="o">=</span><span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>
<span class="n">loc_qubits</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">cnots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span>
    <span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="o">=</span><span class="n">loc_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">a</span><span class="p">];</span> <span class="n">ops</span><span class="p">[</span><span class="n">q2</span><span class="p">]</span><span class="o">=</span><span class="n">paulis</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="n">ket0_5</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">nq</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0_5</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

<span class="c1"># code projectors</span>
<span class="n">ket0000</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket0000</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ket1111</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">ket1111</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ketGHZp</span><span class="o">=</span><span class="p">(</span><span class="n">ket0000</span><span class="o">+</span><span class="n">ket1111</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">XA</span><span class="o">=</span><span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">]);</span> <span class="n">XB</span><span class="o">=</span><span class="n">kronN</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">ket00</span><span class="o">=</span><span class="n">ketGHZp</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">ket10</span><span class="o">=</span><span class="n">XA</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket01</span><span class="o">=</span><span class="n">XB</span><span class="nd">@ket00</span><span class="p">;</span> <span class="n">ket11</span><span class="o">=</span><span class="n">XA</span><span class="nd">@ket01</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span><span class="n">ket10</span><span class="p">,</span><span class="n">ket01</span><span class="p">,</span><span class="n">ket11</span><span class="p">]:</span> <span class="n">k</span><span class="o">/=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">P_code</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ket00</span><span class="p">,</span><span class="n">ket10</span><span class="p">,</span><span class="n">ket01</span><span class="p">,</span><span class="n">ket11</span><span class="p">]:</span> <span class="n">P_code</span> <span class="o">+=</span> <span class="n">k</span><span class="nd">@k</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
<span class="n">P_00</span> <span class="o">=</span> <span class="n">ket00</span><span class="nd">@ket00</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
<span class="n">Pi_a0</span> <span class="o">=</span> <span class="n">kronN</span><span class="p">([</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)])</span>
<span class="n">P_code_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_code</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">P_00_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">P_00</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">run_with_errors</span><span class="p">(</span><span class="n">error_pattern</span><span class="p">):</span>
    <span class="n">state</span><span class="o">=</span><span class="n">ket0_5</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">nq</span><span class="p">;</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">H</span>
    <span class="n">state</span><span class="o">=</span><span class="n">kronN</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span><span class="nd">@state</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
        <span class="n">state</span><span class="o">=</span><span class="n">CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nd">@state</span>
        <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">error_pattern</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">):</span>
            <span class="n">state</span><span class="o">=</span><span class="n">pair_op_on_loc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="nd">@state</span>
    <span class="k">return</span> <span class="n">state</span>

<span class="k">def</span><span class="w"> </span><span class="nf">contributions_for_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Pi_a0</span> <span class="o">@</span> <span class="n">state</span>
    <span class="n">w_code</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_code_5</span> <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="n">w_00</span>   <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_00_5</span>   <span class="o">@</span> <span class="n">post</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span>

<span class="n">nonid_pairs</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="n">accepted_single</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonid_pairs</span><span class="p">:</span>
        <span class="n">w_code</span><span class="p">,</span> <span class="n">w_00</span> <span class="o">=</span> <span class="n">contributions_for_state</span><span class="p">(</span><span class="n">run_with_errors</span><span class="p">({</span><span class="n">i</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)}))</span>
        <span class="k">if</span> <span class="n">w_code</span><span class="o">&gt;</span><span class="mf">1e-9</span><span class="p">:</span>
            <span class="n">accepted_single</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">w_code</span><span class="p">,</span><span class="n">w_00</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number accepted single faults:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">accepted_single</span><span class="p">))</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">accepted_single</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#31</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Number accepted single faults: 7
(0, &#39;X&#39;, &#39;X&#39;, 1.0, 1.0)
(0, &#39;Y&#39;, &#39;Y&#39;, 1.0, 1.0)
(0, &#39;Z&#39;, &#39;Z&#39;, 1.0, 1.0)
(1, &#39;Z&#39;, &#39;Z&#39;, 1.0, 1.0)
(2, &#39;Z&#39;, &#39;Z&#39;, 1.0, 1.0)
(3, &#39;Z&#39;, &#39;Z&#39;, 1.0, 1.0)
(4, &#39;I&#39;, &#39;Z&#39;, 1.0, 1.0)
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#32</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Noiseless target and circuit</li>
<li>The [[4,2,2]] code has stabilizers<ul>
<li>S_Z = ZZZZ</li>
<li>S_X = XXXX</li>
</ul>
</li>
<li>Logical operators (representatives):<ul>
<li>X_A = X I X I, X_B = X X I I</li>
<li>Z_A = Z Z I I, Z_B = Z I Z I</li>
</ul>
</li>
<li>The intended encoded state |00âŸ©AB is the simultaneous +1 eigenstate of Z_A and Z_B, which for this code is the GHZ+ cat state on the four data qubits:</li>
</ul>
<div class="arithmatex">\[
|00\rangle_{AB} = \frac{|0000\rangle + |1111\rangle}{\sqrt{2}}.
\]</div>
<ul>
<li>Circuit (right-to-left order): H1, CNOT12, CNOT10, CNOT23, CNOT34, CNOT04, then measure ancilla qubit 4 in Z.</li>
<li>
<p>In the absence of errors, after CNOTs among data qubits, qubits 0â€“3 are in (|0000âŸ© + |1111âŸ©)/âˆš2 and ancilla is |0âŸ©. The last two CNOTs with ancilla as target implement a Z-parity check Z0Z3; because the GHZ+ state has definite Z0 = Z3, the ancilla deterministically measures 0.</p>
</li>
<li>
<p>Error model and post-selection</p>
</li>
<li>After each of the five CNOT gates (12,10,23,34,04), apply an independent two-qubit depolarizing channel:<ul>
<li>With probability 1 âˆ’ p: identity II.</li>
<li>With probability p: a uniformly random non-identity two-qubit Pauli, 15 possibilities each with probability p/15.</li>
</ul>
</li>
<li>We post-select on:<ul>
<li>Ancilla measurement outcome 0 (projector Î a0).</li>
<li>Passing the codeâ€™s detectable errors, i.e., projection onto the code space Pcode = (I + S_Z)/2 (I + S_X)/2 on the four data qubits.</li>
</ul>
</li>
<li>Define for any error pattern E occurring (as a product of Pauli insertions after the CNOTs):<ul>
<li>Acceptance weight:</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
w_{\text{code}}(E) = \langle\psi|\,\Pi_{a0}\,P_{\text{code}}\,\Pi_{a0}\,|\psi\rangle,
\]</div>
<div class="codehilite"><pre><span></span><code>- Correct-state weight:
</code></pre></div>

<div class="arithmatex">\[
w_{00}(E) = \langle\psi|\,\Pi_{a0}\,P_{00}\,\Pi_{a0}\,|\psi\rangle,
\]</div>
<div class="codehilite"><pre><span></span><code>  where |ÏˆâŸ© is the state after the ideal circuit and E, and P00 = |00âŸ©âŸ¨00| (on qubits 0â€“3).
</code></pre></div>

<ul>
<li>The logical fidelity conditioned on post-selection is</li>
</ul>
<div class="arithmatex">\[
F(p) = \frac{\sum_E \Pr(E)\,w_{00}(E)}{\sum_E \Pr(E)\,w_{\text{code}}(E)}.
\]</div>
<ul>
<li>Small-p expansion to second order</li>
<li>Expand in the number k of error locations with non-identity Paulis (k = 0,1,2) and retain terms O(p^2):<ul>
<li>Exactly 0 faults: weight (1 âˆ’ p)^5 = 1 âˆ’ 5p + 10 p^2.</li>
<li>Exactly 1 fault: weight (1 âˆ’ p)^4 (p/15) = (p/15) âˆ’ (4/15) p^2.</li>
<li>Exactly 2 faults: weight (1 âˆ’ p)^3 (p/15)^2 = (p^2/225).</li>
</ul>
</li>
<li>
<p>We must count which single- and double-fault patterns survive the post-selection and, among those, which still equal |00âŸ©AB.</p>
</li>
<li>
<p>Single-fault analysis (k = 1)</p>
</li>
<li>There are 5 Ã— 15 = 75 single-fault patterns. An exhaustive Clifford/stabilizer analysis shows:<ul>
<li>Exactly seven (7) single-fault patterns pass both the ancilla post-selection and the code projection, namely</li>
<li>After CNOT12: XX, YY, ZZ on qubits (1,2).</li>
<li>After CNOT10: ZZ on (1,0).</li>
<li>After CNOT23: ZZ on (2,3).</li>
<li>After CNOT34: ZZ on (3,4).</li>
<li>After CNOT04: IâŠ—Z (Z on ancilla only).</li>
<li>All seven of these leave the data in |00âŸ©AB (they are stabilizers or Z-type logicals, and |00âŸ©AB is a +1 eigenstate of Z_A and Z_B), so they contribute equally to numerator and denominator.</li>
</ul>
</li>
<li>Therefore the linear term in F(p) cancels:</li>
</ul>
<div class="arithmatex">\[
\text{no }O(p)\text{ degradation in the conditional fidelity.}
\]</div>
<ul>
<li>Double-fault analysis (k = 2)</li>
<li>There are C(5,2) Ã— 15^2 = 2250 two-fault patterns. Exhaustive counting gives:<ul>
<li>Accepted patterns (pass ancilla=0 and code space): 282.</li>
<li>Accepted and correct (still |00âŸ©AB): 138.</li>
<li>Accepted but wrong logical state: 282 âˆ’ 138 = 144.</li>
</ul>
</li>
<li>Using the small-p expansion, the numerator and denominator polynomials up to O(p^2) are:<ul>
<li>Numerator:</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
N(p) = 1 - \frac{68}{15}p + \frac{656}{75} p^2 + O(p^3),
\]</div>
<div class="codehilite"><pre><span></span><code>- Denominator:
</code></pre></div>

<div class="arithmatex">\[
D(p) = 1 - \frac{68}{15}p + \frac{704}{75} p^2 + O(p^3).
\]</div>
<ul>
<li>Forming the ratio</li>
<li>Expand the ratio N(p)/D(p) to O(p^2):</li>
</ul>
<div class="arithmatex">\[
\frac{N}{D} = 1 + \big(n_1 - d_1\big)p + \big(n_2 - d_2 + d_1^2 - d_1 n_1\big)p^2 + O(p^3),
\]</div>
<div class="codehilite"><pre><span></span><code>with n1 = N1/N0, d1 = D1/D0, etc.
</code></pre></div>

<ul>
<li>Since N1 = D1, the O(p) term vanishes. The O(p^2) term reduces to:</li>
</ul>
<div class="arithmatex">\[
F(p) = 1 + \big(n_2 - d_2\big) p^2 + O(p^3) = 1 - \frac{16}{25}\,p^2 + O(p^3).
\]</div>
<ul>
<li>Equivalently, the logical infidelity is</li>
</ul>
<div class="arithmatex">\[
1 - F(p) = \frac{16}{25}\,p^2 + O(p^3).
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Ideal encoded state: |00âŸ©AB = (|0000âŸ© + |1111âŸ©)/âˆš2.</li>
<li>Post-selection projectors: Î a0 on ancilla, Pcode on data; numerator/denominator as above.</li>
<li>Series (to O(p^2)):</li>
<li>N(p) = 1 âˆ’ (68/15)p + (656/75)p^2,</li>
<li>D(p) = 1 âˆ’ (68/15)p + (704/75)p^2,</li>
<li>F(p) = 1 âˆ’ (16/25)p^2 + O(p^3).</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Pauli matrices X, Y, Z; multi-qubit Paulis are tensor products in qubit order 0,1,2,3,(4=ancilla).</li>
<li>Error rate p is the per-CNOT two-qubit depolarizing probability; each non-identity two-qubit Pauli occurs with probability p/15.</li>
<li>Post-selection keeps runs with ancilla measurement 0 and with +1 outcomes for both stabilizers XXXX and ZZZZ.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = 1 âˆ’ (16/25) p^2 + O(p^3).</li>
</ol>
<p>Equivalently, the logical infidelity is (16/25) p^2 + O(p^3).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#33</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#34</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.354992
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>