<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Ideal target state and its stabilizers</li>
<li>The circuit acts (right-to-left) as H2 → CNOT21 → H0 → CNOT03 on |0000⟩.</li>
<li>H2 followed by CNOT21 prepares the Bell state |Φ+⟩ on qubits (2,1).</li>
<li>H0 followed by CNOT03 prepares the Bell state |Φ+⟩ on qubits (0,3).</li>
<li>Hence the ideal final state is</li>
</ul>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{21}\otimes|\Phi^+\rangle_{03},\quad |\Phi^+\rangle=\frac{|00\rangle+|11\rangle}{\sqrt{2}}.
\]</div>
<ul>
<li>A Bell state |Φ+⟩ is stabilized by X⊗X and Z⊗Z. Therefore</li>
</ul>
<div class="arithmatex">\[
\mathcal{S} = \langle X_1X_2,\ Z_1Z_2,\ X_0X_3,\ Z_0Z_3\rangle.
\]</div>
<div class="codehilite"><pre><span></span><code>Equivalently (using the logical-operator identifications provided), this equals
</code></pre></div>

<div class="arithmatex">\[
\langle XXXX,\ ZZZZ,\ IZZI,\ IXXI\rangle.
\]</div>
<ul>
<li>The full stabilizer group has 16 elements and factorizes across the pairs (1,2) and (0,3) as</li>
</ul>
<div class="arithmatex">\[
\mathcal{S}=\{P_{12}\otimes Q_{03}\,:\, P,Q\in\{II,\,XX,\,YY,\,ZZ\}\}.
\]</div>
<ul>
<li>Noise model and propagation</li>
<li>A two-qubit depolarizing channel follows each CNOT:<ul>
<li>With probability 1−p it applies identity.</li>
<li>With probability p it applies uniformly one of the 15 non-identity two-qubit Paulis.</li>
</ul>
</li>
<li>The first channel acts on qubits (2,1) after CNOT21; subsequent gates act only on qubits (0,3), so errors on (2,1) do not propagate.</li>
<li>The second channel acts on qubits (0,3) after CNOT03; there are no later gates.</li>
<li>
<p>Thus the net error at the end is E = E_{21} ⊗ E_{03}, with E_{21} supported on (1,2) and E_{03} on (0,3), independently drawn from their respective two-qubit depolarizing channels.</p>
</li>
<li>
<p>Fidelity under Pauli noise for a stabilizer state</p>
</li>
<li>For a pure stabilizer state |ψ⟩ and a Pauli channel ρ = ∑_E p_E E|ψ⟩⟨ψ|E, the fidelity is</li>
</ul>
<div class="arithmatex">\[
F=\langle\psi|\rho|\psi\rangle=\sum_E p_E\,|\langle\psi|E|\psi\rangle|^2,
\]</div>
<div class="codehilite"><pre><span></span><code>which equals the total probability that E lies in the stabilizer group of |ψ⟩ (since ⟨ψ|E|ψ⟩=0 unless E∈𝒮, in which case it equals ±1).
</code></pre></div>

<ul>
<li>Counting the harmless (stabilizer) errors</li>
<li>E ∈ 𝒮 if and only if E_{21} ∈ {II,XX,YY,ZZ} and E_{03} ∈ {II,XX,YY,ZZ}.</li>
<li>For a two-qubit depolarizing channel on a given pair:<ul>
<li>P(E_pair = II) = 1 − p.</li>
<li>Among the 15 non-identity Paulis, exactly 3 are in {XX,YY,ZZ}, so P(E_pair ∈ {XX,YY,ZZ}) = 3·(p/15) = p/5.</li>
<li>Therefore the “harmless” probability per pair is</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
P_{\text{ok (per pair)}} = (1-p) + \frac{p}{5} = 1 - \frac{4p}{5}.
\]</div>
<ul>
<li>The two pairs are independent, so the total fidelity is the product:</li>
</ul>
<div class="arithmatex">\[
F(p) = \left(1 - \frac{4p}{5}\right)^2.
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Already included above.</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Dimensionless error probability p; no units involved.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = (1 - 4p/5)^2 = 1 - (8/5)p + (16/25)p^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Ideal state and error locations</li>
<li>The circuit prepares the physical state</li>
</ul>
<div class="arithmatex">\[
|\psi_{\mathrm{ideal}}\rangle=|\Phi^+\rangle_{21}\otimes|\Phi^+\rangle_{03},\quad |\Phi^+\rangle=\frac{|00\rangle+|11\rangle}{\sqrt{2}}.
\]</div>
<ul>
<li>A two-qubit depolarizing channel acts after each CNOT. Thus the final error is a product</li>
</ul>
<div class="arithmatex">\[
E=E_{21}\otimes E_{03},
\]</div>
<div class="codehilite"><pre><span></span><code>where each $E_{\mathrm{pair}}$ is a two-qubit Pauli with
<span class="k">-</span> $P(E_{\mathrm{pair}}=II)=1-p$,
<span class="k">-</span> each of the 15 non-identity Paulis with probability $p/15$,
and the two pairs are independent.
</code></pre></div>

<ul>
<li>Detectability condition (membership in the code normalizer)</li>
<li>The code stabilizers are <span class="arithmatex">\(S_X=XXXX\)</span> and <span class="arithmatex">\(S_Z=ZZZZ\)</span>, which factor across the pairs as</li>
</ul>
<div class="arithmatex">\[
S_X=(X_2X_1)\otimes(X_0X_3),\qquad S_Z=(Z_2Z_1)\otimes(Z_0Z_3).
\]</div>
<ul>
<li>For a Pauli <span class="arithmatex">\(P\)</span> on a given pair, define its pair-syndrome</li>
</ul>
<div class="arithmatex">\[
s(P)=(s_X(P),s_Z(P))\in\{0,1\}^2,
\]</div>
<div class="codehilite"><pre><span></span><code>where $s_X(P)=0$ if $P$ commutes with $X\otimes X$ and $1$ if it anticommutes (similarly for $s_Z$ with $Z\otimes Z$).
</code></pre></div>

<ul>
<li>The total error <span class="arithmatex">\(E=E_{21}\otimes E_{03}\)</span> commutes with both <span class="arithmatex">\(S_X,S_Z\)</span> (i.e., is undetected) if and only if the pair-syndromes match:</li>
</ul>
<div class="arithmatex">\[
s(E_{21})=s(E_{03}).
\]</div>
<ul>
<li>Distribution of pair-syndromes under two-qubit depolarizing noise</li>
<li>On a pair, the 16 Paulis split into 4 equally sized classes by <span class="arithmatex">\(s\in\{(0,0),(1,0),(0,1),(1,1)\}\)</span>.</li>
<li>Among non-identity elements, the counts are:<ul>
<li>class <span class="arithmatex">\((0,0)\)</span>: 3 elements (XX, YY, ZZ),</li>
<li>classes <span class="arithmatex">\((1,0)\)</span>, <span class="arithmatex">\((0,1)\)</span>, <span class="arithmatex">\((1,1)\)</span>: 4 elements each.</li>
</ul>
</li>
<li>Therefore, for a single pair:</li>
</ul>
<div class="arithmatex">\[
    P_{00} &amp;:= P\big(s=(0,0)\big) = (1-p)+3\frac{p}{15}=1-\frac{12}{15}p=1-\frac{4p}{5},\\
    P_{10} &amp;= P_{01}=P_{11}=4\frac{p}{15}.
\]</div>
<ul>
<li>Acceptance probability (post-selecting on no detected error)</li>
<li>Because the two pairs are independent,</li>
</ul>
<div class="arithmatex">\[
    = \left(1-\frac{4p}{5}\right)^2+3\left(\frac{4p}{15}\right)^2
\]</div>
<ul>
<li>Logical fidelity of the post-selected state</li>
<li>The logical target is the Bell state <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>, whose logical stabilizer is generated by <span class="arithmatex">\(X_A X_B\)</span> and <span class="arithmatex">\(Z_A Z_B\)</span>. A Pauli error preserves this logical state iff, modulo the code stabilizer, it is in</li>
</ul>
<div class="arithmatex">\[
\{I,\,X_A X_B,\,Y_A Y_B,\,Z_A Z_B\}.
\]</div>
<ul>
<li>Physically, these correspond exactly to the class where both pairs lie in <span class="arithmatex">\(s=(0,0)\)</span> (i.e., <span class="arithmatex">\(E_{21},E_{03}\in\{II,XX,YY,ZZ\}\)</span>). Any accepted error with <span class="arithmatex">\(s\neq(0,0)\)</span> maps the logical Bell state to an orthogonal Bell state and contributes zero to the fidelity.</li>
<li>Hence the numerator (accepted and logically correct) is</li>
</ul>
<div class="arithmatex">\[
P_{\mathrm{good}}=\left(1-\frac{12}{15}p\right)^2=\left(1-\frac{4p}{5}\right)^2.
\]</div>
<ul>
<li>The logical fidelity conditioned on acceptance is</li>
</ul>
<div class="arithmatex">\[
      = \frac{P_{\mathrm{good}}}{P_{\mathrm{acc}}}
      = \frac{\left(1-\frac{12}{15}p\right)^2}
\]</div>
<ul>
<li>Small-p expansion (sanity check)</li>
<li>Using the above,</li>
</ul>
<div class="arithmatex">\[
F_{\mathrm{logical}}(p) = 1 - \frac{16}{75}p^2 + O(p^3),
\]</div>
<div class="codehilite"><pre><span></span><code>showing first-order errors are fully detected and removed by post-selection.
</code></pre></div>

<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>All expressions are given in LaTeX above.</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Dimensionless error probability <span class="arithmatex">\(p\)</span>; no units.</li>
</ul>
<ol start="4">
<li>Final Answer:</li>
</ol>
<div class="arithmatex">\[
F_{\mathrm{logical}}(p)
= \frac{\left(1-\frac{12}{15}p\right)^2}
       {\left(1-\frac{12}{15}p\right)^2 + 3\left(\frac{4}{15}p\right)^2}
= \frac{\left(1-\frac{4p}{5}\right)^2}{1-\frac{8p}{5}+\frac{64}{75}p^2}.
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{logical}}=1 - \frac{\frac{16}{75}p^2}{1-\frac{8}{5}p + \frac{64}{75}p^2}
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># We&#39;ll enumerate the error patterns to compute acceptance and logical fidelity.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>

<span class="n">n</span><span class="o">=</span><span class="mi">5</span>  <span class="c1"># number of qubits 0..4</span>

<span class="c1"># Utility functions for Pauli representation in symplectic binary form</span>
<span class="c1"># Use tuple (x_mask, z_mask) where each is an integer with n bits.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_mul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
    <span class="c1"># Multiply Pauli p and q ignoring phase: XOR masks</span>
    <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="o">=</span><span class="n">p</span>
    <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="o">=</span><span class="n">q</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x1</span> <span class="o">^</span> <span class="n">x2</span><span class="p">,</span> <span class="n">z1</span> <span class="o">^</span> <span class="n">z2</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">conj_cnot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="c1"># Extract bits</span>
    <span class="n">xc</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
    <span class="n">xt</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
    <span class="n">zc</span><span class="o">=</span><span class="p">(</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
    <span class="n">zt</span><span class="o">=</span><span class="p">(</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
    <span class="c1"># After conjugation by CNOT(c,t):</span>
    <span class="c1"># x_t&#39; = x_t XOR x_c; x_c&#39; = x_c</span>
    <span class="c1"># z_c&#39; = z_c XOR z_t; z_t&#39; = z_t</span>
    <span class="n">xtp</span> <span class="o">=</span> <span class="n">xt</span> <span class="o">^</span> <span class="n">xc</span>
    <span class="n">xcp</span> <span class="o">=</span> <span class="n">xc</span>
    <span class="n">zcp</span> <span class="o">=</span> <span class="n">zc</span> <span class="o">^</span> <span class="n">zt</span>
    <span class="n">ztp</span> <span class="o">=</span> <span class="n">zt</span>
    <span class="c1"># Now update masks</span>
    <span class="c1"># Clear bits c,t and set new</span>
    <span class="n">x</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="n">xcp</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">xtp</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="n">zcp</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ztp</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="c1"># Function to get Pauli from a 2-qubit operator on pair (i,j)</span>
<span class="c1"># where local operator is in {I,X,Y,Z}^2 encoded as two chars like &#39;IX&#39;,&#39;YZ&#39;, etc.</span>
<span class="n">pauli_char_to_bits</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="s1">&#39;X&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="s1">&#39;Z&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="s1">&#39;Y&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_on_pair</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">pair</span>
    <span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">s</span>
    <span class="n">xi</span><span class="p">,</span><span class="n">zi</span><span class="o">=</span><span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="n">xj</span><span class="p">,</span><span class="n">zj</span><span class="o">=</span><span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xi</span><span class="p">:</span> <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zi</span><span class="p">:</span> <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xj</span><span class="p">:</span> <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zj</span><span class="p">:</span> <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="c1"># Enumerate 16 two-qubit Paulis on a pair</span>
<span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">all2</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>

<span class="c1"># Gate sequence and errors after each gate</span>
<span class="c1"># Gates: (1,2), (1,0), (2,3), (3,4), (0,4)</span>
<span class="n">Gates</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="c1"># Precompute conjugated errors to end for each gate and each 2-qubit Pauli</span>
<span class="n">conj_to_end</span><span class="o">=</span><span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Gates</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all2</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pauli_on_pair</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
        <span class="c1"># propagate through subsequent gates</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">cc</span><span class="p">,</span><span class="n">tt</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Gates</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">conj_cnot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span>
        <span class="n">conj_to_end</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<span class="c1"># Define stabilizers and logical Zs on data qubits 0..3 (bitmasks for 5 qubits, but we&#39;ll restrict)</span>
<span class="c1"># We&#39;ll use 5-qubit masks but ensure qubit 4 bits are zero</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_pauli_on</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
    <span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">q</span><span class="p">,</span><span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">xi</span><span class="p">,</span><span class="n">zi</span><span class="o">=</span><span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xi</span><span class="p">:</span> <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zi</span><span class="p">:</span> <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="n">Sx</span> <span class="o">=</span> <span class="n">make_pauli_on</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;XXXX&#39;</span><span class="p">))</span>
<span class="n">Sz</span> <span class="o">=</span> <span class="n">make_pauli_on</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ZZZZ&#39;</span><span class="p">))</span>
<span class="n">ZA</span> <span class="o">=</span> <span class="n">make_pauli_on</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ZZII&#39;</span><span class="p">))</span>
<span class="n">ZB</span> <span class="o">=</span> <span class="n">make_pauli_on</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ZIZI&#39;</span><span class="p">))</span>

<span class="c1"># Function to restrict to data (zero out ancilla bits)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">restrict_data</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="c1"># zero out qubit 4 bit</span>
    <span class="n">mask</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># bits 0..3 set</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">z</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>

<span class="c1"># Commutation check for two Pauli operators p and q</span>
<span class="c1"># They commute iff p.x · q.z + p.z · q.x = 0 (mod 2)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">commute</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="o">=</span><span class="n">q</span>
    <span class="c1"># bit dot product mod 2</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">bin</span><span class="p">((</span><span class="n">x1</span> <span class="o">&amp;</span> <span class="n">z2</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">((</span><span class="n">z1</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

<span class="c1"># Generate the good-group G = &lt;Sx, Sz, ZA, ZB&gt; as a set of (x,z) on data qubits</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span> <span class="k">as</span> <span class="n">itprod</span>

<span class="c1"># Build the group (ignoring phases): we can generate all 16 combinations</span>
<span class="n">G_good</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
<span class="c1"># We&#39;ll encode Paul&#39;s as 5-qubit masks but with bit 4 zero; We&#39;ll restrict for comparison simplicity</span>
<span class="n">gens</span><span class="o">=</span><span class="p">[</span><span class="n">Sx</span><span class="p">,</span> <span class="n">Sz</span><span class="p">,</span> <span class="n">ZA</span><span class="p">,</span> <span class="n">ZB</span><span class="p">]</span>
<span class="n">combos</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">itprod</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="k">for</span> <span class="n">coeffs</span> <span class="ow">in</span> <span class="n">combos</span><span class="p">:</span>
    <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span><span class="n">co</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gens</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">co</span><span class="p">:</span>
            <span class="n">p</span><span class="o">=</span><span class="n">pauli_mul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">G_good</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">restrict_data</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

<span class="c1"># Acceptance tests</span>

<span class="k">def</span><span class="w"> </span><span class="nf">accept_code</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">pd</span><span class="o">=</span><span class="n">restrict_data</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">commute</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">Sx</span><span class="p">)</span> <span class="ow">and</span> <span class="n">commute</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">Sz</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">accept_ancilla</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="c1"># accept if no X on ancilla (bit 4 of x is 0). Z on ancilla is fine</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">good_logical</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">pd</span><span class="o">=</span><span class="n">restrict_data</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span> <span class="ow">in</span> <span class="n">G_good</span>

<span class="c1"># Enumerate all patterns: for each gate choose one of 16 Paulis.</span>
<span class="c1"># We&#39;ll accumulate counts A_k and G_k for k = number of non-identity insertions.</span>
<span class="n">A</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">G</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">B</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>  <span class="c1"># bad accepted counts (accepted but not good)</span>

<span class="c1"># We&#39;ll also compute total number of patterns for each k for sanity: T[k]</span>
<span class="n">T</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>

<span class="c1"># Map symbol index to whether it&#39;s identity</span>
<span class="n">is_id</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">all2</span><span class="p">]</span>

<span class="c1"># Pre-list conj Paul&#39;s and whether id to count k easily</span>
<span class="n">conj_by_gate</span> <span class="o">=</span> <span class="n">conj_to_end</span>

<span class="c1"># We&#39;ll enumerate using indices 0..15 for each gate</span>
<span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="c1"># Count number of non-identity selections</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">is_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">)</span>
    <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
    <span class="c1"># Compute final error Pauli</span>
    <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">gate_index</span><span class="p">,</span> <span class="n">sym_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idxs</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pauli_mul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">conj_by_gate</span><span class="p">[</span><span class="n">gate_index</span><span class="p">][</span><span class="n">sym_index</span><span class="p">])</span>
    <span class="c1"># Acceptance checks</span>
    <span class="k">if</span> <span class="n">accept_code</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">accept_ancilla</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">good_logical</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

<span class="c1"># Let&#39;s print counts and totals</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Totals by k:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k, T[k], A[k], G[k], B[k]&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

<span class="c1"># Now we can write P_acc(p) and P_good(p), F = P_good / P_acc</span>
<span class="c1"># We&#39;ll express them as polynomials in q=(p/15) and r=(1-p)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="c1"># We&#39;ll produce coefficients as fractions </span>

<span class="k">def</span><span class="w"> </span><span class="nf">poly_acc</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="c1"># compute value symbolically representation as dict of powers of p up to 5 maybe convert to expanded polynomials later</span>
    <span class="k">pass</span>

<span class="c1"># But easiest: We&#39;ll produce symbolic expression using sympy if allowed, else compute rational coefficients by expanding terms numerically then reconstruct</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="n">Totals</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="nl">k</span><span class="p">:</span>
<span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">G</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">[</span><span class="n">k</span><span class="o">]</span>
<span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span>
<span class="mi">1</span><span class="w"> </span><span class="mi">75</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">0</span>
<span class="mi">2</span><span class="w"> </span><span class="mi">2250</span><span class="w"> </span><span class="mi">282</span><span class="w"> </span><span class="mi">138</span><span class="w"> </span><span class="mi">144</span>
<span class="mi">3</span><span class="w"> </span><span class="mi">33750</span><span class="w"> </span><span class="mi">4222</span><span class="w"> </span><span class="mi">1198</span><span class="w"> </span><span class="mi">3024</span>
<span class="mi">4</span><span class="w"> </span><span class="mi">253125</span><span class="w"> </span><span class="mi">31637</span><span class="w"> </span><span class="mi">7397</span><span class="w"> </span><span class="mi">24240</span>
<span class="mi">5</span><span class="w"> </span><span class="mi">759375</span><span class="w"> </span><span class="mi">94923</span><span class="w"> </span><span class="mi">24027</span><span class="w"> </span><span class="mi">70896</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="n">A</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">282</span><span class="p">,</span><span class="mi">4222</span><span class="p">,</span><span class="mi">31637</span><span class="p">,</span><span class="mi">94923</span><span class="p">]</span>
<span class="n">G</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">138</span><span class="p">,</span><span class="mi">1198</span><span class="p">,</span><span class="mi">7397</span><span class="p">,</span><span class="mi">24027</span><span class="p">]</span>
<span class="n">B</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">144</span><span class="p">,</span><span class="mi">3024</span><span class="p">,</span><span class="mi">24240</span><span class="p">,</span><span class="mi">70896</span><span class="p">]</span>

<span class="c1"># Build polynomials for P_acc and P_good as rational functions values in Fraction</span>
<span class="c1"># Represent polynomial as list of coefficients c0 + c1 p + c2 p^2 + ...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">poly_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="o">+</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">poly_mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">res</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ai</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">bj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">ai</span><span class="o">*</span><span class="n">bj</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="c1"># Build (1-p)^(n) polynomials</span>

<span class="k">def</span><span class="w"> </span><span class="nf">poly_pow_one_minus_p</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># (1-p)^n = sum_{j=0}^n C(n,j) * 1^{n-j} * (-p)^j</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">comb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

<span class="c1"># build term for given k: A[k]*(1-p)^(5-k)*(p/15)^k</span>

<span class="k">def</span><span class="w"> </span><span class="nf">term_poly</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># polynomial for (1-p)^(5-k)</span>
    <span class="n">p1</span><span class="o">=</span><span class="n">poly_pow_one_minus_p</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># multiply by (p/15)^k: scale by 1/15^k and shift degree by k</span>
    <span class="n">scale</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>
    <span class="n">p2</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="o">*</span><span class="n">k</span> <span class="o">+</span> <span class="p">[</span><span class="n">scale</span><span class="p">]</span>  <span class="c1"># placeholder for p^k; we&#39;ll multiply by p1</span>
    <span class="c1"># Multiply p1 and p2: (1-p)^(5-k) * p^k / 15^k</span>
    <span class="n">poly</span><span class="o">=</span><span class="n">poly_mul</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
    <span class="c1"># Multiply by count</span>
    <span class="n">poly</span><span class="o">=</span><span class="p">[</span><span class="n">count</span><span class="o">*</span><span class="n">coeff</span> <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">poly</span>

<span class="c1"># sum for P_acc and P_good</span>
<span class="n">Pacc</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
<span class="n">Pgood</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">Pacc</span><span class="o">=</span><span class="n">poly_add</span><span class="p">(</span><span class="n">Pacc</span><span class="p">,</span> <span class="n">term_poly</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">k</span><span class="p">))</span>
    <span class="n">Pgood</span><span class="o">=</span><span class="n">poly_add</span><span class="p">(</span><span class="n">Pgood</span><span class="p">,</span> <span class="n">term_poly</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">k</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc coefficients (Fractions) up to p^5:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Pacc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good coefficients:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Pgood</span><span class="p">)</span>

<span class="c1"># Simplify into common denominator maybe multiply by 15^5 to show nicer integers? But expression uses denominators 15^k; We&#39;ll just print exact fractions.</span>

<span class="c1"># Now compute P_bad_acc = Pacc - Pgood</span>
<span class="n">Pbad</span><span class="o">=</span><span class="p">[</span><span class="n">Pacc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">Pgood</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">Pgood</span><span class="p">)</span> <span class="k">else</span> <span class="n">Pacc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Pacc</span><span class="p">))]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_bad coefficients:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Pbad</span><span class="p">)</span>

<span class="c1"># Let&#39;s also produce the fidelity F(p) = Pgood/Pacc; We can keep as ratio of polynomials.</span>

<span class="c1"># For sanity, numerical approximation coefficients for small p: F=1 - cp^2 + O(p^3)? We&#39;ll compute series by dividing polynomials.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="k">def</span><span class="w"> </span><span class="nf">series_div</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="c1"># compute series num/den up to p^order where num,den are lists of Fractions</span>
    <span class="n">a</span><span class="o">=</span><span class="n">num</span> <span class="o">+</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
    <span class="n">b</span><span class="o">=</span><span class="n">den</span> <span class="o">+</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">den</span><span class="p">))</span>
    <span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">r</span><span class="o">=</span><span class="n">a</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span>
        <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># subtract q_i * den shifted by i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">order</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="c1"># drop r[0]</span>
        <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">q</span>

<span class="n">series</span><span class="o">=</span><span class="n">series_div</span><span class="p">(</span><span class="n">Pgood</span><span class="p">,</span> <span class="n">Pacc</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series coefficients for F(p) = sum c_n p^n:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>

<span class="c1"># Also print P_acc in a more compact factorized form like sum a_k (1-p)^(5-k) (p/15)^k, we already have counts; maybe we can present that directly.</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>P_acc coefficients (Fractions) up to p^5:
[Fraction(1, 1), Fraction(-68, 15), Fraction(704, 75), Fraction(-32768, 3375), Fraction(253952, 50625), Fraction(-262144, 253125)]
P_good coefficients:
[Fraction(1, 1), Fraction(-68, 15), Fraction(656, 75), Fraction(-29312, 3375), Fraction(223232, 50625), Fraction(-229376, 253125)]
P_bad coefficients:
[Fraction(0, 1), Fraction(0, 1), Fraction(16, 25), Fraction(-128, 125), Fraction(2048, 3375), Fraction(-32768, 253125)]
Series coefficients for F(p) = sum c_n p^n:
[Fraction(1, 1), Fraction(0, 1), Fraction(-16, 25), Fraction(128, 125), Fraction(112, 3375), Fraction(-701632, 253125)]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="n">Pacc</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span> <span class="mi">75</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">3375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span> <span class="mi">50625</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">262144</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)]</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">isclose</span>
<span class="c1"># Evaluate at p=1</span>
<span class="n">p1</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Pacc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Pacc</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc(1)=&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="n">p1</span><span class="p">)</span>
<span class="c1"># Compare to A5 / 15^5</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A5/15^5 =&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">94923</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="mi">5</span><span class="p">)),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">94923</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="mi">5</span><span class="p">))</span>
<span class="c1"># Evaluate F(1) and check good ratio</span>
<span class="n">Pgood</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">656</span><span class="p">,</span> <span class="mi">75</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">29312</span><span class="p">,</span> <span class="mi">3375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">223232</span><span class="p">,</span> <span class="mi">50625</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">229376</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)]</span>
<span class="n">pg1</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Pgood</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good(1)=&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">pg1</span><span class="p">),</span> <span class="n">pg1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;G5/15^5=&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">24027</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="mi">5</span><span class="p">)),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">24027</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="mi">5</span><span class="p">))</span>
<span class="n">F1</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">pg1</span><span class="o">/</span><span class="n">p1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F(1)=&#39;</span><span class="p">,</span> <span class="n">F1</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>P_acc(1)= 0.1250014814814815 10547/84375
A5/15^5 = 0.1250014814814815 10547/84375
P_good(1)= 0.03164049382716049 8009/253125
G5/15^5= 0.03164049382716049 8009/253125
F(1)= 0.25312095066527607
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Target state and circuit</li>
<li>The circuit executes, right-to-left:
    1) H1, 2) CNOT12, 3) CNOT10, 4) CNOT23, 5) CNOT34, 6) CNOT04, then measure M4 in the Z basis.</li>
<li>
<p>In the noiseless case, the data qubits 0–3 are prepared in the logical state |00⟩AB (the unique +1 eigenstate of the code stabilizers XXXX, ZZZZ and logical Zs Z_A=ZZII, Z_B=ZIZI), and the ancilla 4 ends in |0⟩, unentangled from the data.</p>
</li>
<li>
<p>Noise model</p>
</li>
<li>
<p>After each CNOT gate there is an independent two-qubit depolarizing channel:</p>
<ul>
<li>With probability 1−p: identity II on that pair.</li>
<li>With probability p: one of the 15 non-identity two-qubit Paulis, each with probability p/15.</li>
</ul>
</li>
<li>
<p>Pauli propagation through CNOTs</p>
</li>
<li>Conjugation by CNOT(c→t) on a Pauli with symplectic bits (x,z) acts linearly:<ul>
<li>x′_c = x_c, x′_t = x_t ⊕ x_c</li>
<li>z′_c = z_c ⊕ z_t, z′_t = z_t</li>
</ul>
</li>
<li>
<p>We insert the error after the kth CNOT and conjugate it forward through all subsequent CNOTs to get its effect at the end. The total error is the product (in Pauli group, up to a global phase) of the 5 propagated errors.</p>
</li>
<li>
<p>Acceptance and logical-correctness criteria</p>
</li>
<li>Code post-selection: accept only if the data-qubit error E_data commutes with both stabilizers XXXX and ZZZZ (i.e., E_data ∈ normalizer N(𝒮)). Otherwise it is “detected by the code” and the run is rejected.</li>
<li>Ancilla post-selection: in the ideal state the ancilla is |0⟩ and unentangled. Measuring Z4 yields 0 iff the final Pauli on qubit 4 is I or Z. Hence accept iff the ancilla factor has no X (i.e., the X-bit on qubit 4 is 0).</li>
<li>
<p>Logical fidelity among accepted runs: “good” errors are precisely those that fix the target logical state |00⟩AB. Since |00⟩AB is stabilized by the code stabilizers plus the logical Zs, the good set on the data is
    𝒢_good = ⟨XXXX, ZZZZ, Z_A, Z_B⟩.
    Thus an accepted error is logically correct iff E_data ∈ 𝒢_good.</p>
</li>
<li>
<p>Exact counting by stabilizer-Pauli enumeration</p>
</li>
<li>For each gate, there are 16 two-qubit Paulis; for 5 gates, 16^5 patterns. Let k be the number of non-identity insertions (k=0,…,5). Each pattern has probability (1−p)^(5−k) (p/15)^k.</li>
<li>
<p>Exhaustive enumeration (propagating each Pauli forward and checking the two acceptance tests and the “good” membership) yields, for each k, the number of accepted patterns A_k and the number of accepted-and-good patterns G_k:</p>
<ul>
<li>k=0: A_0=1, G_0=1</li>
<li>k=1: A_1=7, G_1=7</li>
<li>k=2: A_2=282, G_2=138</li>
<li>k=3: A_3=4222, G_3=1198</li>
<li>k=4: A_4=31637, G_4=7397</li>
<li>k=5: A_5=94923, G_5=24027</li>
</ul>
</li>
<li>
<p>Therefore</p>
<ul>
<li>Acceptance probability:
  P_acc(p) = ∑_{k=0}^5 A_k (1−p)^{5−k} (p/15)^k.</li>
<li>Good-accepted probability:
  P_good(p) = ∑_{k=0}^5 G_k (1−p)^{5−k} (p/15)^k.</li>
<li>Logical fidelity conditioned on acceptance:
  F_logical(p) = P_good(p) / P_acc(p).</li>
</ul>
</li>
<li>
<p>Closed-form polynomials</p>
</li>
<li>Expanding the above sums gives<ul>
<li>P_acc(p) = 1 − (68/15) p + (704/75) p^2 − (32768/3375) p^3 + (253952/50625) p^4 − (262144/253125) p^5.</li>
<li>P_good(p) = 1 − (68/15) p + (656/75) p^2 − (29312/3375) p^3 + (223232/50625) p^4 − (229376/253125) p^5.</li>
</ul>
</li>
<li>
<p>The (accepted but) logically-wrong probability is P_bad(p) = P_acc(p) − P_good(p) =
    (16/25) p^2 − (128/125) p^3 + (2048/3375) p^4 − (32768/253125) p^5.</p>
</li>
<li>
<p>Sanity check: small-p series</p>
</li>
<li>Dividing P_good by P_acc,
    F_logical(p) = 1 − (16/25) p^2 + (128/125) p^3 + (112/3375) p^4 − (701632/253125) p^5 + O(p^6),
    showing first-order faults are fully detected/removed (no p term), as expected for a fault-tolerant preparation.</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>As above.</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Error probability p is dimensionless.</li>
</ul>
<ol start="4">
<li>Final Answer:
The logical fidelity conditioned on post-selecting both the code’s detectable errors and the ancilla outcome M4=0 is</li>
</ol>
<div class="arithmatex">\[
F_{\mathrm{logical}}(p)
=\frac{P_{\mathrm{good}}(p)}{P_{\mathrm{acc}}(p)}
=\frac{1-\frac{68}{15}p+\frac{656}{75}p^2-\frac{29312}{3375}p^3+\frac{223232}{50625}p^4-\frac{229376}{253125}p^5}
       {1-\frac{68}{15}p+\frac{704}{75}p^2-\frac{32768}{3375}p^3+\frac{253952}{50625}p^4-\frac{262144}{253125}p^5}.
\]</div>
<p>Equivalently,</p>
<div class="arithmatex">\[
F_{\mathrm{logical}}(p)
=1-\frac{\frac{16}{25}p^2-\frac{128}{125}p^3+\frac{2048}{3375}p^4-\frac{32768}{253125}p^5}
           {1-\frac{68}{15}p+\frac{704}{75}p^2-\frac{32768}{3375}p^3+\frac{253952}{50625}p^4-\frac{262144}{253125}p^5}.
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#13</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#14</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">656</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">29312</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">223232</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">229376</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">262144</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.904536
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>