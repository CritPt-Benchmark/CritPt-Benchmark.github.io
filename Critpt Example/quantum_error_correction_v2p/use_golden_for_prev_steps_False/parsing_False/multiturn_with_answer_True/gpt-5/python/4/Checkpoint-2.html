<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">üåì</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Ideal output state of the circuit</li>
<li>Start from |0000‚ü©.</li>
<li>Apply H on qubit 2, then CNOT21: this prepares a Bell pair on qubits (2,1),</li>
</ul>
<div class="arithmatex">\[
|\Phi^+\rangle_{21}=\frac{|00\rangle_{21}+|11\rangle_{21}}{\sqrt{2}},
\]</div>
<div class="codehilite"><pre><span></span><code><span class="k">while</span><span class="w"> </span><span class="nv">qubits</span><span class="w"> </span><span class="ss">(</span><span class="mi">0</span>,<span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="nv">remain</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="o">|</span><span class="mi">00</span>‚ü©.
</code></pre></div>

<ul>
<li>Apply H on qubit 0, then CNOT03: this prepares a Bell pair on qubits (0,3),</li>
</ul>
<div class="arithmatex">\[
|\Phi^+\rangle_{03}=\frac{|00\rangle_{03}+|11\rangle_{03}}{\sqrt{2}}.
\]</div>
<ul>
<li>Therefore, the ideal final 4-qubit state is</li>
</ul>
<div class="arithmatex">\[
|\psi_{\mathrm{id}}\rangle = |\Phi^+\rangle_{21}\otimes |\Phi^+\rangle_{03}.
\]</div>
<ul>
<li>Stabilizers of the ideal state</li>
<li>The Bell state |Œ¶+‚ü© on a pair (i,j) is stabilized by XiXj and ZiZj, and hence by the 4-element subgroup {I‚äóI, XiXj, YiYj, ZiZj} (up to phase).</li>
<li>Hence</li>
</ul>
<div class="arithmatex">\[
\mathcal{S} = \langle X_2X_1,\,Z_2Z_1,\,X_0X_3,\,Z_0Z_3\rangle,
\]</div>
<div class="codehilite"><pre><span></span><code>and factorizes as
</code></pre></div>

<div class="arithmatex">\[
      \mathcal{S}_{21}=\{II,\,X_2X_1,\,Y_2Y_1,\,Z_2Z_1\},\quad
\]</div>
<ul>
<li>Noise model after the CNOTs</li>
<li>After each CNOT, a two-qubit depolarizing channel acts on that pair:</li>
</ul>
<div class="arithmatex">\[
\mathcal{E}(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\in\mathcal{P}_2\setminus\{II\}}P\rho P,
\]</div>
<div class="codehilite"><pre><span></span><code>where the sum runs over the 15 non-identity two-qubit Paulis on that pair.
</code></pre></div>

<ul>
<li>
<p>In our circuit there are two such channels: one on qubits (2,1) after CNOT21 and one on (0,3) after CNOT03. These errors are independent and act on disjoint qubit sets. The single-qubit H gates are assumed perfect.</p>
</li>
<li>
<p>Fidelity with a pure stabilizer state</p>
</li>
<li>
<p>For a pure stabilizer state |œàid‚ü©, a Pauli error P maps |œàid‚ü© to either the same state (up to a global phase) if P‚ààùíÆ, or to a state orthogonal to |œàid‚ü© if P‚àâùíÆ. Therefore, the state fidelity is exactly the probability that the net Pauli error lies in the stabilizer group ùíÆ.</p>
</li>
<li>
<p>Probability that a single two-qubit depolarizing error is ‚Äúbenign‚Äù</p>
</li>
<li>On a given pair (say 2,1), the ‚Äúbenign‚Äù Paulis (those in the pair‚Äôs stabilizer) are {II, XX, YY, ZZ}. Under the depolarizing channel:<ul>
<li>Pr[II] = 1 ‚àí p,</li>
<li>Pr[XX] = Pr[YY] = Pr[ZZ] = p/15.</li>
</ul>
</li>
<li>Hence, the probability that the error on that pair preserves the Bell state is</li>
</ul>
<div class="arithmatex">\[
P_{\mathrm{benign}} = (1-p)+3\frac{p}{15}=1-\frac{4p}{5}.
\]</div>
<ul>
<li>Total fidelity</li>
<li>Because the two error channels act on disjoint pairs and are independent, the final 4-qubit state fidelity is the product of the two benign probabilities:</li>
</ul>
<div class="arithmatex">\[
F(p)=\left(1-\frac{4p}{5}\right)^2.
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All equations are given above in LaTeX.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Qubits labeled 0,1,2,3; CNOTij has control i, target j.</li>
<li>Two-qubit depolarizing noise of strength p acts after each CNOT.</li>
<li>Fidelity is F = ‚ü®œàid|œÅ|œàid‚ü©.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = (1 - 4p/5)^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="c1"># Define Pauli multiplication ignoring phase; represent as strings &#39;I&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;</span>
<span class="c1"># Provide function to compute commutation: returns True if commute, False if anticommute.</span>

<span class="n">paulis</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

<span class="c1"># Single-qubit commutation table: anticommute pairs are X-Z, X-Y, Y-Z</span>
<span class="n">anticommute_pairs</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">),(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">),(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">),(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">),(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">),(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">)}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">single_anticommute</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">or</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">or</span> <span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">anticommute_pairs</span>

<span class="c1"># For tensor products represented as strings over length 4</span>

<span class="k">def</span><span class="w"> </span><span class="nf">anticommutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="c1"># Count number of positions where local Paulis anticommute</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">single_anticommute</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># anticommute iff odd number of local anticommutes</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">commutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>

<span class="c1"># Code stabilizers</span>
<span class="n">S1</span> <span class="o">=</span> <span class="s1">&#39;XXXX&#39;</span>
<span class="n">S2</span> <span class="o">=</span> <span class="s1">&#39;ZZZZ&#39;</span>

<span class="c1"># Logical operators</span>
<span class="n">X_A</span> <span class="o">=</span> <span class="s1">&#39;XIXI&#39;</span>
<span class="n">Z_A</span> <span class="o">=</span> <span class="s1">&#39;ZZII&#39;</span>
<span class="n">X_B</span> <span class="o">=</span> <span class="s1">&#39;XXII&#39;</span>
<span class="n">Z_B</span> <span class="o">=</span> <span class="s1">&#39;ZIZI&#39;</span>

<span class="c1"># Allowed pair Paulis on (2,1) and (0,3)</span>
<span class="c1"># Note our order is (0,1,2,3), so to place a 2-qubit Pauli on pair (2,1)</span>
<span class="c1"># we fill positions: 0:&#39;I&#39;,1:P1,2:P2,3:&#39;I&#39; with P2 on qubit2, P1 on qubit1.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">embed_pair_21</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span>
    <span class="c1"># p1 acts on qubit1, p2 acts on qubit2</span>
    <span class="k">return</span> <span class="s1">&#39;I&#39;</span> <span class="o">+</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span> <span class="o">+</span> <span class="s1">&#39;I&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">embed_pair_03</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">p3</span><span class="p">):</span>
    <span class="c1"># p0 acts on qubit0, p3 acts on qubit3</span>
    <span class="k">return</span> <span class="n">p0</span> <span class="o">+</span> <span class="s1">&#39;I&#39;</span> <span class="o">+</span> <span class="s1">&#39;I&#39;</span> <span class="o">+</span> <span class="n">p3</span>

<span class="c1"># Function to multiply Pauli strings ignoring phase</span>
<span class="c1"># We just need for combining P21 and P03, which act on disjoint supports, so multiplication is just overlay</span>

<span class="k">def</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="c1"># they act on disjoint supports in our construction; assert no conflicts</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="k">if</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="k">else</span> <span class="p">(</span><span class="n">b</span> <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>
    <span class="c1"># None should not appear</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

<span class="c1"># Construct all allowed two-qubit Paulis on a pair, with probabilities depending on p</span>
<span class="n">p</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="c1"># placeholder, probabilities symbolic later</span>

<span class="n">pair_nonidentity</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">paulis</span><span class="p">,</span> <span class="n">paulis</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="c1"># We&#39;ll classify types per pair: parity (x,z)</span>
<span class="n">XZ</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="s1">&#39;X&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="s1">&#39;Y&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="s1">&#39;Z&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pair_type</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">XZ</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">XZ</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">XZ</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">XZ</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="c1"># Verify classes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="n">classes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">paulis</span><span class="p">,</span><span class="n">paulis</span><span class="p">):</span>
    <span class="n">classes</span><span class="p">[</span><span class="n">pair_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>

<span class="n">classes_count</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">classes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Class sizes per pair type (x,z):&#39;</span><span class="p">,</span> <span class="n">classes_count</span><span class="p">)</span>

<span class="c1"># Now enumerate all P_total = P21 * P03 with types equal for acceptance and compute logical effect</span>

<span class="n">all_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">paulis</span><span class="p">,</span> <span class="n">paulis</span><span class="p">))</span>

<span class="c1"># define commutation with logicals -&gt; determine logical effect Ebar as a pair of single-qubit Paulis on (A,B)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">logical_action</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
    <span class="c1"># Determine x,z bits for A and B via commutation</span>
    <span class="c1"># x_bit = anticommutes with Z, z_bit = anticommutes with X</span>
    <span class="n">xA</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Z_A</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">zA</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">X_A</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">xB</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Z_B</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">zB</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">X_B</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="c1"># map bits to char</span>
    <span class="n">inv</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="s1">&#39;I&#39;</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="s1">&#39;X&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="s1">&#39;Z&#39;</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="s1">&#39;Y&#39;</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">inv</span><span class="p">[(</span><span class="n">xA</span><span class="p">,</span><span class="n">zA</span><span class="p">)]</span> <span class="o">+</span> <span class="n">inv</span><span class="p">[(</span><span class="n">xB</span><span class="p">,</span><span class="n">zB</span><span class="p">)]</span>

<span class="c1"># Now compute probabilities symbolically in terms of p: we&#39;ll tally weights as linear/quadratic polynomials in p and 1-p</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="c1"># Probabilities per 2-qubit Pauli on a pair:</span>
<span class="c1"># II: 1-p; each other: p/15</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pair_prob</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;lin&#39;</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># Represent as (type, A, B) meaning A + B p, but we want (1-p)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;constp&#39;</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span> <span class="c1"># means (p/15)</span>

<span class="c1"># We will accumulate probabilities for acceptance and for GHZ-stabilizing logical actions</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>

<span class="c1"># We&#39;ll symbolically compute: total weights as functions: W = c0 + c1 p + c2 p^2</span>
<span class="c1"># Because two independent errors -&gt; polynomial up to p^2.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Poly</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c0</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">c1</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">c2</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c0</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="n">c0</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c0</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">c0</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">c1</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">c2</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">out</span><span class="o">=</span><span class="n">Poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="p">);</span> <span class="n">out</span><span class="o">+=</span><span class="n">other</span><span class="p">;</span> <span class="k">return</span> <span class="n">out</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># multiply polynomials up to degree 2 only; but we will only multiply up to deg1 x deg1 -&gt; deg2 (fine)</span>
        <span class="n">out</span><span class="o">=</span><span class="n">Poly</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">c0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c0</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">c0</span>
        <span class="n">out</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c0</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">c1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">c0</span>
        <span class="n">out</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c0</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">c2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">c1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">c0</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c0</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="si">}</span><span class="s2"> p + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="si">}</span><span class="s2"> p^2&quot;</span>

<span class="c1"># Build polynomial probability for each (a,b) pair on each pair (21 or 03)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">prob_poly_pair</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">:</span>
        <span class="c1"># 1-p = 1 + (-1) p</span>
        <span class="k">return</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># p/15 = 0 + (1/15) p</span>
        <span class="k">return</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Now enumerate and sum accepted cases.</span>

<span class="c1"># For acceptance, type equality across pairs:</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pair_type_key</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pair_type</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># GHZ logical stabilizer set on (A,B): {II, XX, ZZ, YY}</span>
<span class="n">GHZ_stab</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;II&#39;</span><span class="p">,</span> <span class="s1">&#39;XX&#39;</span><span class="p">,</span> <span class="s1">&#39;ZZ&#39;</span><span class="p">,</span> <span class="s1">&#39;YY&#39;</span><span class="p">}</span>

<span class="n">P_accept</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">()</span>
<span class="n">P_good</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">()</span>
<span class="c1"># Also tally distribution over logical actions for accepted events</span>
<span class="n">logdist</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">all_pairs</span><span class="p">:</span>
    <span class="n">P21</span> <span class="o">=</span> <span class="n">embed_pair_21</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># careful: a is (p0, p1) ??? For pair21 we used p1 on qubit1, p2 on qubit2: here let a=(p1,p2)</span>
    <span class="c1"># Actually our &#39;a&#39; will be (p1,p2) for pair (1,2); we set P21 accordingly</span>
    <span class="n">P21</span> <span class="o">=</span> <span class="n">embed_pair_21</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">prob21</span> <span class="o">=</span> <span class="n">prob_poly_pair</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">type21</span> <span class="o">=</span> <span class="n">pair_type</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">all_pairs</span><span class="p">:</span>
        <span class="n">P03</span> <span class="o">=</span> <span class="n">embed_pair_03</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">prob03</span> <span class="o">=</span> <span class="n">prob_poly_pair</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">type03</span> <span class="o">=</span> <span class="n">pair_type</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">type03</span> <span class="o">!=</span> <span class="n">type21</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">Ptot</span> <span class="o">=</span> <span class="n">combine</span><span class="p">(</span><span class="n">P21</span><span class="p">,</span> <span class="n">P03</span><span class="p">)</span>
        <span class="c1"># Confirm commute with stabilizers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span><span class="n">S1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">commutes</span><span class="p">(</span><span class="n">Ptot</span><span class="p">,</span><span class="n">S2</span><span class="p">)):</span>
            <span class="c1"># Shouldn&#39;t happen: type equality implies commute with both</span>
            <span class="k">pass</span>
        <span class="n">act</span> <span class="o">=</span> <span class="n">logical_action</span><span class="p">(</span><span class="n">Ptot</span><span class="p">)</span>
        <span class="n">logdist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">act</span><span class="p">,</span> <span class="n">Poly</span><span class="p">())</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">prob21</span> <span class="o">*</span> <span class="n">prob03</span>
        <span class="n">P_accept</span> <span class="o">+=</span> <span class="n">weight</span>
        <span class="n">logdist</span><span class="p">[</span><span class="n">act</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
        <span class="k">if</span> <span class="n">act</span> <span class="ow">in</span> <span class="n">GHZ_stab</span><span class="p">:</span>
            <span class="n">P_good</span> <span class="o">+=</span> <span class="n">weight</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_accept polynomial:&#39;</span><span class="p">,</span> <span class="n">P_accept</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good polynomial:&#39;</span><span class="p">,</span> <span class="n">P_good</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Distribution over logical actions (polynomials):&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">logdist</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="c1"># Simplify to rational coefficients</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">P_accept</span>
<span class="n">good</span> <span class="o">=</span> <span class="n">P_good</span>

<span class="c1"># Compute logical fidelity F_log(p) = good / acc (as rational functions)</span>
<span class="c1"># For general p, F(p) = (c0g + c1g p + c2g p^2)/(c0a + c1a p + c2a p^2)</span>

<span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">good</span><span class="o">.</span><span class="n">c0</span><span class="p">,</span> <span class="n">good</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">good</span><span class="o">.</span><span class="n">c2</span><span class="p">)</span>
<span class="n">den</span> <span class="o">=</span> <span class="p">(</span><span class="n">acc</span><span class="o">.</span><span class="n">c0</span><span class="p">,</span> <span class="n">acc</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">acc</span><span class="o">.</span><span class="n">c2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num:&#39;</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;den:&#39;</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="nx">Class</span><span class="w"> </span><span class="nx">sizes</span><span class="w"> </span><span class="nx">per</span><span class="w"> </span><span class="nx">pair</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">z</span><span class="p">):</span><span class="w"> </span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">):</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">):</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">):</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">):</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span>
<span class="nx">P_accept</span><span class="w"> </span><span class="nx">polynomial</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">-</span><span class="mi">8</span><span class="o">/</span><span class="mi">5</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="o">/</span><span class="mi">75</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">P_good</span><span class="w"> </span><span class="nx">polynomial</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">-</span><span class="mi">8</span><span class="o">/</span><span class="mi">5</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">16</span><span class="o">/</span><span class="mi">25</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">Distribution</span><span class="w"> </span><span class="nx">over</span><span class="w"> </span><span class="nx">logical</span><span class="w"> </span><span class="nx">actions</span><span class="w"> </span><span class="p">(</span><span class="nx">polynomials</span><span class="p">):</span>
<span class="nx">II</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">76</span><span class="o">/</span><span class="mi">75</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">IX</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">IY</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">IZ</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">XI</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">XX</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">-</span><span class="mi">28</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">XY</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">XZ</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">YI</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">YX</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">YY</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">-</span><span class="mi">28</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">YZ</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">ZI</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">ZX</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">ZY</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">ZZ</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">-</span><span class="mi">28</span><span class="o">/</span><span class="mi">225</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">2</span>
<span class="nx">num</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nx">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">),</span><span class="w"> </span><span class="nx">Fraction</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">))</span>
<span class="nx">den</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nx">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nx">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">),</span><span class="w"> </span><span class="nx">Fraction</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">75</span><span class="p">))</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Ideal encoded target and the prepared state</li>
<li>The circuit (H2 ‚Üí CNOT21) prepares a Bell pair on qubits (2,1), and (H0 ‚Üí CNOT03) prepares a Bell pair on (0,3):</li>
</ul>
<div class="arithmatex">\[
|\psi_{\text{id}}\rangle = |\Phi^+\rangle_{21}\otimes|\Phi^+\rangle_{03},\quad |\Phi^+\rangle=\frac{|00\rangle+|11\rangle}{\sqrt{2}}.
\]</div>
<ul>
<li>This state is stabilized by</li>
</ul>
<div class="arithmatex">\[
X_2X_1,\ Z_2Z_1,\ X_0X_3,\ Z_0Z_3.
\]</div>
<div class="codehilite"><pre><span></span><code>The [[4,2,2]] code stabilizers are $XXXX$ and $ZZZZ$, and the logical Bell (GHZ) stabilizers are $X_A X_B=X_2X_1$ and $Z_A Z_B=Z_2Z_1$.
</code></pre></div>

<ul>
<li>Noise model and independence</li>
<li>After CNOT21, a two-qubit depolarizing channel acts on qubits (2,1); after CNOT03, the same on (0,3). These two channels are independent and act on disjoint qubits.</li>
<li>
<p>For a two-qubit depolarizing channel with error rate <span class="arithmatex">\(p\)</span>:</p>
<ul>
<li><span class="arithmatex">\(II\)</span> occurs with probability <span class="arithmatex">\(1-p\)</span>,</li>
<li>each of the 15 non-identity two-qubit Paulis occurs with probability <span class="arithmatex">\(p/15\)</span>.</li>
</ul>
</li>
<li>
<p>Parity classification on a pair</p>
</li>
<li>For a two-qubit Pauli <span class="arithmatex">\(P\)</span> on a fixed pair, define the parity type</li>
</ul>
<div class="arithmatex">\[
t(P)=(x,z)\in\{0,1\}^2,
\]</div>
<div class="codehilite"><pre><span></span><code>where $x$ is the parity of the number of $X$ or $Y$ factors, and $z$ is the parity of the number of $Z$ or $Y$ factors on the two qubits.
</code></pre></div>

<ul>
<li>The 16 pair Paulis split into four equally sized classes:<ul>
<li>Type I: <span class="arithmatex">\((0,0)\)</span> = {II, XX, YY, ZZ} (4 elements)</li>
<li>Type X: <span class="arithmatex">\((1,0)\)</span> (4 elements)</li>
<li>Type Z: <span class="arithmatex">\((0,1)\)</span> (4 elements)</li>
<li>Type Y: <span class="arithmatex">\((1,1)\)</span> (4 elements)</li>
</ul>
</li>
<li>The probabilities for a single pair are:</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Post-selection (detectable-error rejection)</li>
<li>A 4-qubit Pauli <span class="arithmatex">\(P\)</span> on the two pairs is accepted (undetected) iff it commutes with both code stabilizers <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>.</li>
<li>Using the parity picture: <span class="arithmatex">\(P\)</span> commutes with <span class="arithmatex">\(ZZZZ\)</span> iff the total <span class="arithmatex">\(x\)</span>-parity across all four qubits is even, and commutes with <span class="arithmatex">\(XXXX\)</span> iff the total <span class="arithmatex">\(z\)</span>-parity is even. Since the error is a product of a Pauli on (2,1) and one on (0,3), this is equivalent to requiring the two pair-types match:</li>
</ul>
<div class="arithmatex">\[
t(P_{21})=t(P_{03}).
\]</div>
<ul>
<li>Therefore, the acceptance probability is</li>
</ul>
<div class="arithmatex">\[
      =w_I^2+3\,w_X^2
\]</div>
<ul>
<li>Which accepted errors preserve the logical Bell state?</li>
<li>The logical GHZ (Bell) state on <span class="arithmatex">\((A,B)\)</span> is stabilized by <span class="arithmatex">\(X_A X_B\)</span> and <span class="arithmatex">\(Z_A Z_B\)</span>; physically these are <span class="arithmatex">\(X_2X_1\)</span> and <span class="arithmatex">\(Z_2Z_1\)</span>.</li>
<li>Any accepted error from Type I on both pairs (i.e., <span class="arithmatex">\(t=I\)</span> on (2,1) and <span class="arithmatex">\(t=I\)</span> on (0,3)) is a product of the four pair stabilizers <span class="arithmatex">\(X_2X_1,\ Z_2Z_1,\ X_0X_3,\ Z_0Z_3\)</span>, hence lies in the full stabilizer of <span class="arithmatex">\(|\psi_{\text{id}}\rangle\)</span> and preserves the logical Bell state.</li>
<li>If both pairs are Type X, then the total error anticommutes with <span class="arithmatex">\(Z_AZ_B\)</span> and changes the Bell eigenvalue (similarly, Type Z anticommutes with <span class="arithmatex">\(X_AX_B\)</span>, and Type Y anticommutes with both). Thus types X√óX, Z√óZ, Y√óY never preserve the logical Bell state.</li>
<li>Therefore, the probability of an accepted, logically correct outcome is exactly</li>
</ul>
<div class="arithmatex">\[
P_{\text{good}}=w_I^2=\left(1-\frac{4}{5}p\right)^2.
\]</div>
<ul>
<li>Logical fidelity with post-selection</li>
<li>The logical state fidelity (conditioned on acceptance) is</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Equivalently, expanded as a rational function:</li>
</ul>
<div class="arithmatex">\[
F_{\text{logical}}(p)=\frac{1-\frac{8}{5}p+\frac{16}{25}p^2}{1-\frac{8}{5}p+\frac{64}{75}p^2}.
\]</div>
<ul>
<li>Small-<span class="arithmatex">\(p\)</span> expansion (showing distance-2 detection eliminates all first-order logical error):</li>
</ul>
<div class="arithmatex">\[
F_{\text{logical}}(p)=1-\frac{16}{75}p^2+O(p^3).
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All expressions are written in LaTeX above.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Qubits labeled 0,1,2,3; logical qubits A,B.</li>
<li>Stabilizers: <span class="arithmatex">\(XXXX\)</span>, <span class="arithmatex">\(ZZZZ\)</span>.</li>
<li>Logical operators: <span class="arithmatex">\(X_A=XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A=ZZII\)</span>, <span class="arithmatex">\(Z_B=ZIZI\)</span>.</li>
<li>Two-qubit depolarizing noise of strength <span class="arithmatex">\(p\)</span> acts after each CNOT.</li>
<li>Fidelity is <span class="arithmatex">\(F=\langle\psi_{\text{ideal}}|\rho|\psi_{\text{ideal}}\rangle\)</span>; post-selection keeps only runs with no stabilizer flips.</li>
</ul>
<ol start="4">
<li>Final Answer:
<span class="arithmatex">\(F_{\text{logical}}(p)=\dfrac{\left(1-\frac{4}{5}p\right)^2}{\left(1-\frac{4}{5}p\right)^2+3\left(\frac{4}{15}p\right)^2}
=\dfrac{1-\frac{8}{5}p+\frac{16}{25}p^2}{1-\frac{8}{5}p+\frac{64}{75}p^2}
=1-\dfrac{16}{75}p^2+O(p^3).\)</span></li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.574958
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>