<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="c1"># Represent Pauli on n=5 qubits as (x[], z[]) bit arrays, ignoring global phase</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Utility functions</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># Multiply two Paulis (x,z pairs), ignoring overall phase</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">q</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="c1"># Conjugations</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_H</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># Hadamard on qubit q: X &lt;-&gt; Z, Y-&gt; -Y (phase ignored)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_CNOT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="c1"># Conjugate Pauli by CNOT(c-&gt;t):</span>
    <span class="c1"># X_c -&gt; X_c X_t (i.e., x_t ^= x_c)</span>
    <span class="c1"># Z_t -&gt; Z_c Z_t (i.e., z_c ^= z_t)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
    <span class="c1"># new x_t = x_t ^ x_c</span>
    <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">^=</span> <span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
    <span class="c1"># new z_c = z_c ^ z_t</span>
    <span class="n">z</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">^=</span> <span class="n">z</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="c1"># Build single-qubit Pauli basis</span>
<span class="n">single_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

<span class="c1"># Map two-qubit pauli on given pair (a,b) from labels like &#39;XI&#39;, &#39;XZ&#39;, etc.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">twoq_pauli</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># label is two chars over {I,X,Y,Z}</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
            <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="c1"># Gates in order g1..g5 (right-to-left application order in the problem statement):</span>
<span class="c1"># We&#39;ll label in the chronological forward order they are applied.</span>
<span class="c1"># Sequence: H1, CNOT_12, CNOT_10, CNOT_23, CNOT_34, CNOT_04, then measure ancilla</span>
<span class="c1"># Errors happen AFTER each CNOT, so after g1=CNOT_12, g2=CNOT_10, g3=CNOT_23, g4=CNOT_34, g5=CNOT_04</span>

<span class="n">gates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>  <span class="c1"># g1</span>
    <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># g2</span>
    <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  <span class="c1"># g3</span>
    <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>  <span class="c1"># g4</span>
    <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>  <span class="c1"># g5</span>
<span class="p">]</span>

<span class="c1"># We also have an initial H on qubit 1, but since errors are after gates, it only matters for state prep,</span>
<span class="c1"># not for error propagation to the end (we only propagate errors forward through subsequent CNOTs and measure).</span>

<span class="c1"># Precompute forward conjugation of an error inserted after gate k, to the end.</span>
<span class="c1"># That is, apply successive conjugations of subsequent gates g_{k+1}..g5 to the error.</span>

<span class="c1"># Build list of 15 non-identity 2-qubit labels</span>
<span class="n">labels_2q</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="s1">&#39;IXYZ&#39;</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="s1">&#39;IXYZ&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">labels_2q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
<span class="n">labels_2q</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels_2q</span> <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="s1">&#39;II&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_2q</span><span class="p">)</span> <span class="o">==</span> <span class="mi">15</span>

<span class="c1"># Map from gate idx to qubit pair</span>
<span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="c1"># function to propagate an inserted 2q pauli at gate index k (1..5) with label lab to the end</span>

<span class="k">def</span><span class="w"> </span><span class="nf">propagate_error_to_end</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">lab</span><span class="p">):</span>
    <span class="c1"># initial Pauli right after gate k</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">twoq_pauli</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="c1"># propagate through g_{k+1}..g5</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gates</span><span class="p">)):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">gates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;CNOT&#39;</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">conj_CNOT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Utility: check ancilla acceptance: ancilla (qubit 4) must be I or Z (i.e., x4==0)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">ancilla_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># if x4==1 then ancilla has X or Y, flips Z measurement</span>

<span class="c1"># Utility: code acceptance: commute with XXXX and ZZZZ -&gt; even parity of Z and X respectively on data 0..3</span>

<span class="k">def</span><span class="w"> </span><span class="nf">code_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">px</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="n">pz</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">px</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Logical X presence test using commutation with logical Z_A and Z_B.</span>
<span class="c1"># Z_A = Z on qubits 0 and 1; Z_B = Z on qubits 0 and 2? Wait from problem: Z_A=ZZII (0,1), Z_B=ZIZI (0,2)</span>

<span class="c1"># Build these as Paulis on 5 qubits (ancilla unaffected)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">make_multiZ</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="n">Z_A</span> <span class="o">=</span> <span class="n">make_multiZ</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Z_B</span> <span class="o">=</span> <span class="n">make_multiZ</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># Commutator tester: p anticommutes with q if dot(x_p, z_q)+dot(z_p, x_q) mod 2 == 1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">anticommutes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">q</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">^=</span> <span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">z2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">^=</span> <span class="p">(</span><span class="n">z1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span>

<span class="c1"># Data-only part of a Pauli (zeroing ancilla bits)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">data_part</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">xd</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">zd</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">zd</span><span class="p">)</span>

<span class="c1"># Does P_data include a logical X on A or B?</span>

<span class="k">def</span><span class="w"> </span><span class="nf">has_logical_X</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="c1"># Only data part matters for logical op; ancilla bits ignore</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">data_part</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Z_A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Z_B</span><span class="p">)</span>

<span class="c1"># Lets enumerate single and double faults contributions</span>

<span class="c1"># Precompute errors-to-end for each gate and label</span>
<span class="n">E_end</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels_2q</span><span class="p">:</span>
        <span class="n">E_end</span><span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">lab</span><span class="p">)]</span> <span class="o">=</span> <span class="n">propagate_error_to_end</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">lab</span><span class="p">)</span>

<span class="c1"># Single fault stats</span>
<span class="n">single_stats</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;total&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">&#39;acc_anc&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">&#39;acc_code&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">&#39;acc_both&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">&#39;acc_good&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">&#39;acc_bad&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># accepted but logical X present</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels_2q</span><span class="p">:</span>
        <span class="n">p_end</span> <span class="o">=</span> <span class="n">E_end</span><span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">lab</span><span class="p">)]</span>
        <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ancilla_accepts</span><span class="p">(</span><span class="n">p_end</span><span class="p">):</span>
            <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_anc&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">code_accepts</span><span class="p">(</span><span class="n">p_end</span><span class="p">):</span>
                <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_both&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">has_logical_X</span><span class="p">(</span><span class="n">p_end</span><span class="p">):</span>
                    <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_bad&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_good&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># also count code_accepts marginally</span>
        <span class="k">if</span> <span class="n">code_accepts</span><span class="p">(</span><span class="n">p_end</span><span class="p">):</span>
            <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_code&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">single_stats</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>&#39;&#39;
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single-fault stats:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">single_stats</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
NameError: name &#39;single_stats&#39; is not defined

Single-fault stats:
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="o">=</span><span class="n">p</span>
    <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="o">=</span><span class="n">q</span>
    <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)]</span>
    <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_H</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="n">r</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">],</span><span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_CNOT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="n">r</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">^=</span><span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
    <span class="n">z</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">^=</span><span class="n">z</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="n">single_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">twoq_pauli</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">ch</span><span class="p">,</span><span class="n">q</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">label</span><span class="p">,[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;Z&#39;</span><span class="p">:</span>
            <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="n">gates</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">labels_2q</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="s1">&#39;IXYZ&#39;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="s1">&#39;IXYZ&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_2q</span><span class="p">)</span><span class="o">==</span><span class="mi">15</span>
<span class="n">pairs</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">propagate_error_to_end</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">pairs</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">p</span><span class="o">=</span><span class="n">twoq_pauli</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">gates</span><span class="p">)):</span>
        <span class="n">name</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">gates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">p</span><span class="o">=</span><span class="n">conj_CNOT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="k">def</span><span class="w"> </span><span class="nf">ancilla_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">code_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="n">px</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">%</span><span class="mi">2</span>
    <span class="n">pz</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">%</span><span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">px</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pz</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">make_multiZ</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
    <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span> <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="n">Z_A</span><span class="o">=</span><span class="n">make_multiZ</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Z_B</span><span class="o">=</span><span class="n">make_multiZ</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">anticommutes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="o">=</span><span class="n">q</span>
    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span><span class="o">^=</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">z2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">s</span><span class="o">^=</span><span class="p">(</span><span class="n">z1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">==</span><span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">data_part</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="n">xd</span><span class="o">=</span><span class="n">x</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">zd</span><span class="o">=</span><span class="n">z</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">xd</span><span class="p">,</span><span class="n">zd</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">has_logical_X</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">d</span><span class="o">=</span><span class="n">data_part</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">Z_A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">Z_B</span><span class="p">)</span>

<span class="n">E_end</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels_2q</span><span class="p">:</span>
        <span class="n">E_end</span><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">)]</span><span class="o">=</span><span class="n">propagate_error_to_end</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">)</span>

<span class="n">single_stats</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;acc_anc&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;acc_code&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;acc_both&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;acc_good&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;acc_bad&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels_2q</span><span class="p">:</span>
        <span class="n">p_end</span><span class="o">=</span><span class="n">E_end</span><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">)]</span>
        <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">ancilla_accepts</span><span class="p">(</span><span class="n">p_end</span><span class="p">):</span>
            <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_anc&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">code_accepts</span><span class="p">(</span><span class="n">p_end</span><span class="p">):</span>
                <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_both&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">has_logical_X</span><span class="p">(</span><span class="n">p_end</span><span class="p">):</span>
                    <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_bad&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_good&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">code_accepts</span><span class="p">(</span><span class="n">p_end</span><span class="p">):</span>
            <span class="n">single_stats</span><span class="p">[</span><span class="s1">&#39;acc_code&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single-fault stats:&#39;</span><span class="p">,</span> <span class="n">single_stats</span><span class="p">)</span>

<span class="c1"># Enumerate double faults across distinct gates (k1&lt;k2)</span>

<span class="n">double_stats</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;total_pairs&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;acc_both&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;acc_good&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;acc_bad&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
<span class="n">malignant_list</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lab1</span> <span class="ow">in</span> <span class="n">labels_2q</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lab2</span> <span class="ow">in</span> <span class="n">labels_2q</span><span class="p">:</span>
                <span class="n">p1</span><span class="o">=</span><span class="n">E_end</span><span class="p">[(</span><span class="n">k1</span><span class="p">,</span><span class="n">lab1</span><span class="p">)]</span>
                <span class="n">p2</span><span class="o">=</span><span class="n">E_end</span><span class="p">[(</span><span class="n">k2</span><span class="p">,</span><span class="n">lab2</span><span class="p">)]</span>
                <span class="n">p</span><span class="o">=</span><span class="n">pauli_mult</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                <span class="n">double_stats</span><span class="p">[</span><span class="s1">&#39;total_pairs&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">ancilla_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">code_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="n">double_stats</span><span class="p">[</span><span class="s1">&#39;acc_both&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">has_logical_X</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                        <span class="n">double_stats</span><span class="p">[</span><span class="s1">&#39;acc_bad&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="n">malignant_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k1</span><span class="p">,</span><span class="n">lab1</span><span class="p">,</span><span class="n">k2</span><span class="p">,</span><span class="n">lab2</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">double_stats</span><span class="p">[</span><span class="s1">&#39;acc_good&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Double-fault stats:&#39;</span><span class="p">,</span> <span class="n">double_stats</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of malignant ordered pairs recorded:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">malignant_list</span><span class="p">))</span>

<span class="c1"># As a sanity check, count how many accepted single faults are benign (should be all or some?)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Single-fault stats: {&#39;total&#39;: 75, &#39;acc_anc&#39;: 35, &#39;acc_code&#39;: 19, &#39;acc_both&#39;: 7, &#39;acc_good&#39;: 7, &#39;acc_bad&#39;: 0}
Double-fault stats: {&#39;total_pairs&#39;: 2250, &#39;acc_both&#39;: 282, &#39;acc_good&#39;: 138, &#39;acc_bad&#39;: 144}
Number of malignant ordered pairs recorded: 144
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># Recompute and list the 7 accepted single faults and classify their logical action</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">format_pauli</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;I&#39;</span>
        <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;X&#39;</span>
        <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;Z&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;Y&#39;</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="c1"># replicate computation quickly</span>

<span class="n">pairs</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">labels_2q</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="s1">&#39;IXYZ&#39;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="s1">&#39;IXYZ&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">twoq_pauli</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">ch</span><span class="p">,</span><span class="n">q</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">label</span><span class="p">,[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;Z&#39;</span><span class="p">:</span>
            <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_CNOT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="n">r</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">^=</span><span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
    <span class="n">z</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">^=</span><span class="n">z</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="n">gates</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">propagate_error_to_end</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">pairs</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">p</span><span class="o">=</span><span class="n">twoq_pauli</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">gates</span><span class="p">)):</span>
        <span class="n">name</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">gates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">p</span><span class="o">=</span><span class="n">conj_CNOT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="k">def</span><span class="w"> </span><span class="nf">ancilla_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">code_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="n">px</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">%</span><span class="mi">2</span>
    <span class="n">pz</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">%</span><span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">px</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pz</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

<span class="n">Z_A</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Z_B</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">anticommutes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="o">=</span><span class="n">q</span>
    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span><span class="o">^=</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">z2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">s</span><span class="o">^=</span><span class="p">(</span><span class="n">z1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">==</span><span class="mi">1</span>


<span class="k">def</span><span class="w"> </span><span class="nf">data_part</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">has_logical_X</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">d</span><span class="o">=</span><span class="n">data_part</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">Z_A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">Z_B</span><span class="p">)</span>

<span class="n">accepted_singles</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels_2q</span><span class="p">:</span>
        <span class="n">p</span><span class="o">=</span><span class="n">propagate_error_to_end</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ancilla_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">code_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="n">accepted_singles</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">,</span><span class="n">format_pauli</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">accepted_singles</span><span class="p">))</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">accepted_singles</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="mf">7</span>
<span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">XX</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">XXXXI</span><span class="err">&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">YY</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">XYYXI</span><span class="err">&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">ZZ</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">IZZII</span><span class="err">&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">ZZ</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">ZZIII</span><span class="err">&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">ZZ</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">IIZZI</span><span class="err">&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">ZZ</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">ZIIZZ</span><span class="err">&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">IZ</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">IIIIZ</span><span class="err">&#39;</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># Exact coefficient extraction by enumerating all 16^5 error patterns (including identity per gate)</span>
<span class="c1"># Precompute E_end for each gate and 16 labels</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span>

<span class="n">pairs</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">twoq_pauli</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">ch</span><span class="p">,</span><span class="n">q</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">label</span><span class="p">,[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;Z&#39;</span><span class="p">:</span>
            <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">==</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_CNOT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="n">r</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">^=</span><span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
    <span class="n">z</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">^=</span><span class="n">z</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="n">gates</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="n">labels_2q</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="s1">&#39;IXYZ&#39;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="s1">&#39;IXYZ&#39;</span><span class="p">]</span>  <span class="c1"># includes &#39;II&#39;</span>

<span class="c1"># identity</span>
<span class="n">I5</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># propagate error after gate k with label lab</span>

<span class="k">def</span><span class="w"> </span><span class="nf">propagate_error_to_end</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">lab</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">pairs</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">lab</span><span class="o">==</span><span class="s1">&#39;II&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">I5</span>
    <span class="n">p</span><span class="o">=</span><span class="n">twoq_pauli</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gates</span><span class="p">)):</span>
        <span class="n">name</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">gates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">p</span><span class="o">=</span><span class="n">conj_CNOT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Build map</span>
<span class="n">E_end_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels_2q</span><span class="p">:</span>
        <span class="n">E_end_map</span><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">)]</span> <span class="o">=</span> <span class="n">propagate_error_to_end</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">lab</span><span class="p">)</span>

<span class="c1"># acceptance and logical checks</span>

<span class="k">def</span><span class="w"> </span><span class="nf">ancilla_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">code_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="n">px</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">%</span><span class="mi">2</span>
    <span class="n">pz</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">%</span><span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">px</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pz</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

<span class="n">Z_A</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Z_B</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">anticommutes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="o">=</span><span class="n">q</span>
    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span><span class="o">^=</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">z2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">s</span><span class="o">^=</span><span class="p">(</span><span class="n">z1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">==</span><span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">data_part</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">has_logical_X</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">d</span><span class="o">=</span><span class="n">data_part</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">Z_A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">anticommutes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">Z_B</span><span class="p">)</span>

<span class="c1"># Enumerate all 16^5 patterns; accumulate counts by k faults</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="n">choices</span> <span class="o">=</span> <span class="s1">&#39;II IX IY IZ XI XX XY XZ YI YX YY YZ ZI ZX ZY ZZ&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span><span class="o">==</span><span class="mi">16</span>

<span class="n">counts_acc</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">counts_good</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">counts_tot</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>

<span class="c1"># Precompute identity to speed multiply</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="o">=</span><span class="n">q</span>
    <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)]</span>
    <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="c1"># We&#39;ll iterate; to reduce Python overhead, we expand nested loops instead of product</span>
<span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
<span class="k">for</span> <span class="n">lab1</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
    <span class="n">p1</span><span class="o">=</span><span class="n">E_end_map</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="n">lab1</span><span class="p">)]</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">lab1</span><span class="o">==</span><span class="s1">&#39;II&#39;</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">lab2</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
        <span class="n">p12</span> <span class="o">=</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">E_end_map</span><span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="n">lab2</span><span class="p">)])</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">lab2</span><span class="o">==</span><span class="s1">&#39;II&#39;</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lab3</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
            <span class="n">p123</span> <span class="o">=</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">p12</span><span class="p">,</span> <span class="n">E_end_map</span><span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="n">lab3</span><span class="p">)])</span>
            <span class="n">k3</span> <span class="o">=</span> <span class="n">k2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">lab3</span><span class="o">==</span><span class="s1">&#39;II&#39;</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lab4</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
                <span class="n">p1234</span> <span class="o">=</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">p123</span><span class="p">,</span> <span class="n">E_end_map</span><span class="p">[(</span><span class="mi">4</span><span class="p">,</span><span class="n">lab4</span><span class="p">)])</span>
                <span class="n">k4</span> <span class="o">=</span> <span class="n">k3</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">lab4</span><span class="o">==</span><span class="s1">&#39;II&#39;</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">lab5</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">p1234</span><span class="p">,</span> <span class="n">E_end_map</span><span class="p">[(</span><span class="mi">5</span><span class="p">,</span><span class="n">lab5</span><span class="p">)])</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">k4</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">lab5</span><span class="o">==</span><span class="s1">&#39;II&#39;</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">counts_tot</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">ancilla_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">code_accepts</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                        <span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_logical_X</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                            <span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total patterns:&#39;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;counts_tot by k faults:&#39;</span><span class="p">,</span> <span class="n">counts_tot</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;counts_acc by k faults:&#39;</span><span class="p">,</span> <span class="n">counts_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;counts_good by k faults:&#39;</span><span class="p">,</span> <span class="n">counts_good</span><span class="p">)</span>

<span class="c1"># Build exact polynomials P_acc(p) and P_good(p)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="n">N</span><span class="o">=</span><span class="mi">5</span>
<span class="n">coeff_acc</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">coeff_good</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># P_acc = sum_k counts_acc[k] * (p/15)^k * (1-p)^(N-k) ; same for good counts</span>
<span class="c1"># Expand (1-p)^(N-k) as sum_{j=0..N-k} C(N-k, j) (-1)^j p^j</span>
<span class="c1"># Then coefficient at p^m equals sum over k and j with k+j=m of counts * (1/15)^k * C(N-k, j) * (-1)^j</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">j</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">j</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coeff_acc</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">j</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coeff_good</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c2</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc coeffs [p^0..p^5]:&#39;</span><span class="p">,</span> <span class="n">coeff_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good coeffs [p^0..p^5]:&#39;</span><span class="p">,</span> <span class="n">coeff_good</span><span class="p">)</span>

<span class="c1"># Derive F = P_good/P_acc as series up to p^5 via formal series division</span>

<span class="n">max_deg</span><span class="o">=</span><span class="mi">5</span>
<span class="c1"># Convert to Fractions lists (a0..a5)</span>
<span class="n">a</span><span class="o">=</span><span class="n">coeff_acc</span>
<span class="n">b</span><span class="o">=</span><span class="n">coeff_good</span>

<span class="c1"># Series division b/a to degree 5</span>
<span class="n">f</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="p">(</span><span class="n">max_deg</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># f0 = b0/a0 ; a0 should be 1</span>
<span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_deg</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># b[m] = sum_{i=0..m} a[i] f[m-i]</span>
    <span class="n">s</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>
    <span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">/</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fidelity series coeffs [p^0..p^5]:&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Check p^2 coeff numeric:&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Total patterns: 1048576
counts_tot by k faults: [1, 75, 2250, 33750, 253125, 759375]
counts_acc by k faults: [1, 7, 282, 4222, 31637, 94923]
counts_good by k faults: [1, 7, 138, 1198, 7397, 24027]
P_acc coeffs [p^0..p^5]: [Fraction(1, 1), Fraction(-68, 15), Fraction(704, 75), Fraction(-32768, 3375), Fraction(253952, 50625), Fraction(-262144, 253125)]
P_good coeffs [p^0..p^5]: [Fraction(1, 1), Fraction(-68, 15), Fraction(656, 75), Fraction(-29312, 3375), Fraction(223232, 50625), Fraction(-229376, 253125)]
Fidelity series coeffs [p^0..p^5]: [Fraction(1, 1), Fraction(0, 1), Fraction(-16, 25), Fraction(-704, 375), Fraction(-10496, 3375), Fraction(-216064, 84375)]
Check p^2 coeff numeric: -0.64
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>
<p>Setup, noise model and acceptance conditions</p>
</li>
<li>
<p>The circuit (executed right-to-left) is</p>
</li>
</ul>
<div class="arithmatex">\[
    H_1 \;\xrightarrow{\;CNOT_{1\to 2}\;}\;\xrightarrow{\;CNOT_{1\to 0}\;}\;\xrightarrow{\;CNOT_{2\to 3}\;}\;\xrightarrow{\;CNOT_{3\to 4}\;}\;\xrightarrow{\;CNOT_{0\to 4}\;}\; M_4,
\]</div>
<div class="codehilite"><pre><span></span><code>with data qubits 0–3 and ancilla 4. A two-qubit depolarizing channel acts after each CNOT. Thus there are five independent error locations, one after each CNOT. After a given CNOT on qubits $(i,j)$, the error is one of the 15 non-identity two-qubit Paulis on $(i,j)$, each with probability $p/15$; with probability $1-p$ it is the identity.
</code></pre></div>

<ul>
<li>
<p>Because all gates are Clifford, any sequence of Pauli faults through the circuit is equivalent to a single Pauli <span class="arithmatex">\(P_{\text{tot}}\)</span> on the 5 qubits immediately before measurement.</p>
</li>
<li>
<p>Acceptance (post-selection) consists of:
    1) Ancilla measurement in <span class="arithmatex">\(Z\)</span> with outcome “0”: this occurs if and only if the ancilla component of <span class="arithmatex">\(P_{\text{tot}}\)</span> is in <span class="arithmatex">\(\{I,Z\}\)</span> (since <span class="arithmatex">\(X\)</span> or <span class="arithmatex">\(Y\)</span> on the ancilla flips the <span class="arithmatex">\(Z\)</span> measurement outcome).
    2) “No code-syndrome”: the data (qubits 0–3) component of <span class="arithmatex">\(P_{\text{tot}}\)</span> must commute with both stabilizers <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>. In Pauli-vector terms, this is equivalent to requiring that the total number of <span class="arithmatex">\(X/Y\)</span> on data is even and the total number of <span class="arithmatex">\(Z/Y\)</span> on data is even.</p>
</li>
<li>
<p>Among accepted events, the data operator lies in the normalizer of the stabilizer, i.e. it is equivalent to some logical Pauli (times possibly a stabilizer). With the given logicals</p>
</li>
</ul>
<div class="arithmatex">\[
    X_A=X\,I\,X\,I,\quad X_B=X\,X\,I\,I,\quad Z_A=Z\,Z\,I\,I,\quad Z_B=Z\,I\,Z\,I,
\]</div>
<div class="codehilite"><pre><span></span><code>the prepared logical state $|00\rangle_{AB}$ is stabilized by $Z_A$ and $Z_B$; hence any accepted error equivalent to a logical $Z$ (or product of logical $Z$’s, possibly times stabilizers) leaves the state unchanged, while any accepted error whose logical part contains $X_A$ and/or $X_B$ maps $|00\rangle_{AB}$ to an orthogonal logical basis state.
</code></pre></div>

<ul>
<li>Therefore, the logical fidelity conditioned on acceptance equals the conditional probability that the net (accepted) logical operator contains no <span class="arithmatex">\(X\)</span> on either <span class="arithmatex">\(A\)</span> or <span class="arithmatex">\(B\)</span>:</li>
</ul>
<div class="arithmatex">\[
    F_L(p)=\frac{P\{\text{accepted and no logical }X\}}{P\{\text{accepted}\}}.
\]</div>
<ul>
<li>
<p>Propagation and classification via Pauli analysis</p>
</li>
<li>
<p>Conjugation rules for CNOT<span class="arithmatex">\((c\to t)\)</span> on Paulis:</p>
</li>
</ul>
<div class="arithmatex">\[
    X_c\mapsto X_c X_t,\quad Z_t\mapsto Z_c Z_t,\quad X_t\mapsto X_t,\quad Z_c\mapsto Z_c,
\]</div>
<div class="codehilite"><pre><span></span><code>and $Y=iXZ$ follows from these.
</code></pre></div>

<ul>
<li>Ancilla acceptance depends only on the ancilla component of <span class="arithmatex">\(P_{\text{tot}}\)</span>:</li>
</ul>
<div class="arithmatex">\[
    \text{accept ancilla} \iff P_{\text{tot}}|_4\in\{I,Z\}.
\]</div>
<ul>
<li>Code acceptance depends on parities on data qubits:</li>
</ul>
<div class="arithmatex">\[
    \text{accept code} \iff \#(X/Y)\equiv 0\ (\text{mod }2)\ \text{and}\ \#(Z/Y)\equiv 0\ (\text{mod }2)\ \text{on qubits }0\text{–}3.
\]</div>
<ul>
<li>Presence of a logical <span class="arithmatex">\(X\)</span> component can be detected by commutation with <span class="arithmatex">\(Z_A\)</span> and <span class="arithmatex">\(Z_B\)</span>. For any accepted Pauli <span class="arithmatex">\(P\)</span> on data, <span class="arithmatex">\(P\)</span> has a logical <span class="arithmatex">\(X\)</span> on <span class="arithmatex">\(A\)</span> iff it anticommutes with <span class="arithmatex">\(Z_A\)</span>; similarly for <span class="arithmatex">\(B\)</span>:</li>
</ul>
<div class="arithmatex">\[
    \text{$X_A$ present} \iff \{P,Z_A\}=0,\qquad \text{$X_B$ present} \iff \{P,Z_B\}=0.
\]</div>
<ul>
<li>
<p>First-order (single-fault) analysis</p>
</li>
<li>
<p>We enumerated all 75 single-fault cases: 5 locations × 15 two-qubit Paulis. Exactly 7 are accepted by both ancilla and code. They are</p>
</li>
</ul>
<div class="arithmatex">\[
    \begin{aligned}
    &amp;(1,\ XX)\ \to\ XXXX I,\\
    &amp;(1,\ YY)\ \to\ XYYX I,\\
    &amp;(1,\ ZZ)\ \to\ IZZII,\\
    &amp;(2,\ ZZ)\ \to\ ZZIII,\\
    &amp;(3,\ ZZ)\ \to\ IIZZI,\\
    &amp;(4,\ ZZ)\ \to\ ZIIZZ,\\
    &amp;(5,\ IZ)\ \to\ IIIIZ,
    \end{aligned}
\]</div>
<div class="codehilite"><pre><span></span><code>where the string shows the resulting $P_{\text{tot}}$ on qubits 0–4. All 7 correspond to a stabilizer or a product of logical $Z$’s (possibly times stabilizers), hence are benign for $|00\rangle_{AB}$. Therefore there are no accepted malignant single faults:
</code></pre></div>

<div class="arithmatex">\[
    \Rightarrow\ \text{no }O(p)\text{ logical infidelity}.
\]</div>
<ul>
<li>
<p>Second order (two-fault) analysis and beyond</p>
</li>
<li>
<p>Two-fault patterns (errors on two distinct CNOTs) occur with probability <span class="arithmatex">\(\sim (p/15)^2\)</span> and can combine to produce accepted logical-<span class="arithmatex">\(X\)</span> errors. We exhaustively enumerated all <span class="arithmatex">\(10\times 15^2=2250\)</span> ordered two-fault patterns and found:</p>
</li>
</ul>
<div class="arithmatex">\[
    \#\{\text{accepted}\}=282,\qquad \#\{\text{accepted and benign}\}=138,\qquad \#\{\text{accepted and malignant}\}=144.
\]</div>
<div class="codehilite"><pre><span></span><code>Thus the leading (quadratic) logical infidelity is governed by the 144 malignant, accepted pairs.
</code></pre></div>

<ul>
<li>To obtain the exact dependence on <span class="arithmatex">\(p\)</span> (not only to leading order), we counted, for <span class="arithmatex">\(k=0,\dots,5\)</span>, the number of <span class="arithmatex">\(k\)</span>-fault patterns that are accepted, and among those, how many are benign. Denote these counts by c_acc[k] and c_good[k]. The exhaustive enumeration yields:</li>
</ul>
<div class="arithmatex">\[
    \begin{aligned}
    &amp;\text{Total patterns at }k\text{ faults: }[1,75,2250,33750,253125,759375],\\
    &amp;\text{Accepted counts }c_{\text{acc}}[k]=[1,7,282,4222,31637,94923],\\
    &amp;\text{Accepted and benign }c_{\text{good}}[k]=[1,7,138,1198,7397,24027].\\
    \end{aligned}
\]</div>
<ul>
<li>From these counts, the acceptance probability and the “accepted-and-benign” probability are exact polynomials of degree 5 in <span class="arithmatex">\(p\)</span>:</li>
</ul>
<div class="arithmatex">\[
    \begin{aligned}
    P_{\text{acc}}(p)
    &amp;=\sum_{k=0}^{5} c_{\text{acc}}[k]\,(1-p)^{5-k}\Big(\frac{p}{15}\Big)^k\\
    &amp;=1-\frac{68}{15}p+\frac{704}{75}p^2-\frac{32768}{3375}p^3+\frac{253952}{50625}p^4-\frac{262144}{253125}p^5,\\[4pt]
    P_{\text{good}}(p)
    &amp;=\sum_{k=0}^{5} c_{\text{good}}[k]\,(1-p)^{5-k}\Big(\frac{p}{15}\Big)^k\\
    &amp;=1-\frac{68}{15}p+\frac{656}{75}p^2-\frac{29312}{3375}p^3+\frac{223232}{50625}p^4-\frac{229376}{253125}p^5.\end{aligned}
\]</div>
<ul>
<li>The logical state fidelity conditioned on acceptance is therefore the exact rational function</li>
</ul>
<div class="arithmatex">\[
    F_L(p)=\frac{P_{\text{good}}(p)}{P_{\text{acc}}(p)}.
\]</div>
<ul>
<li>Small-<span class="arithmatex">\(p\)</span> expansion: Since there are no accepted malignant single faults, the linear term cancels in the ratio. Expanding,</li>
</ul>
<div class="arithmatex">\[
    \begin{aligned}
    F_L(p)&amp;=1-\frac{16}{25}p^2-\frac{704}{375}p^3-\frac{10496}{3375}p^4-\frac{216064}{84375}p^5+O(p^6)\\
          &amp;=1-0.64\,p^2-1.877\overline{3}\,p^3-3.11037\,p^4-2.56076\,p^5+O(p^6).
    \end{aligned}
\]</div>
<div class="codehilite"><pre><span></span><code>In particular, the leading coefficient is
</code></pre></div>

<div class="arithmatex">\[
    \frac{16}{25}=\frac{\#\{\text{malignant accepted pairs}\}}{15^2\binom{5}{2}}=\frac{144}{225}.
\]</div>
<ul>
<li>
<p>Physical interpretation</p>
</li>
<li>
<p>The ancilla parity check (CNOTs from qubits 3 and 0 into the ancilla) “flags” the dangerous single “hook” faults that would otherwise produce undetected weight-2 <span class="arithmatex">\(X\)</span>-type errors on the cat state used for <span class="arithmatex">\(|00\rangle_{AB}\)</span> preparation. Consequently, all accepted single faults are purely <span class="arithmatex">\(Z\)</span>-type (logical <span class="arithmatex">\(Z\)</span>’s or stabilizers), leaving <span class="arithmatex">\(|00\rangle_{AB}\)</span> unchanged. The first harmful events require two faults, so the conditional logical infidelity scales as <span class="arithmatex">\(O(p^2)\)</span> with coefficient <span class="arithmatex">\(16/25\)</span>.</p>
</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All equations above are in LaTeX.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Code qubits indexed 0–3, ancilla 4.</li>
<li>Stabilizers: <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>.</li>
<li>Logical operators: <span class="arithmatex">\(X_A=X\,I\,X\,I\)</span>, <span class="arithmatex">\(X_B=X\,X\,I\,I\)</span>, <span class="arithmatex">\(Z_A=Z\,Z\,I\,I\)</span>, <span class="arithmatex">\(Z_B=Z\,I\,Z\,I\)</span>.</li>
<li>Two-qubit depolarizing error after each CNOT: non-identity two-qubit Pauli with probability <span class="arithmatex">\(p/15\)</span>.</li>
</ul>
<ol start="4">
<li>Final Answer:</li>
</ol>
<p>The logical state fidelity of the post-selected output (conditioning on both “no code syndrome” and ancilla outcome <span class="arithmatex">\(|0\rangle\)</span>) is the exact rational function</p>
<div class="arithmatex">\[
F_L(p)
=\frac{1-\frac{68}{15}p+\frac{656}{75}p^2-\frac{29312}{3375}p^3+\frac{223232}{50625}p^4-\frac{229376}{253125}p^5}
{1-\frac{68}{15}p+\frac{704}{75}p^2-\frac{32768}{3375}p^3+\frac{253952}{50625}p^4-\frac{262144}{253125}p^5}.
\]</div>
<p>For small <span class="arithmatex">\(p\)</span> this expands to</p>
<div class="arithmatex">\[
F_L(p)=1-\frac{16}{25}p^2+O(p^3)=1-0.64\,p^2+O(p^3).
\]</div>
<p>In particular, there is no <span class="arithmatex">\(O(p)\)</span> logical error (the circuit is fault-tolerant for this state preparation), and the leading logical infidelity is <span class="arithmatex">\(\frac{16}{25}p^2\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#13</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#14</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">656</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">29312</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">223232</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">229376</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>

    <span class="n">den</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">262144</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>

    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.854078
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>