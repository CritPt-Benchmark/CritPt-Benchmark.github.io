<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Ideal state prepared by the circuit</li>
<li>Start in |0000⟩.</li>
<li>Apply H2: produces (|0⟩+|1⟩)/√2 on qubit 2.</li>
<li>Apply CNOT21: entangles qubits 2 (control) and 1 (target) into a Bell pair</li>
</ul>
<div class="arithmatex">\[
|\Phi^+\rangle_{21}=\frac{|00\rangle_{21}+|11\rangle_{21}}{\sqrt{2}}.
\]</div>
<ul>
<li>Apply H0 and then CNOT03: analogously prepares a Bell pair on qubits 0 and 3,</li>
</ul>
<div class="arithmatex">\[
|\Phi^+\rangle_{03}=\frac{|00\rangle_{03}+|11\rangle_{03}}{\sqrt{2}}.
\]</div>
<ul>
<li>Hence the ideal final 4-qubit state is</li>
</ul>
<div class="arithmatex">\[
|\Psi\rangle = |\Phi^+\rangle_{03}\otimes|\Phi^+\rangle_{21}.
\]</div>
<ul>
<li>Noise model</li>
<li>After each CNOTij, a two-qubit depolarizing channel acts on the same two qubits:</li>
</ul>
<div class="arithmatex">\[
\mathcal{E}_p(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\in\mathcal{P}_2\setminus\{I\}} P\rho P,
\]</div>
<div class="codehilite"><pre><span></span><code>where $\mathcal{P}_2=\{I,X,Y,Z\}^{\otimes 2}$ and the sum runs over the 15 non-identity two-qubit Paulis.
</code></pre></div>

<ul>
<li>
<p>There are two such channels: one on qubits (2,1) after CNOT21 and one on (0,3) after CNOT03. No subsequent gates touch those qubits, so the two channels act independently on disjoint subsystems. The total channel is <span class="arithmatex">\(\mathcal{E}_p^{(03)}\otimes \mathcal{E}_p^{(21)}\)</span>.</p>
</li>
<li>
<p>Fidelity for a single Bell pair under two-qubit depolarizing noise</p>
</li>
<li>For a pure target <span class="arithmatex">\(|\phi\rangle\)</span>, the output fidelity is</li>
</ul>
<div class="arithmatex">\[
F=\langle\phi|\mathcal{E}_p(|\phi\rangle\langle\phi|)|\phi\rangle=(1-p)+\frac{p}{15}\sum_{P\neq I}\left|\langle\phi|P|\phi\rangle\right|^2.
\]</div>
<ul>
<li>For <span class="arithmatex">\(|\phi\rangle=|\Phi^+\rangle\)</span>, the only two-qubit Paulis with nonzero expectation are <span class="arithmatex">\(I, XX, YY, ZZ\)</span>, with</li>
</ul>
<div class="arithmatex">\[
\langle\Phi^+|XX|\Phi^+\rangle=+1,\quad \langle\Phi^+|ZZ|\Phi^+\rangle=+1,\quad \langle\Phi^+|YY|\Phi^+\rangle=-1.
\]</div>
<div class="codehilite"><pre><span></span><code><span class="nv">Hence</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="nv">non</span><span class="o">-</span><span class="nv">identity</span><span class="w"> </span><span class="nv">Paulis</span>,<span class="w"> </span><span class="nv">exactly</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nv">contribute</span><span class="w"> </span>$<span class="o">|</span>\<span class="nv">langle</span>\<span class="nv">cdot</span>\<span class="nv">rangle</span><span class="o">|^</span><span class="mi">2</span><span class="o">=</span><span class="mi">1</span>$<span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">remaining</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="nv">contribute</span><span class="w"> </span><span class="mi">0</span>.<span class="w"> </span><span class="nv">Therefore</span>,
</code></pre></div>

<div class="arithmatex">\[
F_{\text{pair}}(p)=(1-p)+\frac{3p}{15}=1-\frac{4p}{5}.
\]</div>
<ul>
<li>Total 4-qubit fidelity</li>
<li>Since the ideal state factorizes as <span class="arithmatex">\(|\Psi\rangle=|\Phi^+\rangle_{03}\otimes|\Phi^+\rangle_{21}\)</span> and the noise channels act independently on the two disjoint pairs, the total fidelity factorizes:</li>
</ul>
<div class="arithmatex">\[
F_{\text{phys}}(p)=F_{03}(p)\,F_{21}(p)=\left(F_{\text{pair}}(p)\right)^2=\left(1-\frac{4p}{5}\right)^2.
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All equations are provided above in LaTeX.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<p>No special units; standard quantum information conventions for Pauli operators and fidelities are used.</p>
<ol start="4">
<li>Final Answer:
F_phys(p) = (1 - 4p/5)^2 = 1 - (8/5)p + (16/25)p^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Setup and noise model</li>
<li>The circuit prepares the ideal state</li>
</ul>
<div class="arithmatex">\[
|\Psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{03}\otimes|\Phi^+\rangle_{21},\quad |\Phi^+\rangle=\frac{|00\rangle+|11\rangle}{\sqrt{2}}.
\]</div>
<ul>
<li>After each CNOT, a two-qubit depolarizing channel acts on that pair:</li>
</ul>
<div class="arithmatex">\[
\mathcal{E}_p(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\in\mathcal{P}_2\setminus\{I\}}P\rho P.
\]</div>
<ul>
<li>
<p>There are two such channels, on pairs (0,3) and (2,1), acting independently.</p>
</li>
<li>
<p>Post-selection on the code’s stabilizers</p>
</li>
<li>The [[4,2,2]] code has stabilizers <span class="arithmatex">\(g_X=XXXX\)</span> and <span class="arithmatex">\(g_Z=ZZZZ\)</span>. We post-select on the +1 eigenspace of both stabilizers (detectable errors are discarded).</li>
<li>For a two-qubit Pauli error <span class="arithmatex">\(E\)</span> acting on a given pair, define the commutation parities with <span class="arithmatex">\(g_X\)</span> and <span class="arithmatex">\(g_Z\)</span>:</li>
</ul>
<div class="arithmatex">\[
v(E)=(s_X(E),s_Z(E))\in\{(0,0),(0,1),(1,0),(1,1)\},
\]</div>
<div class="codehilite"><pre><span></span><code>where $s_X(E)=1$ if $E$ anticommutes with $g_X$ and 0 otherwise, and similarly for $s_Z$.
</code></pre></div>

<ul>
<li>For a single pair, among the 16 two-qubit Paulis (including identity):<ul>
<li>Class <span class="arithmatex">\(v=(0,0)\)</span> has 4 elements: <span class="arithmatex">\(\{II,XX,YY,ZZ\}\)</span>.</li>
<li>Each of the other three classes has 4 elements: e.g., <span class="arithmatex">\(v=(0,1)\)</span> is <span class="arithmatex">\(\{IX,XI,YZ,ZY\}\)</span>, etc.</li>
</ul>
</li>
<li>The probability per pair to land in each class is</li>
</ul>
<div class="arithmatex">\[
\Pr[v=(0,0)]=(1-p)+3\frac{p}{15}=1-\frac{12}{15}p=1-\frac{4p}{5},
\]</div>
<div class="arithmatex">\[
\Pr[v=(0,1)]=\Pr[v=(1,0)]=\Pr[v=(1,1)]=4\frac{p}{15}.
\]</div>
<ul>
<li>Acceptance condition for the two-gate error pattern</li>
<li>Let <span class="arithmatex">\(v_{03}\)</span> and <span class="arithmatex">\(v_{21}\)</span> be the class labels for the errors on pairs (0,3) and (2,1), respectively. The total error <span class="arithmatex">\(E=E_{03}E_{21}\)</span> commutes with both stabilizers (is accepted) iff</li>
</ul>
<div class="arithmatex">\[
v_{03}=v_{21}.
\]</div>
<ul>
<li>Therefore the total acceptance probability is</li>
</ul>
<div class="arithmatex">\[
P_{\text{acc}}=\sum_{v}\Pr[v]^2=\left(1-\frac{4p}{5}\right)^2+3\left(\frac{4p}{15}\right)^2.
\]</div>
<ul>
<li>Logical action of accepted errors</li>
<li>For <span class="arithmatex">\(v=(0,0)\)</span> on a pair, the allowed errors are <span class="arithmatex">\(II,XX,YY,ZZ\)</span>. Using the given logical representatives</li>
</ul>
<div class="arithmatex">\[
X_A=X_0X_2,\quad X_B=X_0X_1,\quad Z_A=Z_0Z_1,\quad Z_B=Z_0Z_2,
\]</div>
<div class="codehilite"><pre><span></span><code>and stabilizers $XXXX, ZZZZ$, one finds on either pair that
</code></pre></div>

<div class="arithmatex">\[
XX \mapsto X_AX_B,\quad ZZ \mapsto Z_AZ_B,\quad YY \mapsto Y_AY_B.
\]</div>
<div class="codehilite"><pre><span></span><code>Thus when $v_{03}=v_{21}=(0,0)$, the total logical operator is in
</code></pre></div>

<div class="arithmatex">\[
H=\{I,\;X_AX_B,\;Z_AZ_B,\;Y_AY_B\},
\]</div>
<div class="codehilite"><pre><span></span><code>which is exactly the stabilizer set of the logical Bell state $|\Phi^+\rangle_{AB}$. Hence all such accepted events have logical fidelity 1.
</code></pre></div>

<ul>
<li>
<p>For <span class="arithmatex">\(v\neq(0,0)\)</span>, each pair error is detectable by itself, but if <span class="arithmatex">\(v_{03}=v_{21}\)</span> the combined error is accepted. Direct calculation (examples below) shows these map to single-logical-qubit Paulis:</p>
<ul>
<li>For <span class="arithmatex">\(v=(0,1)\)</span>: products yield <span class="arithmatex">\(X_A\)</span> or <span class="arithmatex">\(X_B\)</span> (e.g., <span class="arithmatex">\((I_0X_3)(I_2X_1)=X_1X_3\equiv X_A\)</span>).</li>
<li>For <span class="arithmatex">\(v=(1,0)\)</span>: products yield <span class="arithmatex">\(Z_A\)</span> or <span class="arithmatex">\(Z_B\)</span>.</li>
<li>For <span class="arithmatex">\(v=(1,1)\)</span>: products yield <span class="arithmatex">\(Y_A\)</span> or <span class="arithmatex">\(Y_B\)</span>.
None of these lie in <span class="arithmatex">\(H\)</span>, so they map <span class="arithmatex">\(|\Phi^+\rangle_{AB}\)</span> to an orthogonal logical Bell state, contributing zero to the target-state fidelity.</li>
</ul>
</li>
<li>
<p>Conditional logical fidelity</p>
</li>
<li>The only accepted events with nonzero fidelity are those with <span class="arithmatex">\(v_{03}=v_{21}=(0,0)\)</span>. Therefore</li>
</ul>
<div class="arithmatex">\[
P_{\text{good}}=\Pr[v=(0,0)]^2=\left(1-\frac{4p}{5}\right)^2.
\]</div>
<ul>
<li>Conditioned on acceptance,</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Small-<span class="arithmatex">\(p\)</span> expansion: <span class="arithmatex">\(F_{\text{logical}}(p)=1-\frac{16}{75}p^2+O(p^3)\)</span>, showing first-order errors are fully post-selected away, as expected for a distance-2 detection code.</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All expressions above are typeset in LaTeX.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<p>Standard stabilizer-code and depolarizing-channel conventions; no physical units involved.</p>
<ol start="4">
<li>Final Answer:
<span class="arithmatex">\(F_{\rm logical}(p)=\dfrac{\left(1-\frac{12}{15}p\right)^2}{\left(1-\frac{12}{15}p\right)^2+3\left(\frac{4}{15}p\right)^2}
=\dfrac{\left(1-\frac{4p}{5}\right)^2}{\left(1-\frac{4p}{5}\right)^2+\frac{16}{75}p^2}.\)</span></li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{logical}}=1 - \frac{\frac{16}{75}p^2}{1-\frac{8}{5}p + \frac{64}{75}p^2}
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Code, noise, and acceptance</li>
<li>[[4,2,2]] code: stabilizers S = {XXXX, ZZZZ}. Logical Zs: Z_A = Z0Z1, Z_B = Z0Z2. Target logical state |00⟩AB is the +1 eigenstate of Z_A and Z_B.</li>
<li>Circuit (right-to-left): H1, CNOT12, CNOT10, CNOT23, CNOT34, CNOT04, then measure Z4 on ancilla.</li>
<li>Noise: after each CNOTij a two-qubit depolarizing channel acts on the same two qubits, producing one of the 15 non-identity two-qubit Paulis with probability p/15 (and identity with 1−p).</li>
<li>
<p>Postselection: accept only if (i) ancilla measurement is |0⟩ (equivalently, the effective Pauli at the end commutes with Z4), and (ii) the effective Pauli on data commutes with both stabilizers XXXX and ZZZZ (i.e., no detectable code error).</p>
</li>
<li>
<p>Pauli-tracking and syndrome bits</p>
</li>
<li>Use the binary symplectic (x|z) representation. Under conjugation by CNOTc→t:<ul>
<li>x_t ← x_t ⊕ x_c, z_c ← z_c ⊕ z_t, and x_c, z_t unchanged.</li>
</ul>
</li>
<li>For an effective Pauli at the end:<ul>
<li>Ancilla flip bit: a = x4 (anticommutes with Z4 iff x4=1).</li>
<li>Stabilizer syndromes on data qubits 0..3:</li>
<li>s_Z = x0 ⊕ x1 ⊕ x2 ⊕ x3 (anticommutes with ZZZZ iff odd number of X/Y).</li>
<li>s_X = z0 ⊕ z1 ⊕ z2 ⊕ z3 (anticommutes with XXXX iff odd number of Z/Y).</li>
</ul>
</li>
<li>
<p>Acceptance requires (a, s_X, s_Z) = (0,0,0).</p>
</li>
<li>
<p>Propagating a single fault forward</p>
</li>
<li>Label the five two-qubit gates G1..G5 in time order after H1:<ul>
<li>G1=CNOT12, G2=CNOT10, G3=CNOT23, G4=CNOT34, G5=CNOT04.</li>
</ul>
</li>
<li>For a single Pauli fault inserted immediately after Gk, propagate through the remaining gates to obtain the linear maps from the local two-qubit input bits (x,z) to the output bits (x_data, x4, zsum):<ul>
<li>G5 (on qubits {0,4}): x_data = (x0,0,0,0), x4 = x4, zsum = z0.</li>
<li>G4 (on {3,4}) then G5: x_data = (0,0,0,x3), x4 = x4, zsum = z3 ⊕ z4.</li>
<li>G3 (on {2,3}) then G4,G5: x_data = (0,0,x2,x3), x4 = x3, zsum = z2 ⊕ z3.</li>
<li>G2 (on {1,0}) then G3,G4,G5: x_data = (x0,x1,0,0), x4 = x0, zsum = z0 ⊕ z1.</li>
<li>G1 (on {1,2}) then G2,G3,G4,G5: x_data = (x1,x1,x2,x2), x4 = x1 ⊕ x2, zsum = z1 ⊕ z2.</li>
</ul>
</li>
<li>
<p>Define the 3-bit acceptance signature u_k = (s_Z, s_X, a) = (parity(x_data), zsum, x4).</p>
</li>
<li>
<p>Single-fault acceptance counts</p>
</li>
<li>For G5,G4,G3,G2 the map u_k takes all 8 values with preimage sizes:<ul>
<li>|u=(0,0,0)| = 1 (only the pure Z on the non-data qubit(s)), and |u| = 2 for each of the other 7 triples. Thus the number of accepted single faults n_k = 1 for each of G2–G5.</li>
</ul>
</li>
<li>For G1, parity(x_data) ≡ 0 always, so u1 spans only the 4 triples with s_Z=0. The preimage counts are:<ul>
<li>|u=(0,0,0)| = 3 (XX, ZZ, YY on qubits 1 and 2), and |u| = 4 on the other three triples with s_Z=0, while 0 on the four triples with s_Z=1. Hence n1 = 3.</li>
</ul>
</li>
<li>Therefore Σ_k n_k = 1+1+1+1+3 = 7. The linear coefficient in the acceptance probability is</li>
</ul>
<div class="arithmatex">\[
\alpha = 5 - \frac{1}{15}\sum_k n_k = 5 - \frac{7}{15} = \frac{68}{15}.
\]</div>
<ul>
<li>Two-fault acceptance probability at O(p^2)</li>
<li>For independent faults at gates k and ℓ, acceptance requires u_k = u_ℓ. Let a_k(u) be the counts of inputs mapping to signature u for gate k.</li>
<li>The O(p^2) contribution from (k,ℓ) is</li>
</ul>
<div class="arithmatex">\[
A_{k\ell} = \frac{1}{15^2}\sum_{u} a_k(u)\,a_\ell(u).
\]</div>
<ul>
<li>Using the distributions above:<ul>
<li>For pairs among G2–G5 (four “normal” gates): a(u)=1 for u=(0,0,0), and 2 otherwise on all 8 u ⇒ A_{NN} = (1+7·4)/225 = 29/225.</li>
<li>For pairs involving G1 and a normal: a1 zero on the 4 u with s_Z=1; on s_Z=0 triples, a1=(3,4,4,4), while aN=(1,2,2,2) ⇒ A_{1N} = (3·1+3·8)/225 = 27/225.</li>
</ul>
</li>
<li>Summing over all unordered pairs (k&lt;ℓ): 6 normal-normal pairs and 4 of type (1,normal):</li>
</ul>
<div class="arithmatex">\[
\sum_{k&lt;\ell} A_{k\ell} = 6\cdot\frac{29}{225}+4\cdot\frac{27}{225} = \frac{94}{75}.
\]</div>
<ul>
<li>Two-fault “good” events at O(p^2)</li>
<li>“Good” means accepted and no X/Y on data after combining both faults; equivalently, the 4-bit x_data vectors must cancel exactly: x_data(k) = x_data(ℓ). In addition, acceptance requires equal s_X and a.</li>
<li>To count this, refine the signature to the 6-bit label v_k = (x_data (4 bits), s_X, a). Let b_k(v) be the preimage count of v for gate k.</li>
<li>For each gate, b_k has the same shape: v spans 8 outputs; at v0=(x=0000,s_X=0,a=0), b_k=1; for the other 7 outputs in its image, b_k=2.</li>
<li>For a given pair (k,ℓ), the O(p^2) “good” contribution is</li>
</ul>
<div class="arithmatex">\[
B_{k\ell}=\frac{1}{15^2}\sum_{v} b_k(v)\,b_\ell(v),
\]</div>
<div class="codehilite"><pre><span></span><code>where the sum is over the intersection of the two 8-element images.
</code></pre></div>

<ul>
<li>Intersections (x-support constraints) yield two cases repeatedly:<ul>
<li>Intersection of size 4: sum of products = 1 + 3·(2·2) = 13 ⇒ B = 13/225.</li>
<li>Intersection of size 2: sum of products = 1 + (2·2) = 5 ⇒ B = 5/225.</li>
</ul>
</li>
<li>Tally over pairs:<ul>
<li>Among normals: 3 pairs have B=13/225; 3 pairs have B=5/225.</li>
<li>With G1: two pairs have B=13/225; two have B=5/225.</li>
<li>Hence</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
\sum_{k&lt;\ell} B_{k\ell}=\frac{3\cdot 13+3\cdot 5+2\cdot 13+2\cdot 5}{225}=\frac{90}{225}=\frac{2}{5}.
\]</div>
<ul>
<li>Assemble acceptance and good probabilities to O(p^2)</li>
<li>Acceptance:</li>
</ul>
<div class="arithmatex">\[
P_{\rm acc}(p) = (1-p)^5 + \sum_k p(1-p)^4\frac{n_k}{15} + \sum_{k&lt;\ell} p^2 A_{k\ell} + O(p^3).
\]</div>
<div class="codehilite"><pre><span></span><code>Expanding:
</code></pre></div>

<div class="arithmatex">\[
P_{\rm acc}(p) = 1 - \frac{68}{15}p + \frac{704}{75}p^2 + O(p^3).
\]</div>
<ul>
<li>Good:</li>
</ul>
<div class="arithmatex">\[
P_{\rm good}(p) = (1-p)^5 + \sum_k p(1-p)^4\frac{n_k}{15} + \sum_{k&lt;\ell} p^2 B_{k\ell} + O(p^3),
\]</div>
<div class="codehilite"><pre><span></span><code>so
</code></pre></div>

<div class="arithmatex">\[
\]</div>
<div class="codehilite"><pre><span></span><code>The difference at O(p^2) is
</code></pre></div>

<div class="arithmatex">\[
\sum_{k&lt;\ell}(A_{k\ell} - B_{k\ell}) = \frac{64}{75}.
\]</div>
<ul>
<li>Logical fidelity conditioned on acceptance</li>
<li>By definition,</li>
</ul>
<div class="arithmatex">\[
F_{\rm logical}(p) = \frac{P_{\rm good}(p)}{P_{\rm acc}(p)} = 1 - \frac{\frac{64}{75}p^2}{1 - \frac{68}{15}p + \frac{704}{75}p^2} + O(p^3).
\]</div>
<ul>
<li>This expression is exact to all orders within the second-order rational form because the numerator/denominator structure mirrors independent-location counting (as in Subproblem 2).</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All expressions are presented in LaTeX above.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Standard stabilizer and Pauli-channel conventions.</li>
<li>Measurement M4 is in the Z basis; acceptance requires commuting with Z4 (no flip).</li>
</ul>
<ol start="4">
<li>Final Answer:
<span class="arithmatex">\(F_{\rm logical}(p) \;=\; 1 \;-\; \dfrac{\tfrac{64}{75}\,p^2}{\,1 - \tfrac{68}{15}\,p + \tfrac{704}{75}\,p^2\,}\,.\)</span></li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.474045
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>