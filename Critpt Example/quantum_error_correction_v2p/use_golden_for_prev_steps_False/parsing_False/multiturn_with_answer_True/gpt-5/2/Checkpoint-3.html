<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Circuit and error model</li>
<li>The circuit is (in time order right→left): apply H2, then CNOT21, then H0, then CNOT03.</li>
<li>Only the two CNOTs are noisy. After each CNOTij a 2-qubit depolarizing channel acts on qubits i,j:</li>
</ul>
<div class="arithmatex">\[
\mathcal{E}(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\in\mathcal{P}_2\setminus\{II\}} P\,\rho\,P,
\]</div>
<div class="codehilite"><pre><span></span><code>where the 15 non-identity two-qubit Paulis are equiprobable.
</code></pre></div>

<ul>
<li>Ideal (noiseless) output state and its stabilizer</li>
<li>H2 creates |+⟩ on qubit 2; CNOT21 then prepares a Bell pair |Φ+⟩ on qubits (2,1).</li>
<li>H0 creates |+⟩ on qubit 0; CNOT03 then prepares a Bell pair |Φ+⟩ on qubits (0,3).</li>
<li>Hence the ideal 4-qubit output is</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>The stabilizer of a Bell pair |Φ+⟩ij is generated by X_iX_j and Z_iZ_j. Therefore the ideal 4-qubit state is the unique stabilizer state with generators</li>
</ul>
<div class="arithmatex">\[
X_1X_2,\; Z_1Z_2,\; X_0X_3,\; Z_0Z_3.
\]</div>
<div class="codehilite"><pre><span></span><code>Equivalently, this is the logical Bell state (|00⟩AB+|11⟩AB)/√2, since
X_A X_B = IXXI and Z_A Z_B = IZZI together with the code stabilizers XXXX and ZZZZ generate the same group.
</code></pre></div>

<ul>
<li>Location and propagation of errors</li>
<li>The error after CNOT21 acts only on qubits (2,1) and commutes with the later gates H0 and CNOT03 (which act on disjoint qubits). Thus it reaches the end unchanged as some P21.</li>
<li>The error after CNOT03 acts only on qubits (0,3) and is the last operation, so it is Q03 at the end.</li>
<li>Therefore the final state is a classical mixture over Pauli errors of the form</li>
</ul>
<div class="arithmatex">\[
E = Q_{03}\otimes P_{21},\qquad P_{21},Q_{03}\in\mathcal{P}_2.
\]</div>
<ul>
<li>Fidelity reduction to stabilizer membership</li>
<li>With Pauli errors on a pure stabilizer state, the output density matrix is</li>
</ul>
<div class="arithmatex">\[
\rho_{\text{out}}=\sum_{P,Q} \Pr(P)\Pr(Q)\,(Q\otimes P)\,|\psi\rangle\langle\psi|\,(Q\otimes P),
\]</div>
<div class="codehilite"><pre><span></span><code>and the state fidelity is
</code></pre></div>

<div class="arithmatex">\[
F=\langle\psi|\rho_{\text{out}}|\psi\rangle=\sum_{P,Q}\Pr(P)\Pr(Q)\,|\langle\psi|(Q\otimes P)|\psi\rangle|^2.
\]</div>
<ul>
<li>For a stabilizer state, a Pauli E has overlap 1 iff E is in its stabilizer group S, and 0 otherwise. Because S factorizes here as</li>
</ul>
<div class="arithmatex">\[
S = \{II,\,X_0X_3,\,Z_0Z_3,\,Y_0Y_3\}\ \otimes\ \{II,\,X_1X_2,\,Z_1Z_2,\,Y_1Y_2\},
\]</div>
<div class="codehilite"><pre><span></span><code>we have
</code></pre></div>

<div class="arithmatex">\[
F = \Pr(Q_{03}\in S_{03})\cdot \Pr(P_{21}\in S_{12}).
\]</div>
<ul>
<li>Probability a 2-qubit depolarizing error lands in the pairwise stabilizer</li>
<li>For a given pair (i,j), the stabilizer of |Φ+⟩ij contains exactly the 4 Paulis {II, XX, ZZ, YY} on that pair.</li>
<li>Under the depolarizing channel:<ul>
<li>Identity II occurs with probability 1−p.</li>
<li>Among the 15 non-identity Paulis, exactly 3 belong to the stabilizer (XX, YY, ZZ). Hence the additional probability is (3/15)p = (1/5)p.</li>
</ul>
</li>
<li>Therefore for either pair,</li>
</ul>
<div class="arithmatex">\[
\Pr(\text{pairwise error} \in \{II,XX,YY,ZZ\}) = (1-p) + \frac{p}{5} = 1-\frac{4}{5}p.
\]</div>
<ul>
<li>Independence across the two CNOTs yields</li>
</ul>
<div class="arithmatex">\[
F(p)=\Big(1-\frac{4}{5}p\Big)^2.
\]</div>
<ol start="2">
<li>
<p>Mathematical Typesetting
- Provided inline and display equations above.</p>
</li>
<li>
<p>Conventions and Units
- Dimensionless error rate p. No units involved.</p>
</li>
<li>
<p>Final Answer:
F(p) = (1 - 4p/5)^2 = 1 - (8/5)p + (16/25)p^2.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Circuit, noise, and ideal output</li>
<li>Time order: apply H2, then CNOT21 (noisy), then H0, then CNOT03 (noisy).</li>
<li>Each CNOTij is followed by a two-qubit depolarizing channel on qubits i,j: with probability p it applies a uniformly random non-identity 2-qubit Pauli (15 choices), and with probability 1−p it applies identity.</li>
<li>The ideal output state is a tensor product of Bell pairs:</li>
</ul>
<div class="arithmatex">\[
\]</div>
<div class="codehilite"><pre><span></span><code>It lies in the [[4,2,2]] code space with stabilizers XXXX and ZZZZ.
</code></pre></div>

<ul>
<li>Effect of a two-qubit Pauli on a Bell pair</li>
<li>For pair (i,j), let the two stabilizers be X_iX_j and Z_iZ_j. A Pauli P on that pair flips the eigenvalue of X_iX_j iff it has an odd number of factors in {Z,Y} on that pair; similarly it flips the eigenvalue of Z_iZ_j iff it has an odd number of factors in {X,Y}.</li>
<li>Thus each two-qubit Pauli error on a pair falls into one of four classes labeled by</li>
</ul>
<div class="arithmatex">\[
(s_X, s_Z)\in\{0,1\}^2,
\]</div>
<div class="codehilite"><pre><span></span><code>where s_X (resp. s_Z) is whether the X-pair (resp. Z-pair) stabilizer sign flips.
</code></pre></div>

<ul>
<li>Acting on |Φ+⟩, these four classes map the Bell state to:<ul>
<li>(0,0) → |Φ+⟩,</li>
<li>(1,0) → |Φ−⟩,</li>
<li>(0,1) → |Ψ+⟩,</li>
<li>(1,1) → |Ψ−⟩.</li>
</ul>
</li>
<li>Counting within the 16 Paulis on the pair: the (0,0) class is the stabilizer of |Φ+⟩ and contains {II, XX, YY, ZZ} (4 elements), while each of the other three classes has 4 elements.</li>
<li>Under the depolarizing channel (identity prob 1−p and each non-identity Pauli prob p/15), the single-pair probabilities are</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Post-selection (detectable-error rejection) in the [[4,2,2]] code</li>
<li>The code stabilizers are S_X=XXXX=(X_1X_2)(X_0X_3) and S_Z=ZZZZ=(Z_1Z_2)(Z_0Z_3).</li>
<li>An error E=P_{21}\otimes Q_{03} passes post-selection iff it commutes with both S_X and S_Z. In the Bell-pair language, this requires the two pairs to have identical flip parities:</li>
</ul>
<div class="arithmatex">\[
s_X(P_{21})=s_X(Q_{03}),\qquad s_Z(P_{21})=s_Z(Q_{03}).
\]</div>
<div class="codehilite"><pre><span></span><code><span class="nv">Equivalently</span>,<span class="w"> </span><span class="nv">both</span><span class="w"> </span><span class="nv">pairs</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="nv">up</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">same</span><span class="w"> </span><span class="nv">Bell</span><span class="w"> </span><span class="nv">state</span><span class="w"> </span><span class="nv">c</span>∈{Φ<span class="o">+</span>,Φ−,Ψ<span class="o">+</span>,Ψ−}.
</code></pre></div>

<ul>
<li>Therefore the acceptance probability is</li>
</ul>
<div class="arithmatex">\[
      = \left(1-\frac{12}{15}p\right)^2 + 3\left(4\frac{p}{15}\right)^2
\]</div>
<ul>
<li>Logical state conditioned on acceptance and its fidelity</li>
<li>When accepted, the two pairs are in the same Bell state c, which determines the logical two-qubit Bell state on AB. The target is c=Φ+.</li>
<li>Hence the conditional logical fidelity is</li>
</ul>
<div class="arithmatex">\[
      = \Pr(c=\Phi^+\mid \text{accepted})
      = \frac{p_{\Phi^+}^2}{\sum_c p_c^2}
      = \frac{\left(1-\frac{12}{15}p\right)^2}
\]</div>
<ul>
<li>In expanded form,</li>
</ul>
<div class="arithmatex">\[
      = \frac{1-\frac{8}{5}p+\frac{16}{25}p^2}
             {1-\frac{8}{5}p+\frac{64}{75}p^2}
\]</div>
<div class="codehilite"><pre><span></span><code>The linear term cancels due to post-selection: logical infidelity scales as O(p^2).
</code></pre></div>

<ol start="2">
<li>
<p>Mathematical Typesetting
- All formulas provided in LaTeX above.</p>
</li>
<li>
<p>Conventions and Units
- Dimensionless gate error rate p; ideal stabilizer measurements for post-selection.</p>
</li>
<li>
<p>Final Answer:</p>
</li>
</ol>
<div class="arithmatex">\[
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{logical}}=1 - \frac{\frac{16}{75}p^2}{1-\frac{8}{5}p + \frac{64}{75}p^2}
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Circuit, noise, and target</li>
<li>Time order: H1, CNOT12, CNOT10, CNOT23, CNOT34, CNOT04, then measure Z4.</li>
<li>Each CNOTab is followed by a 2-qubit depolarizing channel on a,b: with probability p it applies a uniformly random non-identity 2-qubit Pauli (15 choices), and with probability 1−p it applies identity.</li>
<li>The ideal data state after CNOT23 is the 4-qubit GHZ</li>
</ul>
<div class="arithmatex">\[
|\text{GHZ}\rangle_{0123}=\frac{|0000\rangle+|1111\rangle}{\sqrt{2}},
\]</div>
<div class="codehilite"><pre><span></span><code>which is the logical state |00⟩AB for the [[4,2,2]] code (stabilizers S_X=XXXX, S_Z=ZZZZ; logical Z_A=Z_0Z_1, Z_B=Z_0Z_2).
</code></pre></div>

<ul>
<li>
<p>The last two gates CNOT34 and CNOT04 with ancilla 4 implement a nondestructive Z-parity check of qubits 3 and 0; the ideal outcome is Z4=0. We post-select on</p>
<ul>
<li>ancilla measurement Z4=0,</li>
<li>code-detectable errors rejected, i.e., the final data operator E must commute with both S_X and S_Z.</li>
</ul>
</li>
<li>
<p>Syndrome bookkeeping and acceptance conditions</p>
</li>
<li>For any final Pauli E on data, define for each pair (i,j) the parity bits</li>
</ul>
<div class="arithmatex">\[
\]</div>
<div class="codehilite"><pre><span></span><code><span class="k">For</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span>[[<span class="mi">4</span>,<span class="mi">2</span>,<span class="mi">2</span>]]<span class="w"> </span><span class="nv">code</span>,
</code></pre></div>

<div class="arithmatex">\[
\text{commute with }S_X\iff s_X^{(12)}(E)\oplus s_X^{(03)}(E)=0,
\]</div>
<div class="arithmatex">\[
\text{commute with }S_Z\iff s_Z^{(12)}(E)\oplus s_Z^{(03)}(E)=0.
\]</div>
<ul>
<li>
<p>Ancilla outcome in Z is flipped by an X or Y on qubit 4 just before measurement. Because X on control (0 or 3) before the corresponding CNOT also propagates to X on the ancilla (Heisenberg: X_c→X_cX_t), any X/Y present on 0 or 3 at the moment those CNOTs are applied flips the ancilla outcome. Thus, to linear order, a single X/Y on 0 or 3 causes ancilla “1” and is rejected.</p>
</li>
<li>
<p>Single-fault analysis (O(p)): all single faults are detected</p>
</li>
<li>Using CNOT conjugation rules (CNOT_{c,t}: X_c→X_cX_t, Z_t→Z_cZ_t; X_t, Z_c unchanged) to propagate a fault forward, one finds:<ul>
<li>After CNOT12: a single non-identity Pauli on {1,2} that both commutes with S and does not flip the ancilla must be Z_1Z_2. All other 14/15 are rejected (either trigger S or flip the ancilla via propagation X_{1,2}→X_{0,3}).</li>
<li>After CNOT10 or CNOT23: any non-identity two-qubit Pauli is rejected (15/15), because to pass both S and ancilla constraints would require no X/Y on 0 or 3 and no odd number of Z/Y on the touched pair—impossible unless identity.</li>
<li>After CNOT34 or CNOT04: the only single non-identity that preserves S and gives ancilla 0 is I·Z_4 (on that gate’s pair), so 14/15 are rejected.</li>
</ul>
</li>
<li>Therefore, to first order (small p),</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>
<p>Conclusion: every single fault is detected (rejected) except three harmless weight-2 Z-only patterns (one on CNOT12 and one Z_4-only on each ancilla CNOT). Hence there is no linear-in-p logical error after post-selection; the logical infidelity starts at O(p^2).</p>
</li>
<li>
<p>Two-fault patterns that pass and cause a logical error (O(p^2))</p>
</li>
<li>To slip through post-selection and still be wrong, an error pattern must:
    1) commute with S_X and S_Z,
    2) yield ancilla outcome 0,
    3) implement a logical X (contains X_A and/or X_B in the normalizer) on |00⟩AB (pure logical Z’s are harmless on |00⟩AB).</li>
<li>The only two-fault patterns satisfying (1)-(3) at order p^2 are:<ul>
<li>A “danger” fault on CNOT10 or CNOT23 that puts X/Y on both qubits of that gate in the same basis, i.e.</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
\{X_1X_0,\,Y_1Y_0\}\ \text{on }(1,0),\qquad \{X_2X_3,\,Y_2Y_3\}\ \text{on }(2,3),
\]</div>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nx">which</span><span class="w"> </span><span class="nx">produce</span><span class="w"> </span><span class="nx">s_Z</span><span class="o">^</span><span class="p">{(</span><span class="mi">12</span><span class="p">)}=</span><span class="nx">s_Z</span><span class="o">^</span><span class="p">{(</span><span class="mi">03</span><span class="p">)}=</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nx">so</span><span class="w"> </span><span class="nx">S_Z</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">satisfied</span><span class="p">),</span><span class="w"> </span><span class="nx">s_X</span><span class="o">^</span><span class="p">{(</span><span class="mi">12</span><span class="p">)}=</span><span class="nx">s_X</span><span class="o">^</span><span class="p">{(</span><span class="mi">03</span><span class="p">)}=</span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nx">so</span><span class="w"> </span><span class="nx">S_X</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">satisfied</span><span class="p">),</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">implement</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">logical</span><span class="w"> </span><span class="nx">X</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">one</span><span class="w"> </span><span class="nx">logical</span><span class="w"> </span><span class="nx">qubit</span><span class="w"> </span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="nx">fact</span><span class="w"> </span><span class="nx">X_B</span><span class="w"> </span><span class="nx">up</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">stabilizers</span><span class="p">).</span>
<span class="o">-</span><span class="w"> </span><span class="nx">Combined</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">second</span><span class="w"> </span><span class="nx">fault</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">ancilla</span><span class="w"> </span><span class="nx">stage</span><span class="w"> </span><span class="nx">that</span><span class="w"> </span><span class="nx">flips</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">ancilla</span><span class="w"> </span><span class="nx">outcome</span><span class="w"> </span><span class="nx">back</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">changing</span><span class="w"> </span><span class="nx">s_X</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nx">s_Z</span><span class="p">:</span>
<span class="w">  </span><span class="nx">on</span><span class="w"> </span><span class="nx">CNOT04</span><span class="w"> </span><span class="nx">allowed</span><span class="w"> </span><span class="nx">errors</span><span class="w"> </span><span class="nx">are</span><span class="w"> </span><span class="nx">I_0X_4</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nx">I_0Y_4</span><span class="p">;</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">CNOT34</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">only</span><span class="w"> </span><span class="nx">allowed</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">I_3X_4</span><span class="w"> </span><span class="p">(</span><span class="nx">propagated</span><span class="w"> </span><span class="nx">through</span><span class="w"> </span><span class="nx">CNOT04</span><span class="p">,</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="nx">remains</span><span class="w"> </span><span class="nx">X_4</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">does</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">touch</span><span class="w"> </span><span class="nx">data</span><span class="p">).</span>
</code></pre></div>

<ul>
<li>Counting the two-fault patterns that satisfy all constraints:<ul>
<li>CNOT10 “danger” (2 choices) × {I_0X_4, I_0Y_4, I_3X_4} (3 choices) → 6 patterns,</li>
<li>CNOT23 “danger” (2 choices) × same 3 choices → 6 patterns,</li>
<li>total 12 patterns.</li>
</ul>
</li>
<li>Each occurs with probability (p/15)^2 to leading order (other gates are identity with prob 1+O(p)). Hence</li>
</ul>
<div class="arithmatex">\[
P_{\text{wrong}\,\cap\,\text{acc}}(p)=12\left(\frac{p}{15}\right)^2+O(p^3)=\frac{4}{75}p^2+O(p^3).
\]</div>
<ul>
<li>Conditional logical fidelity</li>
<li>The logical fidelity conditioned on acceptance is</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Small-p expansion:</li>
</ul>
<div class="arithmatex">\[
F_{\text{logical}}(p)=1-\frac{4}{75}p^2+O(p^3).
\]</div>
<div class="codehilite"><pre><span></span><code>The linear term vanishes (all single faults are detected), and the leading logical infidelity is quadratic with coefficient 4/75.
</code></pre></div>

<ol start="2">
<li>
<p>Mathematical Typesetting
- All expressions are given in LaTeX.</p>
</li>
<li>
<p>Conventions and Units
- Dimensionless gate error rate p; perfect H and measurement; depolarizing noise only after the five CNOTs.</p>
</li>
<li>
<p>Final Answer:</p>
</li>
</ol>
<div class="arithmatex">\[
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.680899
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>