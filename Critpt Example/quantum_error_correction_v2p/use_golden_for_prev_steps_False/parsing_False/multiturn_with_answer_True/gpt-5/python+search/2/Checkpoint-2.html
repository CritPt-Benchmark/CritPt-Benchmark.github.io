<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">üåì</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-step derivation</p>
<ul>
<li>Circuit, noise model, and target state</li>
<li>The circuit is applied right-to-left:
    1) H2
    2) CNOT21
    3) H0
    4) CNOT03</li>
<li>Only the two CNOTs are followed by two-qubit depolarizing channels acting on the gate‚Äôs two qubits. The model states that with probability p an error occurs and, conditioned on an error, one of the 15 non-identity two-qubit Paulis is applied uniformly at random, i.e.,</li>
</ul>
<div class="arithmatex">\[
\mathcal{E}^{(2)}(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\in\mathcal{P}_2\setminus\{II\}}P\rho P,
\]</div>
<div class="codehilite"><pre><span></span><code>where $\mathcal{P}_2=\{I,X,Y,Z\}^{\otimes 2}$. This is the ‚Äúuniform Pauli‚Äù form of the 2-qubit depolarizing/Pauli channel. ([qiskit.github.io](https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai), [docs.quantum.ibm.com](https://docs.quantum.ibm.com/api/qiskit/0.42/qiskit_aer.noise.depolarizing_error?utm_source=openai), [qml-tutorial.github.io](https://qml-tutorial.github.io/chapter2/2/?utm_source=openai))
</code></pre></div>

<ul>
<li>H followed by CNOT on |00‚ü© prepares a Bell state; hence each pair (2,1) and (0,3) is prepared into <span class="arithmatex">\(|\Phi^+\rangle=(|00\rangle+|11\rangle)/\sqrt{2}\)</span>. Therefore, the ideal final 4-qubit state is a product of two Bell pairs,</li>
</ul>
<div class="arithmatex">\[
|\Psi_{\mathrm{ideal}}\rangle = |\Phi^+\rangle_{21}\otimes|\Phi^+\rangle_{03}.
\]</div>
<div class="codehilite"><pre><span></span><code>([en.wikipedia.org](https://en.wikipedia.org/wiki/Bell_state))
</code></pre></div>

<ul>
<li>Factorization of the noisy state</li>
<li>The first error channel acts on qubits (2,1) immediately after CNOT21. No later gate touches qubits 1 or 2. The second error channel acts on (0,3) after CNOT03. Therefore, the final state factors as a tensor product of two two-qubit states:</li>
</ul>
<div class="arithmatex">\[
\rho_{\text{final}}=\rho_{21}\otimes\rho_{03},
\]</div>
<div class="codehilite"><pre><span></span><code>with
</code></pre></div>

<div class="arithmatex">\[
\]</div>
<ul>
<li>Bell-pair survival under a 2-qubit depolarizing/Pauli channel</li>
<li>For a single pair (say, 21), the fidelity with the ideal Bell state is</li>
</ul>
<div class="arithmatex">\[
      =(1-p)\underbrace{\langle\Phi^+|\Phi^+\rangle}_{=1}
\]</div>
<ul>
<li>Using the stabilizer properties of <span class="arithmatex">\(|\Phi^+\rangle\)</span>,</li>
</ul>
<div class="arithmatex">\[
      (Z\!\otimes\!Z)|\Phi^+\rangle=|\Phi^+\rangle,\quad
\]</div>
<div class="codehilite"><pre><span></span><code><span class="nv">so</span><span class="w"> </span>$<span class="o">|</span>\<span class="nv">langle</span>\<span class="nv">Phi</span><span class="o">^+|</span><span class="nv">P</span><span class="o">|</span>\<span class="nv">Phi</span><span class="o">^+</span>\<span class="nv">rangle</span><span class="o">|^</span><span class="mi">2</span><span class="o">=</span><span class="mi">1</span>$<span class="w"> </span><span class="k">for</span><span class="w"> </span>$<span class="nv">P</span>\<span class="nv">in</span>\{<span class="nv">XX</span>,<span class="nv">YY</span>,<span class="nv">ZZ</span>\}$<span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">remaining</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="nv">non</span><span class="o">-</span><span class="nv">identity</span><span class="w"> </span><span class="nv">two</span><span class="o">-</span><span class="nv">qubit</span><span class="w"> </span><span class="nv">Paulis</span><span class="w"> </span><span class="ss">(</span><span class="nv">they</span><span class="w"> </span><span class="nv">map</span><span class="w"> </span>$<span class="o">|</span>\<span class="nv">Phi</span><span class="o">^+</span>\<span class="nv">rangle</span>$<span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">some</span><span class="w"> </span><span class="nv">orthogonal</span><span class="w"> </span><span class="nv">Bell</span><span class="w"> </span><span class="nv">state</span>,<span class="w"> </span><span class="nv">e</span>.<span class="nv">g</span>.,<span class="w"> </span>$<span class="nv">ZI</span><span class="o">|</span>\<span class="nv">Phi</span><span class="o">^+</span>\<span class="nv">rangle</span><span class="o">=|</span>\<span class="nv">Phi</span><span class="o">^-</span>\<span class="nv">rangle</span>$<span class="ss">)</span>.<span class="w"> </span><span class="nv">Hence</span>,
</code></pre></div>

<div class="arithmatex">\[
      =1-\frac{12}{15}\,p
\]</div>
<div class="codehilite"><pre><span></span><code>(The three Paulis XX, YY, ZZ leave the pure density matrix unchanged, since $P|\Phi^+\rangle\langle\Phi^+|P=|\Phi^+\rangle\langle\Phi^+|$ even when the eigenvalue is ‚àí1.)
</code></pre></div>

<ul>
<li>Four-qubit physical-state fidelity</li>
<li>The target is a product state <span class="arithmatex">\(|\Psi_{\mathrm{ideal}}\rangle=|\Phi^+\rangle_{21}\otimes|\Phi^+\rangle_{03}\)</span> and the noisy state factors: <span class="arithmatex">\(\rho_{\text{final}}=\rho_{21}\otimes\rho_{03}\)</span>. Using <span class="arithmatex">\(\mathrm{Tr}[(A\otimes B)(C\otimes D)]=\mathrm{Tr}[AC]\mathrm{Tr}[BD]\)</span>,</li>
</ul>
<div class="arithmatex">\[
      =\langle\Phi^+|\rho_{21}|\Phi^+\rangle\;\langle\Phi^+|\rho_{03}|\Phi^+\rangle
      =\left(F_{\text{pair}}(p)\right)^2
\]</div>
<p>2) Mathematical details used
- Depolarizing/Pauli channel acting uniformly on non-identity n-qubit Paulis (here n=2) and the standard H‚ÄìCNOT Bell-state preparation. (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>, <a href="https://docs.quantum.ibm.com/api/qiskit/0.42/qiskit_aer.noise.depolarizing_error?utm_source=openai">docs.quantum.ibm.com</a>, <a href="https://en.wikipedia.org/wiki/Bell_state">en.wikipedia.org</a>)</p>
<p>3) Conventions and units
- Qubits labeled 0,1,2,3 as in the prompt. Gates are ideal except for the specified post-CNOT two-qubit depolarizing channels of error probability p. Fidelity is the state overlap with the ideal pure state, <span class="arithmatex">\(F=\langle\psi|\rho|\psi\rangle\)</span>.</p>
<p>Final Answer:</p>
<div class="arithmatex">\[
F_{\mathrm{phys}}(p)=\left(1-\frac{4}{5}p\right)^2.
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-step derivation</p>
<ul>
<li>Setup: code, circuit, noise, target</li>
<li>[[4,2,2]] code with stabilizers S = ‚ü®XXXX, ZZZZ‚ü©. A convenient choice of logical Paulis (up to stabilizers) is
    X_A = X I X I, X_B = X X I I, Z_A = Z Z I I, Z_B = Z I Z I, in the physical-qubit order (0,1,2,3). The codespace basis and stabilizers are standard for this code. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>, <a href="https://ar5iv.org/html/quant-ph/0703264?utm_source=openai">ar5iv.org</a>)</li>
<li>The state-preparation circuit acts right-to-left: H2 ‚Üí CNOT21 ‚Üí H0 ‚Üí CNOT03. Ideal action on |0000‚ü©: H2+CNOT21 prepares |Œ¶+‚ü©21; H0+CNOT03 prepares |Œ¶+‚ü©03, so the ideal 4-qubit state is
    |Œ®ideal‚ü© = |Œ¶+‚ü©21 ‚äó |Œ¶+‚ü©03,
    where |Œ¶+‚ü© = (|00‚ü©+|11‚ü©)/‚àö2. (<a href="https://qubit.guide/5.7-bell-states?utm_source=openai">qubit.guide</a>, <a href="https://en.wikipedia.org/wiki/Bell_state">en.wikipedia.org</a>)</li>
<li>
<p>Noise model: After each CNOTij, a two-qubit depolarizing (uniform Pauli) channel acts on those two qubits: with probability 1‚àíp nothing happens; with probability p a random non-identity 2-qubit Pauli from the 15 possibilities is applied uniformly (probability p/15 each). For n qubits this is the ‚Äúuniform Pauli‚Äù point of the depolarizing family. (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>)</p>
</li>
<li>
<p>One Bell pair under a two-qubit Pauli channel</p>
</li>
<li>
<p>The Bell state |Œ¶+‚ü© is stabilized by XX and ZZ, and (up to a global phase) any two-qubit Pauli maps a Bell state to some Bell state. In particular, the four operators {I, XX, YY, ZZ} leave |Œ¶+‚ü© invariant (eigenvalue ¬±1), while the remaining 12 Paulis map |Œ¶+‚ü© to the other three Bell states in 4-to-1 groupings (cosets). Therefore, for a single depolarized pair:
    P(Œ¶+) = (1‚àíp) + 3¬∑(p/15) = 1 ‚àí 12p/15,
    P(Œ¶‚àí) = P(Œ®+) = P(Œ®‚àí) = 4p/15.
    (This uses that Bell states are permuted by local/two-qubit Paulis and |Œ¶+‚ü© is an eigenstate of XX and ZZ.) (<a href="https://en.wikipedia.org/wiki/Bell_state">en.wikipedia.org</a>)</p>
</li>
<li>
<p>Independent noise on the two disjoint pairs</p>
</li>
<li>
<p>The two error channels act independently on (2,1) and (0,3), and no later gate mixes the pairs, so the joint distribution for the pair-types factorizes.</p>
</li>
<li>
<p>Post-selection criterion (detectable errors rejected)</p>
</li>
<li>
<p>Measuring the stabilizers XXXX and ZZZZ yields the trivial syndrome (+1,+1) iff the total Pauli error P commutes with both stabilizers, i.e., P lies in the normalizer of S. Equivalently for our two-Bell-pair picture, write the pairwise parities
    sXX(pair) = eigenvalue of X‚äóX on that pair, sZZ(pair) = eigenvalue of Z‚äóZ,
    which for the four Bell states are
    Œ¶+: (+,+), Œ¶‚àí: (‚àí,+), Œ®+: (+,‚àí), Œ®‚àí: (‚àí,‚àí).
    Since XXXX = (X2X1)(X0X3) and ZZZZ = (Z2Z1)(Z0Z3), the stabilizer outcomes are the products of the corresponding pairwise parities. Hence the run is accepted iff the two pairs have the same Bell label (their (sXX,sZZ) agree componentwise). (<a href="https://quantum.cloud.ibm.com/learning/courses/foundations-of-quantum-error-correction/stabilizer-formalism/stabilizer-codes?utm_source=openai">quantum.cloud.ibm.com</a>)</p>
</li>
<li>
<p>Acceptance probability</p>
</li>
<li>
<p>Let q := P(Œ¶+) = 1 ‚àí 12p/15 = 1 ‚àí 4p/5 and r := P(Œ¶‚àí) = P(Œ®+) = P(Œ®‚àí) = 4p/15 for each pair. The acceptance probability is
    Pacc = q^2 + 3 r^2
          = (1 ‚àí 4p/5)^2 + 3 (4p/15)^2
          = 1 ‚àí 8p/5 + (64/75)p^2.</p>
</li>
<li>
<p>Which accepted events keep the logical Bell state correct?</p>
</li>
<li>The target logical state is the logical Bell state |Œ¶+‚ü©AB, which our physical product |Œ¶+‚ü©21|Œ¶+‚ü©03 realizes. Accepted events fall into four classes:
    1) (Œ¶+,Œ¶+): P = P21‚äóP03 with Ppair ‚àà {I, XX, YY, ZZ}. Using XXXX = (X2X1)(X0X3) and ZZZZ = (Z2Z1)(Z0Z3), one checks that any such P equals a stabilizer times one of {I, X_A X_B, Z_A Z_B, Y_A Y_B}. All of these act as ¬±1 on |Œ¶+‚ü©AB (global phase allowed), so the logical state remains the target. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>, <a href="https://ar5iv.org/html/quant-ph/0703264?utm_source=openai">ar5iv.org</a>)
    2) (Œ¶‚àí,Œ¶‚àí): A representative is P = Z2 ¬∑ Z0, which equals the logical Z_B (up to stabilizers) because Z_B = Z0 Z2. This maps |Œ¶+‚ü©AB ‚Üí |Œ¶‚àí‚ü©AB, orthogonal to the target. All choices in this class are equivalent to logical Z_B (times stabilizers), hence ‚Äúbad‚Äù for fidelity. (<a href="https://ar5iv.org/html/quant-ph/0703264?utm_source=openai">ar5iv.org</a>)
    3) (Œ®+,Œ®+): A representative is P = X2 ¬∑ X0 = X_A, mapping |Œ¶+‚ü©AB ‚Üí |Œ®+‚ü©AB (orthogonal). All such are equivalent to logical X_A (times stabilizers), so ‚Äúbad.‚Äù (<a href="https://ar5iv.org/html/quant-ph/0703264?utm_source=openai">ar5iv.org</a>)
    4) (Œ®‚àí,Œ®‚àí): A representative is P = Y2 ¬∑ Y0 ‚àù X_A Z_B, mapping |Œ¶+‚ü©AB ‚Üí |Œ®‚àí‚ü©AB (orthogonal). Again ‚Äúbad.‚Äù (<a href="https://ar5iv.org/html/quant-ph/0703264?utm_source=openai">ar5iv.org</a>)</li>
<li>
<p>Therefore, among accepted runs, only the (Œ¶+,Œ¶+) sector produces the correct logical Bell state.</p>
</li>
<li>
<p>Logical fidelity conditioned on post-selection</p>
</li>
<li>The (conditional) logical state fidelity is the probability mass of the (Œ¶+,Œ¶+) sector conditioned on acceptance:
    Flogical(p) = P[(Œ¶+,Œ¶+)] / Pacc = q^2 / (q^2 + 3 r^2)
                = (1 ‚àí 4p/5)^2 / [ (1 ‚àí 4p/5)^2 + 3 (4p/15)^2 ].</li>
<li>Series for small p: Flogical(p) = 1 ‚àí (16/75) p^2 + O(p^3), reflecting the removal (by post-selection) of all O(p) logical errors. (<a href="https://quantum.cloud.ibm.com/learning/courses/foundations-of-quantum-error-correction/stabilizer-formalism/stabilizer-codes?utm_source=openai">quantum.cloud.ibm.com</a>)</li>
</ul>
<p>2) Mathematical identities and facts used
- Bell-state properties and preparation by H‚ÄìCNOT; |Œ¶+‚ü© stabilized by XX and ZZ; Paulis permute the Bell basis. (<a href="https://en.wikipedia.org/wiki/Bell_state">en.wikipedia.org</a>)
- [[4,2,2]] code stabilizers and typical logical representatives used above. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>, <a href="https://ar5iv.org/html/quant-ph/0703264?utm_source=openai">ar5iv.org</a>)
- Error detection accepts exactly errors commuting with all stabilizer generators (normalizer elements). (<a href="https://quantum.cloud.ibm.com/learning/courses/foundations-of-quantum-error-correction/stabilizer-formalism/stabilizer-codes?utm_source=openai">quantum.cloud.ibm.com</a>)
- Uniform two-qubit depolarizing channel (uniform Pauli at the ‚ÄúPauli point‚Äù). (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>)</p>
<p>3) Conventions and units
- Qubits labeled (0,1,2,3); logical qubits A,B. Gates ideal except for the specified two-qubit depolarizing channel of strength p applied after each CNOT. Fidelity is the pure-state overlap with the conditional logical state.</p>
<p>4) Final Answer:</p>
<div class="arithmatex">\[
F_{\rm logical}(p)
=\frac{\bigl(1-\tfrac{4}{5}p\bigr)^2}
       {\bigl(1-\tfrac{4}{5}p\bigr)^2+3\bigl(\tfrac{4}{15}p\bigr)^2}
=\frac{1-\tfrac{8}{5}p+\tfrac{16}{25}p^2}{1-\tfrac{8}{5}p+\tfrac{64}{75}p^2}\,.
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.550633
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>