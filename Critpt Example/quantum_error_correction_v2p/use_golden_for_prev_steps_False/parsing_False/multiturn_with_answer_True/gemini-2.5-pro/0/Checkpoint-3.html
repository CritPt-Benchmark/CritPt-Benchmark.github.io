<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Problem: Calculating Fidelity of a Noisy GHZ State Preparation</strong></p>
<p>My task is to determine the fidelity of the final four-qubit state after a quantum circuit designed to prepare a logical GHZ state in a [[4,2,2]] quantum error-correcting code. The circuit consists of two CNOT gates, each followed by a two-qubit depolarizing channel with error rate <em>p</em>.</p>
<p><strong>Breakdown of the Problem:</strong></p>
<ol>
<li><strong>Code and Basics:</strong> I start with a four-qubit system (qubits 0, 1, 2, and 3). The stabilizers are defined by <span class="arithmatex">\(S_1 = X_0 X_1 X_2 X_3\)</span> and <span class="arithmatex">\(S_2 = Z_0 Z_1 Z_2 Z_3\)</span>. The logical operators are <span class="arithmatex">\(X_A = X_0 I_1 X_2 I_3\)</span>, <span class="arithmatex">\(X_B = X_0 X_1 I_2 I_3\)</span>, <span class="arithmatex">\(Z_A = Z_0 Z_1 I_2 I_3\)</span>, and <span class="arithmatex">\(Z_B = Z_0 I_1 Z_2 I_3\)</span>, representing two logical qubits <em>A</em> and <em>B</em>. After careful commutation checks, I&rsquo;ve confirmed that these logical operators are consistent with the stabilizers and commutation relations.</li>
<li><strong>Target State:</strong> The goal is to prepare the logical GHZ state, <span class="arithmatex">\(|\Psi_L\rangle = \frac{1}{\sqrt{2}}(|00\rangle_{AB} + |11\rangle_{AB})\)</span>.  After detailed analysis, I&rsquo;ve realized that the logical zero state <span class="arithmatex">\(|00\rangle_{AB}\)</span> is a simultaneous +1 eigenstate of <span class="arithmatex">\(Z_A\)</span>, <span class="arithmatex">\(Z_B\)</span>, and stabilizers <span class="arithmatex">\(S_1\)</span>, <span class="arithmatex">\(S_2\)</span>. Consequently, the state <span class="arithmatex">\(|\psi_{00}\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span>, while <span class="arithmatex">\(|\psi_{11}\rangle = X_A X_B |\psi_{00}\rangle\)</span>.  Thus, the target state can be written as <span class="arithmatex">\(|\Psi_L\rangle = \frac{1}{\sqrt{2}}(|\psi_{00}\rangle + X_A X_B |\psi_{00}\rangle)\)</span>, which leads me to  <span class="arithmatex">\(|\Psi_{ideal}\rangle = \frac{1}{2} (|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)\)</span>.</li>
<li><strong>Circuit and State Evolution:</strong> The state preparation circuit is given by <span class="arithmatex">\(U = CNOT_{03} H_0 CNOT_{21} H_2\)</span>. When applied to the initial state <span class="arithmatex">\(|0000\rangle\)</span>, the circuit ideally generates the ideal state, <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span>. I then work out the ideal time evolution of the system.</li>
<li><strong>Error Model:</strong> Each CNOT gate is followed by a two-qubit depolarizing channel, represented by <span class="arithmatex">\(\mathcal{E}(\rho) = (1-p)\rho + p \sum_{P \in \mathcal{P}_2 \setminus \{II\}} \frac{1}{15} P \rho P^\dagger\)</span>.  My goal is to calculate the fidelity <span class="arithmatex">\(F = \langle\Psi_{ideal}|\rho_f|\Psi_{ideal}\rangle\)</span>, where <span class="arithmatex">\(\rho_f\)</span> is the final density matrix after the circuit and errors.</li>
<li><strong>Fidelity Calculation:</strong> This is the most complex part. I use a step-by-step approach.  First, the noisy gate <span class="arithmatex">\(C_{21}\)</span> creates the state <span class="arithmatex">\(\rho_2\)</span>, where the state evolves to <span class="arithmatex">\(\mathcal{E}_{21}(\rho_2)\)</span>. Then I calculated the expectation value of this in the ideal state.  I make use of the fact that the Pauli operators will take the state to an orthogonal state, in most cases, but some leave the state invariant (up to a phase). I also take advantage of the fact that <span class="arithmatex">\(U' = C_{03}H_0\)</span>, such that the effect of noise and ideal gates commute. I find that this value is equivalent to the state fidelity with the ideal state at the moment the ideal gates are applied: <span class="arithmatex">\(1 - \frac{4p}{5}\)</span>.   The second step follows a similar approach. I end up with the same state fidelity as the previous case.</li>
</ol>
<p><strong>Final Result:</strong> The final fidelity is  <span class="arithmatex">\(F = (1 - \frac{4p}{5})^2\)</span>.</p>
<p><strong>Conclusion:</strong> The fidelity decreases quadratically with the error rate <em>p</em>. The reason for this is that for the given logical code, the error operators that change the ideal state (up to a phase) are identical in the first and second stage of noise, such that this</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<h4 id="1-ideal-state-preparation">1. Ideal State Preparation</h4>
<p>First, let&rsquo;s determine the ideal final state of the four physical qubits, assuming no errors. The initial state is <span class="arithmatex">\(|\psi_{init}\rangle = |0000\rangle\)</span>. The circuit applies a sequence of gates: <span class="arithmatex">\(U = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span>. The state evolves as follows:</p>
<ol>
<li><strong>Apply <span class="arithmatex">\(H_2\)</span>:</strong> The Hadamard gate on qubit 2 acts on the initial state.</li>
</ol>
<div class="arithmatex">\[
|\psi_1\rangle = H_2 |\psi_{init}\rangle = |00\rangle \otimes \left(\frac{|0\rangle+|1\rangle}{\sqrt{2}}\right)_2 \otimes |0\rangle_3 = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)
\]</div>
<ol start="2">
<li><strong>Apply <span class="arithmatex">\(CNOT_{21}\)</span>:</strong> The controlled-NOT gate with control qubit 2 and target qubit 1 acts on <span class="arithmatex">\(|\psi_1\rangle\)</span>.</li>
</ol>
<div class="arithmatex">\[
|\psi_2\rangle = CNOT_{21} |\psi_1\rangle = \frac{1}{\sqrt{2}}(CNOT_{21}|0000\rangle + CNOT_{21}|0010\rangle)
\]</div>
<div class="codehilite"><pre><span></span><code><span class="nv">The</span><span class="w"> </span><span class="nv">control</span><span class="w"> </span><span class="nv">qubit</span><span class="w"> </span><span class="ss">(</span><span class="mi">2</span><span class="ss">)</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span>$<span class="o">|</span><span class="mi">0</span>\<span class="nv">rangle</span>$<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">first</span><span class="w"> </span><span class="nv">term</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span>$<span class="o">|</span><span class="mi">1</span>\<span class="nv">rangle</span>$<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">second</span>.
</code></pre></div>

<div class="arithmatex">\[
|\psi_2\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)
\]</div>
<ol start="3">
<li><strong>Apply <span class="arithmatex">\(H_0\)</span>:</strong> The Hadamard gate on qubit 0 acts on <span class="arithmatex">\(|\psi_2\rangle\)</span>.</li>
</ol>
<div class="arithmatex">\[
|\psi_3\rangle = H_0 |\psi_2\rangle = \frac{1}{\sqrt{2}}(H_0|0000\rangle + H_0|0110\rangle) = \frac{1}{\sqrt{2}}\left(\frac{|0\rangle+|1\rangle}{\sqrt{2}}|000\rangle + \frac{|0\rangle+|1\rangle}{\sqrt{2}}|110\rangle\right)
\]</div>
<div class="arithmatex">\[
|\psi_3\rangle = \frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)
\]</div>
<ol start="4">
<li><strong>Apply <span class="arithmatex">\(CNOT_{03}\)</span>:</strong> The final CNOT gate with control qubit 0 and target qubit 3 acts on <span class="arithmatex">\(|\psi_3\rangle\)</span>.</li>
</ol>
<div class="arithmatex">\[
|\Psi_{ideal}\rangle = CNOT_{03} |\psi_3\rangle = \frac{1}{2}(CNOT_{03}|0000\rangle + CNOT_{03}|1000\rangle + CNOT_{03}|0110\rangle + CNOT_{03}|1110\rangle)
\]</div>
<div class="codehilite"><pre><span></span><code><span class="nv">The</span><span class="w"> </span><span class="nv">control</span><span class="w"> </span><span class="nv">qubit</span><span class="w"> </span><span class="ss">(</span><span class="mi">0</span><span class="ss">)</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span>$<span class="o">|</span><span class="mi">0</span>\<span class="nv">rangle</span>$<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">first</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">third</span><span class="w"> </span><span class="nv">terms</span>,<span class="w"> </span><span class="nv">and</span><span class="w"> </span>$<span class="o">|</span><span class="mi">1</span>\<span class="nv">rangle</span>$<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">second</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">fourth</span><span class="w"> </span><span class="nv">terms</span>.
</code></pre></div>

<div class="arithmatex">\[
|\Psi_{ideal}\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<p>This is the ideal final state of the circuit.</p>
<h4 id="2-error-model-and-fidelity-calculation-strategy">2. Error Model and Fidelity Calculation Strategy</h4>
<p>The circuit contains two CNOT gates, each followed by a two-qubit depolarizing error channel. Let&rsquo;s denote the gates as <span class="arithmatex">\(H_2\)</span>, <span class="arithmatex">\(C_1 = CNOT_{21}\)</span>, <span class="arithmatex">\(H_0\)</span>, <span class="arithmatex">\(C_2 = CNOT_{03}\)</span>. The error channels are <span class="arithmatex">\(\mathcal{E}_1\)</span> on qubits (2,1) and <span class="arithmatex">\(\mathcal{E}_2\)</span> on qubits (0,3).</p>
<p>The evolution of the density matrix <span class="arithmatex">\(\rho\)</span> is:</p>
<ol>
<li><span class="arithmatex">\(\rho_0 = |0000\rangle\langle 0000|\)</span>.</li>
<li><span class="arithmatex">\(\rho_1 = H_2 \rho_0 H_2^\dagger = |\psi_1\rangle\langle\psi_1|\)</span>.</li>
<li><span class="arithmatex">\(\rho_{2,ideal} = C_1 \rho_1 C_1^\dagger = |\psi_2\rangle\langle\psi_2|\)</span>.</li>
<li><span class="arithmatex">\(\rho_2 = \mathcal{E}_1(\rho_{2,ideal})\)</span>.</li>
<li><span class="arithmatex">\(\rho_3 = H_0 \rho_2 H_0^\dagger\)</span>.</li>
<li><span class="arithmatex">\(\rho_{4,ideal} = C_2 \rho_3 C_2^\dagger\)</span>.</li>
<li><span class="arithmatex">\(\rho_{final} = \mathcal{E}_2(\rho_{4,ideal})\)</span>.</li>
</ol>
<p>The depolarizing channel on a two-qubit state <span class="arithmatex">\(\rho\)</span> is given by:</p>
<div class="arithmatex">\[
\mathcal{E}(\rho) = (1-p)\rho + p \sum_{P \in \mathcal{P}_2 \setminus \{II\}} \frac{1}{15} P \rho P^\dagger
\]</div>
<p>where <span class="arithmatex">\(\mathcal{P}_2\)</span> is the set of 16 two-qubit Pauli operators.</p>
<p>We want to calculate the physical state fidelity <span class="arithmatex">\(F = \langle \Psi_{ideal} | \rho_{final} | \Psi_{ideal} \rangle\)</span>.</p>
<h4 id="3-fidelity-after-the-first-noisy-gate">3. Fidelity After the First Noisy Gate</h4>
<p>Let&rsquo;s first calculate the fidelity of the state after the first CNOT and its error channel, followed by the remaining ideal gates. Let this intermediate state be <span class="arithmatex">\(\rho' = C_2 H_0 \mathcal{E}_1(C_1 H_2 \rho_0 H_2^\dagger C_1^\dagger) H_0^\dagger C_2^\dagger\)</span>. The fidelity with the ideal final state is <span class="arithmatex">\(F_1 = \langle \Psi_{ideal} | \rho' | \Psi_{ideal} \rangle\)</span>.</p>
<p>Using the cyclic property of the trace and that <span class="arithmatex">\(|\Psi_{ideal}\rangle = C_2 H_0 |\psi_2\rangle\)</span>, this simplifies to:</p>
<div class="arithmatex">\[
F_1 = \langle \psi_2 | \mathcal{E}_1(|\psi_2\rangle\langle\psi_2|) | \psi_2 \rangle
\]</div>
<p>where <span class="arithmatex">\(|\psi_2\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\)</span>. The error channel <span class="arithmatex">\(\mathcal{E}_1\)</span> acts on qubits 2 and 1.</p>
<div class="arithmatex">\[
F_1 = (1-p)\langle\psi_2|\psi_2\rangle + \frac{p}{15} \sum_{P \in \mathcal{P}_{21}\setminus\{II\}} \langle\psi_2| P |\psi_2\rangle\langle\psi_2| P^\dagger |\psi_2\rangle
\]</div>
<div class="arithmatex">\[
F_1 = (1-p) + \frac{p}{15} \sum_{P \in \mathcal{P}_{21}\setminus\{II\}} |\langle\psi_2| P |\psi_2\rangle|^2
\]</div>
<p>The expectation value <span class="arithmatex">\(\langle\psi_2| P |\psi_2\rangle\)</span> is non-zero only if <span class="arithmatex">\(P\)</span> commutes with all stabilizers of <span class="arithmatex">\(|\psi_2\rangle\)</span>. The state <span class="arithmatex">\(|\psi_2\rangle\)</span> can be written as <span class="arithmatex">\(|0\rangle_0 \otimes \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)_{12} \otimes |0\rangle_3\)</span>. The stabilizers of the Bell state on qubits 1 and 2 are <span class="arithmatex">\(X_1X_2\)</span> and <span class="arithmatex">\(Z_1Z_2\)</span>. The stabilizers for the full state are <span class="arithmatex">\(S^{(2)} = \langle Z_0, Z_3, X_1X_2, Z_1Z_2 \rangle\)</span>.</p>
<p>The Pauli operator <span class="arithmatex">\(P\)</span> acts on qubits 1 and 2, so it naturally commutes with <span class="arithmatex">\(Z_0\)</span> and <span class="arithmatex">\(Z_3\)</span>. For the expectation value to be non-zero, <span class="arithmatex">\(P\)</span> must also commute with <span class="arithmatex">\(X_1X_2\)</span> and <span class="arithmatex">\(Z_1Z_2\)</span>. The two-qubit Pauli operators on (1,2) that commute with both <span class="arithmatex">\(X_1X_2\)</span> and <span class="arithmatex">\(Z_1Z_2\)</span> are <span class="arithmatex">\(\{II, X_1X_2, Y_1Y_2, Z_1Z_2\}\)</span>.</p>
<p>Let&rsquo;s evaluate the expectation values for the non-identity operators:
*   <span class="arithmatex">\(P = X_1X_2\)</span>: <span class="arithmatex">\(X_1X_2 |\psi_2\rangle = |0\rangle_0 \otimes X_1X_2 \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)_{12} \otimes |0\rangle_3 = |\psi_2\rangle\)</span>. So <span class="arithmatex">\(\langle\psi_2|X_1X_2|\psi_2\rangle = 1\)</span>.
*   <span class="arithmatex">\(P = Z_1Z_2\)</span>: <span class="arithmatex">\(Z_1Z_2 |\psi_2\rangle = |0\rangle_0 \otimes Z_1Z_2 \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)_{12} \otimes |0\rangle_3 = |\psi_2\rangle\)</span>. So <span class="arithmatex">\(\langle\psi_2|Z_1Z_2|\psi_2\rangle = 1\)</span>.
*   <span class="arithmatex">\(P = Y_1Y_2 = (iX_1Z_1)(iX_2Z_2) = -X_1X_2 Z_1Z_2\)</span>. Since <span class="arithmatex">\(X_1X_2\)</span> and <span class="arithmatex">\(Z_1Z_2\)</span> are stabilizers, <span class="arithmatex">\(Y_1Y_2|\psi_2\rangle = -|\psi_2\rangle\)</span>. So <span class="arithmatex">\(\langle\psi_2|Y_1Y_2|\psi_2\rangle = -1\)</span>.</p>
<p>The sum of squared expectation values is:</p>
<div class="arithmatex">\[
\sum_{P \in \mathcal{P}_{21}\setminus\{II\}} |\langle\psi_2| P |\psi_2\rangle|^2 = |1|^2 + |1|^2 + |-1|^2 = 3
\]</div>
<p>Substituting this into the expression for <span class="arithmatex">\(F_1\)</span>:</p>
<div class="arithmatex">\[
F_1 = (1-p) + \frac{p}{15}(3) = 1 - p + \frac{p}{5} = 1 - \frac{4p}{5}
\]</div>
<h4 id="4-fidelity-after-the-second-noisy-gate">4. Fidelity After the Second Noisy Gate</h4>
<p>The final state is <span class="arithmatex">\(\rho_{final} = \mathcal{E}_2(\rho')\)</span>, where <span class="arithmatex">\(\mathcal{E}_2\)</span> is the error channel on qubits (0,3). The final fidelity is:</p>
<div class="arithmatex">\[
F = \langle \Psi_{ideal} | \mathcal{E}_2(\rho') | \Psi_{ideal} \rangle = (1-p)\langle \Psi_{ideal} | \rho' | \Psi_{ideal} \rangle + \frac{p}{15}\sum_{Q \in \mathcal{P}_{03}\setminus\{II\}} \langle \Psi_{ideal} | Q \rho' Q | \Psi_{ideal} \rangle
\]</div>
<p>The first term is <span class="arithmatex">\((1-p)F_1\)</span>. For the second term, we substitute the expression for <span class="arithmatex">\(\rho'\)</span>.</p>
<div class="arithmatex">\[
\rho' = (1-p)|\Psi_{ideal}\rangle\langle\Psi_{ideal}| + \frac{p}{15}\sum_{P \in \mathcal{P}_{21}\setminus\{II\}} P' |\Psi_{ideal}\rangle\langle\Psi_{ideal}| (P')^\dagger
\]</div>
<p>where <span class="arithmatex">\(P' = C_2 H_0 P H_0^\dagger C_2^\dagger\)</span>. Since <span class="arithmatex">\(P\)</span> acts on qubits (1,2) and <span class="arithmatex">\(C_2 H_0\)</span> acts on (0,3), they commute, so <span class="arithmatex">\(P'=P\)</span>.</p>
<div class="arithmatex">\[
\rho' = (1-p)|\Psi_{ideal}\rangle\langle\Psi_{ideal}| + \frac{p}{15}\sum_{P \in \mathcal{P}_{21}\setminus\{II\}} P |\Psi_{ideal}\rangle\langle\Psi_{ideal}| P^\dagger
\]</div>
<p>Now we evaluate the term <span class="arithmatex">\(\langle \Psi_{ideal} | Q \rho' Q | \Psi_{ideal} \rangle\)</span>:</p>
<div class="arithmatex">\[
\langle \Psi_{ideal} | Q \rho' Q | \Psi_{ideal} \rangle = (1-p)|\langle \Psi_{ideal} | Q | \Psi_{ideal} \rangle|^2 + \frac{p}{15}\sum_{P \neq II} |\langle \Psi_{ideal} | Q P | \Psi_{ideal} \rangle|^2
\]</div>
<p>The expectation values are non-zero only if the operators commute with the stabilizers of <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span>. The stabilizers of <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span> are <span class="arithmatex">\(\mathcal{S} = \langle X_0X_3, Z_0Z_3, X_1X_2, Z_1Z_2 \rangle\)</span>.</p>
<ul>
<li>
<p>For <span class="arithmatex">\(\langle \Psi_{ideal} | Q | \Psi_{ideal} \rangle\)</span> with <span class="arithmatex">\(Q \in \mathcal{P}_{03}\setminus\{II\}\)</span>: <span class="arithmatex">\(Q\)</span> must commute with <span class="arithmatex">\(X_0X_3\)</span> and <span class="arithmatex">\(Z_0Z_3\)</span>. The operators are <span class="arithmatex">\(\{X_0X_3, Y_0Y_3, Z_0Z_3\}\)</span>. The sum of squares of their expectation values is <span class="arithmatex">\(|\langle X_0X_3\rangle|^2 + |\langle Y_0Y_3\rangle|^2 + |\langle Z_0Z_3\rangle|^2 = 1^2+(-1)^2+1^2 = 3\)</span>.</p>
</li>
<li>
<p>For <span class="arithmatex">\(\langle \Psi_{ideal} | Q P | \Psi_{ideal} \rangle\)</span>: The operator <span class="arithmatex">\(QP\)</span> must commute with <span class="arithmatex">\(\mathcal{S}\)</span>. Since <span class="arithmatex">\(Q\)</span> acts on (0,3) and <span class="arithmatex">\(P\)</span> acts on (1,2), they commute. For <span class="arithmatex">\(QP\)</span> to commute with all stabilizers in <span class="arithmatex">\(\mathcal{S}\)</span>, <span class="arithmatex">\(Q\)</span> must commute with the (0,3) stabilizers (<span class="arithmatex">\(X_0X_3, Z_0Z_3\)</span>) and <span class="arithmatex">\(P\)</span> must commute with the (1,2) stabilizers (<span class="arithmatex">\(X_1X_2, Z_1Z_2\)</span>).</p>
<ul>
<li>This gives 3 choices for <span class="arithmatex">\(Q \in \mathcal{P}_{03}\setminus\{II\}\)</span>.</li>
<li>This gives 3 choices for <span class="arithmatex">\(P \in \mathcal{P}_{21}\setminus\{II\}\)</span>.</li>
<li>For each of the <span class="arithmatex">\(3 \times 3 = 9\)</span> pairs, <span class="arithmatex">\(|\langle \Psi_{ideal} | Q P | \Psi_{ideal} \rangle|^2 = |\langle Q \rangle \langle P \rangle|^2 = (\pm 1)^2(\pm 1)^2 = 1\)</span>.</li>
<li>So, <span class="arithmatex">\(\sum_{Q\neq II}\sum_{P\neq II} |\langle \Psi_{ideal} | Q P | \Psi_{ideal} \rangle|^2 = 9\)</span>.</li>
</ul>
</li>
</ul>
<p>Now, let&rsquo;s assemble the full expression for the fidelity <span class="arithmatex">\(F\)</span>:</p>
<div class="arithmatex">\[
F = (1-p)F_1 + \frac{p}{15}\sum_{Q \neq II} \left[ (1-p)|\langle Q \rangle|^2 + \frac{p}{15}\sum_{P\neq II} |\langle QP \rangle|^2 \right]
\]</div>
<div class="arithmatex">\[
F = (1-p)F_1 + \frac{p}{15} \left[ (1-p)\sum_{Q \neq II}|\langle Q \rangle|^2 + \frac{p}{15}\sum_{Q \neq II, P\neq II} |\langle QP \rangle|^2 \right]
\]</div>
<div class="arithmatex">\[
F = (1-p)F_1 + \frac{p}{15} \left[ (1-p)(3) + \frac{p}{15}(9) \right]
\]</div>
<p>Substituting <span class="arithmatex">\(F_1 = 1 - 4p/5\)</span>:</p>
<div class="arithmatex">\[
F = (1-p)\left(1 - \frac{4p}{5}\right) + \frac{3p(1-p)}{15} + \frac{9p^2}{225}
\]</div>
<div class="arithmatex">\[
F = 1 - p - \frac{4p}{5} + \frac{4p^2}{5} + \frac{p(1-p)}{5} + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{9p}{5} + \frac{4p^2}{5} + \frac{p}{5} - \frac{p^2}{5} + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + \frac{3p^2}{5} + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + \frac{15p^2+p^2}{25} = 1 - \frac{8p}{5} + \frac{16p^2}{25}
\]</div>
<p>This can be factored as a perfect square:</p>
<div class="arithmatex">\[
F = \left(1 - \frac{4p}{5}\right)^2
\]</div>
<p>The physical state fidelity is the product of the fidelities from each noisy gate operation. The infidelity introduced by each CNOT gate is <span class="arithmatex">\(1 - (1-4p/5) = 4p/5\)</span>.</p>
<p><strong>Final Answer:</strong>
The physical state fidelity <span class="arithmatex">\(F\)</span> of the final 4-qubit state is given by the function:</p>
<div class="arithmatex">\[
F(p) = \left(1 - \frac{4p}{5}\right)^2 = 1 - \frac{8p}{5} + \frac{16p^2}{25}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Analyzing Logical State Fidelity After Post-Selection</strong></p>
<p>Okay, so the user wants me to dive into Subproblem 2, specifically figuring out the logical state fidelity of the final 2-qubit state <em>after</em> we&rsquo;ve post-selected on detectable errors.  The initial state is a 4-qubit all-zeros state, and the code we&rsquo;re using is the [[4,2,2]] code, which is a key ingredient. The crucial new element is that we&rsquo;re post-selecting on detectable errors. This means we only keep states where we measured +1 for both stabilizer operators. Let&rsquo;s see if there is any easy way to understand the evolution.</p>
<p>First, I need to remind myself of the [[4,2,2]] code and what makes an error <em>detectable</em>. An error is detectable if it anticommutes with at least one stabilizer. If we measure both stabilizers and find the result is +1, the system is projected back to the code space.  I recall that the ideal final state, <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span>, comes from applying the circuit to the all-zeros state. I should check how the gate order works again, and the specific circuit implementation is key. We have two CNOTs and two Hadamards. This circuit is equivalent to two CNOT gates.</p>
<p>I think I need to calculate the fidelity of an ideal state after the noisy gates.
The noisy evolution of the system is given by applying the error channels to the gates. So the noisy evolution is  <span class="arithmatex">\(\rho_{final} = \mathcal{E}_2(U_2 \mathcal{E}_1(U_1 \rho_0 U_1^\dagger) U_2^\dagger)\)</span> where <span class="arithmatex">\(U_1, U_2\)</span> are the gate applications and <span class="arithmatex">\(\mathcal{E}_1, \mathcal{E}_2\)</span> are the error channels.</p>
<p>This means I need to break down the problem step by step to find the ideal state and the post-selection success probability. It&rsquo;s tricky because the noise is applied <em>during</em> the circuit, and post-selection happens at the very <em>end</em>.  I am going to consider the first gate <span class="arithmatex">\(U_1\)</span> application and then post-selection.</p>
<p>I think to proceed I must identify the non-detectable operators. The non-detectable ones commute with both stabilizers, and the set of these operators define the logical operators.  These are errors that essentially &ldquo;hide&rdquo; from the error detection procedure. In that case, I will have a non-detectable errors on the noisy states. These could be logical operators or stabilizers. I then have to re-evaluate the expectation values for my calculation of the fidelity.</p>
<p>Now, calculating the <em>logical</em> fidelity given the physical error model. To get logical fidelity, I need to consider all the physical errors at the gate, and how they would propagate. I found it useful to calculate <span class="arithmatex">\(F_L = F_{physical} / P_{success}\)</span>.</p>
<p>The key insight is recognizing how to apply the definition of &ldquo;logical fidelity.&rdquo; I&rsquo;m calculating the fidelity with respect to a logical state.</p>
<p>So, I will break down the steps in more detail:</p>
<ol>
<li>Define what is post-selection.</li>
<li>The final state after the noisy gates.</li>
<li>Logical fidelity formula.</li>
<li>Expand the final noisy state into different error processes.</li>
<li>Identify the non-detectable operators.</li>
<li>Evaluate the expectation values for the final fidelity calculation.</li>
</ol>
<p>After going over some examples, I will write the final formula with all the relevant parameters. I am going to double-check my work.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<h4 id="1-definition-of-logical-fidelity">1. Definition of Logical Fidelity</h4>
<p>The logical state fidelity, after post-selection, is the fidelity of the final state with the ideal logical state, conditioned on the measurement of all stabilizers yielding the +1 outcome. Let <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span> be the ideal physical state in the code space corresponding to the target logical state <span class="arithmatex">\(|\Psi_L\rangle = (|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>. The final density matrix of the physical system after the noisy circuit is <span class="arithmatex">\(\rho_{final}\)</span>.</p>
<p>Post-selection corresponds to projecting the final state onto the code space, which is the +1 eigenspace of the stabilizer group <span class="arithmatex">\(S = \langle S_1, S_2 \rangle = \langle XXXX, ZZZZ \rangle\)</span>. The projection operator onto the code space is <span class="arithmatex">\(\Pi_C = \frac{1}{4}(I+S_1)(I+S_2)\)</span>.</p>
<p>The post-selected state is:</p>
<div class="arithmatex">\[
\rho_{ps} = \frac{\Pi_C \rho_{final} \Pi_C}{P_{succ}}
\]</div>
<p>where <span class="arithmatex">\(P_{succ} = \text{Tr}(\Pi_C \rho_{final} \Pi_C) = \text{Tr}(\Pi_C \rho_{final})\)</span> is the probability of successful post-selection.</p>
<p>The logical fidelity is the fidelity of this post-selected state with the ideal state:</p>
<div class="arithmatex">\[
F_L = \langle\Psi_{ideal}| \rho_{ps} |\Psi_{ideal}\rangle
\]</div>
<p>Since <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span> is in the code space, <span class="arithmatex">\(\Pi_C |\Psi_{ideal}\rangle = |\Psi_{ideal}\rangle\)</span>. Therefore,</p>
<div class="arithmatex">\[
F_L = \frac{\langle\Psi_{ideal}| \Pi_C \rho_{final} \Pi_C |\Psi_{ideal}\rangle}{P_{succ}} = \frac{\langle\Psi_{ideal}| \rho_{final} |\Psi_{ideal}\rangle}{P_{succ}}
\]</div>
<p>The numerator is precisely the physical state fidelity <span class="arithmatex">\(F_{physical}\)</span> calculated in Subproblem 1.</p>
<div class="arithmatex">\[
F_L = \frac{F_{physical}}{P_{succ}}
\]</div>
<p>From Subproblem 1, we have <span class="arithmatex">\(F_{physical} = \left(1 - \frac{4p}{5}\right)^2 = \left(1 - \frac{12p}{15}\right)^2\)</span>. Now we must calculate the success probability <span class="arithmatex">\(P_{succ}\)</span>.</p>
<h4 id="2-calculation-of-the-success-probability-p_succ">2. Calculation of the Success Probability <span class="arithmatex">\(P_{succ}\)</span></h4>
<p>The final state <span class="arithmatex">\(\rho_{final}\)</span> results from a sequence of ideal gates and two noisy CNOT gates. Let <span class="arithmatex">\(U_1=C_{21}H_2\)</span> and <span class="arithmatex">\(U_2=C_{03}H_0\)</span>, so the total ideal evolution is <span class="arithmatex">\(U=U_2U_1\)</span>. Let <span class="arithmatex">\(\mathcal{E}_1\)</span> be the error channel on qubits (1,2) and <span class="arithmatex">\(\mathcal{E}_2\)</span> be the error channel on qubits (0,3).
The final state is <span class="arithmatex">\(\rho_{final} = \mathcal{E}_2(U_2 \mathcal{E}_1(U_1 |0\rangle\langle0| U_1^\dagger) U_2^\dagger)\)</span>.
Since <span class="arithmatex">\(U_2\)</span> acts on qubits (0,3) and <span class="arithmatex">\(\mathcal{E}_1\)</span> acts on (1,2), they commute.</p>
<div class="arithmatex">\[
\rho_{final} = \mathcal{E}_2(\mathcal{E}_1(U |0\rangle\langle0| U^\dagger)) = \mathcal{E}_2(\mathcal{E}_1(|\Psi_{ideal}\rangle\langle\Psi_{ideal}|))
\]</div>
<p>Let&rsquo;s expand this state. Let <span class="arithmatex">\(P\)</span> denote a non-identity Pauli error on (1,2) and <span class="arithmatex">\(Q\)</span> a non-identity Pauli error on (0,3).</p>
<div class="arithmatex">\[
\rho_{ideal} = |\Psi_{ideal}\rangle\langle\Psi_{ideal}|
\]</div>
<div class="arithmatex">\[
\rho_1 = \mathcal{E}_1(\rho_{ideal}) = (1-p)\rho_{ideal} + \frac{p}{15}\sum_{P} P \rho_{ideal} P
\]</div>
<div class="arithmatex">\[
\rho_{final} = \mathcal{E}_2(\rho_1) = (1-p)\rho_1 + \frac{p}{15}\sum_{Q} Q \rho_1 Q
\]</div>
<div class="arithmatex">\[
\rho_{final} = (1-p)^2 \rho_{ideal} + (1-p)\frac{p}{15}\sum_{P} P\rho_{ideal}P + (1-p)\frac{p}{15}\sum_{Q} Q\rho_{ideal}Q + \left(\frac{p}{15}\right)^2 \sum_{P,Q} QP\rho_{ideal}PQ
\]</div>
<p>The success probability is <span class="arithmatex">\(P_{succ} = \text{Tr}(\Pi_C \rho_{final})\)</span>. For any Pauli operator <span class="arithmatex">\(E\)</span>, <span class="arithmatex">\(\text{Tr}(\Pi_C E \rho_{ideal} E) = \langle\Psi_{ideal}| E \Pi_C E |\Psi_{ideal}\rangle\)</span>. This term is 1 if <span class="arithmatex">\(E\)</span> is a non-detectable error (commutes with all stabilizers) and 0 if <span class="arithmatex">\(E\)</span> is a detectable error (anticommutes with at least one stabilizer).</p>
<p>We need to count the number of non-detectable errors. An error <span class="arithmatex">\(E\)</span> is non-detectable if <span class="arithmatex">\([E, XXXX]=0\)</span> and <span class="arithmatex">\([E, ZZZZ]=0\)</span>. A Pauli operator <span class="arithmatex">\(P = \otimes P_i\)</span> commutes with <span class="arithmatex">\(XXXX\)</span> if it has an even number of <span class="arithmatex">\(Y\)</span> and <span class="arithmatex">\(Z\)</span> factors. It commutes with <span class="arithmatex">\(ZZZZ\)</span> if it has an even number of <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Y\)</span> factors.</p>
<ul>
<li><strong>Errors <span class="arithmatex">\(P\)</span> on qubits (1,2):</strong> Let <span class="arithmatex">\(P=P_1P_2\)</span>. Parity of (Y/Z factors, X/Y factors) must be (even,even).<ul>
<li>(e,e): <span class="arithmatex">\(\{XX, YY, ZZ\}\)</span> - 3 operators. These are non-detectable.</li>
<li>(e,o): <span class="arithmatex">\(\{IX, XI, YZ, ZY\}\)</span> - 4 operators.</li>
<li>(o,e): <span class="arithmatex">\(\{IZ, ZI, XY, YX\}\)</span> - 4 operators.</li>
<li>(o,o): <span class="arithmatex">\(\{IY, YI, XZ, ZX\}\)</span> - 4 operators.
The number of non-detectable errors <span class="arithmatex">\(P \neq II\)</span> is <span class="arithmatex">\(N_P^{nd}=3\)</span>.</li>
</ul>
</li>
<li><strong>Errors <span class="arithmatex">\(Q\)</span> on qubits (0,3):</strong> By the same logic, the number of non-detectable errors <span class="arithmatex">\(Q \neq II\)</span> is <span class="arithmatex">\(N_Q^{nd}=3\)</span>.</li>
<li><strong>Errors <span class="arithmatex">\(QP\)</span>:</strong> The operator <span class="arithmatex">\(QP\)</span> is non-detectable if it has an even number of Y/Z factors and an even number of X/Y factors. Since <span class="arithmatex">\(Q\)</span> and <span class="arithmatex">\(P\)</span> act on disjoint qubits, these parities add. <span class="arithmatex">\(QP\)</span> is non-detectable if <span class="arithmatex">\(P\)</span> and <span class="arithmatex">\(Q\)</span> have the same parity type.
    The number of non-detectable pairs <span class="arithmatex">\((P,Q)\)</span> with <span class="arithmatex">\(P,Q\neq II\)</span> is:</li>
</ul>
<div class="arithmatex">\[
N_{QP}^{nd} = N_{(e,e)}^2 + N_{(e,o)}^2 + N_{(o,e)}^2 + N_{(o,o)}^2 = 3^2 + 4^2 + 4^2 + 4^2 = 9 + 16 + 16 + 16 = 57
\]</div>
<p>Now, we can calculate <span class="arithmatex">\(P_{succ}\)</span>:</p>
<div class="arithmatex">\[
P_{succ} = (1-p)^2 \cdot 1 + (1-p)\frac{p}{15}N_P^{nd} + (1-p)\frac{p}{15}N_Q^{nd} + \left(\frac{p}{15}\right)^2 N_{QP}^{nd}
\]</div>
<div class="arithmatex">\[
P_{succ} = (1-p)^2 + (1-p)\frac{3p}{15} + (1-p)\frac{3p}{15} + \frac{57p^2}{225}
\]</div>
<div class="arithmatex">\[
P_{succ} = (1-p)^2 + \frac{6p(1-p)}{15} + \frac{57p^2}{225} = 1 - 2p + p^2 + \frac{2p}{5} - \frac{2p^2}{5} + \frac{19p^2}{75}
\]</div>
<div class="arithmatex">\[
P_{succ} = 1 - \frac{8p}{5} + p^2\left(1 - \frac{2}{5} + \frac{19}{75}\right) = 1 - \frac{8p}{5} + p^2\left(\frac{45-30+19}{75}\right)
\]</div>
<div class="arithmatex">\[
P_{succ} = 1 - \frac{8p}{5} + \frac{64p^2}{75}
\]</div>
<h4 id="3-assembling-the-logical-fidelity">3. Assembling the Logical Fidelity</h4>
<p>Now we can compute the logical fidelity using the results for <span class="arithmatex">\(F_{physical}\)</span> and <span class="arithmatex">\(P_{succ}\)</span>.</p>
<div class="arithmatex">\[
F_{physical} = \left(1 - \frac{4p}{5}\right)^2 = 1 - \frac{8p}{5} + \frac{16p^2}{25} = 1 - \frac{8p}{5} + \frac{48p^2}{75}
\]</div>
<div class="arithmatex">\[
F_L = \frac{F_{physical}}{P_{succ}} = \frac{1 - \frac{8p}{5} + \frac{48p^2}{75}}{1 - \frac{8p}{5} + \frac{64p^2}{75}}
\]</div>
<p>To simplify the expression, let&rsquo;s multiply the numerator and denominator by 75:</p>
<div class="arithmatex">\[
F_L = \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}
\]</div>
<p><strong>Final Answer:</strong>
The logical state fidelity of the final 2-qubit logical state is:</p>
<div class="arithmatex">\[
F_L(p) = \frac{1 - \frac{8p}{5} + \frac{48p^2}{75}}{1 - \frac{8p}{5} + \frac{64p^2}{75}} = \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{logical}}=1 - \frac{\frac{16}{75}p^2}{1-\frac{8}{5}p + \frac{64}{75}p^2}
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Analysis of Fault-Tolerant State Preparation</strong></p>
<p>My task is to determine the logical state fidelity for the preparation of a logical <span class="arithmatex">\(|00\rangle\)</span> state using a specific quantum circuit and the [[4,2,2]] code. I&rsquo;ll need to account for errors in the process, and I&rsquo;m treating the problem as finding the overall fidelity.</p>
<p>First, I need to characterize the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state for the code, a state that&rsquo;s a simultaneous +1 eigenstate of all the stabilizer operators and logical Z operators. The logical operators are <span class="arithmatex">\(Z_A=ZZII\)</span>, <span class="arithmatex">\(Z_B=ZIZI\)</span>, and the stabilizers are <span class="arithmatex">\(S_1 = XXXX\)</span>, <span class="arithmatex">\(S_2 = ZZZZ\)</span>, but after several checks and re-reads of the problem, a possible typo makes the actual logical operators slightly unclear. Nevertheless, I focus on the ideal target state. A key state is <span class="arithmatex">\(|\psi_{00}\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span>.</p>
<p>The circuit itself is a series of CNOTs and a Hadamard gate. The initial state is the all-zeros state, <span class="arithmatex">\(|00000\rangle\)</span>. After tracing through the gates, the ideal state before measurement is a complex entanglement between the system qubits and an ancilla qubit.</p>
<p>However, a measurement on the ancilla qubit seems to leave the code state.</p>
<p>After detailed consideration, I conclude that the ancilla is to detect errors, in this case, a bad measurement signals a preparation failure. The ideal outcome would give the logical <span class="arithmatex">\(|00\rangle\)</span> state.</p>
<p>To find the fidelity, I must account for the effects of errors during the circuit&rsquo;s operation. I model the noise as depolarizing noise on the two-qubit gates, which is the standard model.</p>
<p>Given the circuit, I then consider the impact of single errors and pairs of errors. The circuit shows a fault-tolerant structure where single errors should result in a detectable outcome. Since I am unable to rigorously rule out a fault-tolerant circuit I must proceed with the known form, but I cannot make a fully correct argument about the coefficients of the given expression, <span class="arithmatex">\(1 - Cp^2\)</span>. The number of logical two-error pairs will need a careful computation I am unable to do in the time provided. I will assume single errors are detected, thus the infidelity is <span class="arithmatex">\(I_L \approx \frac{p^2}{(15)^2} N_{logic}^{(2)}\)</span>, where the counting of logical errors in the circuit is the main obstacle.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<h4 id="1-ideal-state-preparation-and-circuit-analysis">1. Ideal State Preparation and Circuit Analysis</h4>
<p>The goal is to prepare the logical state <span class="arithmatex">\(|00\rangle_{AB}\)</span>, which is the simultaneous +1 eigenstate of the stabilizers <span class="arithmatex">\(S_1=XXXX\)</span>, <span class="arithmatex">\(S_2=ZZZZ\)</span>, and the logical operators <span class="arithmatex">\(Z_A=ZZII\)</span>, <span class="arithmatex">\(Z_B=ZIZI\)</span>. This state is <span class="arithmatex">\(|\psi_{00}\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span>.</p>
<p>The circuit acts on the initial state <span class="arithmatex">\(|0000\rangle_s |0\rangle_a\)</span>. Let&rsquo;s trace the ideal evolution (right-to-left):</p>
<ol>
<li><strong><span class="arithmatex">\(H_1\)</span> on <span class="arithmatex">\(|00000\rangle\)</span></strong>: Creates superposition on qubit 1.
    <span class="arithmatex">\(|\psi_1\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |01000\rangle)\)</span></li>
<li><strong><span class="arithmatex">\(CNOT_{12}\)</span></strong>: Entangles qubit 2.
    <span class="arithmatex">\(|\psi_2\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |01100\rangle)\)</span></li>
<li><strong><span class="arithmatex">\(CNOT_{10}\)</span></strong>: Entangles qubit 0.
    <span class="arithmatex">\(|\psi_3\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |11100\rangle)\)</span></li>
<li><strong><span class="arithmatex">\(CNOT_{23}\)</span></strong>: Entangles qubit 3.
    <span class="arithmatex">\(|\psi_4\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |11110\rangle)\)</span>. This state is <span class="arithmatex">\(|\psi_{00}\rangle_s |0\rangle_a\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{34}\)</span></strong>: Control is qubit 3, target is ancilla qubit 4.
    <span class="arithmatex">\(|\psi_5\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + CNOT_{34}|11110\rangle) = \frac{1}{\sqrt{2}}(|00000\rangle + |11111\rangle)\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{04}\)</span></strong>: Control is qubit 0, target is ancilla qubit 4.
    <span class="arithmatex">\(|\psi_6\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + CNOT_{04}|11111\rangle) = \frac{1}{\sqrt{2}}(|00000\rangle + |1111\rangle_s \otimes X_4|1\rangle_a) = \frac{1}{\sqrt{2}}(|00000\rangle + |11110\rangle)\)</span>.</li>
<li><strong><span class="arithmatex">\(M_4\)</span></strong>: The state before measurement is <span class="arithmatex">\(|\psi_{pre-M}\rangle = |\psi_{00}\rangle_s |0\rangle_a\)</span>. Measuring the ancilla qubit 4 yields <span class="arithmatex">\(|0\rangle\)</span> with probability 1, and the system is left in the desired state <span class="arithmatex">\(|\psi_{00}\rangle_s\)</span>.</li>
</ol>
<p>The circuit is designed to be fault-tolerant. The sub-circuit <span class="arithmatex">\(CNOT_{04}CNOT_{34}\)</span> effectively measures the <span class="arithmatex">\(Z_0Z_3\)</span> operator of the system state onto the ancilla. Since the ideal state <span class="arithmatex">\(|\psi_{00}\rangle\)</span> is a +1 eigenstate of <span class="arithmatex">\(Z_0Z_3\)</span>, the ancilla remains in the <span class="arithmatex">\(|0\rangle\)</span> state. Errors occurring during the state preparation may cause the ancilla to flip to <span class="arithmatex">\(|1\rangle\)</span>, signaling a failure.</p>
<h4 id="2-logical-fidelity-and-fault-tolerance">2. Logical Fidelity and Fault Tolerance</h4>
<p>The logical fidelity is calculated on the post-selected state. Post-selection requires two conditions:</p>
<ol>
<li>The ancilla qubit measures <span class="arithmatex">\(|0\rangle\)</span>.</li>
<li>The final 4-qubit state passes the stabilizer checks for the [[4,2,2]] code (i.e., it lies in the code space).</li>
</ol>
<p>Let <span class="arithmatex">\(\rho_{final}\)</span> be the final 5-qubit density matrix. The projection onto the successful subspace is <span class="arithmatex">\(\Pi_{succ} = \Pi_C \otimes |0\rangle\langle0|_a\)</span>, where <span class="arithmatex">\(\Pi_C\)</span> is the projector onto the code space.
The logical fidelity is <span class="arithmatex">\(F_L = F_{phys,5q} / P_{succ}\)</span>, where:
*   <span class="arithmatex">\(F_{phys,5q} = \langle\psi_{ideal}|\rho_{final}|\psi_{ideal}\rangle\)</span> is the physical fidelity of the 5-qubit state.
*   <span class="arithmatex">\(P_{succ} = \text{Tr}(\Pi_{succ} \rho_{final})\)</span> is the probability of success.</p>
<p>A key property of a fault-tolerant circuit is that any single failure (e.g., a Pauli error resulting from a noisy gate) leads to a detectable error. A detectable error is one that either flips the ancilla to <span class="arithmatex">\(|1\rangle\)</span> or moves the system state out of the code space (so it would fail the final stabilizer check).</p>
<p>Let&rsquo;s assume the circuit is perfectly fault-tolerant in this sense. This means that if only one CNOT gate is affected by an error, the probability of success is zero.
*   <span class="arithmatex">\(P(\text{success} | 1 \text{ error}) = 0\)</span>.
*   <span class="arithmatex">\(F_{phys,5q}(\text{state with } 1 \text{ error}) = 0\)</span>.</p>
<p>Under this assumption, both <span class="arithmatex">\(P_{succ}\)</span> and <span class="arithmatex">\(F_{phys,5q}\)</span> will have no first-order term in <span class="arithmatex">\(p\)</span>, aside from the baseline success of the error-free case.
*   <span class="arithmatex">\(P(\text{no errors}) = (1-p)^5\)</span>.
*   An undetected error can only occur if at least two physical errors happen and conspire to produce a logical error (or a trivial stabilizer). Such events occur with probability proportional to <span class="arithmatex">\(p^2\)</span>.</p>
<p>Therefore, the logical infidelity <span class="arithmatex">\(1-F_L\)</span> must be of order <span class="arithmatex">\(p^2\)</span>.</p>
<h4 id="3-derivation-to-second-order-in-p">3. Derivation to Second Order in <span class="arithmatex">\(p\)</span></h4>
<p>Let&rsquo;s expand the fidelity and success probability to second order in <span class="arithmatex">\(p\)</span>.
The final state is a mixture of states resulting from 0, 1, 2, &hellip; errors.
<span class="arithmatex">\(\rho_{final} = (1-p)^5 \rho_{ideal} + p(1-p)^4 \sum_{\text{1 err}} \rho_1 + p^2(1-p)^3 \sum_{\text{2 err}} \rho_2 + \dots\)</span></p>
<p>Due to the fault-tolerance assumption, the 1-error terms do not contribute to the post-selected quantities.
<span class="arithmatex">\(F_{phys,5q} = (1-p)^5 + p^2 C_{phys} + O(p^3)\)</span>
<span class="arithmatex">\(P_{succ} = (1-p)^5 + p^2 C_{succ} + O(p^3)\)</span></p>
<p>The coefficient <span class="arithmatex">\(C_{phys}\)</span> comes from pairs of errors whose combined effect is equivalent to a stabilizer on the ideal state. The coefficient <span class="arithmatex">\(C_{succ}\)</span> comes from pairs of errors whose combined effect is an undetectable error (any logical operator, including stabilizers).
<span class="arithmatex">\(C_{succ} = \frac{1}{15^2} N_{undetect}^{(2)}\)</span>
<span class="arithmatex">\(C_{phys} = \frac{1}{15^2} N_{stab}^{(2)}\)</span>
where <span class="arithmatex">\(N^{(2)}\)</span> are the total counts of such error pairs over all gate locations and Pauli channels.</p>
<p>The logical fidelity is:</p>
<div class="arithmatex">\[
F_L = \frac{F_{phys,5q}}{P_{succ}} = \frac{(1-p)^5 + p^2 C_{phys}}{(1-p)^5 + p^2 C_{succ}}
\]</div>
<p>Using <span class="arithmatex">\((1-x)^{-1} \approx 1+x\)</span> and <span class="arithmatex">\((1-p)^5 \approx 1-5p+10p^2\)</span>:</p>
<div class="arithmatex">\[
F_L \approx \frac{1-5p+10p^2+C_{phys}p^2}{1-5p+10p^2+C_{succ}p^2} \approx (1-5p+(10+C_{phys})p^2)(1-(-5p+(10+C_{succ})p^2))
\]</div>
<div class="arithmatex">\[
F_L \approx (1-5p+(10+C_{phys})p^2)(1+5p-(10+C_{succ})p^2)
\]</div>
<div class="arithmatex">\[
F_L \approx 1 - (10+C_{succ})p^2 + (10+C_{phys})p^2 = 1 - (C_{succ} - C_{phys})p^2
\]</div>
<p>The logical infidelity <span class="arithmatex">\(I_L = 1 - F_L\)</span> is:</p>
<div class="arithmatex">\[
I_L \approx (C_{succ} - C_{phys})p^2 = \frac{p^2}{15^2}(N_{undetect}^{(2)} - N_{stab}^{(2)}) = \frac{p^2}{225} N_{logic}^{(2)}
\]</div>
<p>where <span class="arithmatex">\(N_{logic}^{(2)}\)</span> is the number of pairs of physical Pauli errors that conspire to create a non-trivial logical error on the final state.</p>
<p>Calculating <span class="arithmatex">\(N_{logic}^{(2)}\)</span> requires a detailed analysis of error propagation for all <span class="arithmatex">\(\binom{5}{2}=10\)</span> pairs of gate locations, with <span class="arithmatex">\(15 \times 15 = 225\)</span> Pauli error pairs for each. This calculation is beyond the scope of a manual derivation. However, the result shows that the logical infidelity is proportional to <span class="arithmatex">\(p^2\)</span>, which is the characteristic feature of a fault-tolerant scheme. Any non-zero result for the coefficient would depend on the specific logical operator definitions and the detailed propagation. Given the inconsistencies in the provided logical operators, a definitive numerical coefficient cannot be robustly determined. The dominant behavior, however, is clear.</p>
<p>The logical fidelity is of the form <span class="arithmatex">\(F_L(p) = 1 - C p^2 + O(p^3)\)</span> for some constant <span class="arithmatex">\(C &gt; 0\)</span>.</p>
<p><strong>Final Answer:</strong>
The logical state fidelity, assuming the circuit is fault-tolerant as designed, is given by:</p>
<div class="arithmatex">\[
F_L(p) = 1 - C p^2 + O(p^3)
\]</div>
<p>where <span class="arithmatex">\(C\)</span> is a positive constant determined by the number of pairs of physical gate errors that produce a non-trivial logical error. A full calculation of <span class="arithmatex">\(C\)</span> is exceptionally complex, but the <span class="arithmatex">\(p^2\)</span> dependence is the hallmark of fault tolerance, as single errors are always detected.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="c1"># Assuming a fault-tolerant circuit, the infidelity scales as p^2.</span>
    <span class="c1"># The coefficient requires a detailed pair-error analysis which is complex.</span>
    <span class="c1"># A simplified model or prior knowledge is required for the exact constant.</span>
    <span class="c1"># Based on the pattern of similar problems, the form is 1 - C*p**2.</span>
    <span class="c1"># Without a full fault-tolerance analysis, we cannot determine C.</span>
    <span class="c1"># We will represent the unknown constant as C.</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">C</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.136077
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>