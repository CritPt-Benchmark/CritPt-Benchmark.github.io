<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="subproblems">Checkpoints</h1>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>The Problem of Quantum Error Correction</strong></p>
<p>My task is to delve into the realm of quantum error correction using the [4,2,2] code. This involves understanding how to protect two logical qubits, A and B, encoded into four physical qubits labeled 0, 1, 2, and 3. The code&rsquo;s distance of two implies the ability to detect single-qubit errors.</p>
<p>The code&rsquo;s structure is defined by the following:
*   <strong>Stabilizers:</strong>
    *   <span class="arithmatex">\(S_1 = X_0X_1X_2X_3\)</span> (XXXX)
    *   <span class="arithmatex">\(S_2 = Z_0Z_1Z_2Z_3\)</span> (ZZZZ)
*   <strong>Logical Operators:</strong>
    *   <span class="arithmatex">\(X_A = X_0I_1X_2I_3\)</span> (XIXI)
    *   <span class="arithmatex">\(X_B = X_0X_1I_2I_3\)</span> (XXII)
    *   <span class="arithmatex">\(Z_A = Z_0Z_1I_2I_3\)</span> (ZZII)
    *   <span class="arithmatex">\(Z_B = Z_0I_1Z_2I_3\)</span> (ZIZI)</p>
<p>The objective is to prepare a two-qubit logical GHZ state: <span class="arithmatex">\(|\psi_L\rangle = \frac{1}{\sqrt{2}}(|00\rangle_{AB} + |11\rangle_{AB})\)</span>.</p>
<p><strong>State Preparation</strong></p>
<p>The circuit to prepare this state is defined by <span class="arithmatex">\(U = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span>. Starting from the initial state <span class="arithmatex">\(|0000\rangle\)</span>, I traced the state through each gate operation.  I checked the ideal state and verified it to be a logical GHZ state.</p>
<p>The GHZ state is a simultaneous +1 eigenstate of <span class="arithmatex">\(Z_A Z_B\)</span> and <span class="arithmatex">\(X_A X_B\)</span> and belongs to the codespace of the code.</p>
<p><strong>Error Model and Fidelity</strong></p>
<p>The error model states that each CNOT gate is followed by a two-qubit depolarizing error channel <span class="arithmatex">\(\mathcal{E}_{ij}\)</span>.  This depolarizing channel acts as a sum of Pauli error operators: <span class="arithmatex">\(\mathcal{E}_{ij}(\rho) = (1-p) \rho + p \sum_{P \in \{I,X,Y,Z\}^{\otimes 2} \setminus \{II\}} \frac{1}{15} P \rho P^\dagger\)</span>. My main goal is to calculate the physical state fidelity, which is <span class="arithmatex">\(F = \langle \psi_{ideal} | \rho_{final} | \psi_{ideal} \rangle\)</span>, as a function of the error probability <span class="arithmatex">\(p\)</span>.</p>
<p>The ideal final state, <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span>, can be obtained by applying the state-preparation circuit U to the initial state, <span class="arithmatex">\(|0000\rangle\)</span>.</p>
<p><strong>Deriving the Final Fidelity</strong></p>
<p>By tracking the effects of the circuit and the error channels, I derived the following expression for the final fidelity:</p>
<p><span class="arithmatex">\(F = (1-p)^2 + \frac{6 p(1-p)}{15} + \frac{9 p^2}{225}\)</span></p>
<p>Using some Pauli algebra with the stabilizer elements of the ideal state, I simplified this result:</p>
<p><span class="arithmatex">\(F = (1 - \frac{4}{5}p)^2\)</span></p>
<p>This is the central result that describes the fidelity, with the error model, and how the quality of the state is degraded, in this particular error correction problem.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p><strong>1. Determine the ideal final state</strong></p>
<p>The circuit consists of the sequence of operations <span class="arithmatex">\(U = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span> applied to the initial state <span class="arithmatex">\(|\psi_{init}\rangle = |0000\rangle\)</span>. The operations are applied from right to left.</p>
<ol>
<li><strong>Initial state:</strong> <span class="arithmatex">\(|\psi_0\rangle = |0000\rangle\)</span>.</li>
<li><strong>Apply <span class="arithmatex">\(H_2\)</span> (Hadamard on qubit 2):</strong></li>
</ol>
<div class="arithmatex">\[
|\psi_1\rangle = H_2 |\psi_0\rangle = |00\rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)_2 \otimes |0\rangle_3 = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)
\]</div>
<ol start="3">
<li><strong>Apply <span class="arithmatex">\(CNOT_{21}\)</span> (control on 2, target on 1):</strong> This gate flips qubit 1 if qubit 2 is <span class="arithmatex">\(|1\rangle\)</span>.</li>
</ol>
<div class="arithmatex">\[
|\psi_2\rangle = CNOT_{21} |\psi_1\rangle = \frac{1}{\sqrt{2}}(CNOT_{21}|0000\rangle + CNOT_{21}|0010\rangle) = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)
\]</div>
<ol start="4">
<li><strong>Apply <span class="arithmatex">\(H_0\)</span> (Hadamard on qubit 0):</strong></li>
</ol>
<div class="arithmatex">\[
|\psi_3\rangle = H_0 |\psi_2\rangle = \frac{1}{\sqrt{2}} \left( H_0|0000\rangle + H_0|0110\rangle \right) = \frac{1}{\sqrt{2}} \left( \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)_0|000\rangle + \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)_0|110\rangle \right)
\]</div>
<div class="arithmatex">\[
|\psi_3\rangle = \frac{1}{2} (|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)
\]</div>
<ol start="5">
<li><strong>Apply <span class="arithmatex">\(CNOT_{03}\)</span> (control on 0, target on 3):</strong> This gate flips qubit 3 if qubit 0 is <span class="arithmatex">\(|1\rangle\)</span>.</li>
</ol>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = CNOT_{03} |\psi_3\rangle = \frac{1}{2} (CNOT_{03}|0000\rangle + CNOT_{03}|1000\rangle + CNOT_{03}|0110\rangle + CNOT_{03}|1110\rangle)
\]</div>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = \frac{1}{2} (|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<p>This is the pure quantum state produced by the circuit in the absence of errors.</p>
<p><strong>2. Model the circuit with errors</strong></p>
<p>The circuit contains two <span class="arithmatex">\(CNOT\)</span> gates, each followed by a two-qubit depolarizing error channel. Let <span class="arithmatex">\(C_1 = CNOT_{21}\)</span> and <span class="arithmatex">\(C_2 = CNOT_{03}\)</span>. The ideal unitaries between the CNOTs are <span class="arithmatex">\(U_1 = H_2\)</span> and <span class="arithmatex">\(U_2 = H_0\)</span>. The error channel after a CNOT gate on qubits <span class="arithmatex">\(i,j\)</span> is given by:</p>
<div class="arithmatex">\[
\mathcal{E}_{ij}(\rho) = (1-p) \rho + p \sum_{P \in \mathcal{P}_{ij}^*} \frac{1}{15} P \rho P
\]</div>
<p>where <span class="arithmatex">\(\mathcal{P}_{ij}^*\)</span> is the set of 15 non-identity two-qubit Pauli operators on qubits <span class="arithmatex">\(i\)</span> and <span class="arithmatex">\(j\)</span>.</p>
<p>The evolution of the density matrix <span class="arithmatex">\(\rho\)</span> from the initial state <span class="arithmatex">\(\rho_0 = |\psi_{init}\rangle\langle\psi_{init}|\)</span> is:</p>
<ol>
<li><span class="arithmatex">\(\rho_1 = U_1 \rho_0 U_1^\dagger\)</span></li>
<li><span class="arithmatex">\(\rho_2 = C_1 \rho_1 C_1^\dagger\)</span></li>
<li><span class="arithmatex">\(\rho_3 = \mathcal{E}_{21}(\rho_2) = (1-p)\rho_2 + \frac{p}{15}\sum_{P_1 \in \mathcal{P}_{21}^*} P_1 \rho_2 P_1\)</span></li>
<li><span class="arithmatex">\(\rho_4 = U_2 \rho_3 U_2^\dagger\)</span></li>
<li><span class="arithmatex">\(\rho_5 = C_2 \rho_4 C_2^\dagger\)</span></li>
<li><span class="arithmatex">\(\rho_{final} = \mathcal{E}_{03}(\rho_5) = (1-p)\rho_5 + \frac{p}{15}\sum_{P_2 \in \mathcal{P}_{03}^*} P_2 \rho_5 P_2\)</span></li>
</ol>
<p>Let&rsquo;s express <span class="arithmatex">\(\rho_{final}\)</span> in terms of <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span>.
Let <span class="arithmatex">\(U_{mid} = C_2 U_2\)</span>. The ideal state is <span class="arithmatex">\(|\psi_{ideal}\rangle = U_{mid} C_1 U_1 |\psi_{init}\rangle\)</span>. The density matrix before the second error channel is:</p>
<div class="arithmatex">\[
\rho_5 = U_{mid} \mathcal{E}_{21}(C_1 U_1 \rho_0 U_1^\dagger C_1^\dagger) U_{mid}^\dagger
\]</div>
<div class="arithmatex">\[
\rho_5 = (1-p) U_{mid} \rho_2 U_{mid}^\dagger + \frac{p}{15}\sum_{P_1} U_{mid} P_1 \rho_2 P_1 U_{mid}^\dagger
\]</div>
<p>Since <span class="arithmatex">\(\rho_2 = C_1 U_1 \rho_0 U_1^\dagger C_1^\dagger\)</span>, we have <span class="arithmatex">\(U_{mid} \rho_2 U_{mid}^\dagger = |\psi_{ideal}\rangle\langle\psi_{ideal}|\)</span>.
Let <span class="arithmatex">\(\tilde{P}_1 = U_{mid} P_1 U_{mid}^\dagger\)</span>. Since <span class="arithmatex">\(P_1\)</span> acts on qubits {1,2} and <span class="arithmatex">\(U_{mid}=CNOT_{03}H_0\)</span> acts on qubits {0,3}, they commute, so <span class="arithmatex">\(\tilde{P}_1 = P_1\)</span>.</p>
<div class="arithmatex">\[
\rho_5 = (1-p) |\psi_{ideal}\rangle\langle\psi_{ideal}| + \frac{p}{15}\sum_{P_1 \in \mathcal{P}_{21}^*} P_1 |\psi_{ideal}\rangle\langle\psi_{ideal}| P_1
\]</div>
<p>Now we apply the second error channel <span class="arithmatex">\(\mathcal{E}_{03}\)</span>:</p>
<div class="arithmatex">\[
\rho_{final} = (1-p)\rho_5 + \frac{p}{15}\sum_{P_2 \in \mathcal{P}_{03}^*} P_2 \rho_5 P_2
\]</div>
<p>Substituting the expression for <span class="arithmatex">\(\rho_5\)</span>:</p>
<div class="arithmatex">\[
\rho_{final} = (1-p)^2 |\psi_{ideal}\rangle\langle\psi_{ideal}| + \frac{p(1-p)}{15}\sum_{P_1} P_1 |\psi_{ideal}\rangle\langle\psi_{ideal}| P_1 + \frac{p(1-p)}{15}\sum_{P_2} P_2 |\psi_{ideal}\rangle\langle\psi_{ideal}| P_2 + \frac{p^2}{15^2}\sum_{P_1,P_2} P_2 P_1 |\psi_{ideal}\rangle\langle\psi_{ideal}| P_1 P_2
\]</div>
<p><strong>3. Calculate the fidelity</strong></p>
<p>The physical state fidelity is <span class="arithmatex">\(F = \langle\psi_{ideal}|\rho_{final}|\psi_{ideal}\rangle\)</span>. Let <span class="arithmatex">\(|\psi\rangle = |\psi_{ideal}\rangle\)</span>.</p>
<div class="arithmatex">\[
F = (1-p)^2 |\langle\psi|\psi\rangle|^2 + \frac{p(1-p)}{15}\sum_{P_1} |\langle\psi|P_1|\psi\rangle|^2 + \frac{p(1-p)}{15}\sum_{P_2} |\langle\psi|P_2|\psi\rangle|^2 + \frac{p^2}{15^2}\sum_{P_1,P_2} |\langle\psi|P_2 P_1|\psi\rangle|^2
\]</div>
<p>To evaluate the sums, we need to find which Pauli operators have non-zero expectation value with respect to <span class="arithmatex">\(|\psi\rangle\)</span>. A Pauli operator <span class="arithmatex">\(P\)</span> has a non-zero expectation value <span class="arithmatex">\(\langle\psi|P|\psi\rangle\)</span> only if <span class="arithmatex">\(|\psi\rangle\)</span> is an eigenstate of <span class="arithmatex">\(P\)</span>. Since <span class="arithmatex">\(|\psi\rangle\)</span> is a stabilizer state, this means <span class="arithmatex">\(P\)</span> must be an element of the stabilizer group <span class="arithmatex">\(\mathcal{S}_\psi\)</span> of <span class="arithmatex">\(|\psi\rangle\)</span> (or <span class="arithmatex">\(-P \in \mathcal{S}_\psi\)</span>). For such a <span class="arithmatex">\(P\)</span>, <span class="arithmatex">\(|\langle\psi|P|\psi\rangle|^2=1\)</span>. Otherwise, it is 0.</p>
<p><strong>4. Determine the stabilizer group of the ideal state</strong></p>
<p>The state <span class="arithmatex">\(|\psi\rangle = \frac{1}{2} (|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)\)</span> is a logical GHZ state in the [[4,2,2]] code. It is stabilized by the code&rsquo;s stabilizers <span class="arithmatex">\(S_1=XXXX\)</span> and <span class="arithmatex">\(S_2=ZZZZ\)</span>. It is also a logical Bell state, so it is an eigenstate of <span class="arithmatex">\(X_A X_B\)</span> and <span class="arithmatex">\(Z_A Z_B\)</span>.
<span class="arithmatex">\(X_A X_B = (XIXI)(XXII) = I_0X_1X_2I_3\)</span>.
<span class="arithmatex">\(Z_A Z_B = (ZZII)(ZIZI) = I_0Z_1Z_2I_3\)</span>.
One can verify that <span class="arithmatex">\(|\psi\rangle\)</span> is a +1 eigenstate of both <span class="arithmatex">\(IXXI\)</span> and <span class="arithmatex">\(IZZI\)</span>.
The stabilizer group <span class="arithmatex">\(\mathcal{S}_\psi\)</span> is generated by <span class="arithmatex">\(\langle XXXX, ZZZZ, IXXI, IZZI \rangle\)</span>.
A simpler set of generators can be found:
*   <span class="arithmatex">\(g_1 = (XXXX)(IXXI) = X_0 I_1 I_2 X_3 = X_0X_3\)</span>
*   <span class="arithmatex">\(g_2 = (ZZZZ)(IZZI) = Z_0 I_1 I_2 Z_3 = Z_0Z_3\)</span>
*   <span class="arithmatex">\(g_3 = I_0 X_1 X_2 I_3 = X_1X_2\)</span>
*   <span class="arithmatex">\(g_4 = I_0 Z_1 Z_2 I_3 = Z_1Z_2\)</span>
So <span class="arithmatex">\(\mathcal{S}_\psi = \langle X_0X_3, Z_0Z_3, X_1X_2, Z_1Z_2 \rangle\)</span>. This group consists of Pauli operators that are tensor products of a Pauli on {0,3} and a Pauli on {1,2}.
Let <span class="arithmatex">\(G_{03} = \langle X_0X_3, Z_0Z_3 \rangle = \{I, X_0X_3, Z_0Z_3, Y_0Y_3\}\)</span> (up to phases).
Let <span class="arithmatex">\(G_{12} = \langle X_1X_2, Z_1Z_2 \rangle = \{I, X_1X_2, Z_1Z_2, Y_1Y_2\}\)</span> (up to phases).
Then <span class="arithmatex">\(\mathcal{S}_\psi\)</span> consists of products of elements from <span class="arithmatex">\(G_{03}\)</span> and <span class="arithmatex">\(G_{12}\)</span>.</p>
<p><strong>5. Evaluate the sums</strong></p>
<ul>
<li><strong>Sum over <span class="arithmatex">\(P_1 \in \mathcal{P}_{21}^*\)</span>:</strong> <span class="arithmatex">\(P_1\)</span> acts on qubits {1,2}. We need to count how many non-identity Paulis on {1,2} are in <span class="arithmatex">\(\mathcal{S}_\psi\)</span>. These are the non-identity elements of <span class="arithmatex">\(G_{12}\)</span>: <span class="arithmatex">\(X_1X_2\)</span>, <span class="arithmatex">\(Z_1Z_2\)</span>, and <span class="arithmatex">\(Y_1Y_2\)</span>. There are 3 such operators.</li>
</ul>
<div class="arithmatex">\[
\sum_{P_1 \in \mathcal{P}_{21}^*} |\langle\psi|P_1|\psi\rangle|^2 = 1+1+1 = 3
\]</div>
<ul>
<li><strong>Sum over <span class="arithmatex">\(P_2 \in \mathcal{P}_{03}^*\)</span>:</strong> <span class="arithmatex">\(P_2\)</span> acts on qubits {0,3}. We need to count how many non-identity Paulis on {0,3} are in <span class="arithmatex">\(\mathcal{S}_\psi\)</span>. These are the non-identity elements of <span class="arithmatex">\(G_{03}\)</span>: <span class="arithmatex">\(X_0X_3\)</span>, <span class="arithmatex">\(Z_0Z_3\)</span>, and <span class="arithmatex">\(Y_0Y_3\)</span>. There are 3 such operators.</li>
</ul>
<div class="arithmatex">\[
\sum_{P_2 \in \mathcal{P}_{03}^*} |\langle\psi|P_2|\psi\rangle|^2 = 1+1+1 = 3
\]</div>
<ul>
<li><strong>Sum over <span class="arithmatex">\(P_1 \in \mathcal{P}_{21}^*\)</span> and <span class="arithmatex">\(P_2 \in \mathcal{P}_{03}^*\)</span>:</strong> The product <span class="arithmatex">\(P_2P_1\)</span> is in <span class="arithmatex">\(\mathcal{S}_\psi\)</span> if and only if <span class="arithmatex">\(P_1\)</span> is one of the 3 non-identity elements in <span class="arithmatex">\(G_{12}\)</span> and <span class="arithmatex">\(P_2\)</span> is one of the 3 non-identity elements in <span class="arithmatex">\(G_{03}\)</span>. This gives <span class="arithmatex">\(3 \times 3 = 9\)</span> pairs <span class="arithmatex">\((P_1, P_2)\)</span>.</li>
</ul>
<div class="arithmatex">\[
\sum_{P_1,P_2} |\langle\psi|P_2 P_1|\psi\rangle|^2 = 9
\]</div>
<p><strong>6. Combine the terms to find the final fidelity</strong></p>
<p>Substitute the values of the sums into the expression for <span class="arithmatex">\(F\)</span>:</p>
<div class="arithmatex">\[
F = (1-p)^2 + \frac{p(1-p)}{15}(3) + \frac{p(1-p)}{15}(3) + \frac{p^2}{15^2}(9)
\]</div>
<div class="arithmatex">\[
F = (1-p)^2 + \frac{6p(1-p)}{15} + \frac{9p^2}{225}
\]</div>
<div class="arithmatex">\[
F = (1-p)^2 + \frac{2p(1-p)}{5} + \frac{p^2}{25}
\]</div>
<p>Now, expand and simplify the polynomial in <span class="arithmatex">\(p\)</span>:</p>
<div class="arithmatex">\[
F = (1 - 2p + p^2) + \left(\frac{2}{5}p - \frac{2}{5}p^2\right) + \frac{1}{25}p^2
\]</div>
<div class="arithmatex">\[
F = 1 + \left(-2 + \frac{2}{5}\right)p + \left(1 - \frac{2}{5} + \frac{1}{25}\right)p^2
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8}{5}p + \left(\frac{25 - 10 + 1}{25}\right)p^2
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<p>This expression is a perfect square:</p>
<div class="arithmatex">\[
F = \left(1 - \frac{4}{5}p\right)^2
\]</div>
<p>Final Answer:
The physical state fidelity of the final 4-qubit state is <span class="arithmatex">\(F(p) = \left(1 - \frac{4}{5}p\right)^2\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{physical}}=(1-\frac{12}{15}p)^2
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Recap of My Strategy for Calculating Logical Fidelity</strong></p>
<p>Okay, so I&rsquo;m tasked with figuring out the logical state fidelity after some post-selection.  I&rsquo;ve already handled the physical fidelity in the first subproblem, so I&rsquo;ve got that part down.  Essentially, what I need to do is incorporate this post-selection step and then determine the fidelity of the final state with the <em>ideal</em> logical state.</p>
<p><strong>Step-by-Step Breakdown:</strong></p>
<ol>
<li>
<p><strong>Post-Selection Mechanics:</strong>  The post-selection is based on detecting specific errors.  My code here is a [[4,2,2]] code, which has stabilizers like XXXX and ZZZZ, meaning I have a subspace that is the codespace, C. The project onto the codespace is <span class="arithmatex">\(\Pi_{\mathcal{C}}\)</span>. After measuring stabilizers (+1), I project the final state onto the codespace.</p>
</li>
<li>
<p><strong>State After Post-Selection:</strong>  After post-selection, I get a new state,  <span class="arithmatex">\(\rho_{ps} = \frac{\Pi_{\mathcal{C}} \rho_{final} \Pi_{\mathcal{C}}}{\text{Tr}(\Pi_{\mathcal{C}} \rho_{final} \Pi_{\mathcal{C}})}\)</span>.  I want to calculate the logical fidelity, which is <span class="arithmatex">\(\langle\psi_{ideal}| \rho_{ps} |\psi_{ideal}\rangle\)</span>.</p>
</li>
<li>
<p><strong>Logical Fidelity is Simplified:</strong> Because the ideal state <em>already</em> lives in the codespace, the formula <span class="arithmatex">\(\langle\psi_{ideal}| \rho_{ps} |\psi_{ideal}\rangle = \frac{\langle\psi_{ideal}| \rho_{final} |\psi_{ideal}\rangle}{\text{Tr}(\Pi_{\mathcal{C}} \rho_{final})}\)</span> boils down to <span class="arithmatex">\(F_{logical} = \frac{F_{physical}}{P_{success}}\)</span> where <span class="arithmatex">\(P_{success} = \text{Tr}(\Pi_{\mathcal{C}} \rho_{final})\)</span>.  This also means, <span class="arithmatex">\(F_{logical} = F_{physical} / P_{success}\)</span>.</p>
</li>
<li>
<p><strong>Calculating Success Probability, P<span class="arithmatex">\(_{success}\)</span>:</strong> This is the most involved part. I need to figure out what the probability is that the system survives post-selection. To do this I needed to classify the effects that the errors and stabilizers play on each other.</p>
</li>
</ol>
<ul>
<li>To figure out <span class="arithmatex">\(P_{success}\)</span>, I break down the final density matrix <span class="arithmatex">\(\rho_{final}\)</span> into a sum of terms based on different Pauli errors.</li>
<li>I can also define detectable vs undetectable by the Pauli error and whether or not it commutes. Undetectable means no projection.</li>
<li>The math works out where errors that anticommute with stabilizers get projected out. This means that my total probability of success is a product of these two numbers (the sum of the terms that contribute to <span class="arithmatex">\(\rho_{final}\)</span> and <span class="arithmatex">\(\Pi_\mathcal{C}\)</span>)</li>
</ul>
<ol start="5">
<li><strong>Putting it all Together:</strong> I have <span class="arithmatex">\(F_{physical} = (1 - \frac{4}{5}p)^2\)</span> and I worked my way through to get <span class="arithmatex">\(P_{success} = 1 - \frac{8}{5}p + \frac{64}{75}p^2\)</span>.  Therefore <span class="arithmatex">\(F_{logical} = \frac{(1 - \frac{4}{5}p)^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2}\)</span> which is my final answer.</li>
</ol>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p><strong>1. Define Logical Fidelity with Post-Selection</strong></p>
<p>The logical state fidelity is the fidelity of the final state with the ideal logical state, conditioned on passing the error detection check. The error detection check consists of measuring the code stabilizers, <span class="arithmatex">\(S_1 = XXXX\)</span> and <span class="arithmatex">\(S_2 = ZZZZ\)</span>, and accepting the state only if both measurement outcomes are +1. This corresponds to projecting the final state onto the codespace <span class="arithmatex">\(\mathcal{C}\)</span>.</p>
<p>The projector onto the codespace is <span class="arithmatex">\(\Pi_{\mathcal{C}} = \frac{1}{4}(I+S_1)(I+S_2)\)</span>.
The final physical density matrix, derived in Subproblem 1, is <span class="arithmatex">\(\rho_{final}\)</span>.
After the stabilizer measurements, the unnormalized post-selected state is <span class="arithmatex">\(\rho'_{ps} = \Pi_{\mathcal{C}} \rho_{final} \Pi_{\mathcal{C}}\)</span>.
The probability of successfully passing the check is <span class="arithmatex">\(P_{success} = \text{Tr}(\rho'_{ps}) = \text{Tr}(\Pi_{\mathcal{C}} \rho_{final})\)</span>.
The normalized post-selected state is <span class="arithmatex">\(\rho_{ps} = \rho'_{ps} / P_{success}\)</span>.</p>
<p>The ideal state <span class="arithmatex">\(|\psi_{ideal}\rangle = \frac{1}{2} (|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)\)</span> is a codeword, so it lies within the codespace, meaning <span class="arithmatex">\(\Pi_{\mathcal{C}}|\psi_{ideal}\rangle = |\psi_{ideal}\rangle\)</span>.</p>
<p>The logical fidelity is the fidelity of the post-selected state with the ideal state:</p>
<div class="arithmatex">\[
F_{logical} = \langle\psi_{ideal}| \rho_{ps} |\psi_{ideal}\rangle = \frac{\langle\psi_{ideal}| \Pi_{\mathcal{C}} \rho_{final} \Pi_{\mathcal{C}} |\psi_{ideal}\rangle}{P_{success}}
\]</div>
<p>Using <span class="arithmatex">\(\Pi_{\mathcal{C}}|\psi_{ideal}\rangle = |\psi_{ideal}\rangle\)</span>, the numerator simplifies to:</p>
<div class="arithmatex">\[
\langle\psi_{ideal}| \rho_{final} |\psi_{ideal}\rangle = F_{physical}
\]</div>
<p>where <span class="arithmatex">\(F_{physical}\)</span> is the physical fidelity calculated in Subproblem 1.
Thus, we have:</p>
<div class="arithmatex">\[
F_{logical} = \frac{F_{physical}}{P_{success}}
\]</div>
<p>From Subproblem 1, we have <span class="arithmatex">\(F_{physical} = \left(1 - \frac{4}{5}p\right)^2\)</span>. We now need to compute <span class="arithmatex">\(P_{success}\)</span>.</p>
<p><strong>2. Calculate the Success Probability (<span class="arithmatex">\(P_{success}\)</span>)</strong></p>
<p>The success probability is <span class="arithmatex">\(P_{success} = \text{Tr}(\Pi_{\mathcal{C}} \rho_{final})\)</span>. The final density matrix is:</p>
<div class="arithmatex">\[
\rho_{final} = (1-p)^2 |\psi\rangle\langle\psi| + \frac{p(1-p)}{15}\sum_{P_1} P_1 |\psi\rangle\langle\psi| P_1 + \frac{p(1-p)}{15}\sum_{P_2} P_2 |\psi\rangle\langle\psi| P_2 + \frac{p^2}{225}\sum_{P_1,P_2} P_2 P_1 |\psi\rangle\langle\psi| P_1 P_2
\]</div>
<p>where <span class="arithmatex">\(|\psi\rangle = |\psi_{ideal}\rangle\)</span>, <span class="arithmatex">\(P_1 \in \mathcal{P}_{21}^*\)</span> (non-identity Paulis on qubits {1,2}), and <span class="arithmatex">\(P_2 \in \mathcal{P}_{03}^*\)</span> (non-identity Paulis on qubits {0,3}).</p>
<p>The trace of a generic term <span class="arithmatex">\(P|\psi\rangle\langle\psi|P\)</span> is <span class="arithmatex">\(\text{Tr}(\Pi_{\mathcal{C}} P|\psi\rangle\langle\psi|P) = \langle\psi|P\Pi_{\mathcal{C}}P|\psi\rangle\)</span>.
An error operator <span class="arithmatex">\(P\)</span> is <em>detectable</em> if it anticommutes with at least one code stabilizer (<span class="arithmatex">\(S_1\)</span> or <span class="arithmatex">\(S_2\)</span>). If an error <span class="arithmatex">\(P\)</span> is detectable, the state <span class="arithmatex">\(P|\psi\rangle\)</span> is in an error space orthogonal to the codespace, so <span class="arithmatex">\(\Pi_{\mathcal{C}} P|\psi\rangle = 0\)</span>. Consequently, for a detectable error <span class="arithmatex">\(P\)</span>, <span class="arithmatex">\(\text{Tr}(\Pi_{\mathcal{C}} P|\psi\rangle\langle\psi|P) = 0\)</span>.
An error <span class="arithmatex">\(P\)</span> is <em>undetectable</em> if it commutes with all code stabilizers. For such a <span class="arithmatex">\(P\)</span>, the state <span class="arithmatex">\(P|\psi\rangle\)</span> remains in the codespace. Thus, <span class="arithmatex">\(\text{Tr}(\Pi_{\mathcal{C}} P|\psi\rangle\langle\psi|P) = \text{Tr}(P|\psi\rangle\langle\psi|P) = 1\)</span>.</p>
<p>So, to calculate <span class="arithmatex">\(P_{success}\)</span>, we need to count the number of undetectable errors for each term in <span class="arithmatex">\(\rho_{final}\)</span>.</p>
<ul>
<li>
<p><strong>Classification of single CNOT errors:</strong> A two-qubit Pauli <span class="arithmatex">\(P_{ij}\)</span> is undetectable if it commutes with both <span class="arithmatex">\(S_1=XXXX\)</span> and <span class="arithmatex">\(S_2=ZZZZ\)</span>. This occurs if <span class="arithmatex">\(P_{ij}\)</span> is one of <span class="arithmatex">\(\{X_iX_j, Y_iY_j, Z_iZ_j\}\)</span>. There are 3 undetectable errors out of 15 non-identity Paulis. The remaining 12 are detectable.</p>
</li>
<li>
<p><strong>Classification of two CNOT errors:</strong> An error <span class="arithmatex">\(P = P_1P_2\)</span> is undetectable if it commutes with both <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>. Since <span class="arithmatex">\(P_1\)</span> and <span class="arithmatex">\(P_2\)</span> act on disjoint sets of qubits, <span class="arithmatex">\(P\)</span> commutes with a stabilizer <span class="arithmatex">\(S\)</span> if either both <span class="arithmatex">\(P_1, P_2\)</span> commute with <span class="arithmatex">\(S\)</span> or both anticommute with <span class="arithmatex">\(S\)</span>.
    Let&rsquo;s classify the 15 errors on a given pair of qubits based on their commutation with <span class="arithmatex">\((S_1, S_2)\)</span>:</p>
<ul>
<li>Commute with both (C,C): 3 operators (<span class="arithmatex">\(\{XX, YY, ZZ\}\)</span>)</li>
<li>Commute with <span class="arithmatex">\(S_1\)</span>, anticommute with <span class="arithmatex">\(S_2\)</span> (C,A): 4 operators (<span class="arithmatex">\(\{IX, XI, YZ, ZY\}\)</span>)</li>
<li>Anticommute with <span class="arithmatex">\(S_1\)</span>, commute with <span class="arithmatex">\(S_2\)</span> (A,C): 4 operators (<span class="arithmatex">\(\{IZ, ZI, XY, YX\}\)</span>)</li>
<li>Anticommute with both (A,A): 4 operators (<span class="arithmatex">\(\{IY, YI, XZ, ZX\}\)</span>)
The total number of pairs <span class="arithmatex">\((P_1, P_2)\)</span> for which <span class="arithmatex">\(P_1P_2\)</span> is undetectable is the sum of products of counts for matching types:</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
N_{undetect} = N_{CC}^2 + N_{CA}^2 + N_{AC}^2 + N_{AA}^2 = 3^2 + 4^2 + 4^2 + 4^2 = 9 + 16 + 16 + 16 = 57
\]</div>
<ul>
<li><strong>Calculating <span class="arithmatex">\(P_{success}\)</span>:</strong> We sum the probabilities of all events that result in an overall undetectable error.<ol>
<li>No error (Identity operator, is undetectable): <span class="arithmatex">\((1-p)^2\)</span></li>
<li>One error on first CNOT, none on second: <span class="arithmatex">\(p(1-p) \times \frac{3}{15}\)</span> (3 undetectable errors)</li>
<li>One error on second CNOT, none on first: <span class="arithmatex">\((1-p)p \times \frac{3}{15}\)</span> (3 undetectable errors)</li>
<li>Errors on both CNOTs: <span class="arithmatex">\(p^2 \times \frac{57}{225}\)</span> (57 undetectable pairs)</li>
</ol>
</li>
</ul>
<div class="arithmatex">\[
P_{success}(p) = (1-p)^2 + \frac{3p(1-p)}{15} + \frac{3p(1-p)}{15} + \frac{57p^2}{225}
\]</div>
<div class="arithmatex">\[
P_{success}(p) = (1-p)^2 + \frac{6p(1-p)}{15} + \frac{57p^2}{225}
\]</div>
<div class="arithmatex">\[
P_{success}(p) = (1-2p+p^2) + \frac{2}{5}(p-p^2) + \frac{19}{75}p^2
\]</div>
<div class="arithmatex">\[
P_{success}(p) = 1 + (-2+\frac{2}{5})p + (1-\frac{2}{5}+\frac{19}{75})p^2
\]</div>
<div class="arithmatex">\[
P_{success}(p) = 1 - \frac{8}{5}p + \left(\frac{75-30+19}{75}\right)p^2 = 1 - \frac{8}{5}p + \frac{64}{75}p^2
\]</div>
<p><strong>3. Final Calculation of Logical Fidelity</strong></p>
<p>Now we combine our results for <span class="arithmatex">\(F_{physical}\)</span> and <span class="arithmatex">\(P_{success}\)</span>.</p>
<div class="arithmatex">\[
F_{physical} = \left(1 - \frac{4}{5}p\right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<div class="arithmatex">\[
F_{logical}(p) = \frac{F_{physical}(p)}{P_{success}(p)} = \frac{1 - \frac{8}{5}p + \frac{16}{25}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2}
\]</div>
<p>The logical infidelity <span class="arithmatex">\(1-F_{logical}\)</span> to leading order in <span class="arithmatex">\(p\)</span> is:</p>
<div class="arithmatex">\[
1 - F_{logical} = 1 - \frac{1 - \frac{8}{5}p + \frac{16}{25}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2} = \frac{(1 - \frac{8}{5}p + \frac{64}{75}p^2) - (1 - \frac{8}{5}p + \frac{16}{25}p^2)}{1 - \frac{8}{5}p + \frac{64}{75}p^2}
\]</div>
<div class="arithmatex">\[
1 - F_{logical} = \frac{(\frac{64}{75} - \frac{16}{25})p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2} = \frac{(\frac{64-48}{75})p^2}{1 - O(p)} = \frac{16}{75}p^2 + O(p^3)
\]</div>
<p>This confirms that logical errors are a second-order effect, as single undetectable errors from one CNOT happen to be stabilizers of the final state and thus cause no logical error.</p>
<p>Final Answer:
The logical state fidelity is given by the function:</p>
<div class="arithmatex">\[
F_{logical}(p) = \frac{1 - \frac{8}{5}p + \frac{16}{25}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>The correct answer is:
$
F_{\rm{logical}}=1 - \frac{\frac{16}{75}p^2}{1-\frac{8}{5}p + \frac{64}{75}p^2}
$</p>
<p>Now let&rsquo;s solve the next Checkpoint.</p>
<h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Analysis of a Quantum Circuit for State Preparation</strong></p>
<p>I&rsquo;m tasked with analyzing a quantum circuit designed to prepare the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state using a [[4,2,2]] code, which involves some stabilizer checks and post-selection on an ancilla qubit.  I will first understand the ideal circuit, then incorporate the error model and post-selection to calculate the logical state fidelity.</p>
<p><strong>The Ideal Scenario:</strong></p>
<ol>
<li>
<p><strong>Ideal Circuit:</strong></p>
<ul>
<li>Initialize with <span class="arithmatex">\(|00000\rangle\)</span>, including an ancilla qubit.</li>
<li>Apply a Hadamard gate to qubit 1: <span class="arithmatex">\(H_1|00000\rangle = |00000\rangle + |10000\rangle\)</span>, which will lead to a superposition.</li>
<li>Apply CNOT gates.<ul>
<li>CNOT(1,2), CNOT(1,0), CNOT(2,3), CNOT(3,4), CNOT(0,4)</li>
</ul>
</li>
<li>This ideal process results in a state prior to measurement of the ancilla in the Z basis, and prior to our post-selection step on stabilizer checks.</li>
</ul>
</li>
<li>
<p><strong>State Verification:</strong> Through the CNOT process, I derive that my ideal final data-qubit state is indeed a logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> eigenstate.  My ideal state is simply the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> combined with the ancilla in state <span class="arithmatex">\(|0\rangle\)</span>, a good sign.</p>
</li>
</ol>
<p><strong>Error Model and Fidelity Calculation:</strong></p>
<ol>
<li>
<p><strong>Fault Tolerance Analysis:</strong> The circuit includes 5 CNOT gates, each of which has a two-qubit depolarizing channel error probability of <em>p</em>. My ultimate goal is to determine fidelity of the state, given that I post-select on ancilla value as well as stabilizer values. I need to calculate the probability of success, <em>P<sub>success</sub></em>, given by <span class="arithmatex">\(\text{Tr}((\Pi_{\mathcal{C}} \otimes P_0) \rho_{final})\)</span>, along with <em>F<sub>physical</sub></em>, the overlap of the noisy final state with the ideal state, and the ratio of these: <em>F<sub>logical</sub> = F<sub>physical</sub>/P<sub>success</sub></em>.</p>
</li>
<li>
<p><strong>Identifying Logical Errors:</strong> I am using the standard framework, as this should be fault tolerant: The circuit is designed such that there can be no single error that will lead to a logical error and pass post-selection. This means <em>all</em> single physical errors on the CNOTs are detected. Errors that lead to logical faults must therefore come from <em>pairs</em> of errors. In the ideal case, the system can have at most an <span class="arithmatex">\(O(p^2)\)</span> fidelity. In other words, with post-selection, I need to count pairs of errors.</p>
</li>
<li>
<p><strong>Error Propagation:</strong> I will break down each gate and identify all Pauli errors. If the circuit is fault-tolerant, any single error will either fail the ancilla check or fail the stabilizer check.</p>
</li>
<li>
<p><strong>Logical Errors.</strong> To estimate the linear term, I will calculate which Pauli-error(s) will go undetected and cause logical errors.</p>
</li>
</ol>
<ul>
<li>Gate CNOT(1,2): Errors X1X2, Y1Y2. Both are logical errors. (2 errors)</li>
<li>Gate CNOT(1,0): Errors X0X1, Y0Y1. (2 logical errors).</li>
<li>Gate CNOT(2,3): 0 logical errors.</li>
<li>Gate CNOT(3,4): I will include two logical errors <span class="arithmatex">\(X_3X_4\)</span>, <span class="arithmatex">\(Y_3Y_4\)</span>. <span class="arithmatex">\(I_3Z_4\)</span> causes no logical error. (2 logical errors).</li>
<li>Gate CNOT(0,4): <span class="arithmatex">\(X_0 \otimes I_4\)</span>. <span class="arithmatex">\(Y_0 \otimes I_4\)</span>. (0 errors).</li>
</ul>
<ol start="5">
<li><strong>Calculate Logical Fidelity.</strong></li>
</ol>
<p>From those results, the logical infidelity is <span class="arithmatex">\(1-F_L = \frac{p}{15}N\)</span>, meaning linear in error-probability <em>p</em>, where <em>N = 6</em>. Thus the final solution to the problem, given the error model, is that the logical fidelity equals <span class="arithmatex">\(1 - \frac{2}{5}p\)</span>.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p><strong>1. Ideal State Preparation</strong></p>
<p>The circuit is <span class="arithmatex">\(U = (M_4) (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)\)</span> applied to the initial state <span class="arithmatex">\(|\psi_0\rangle = |0000\rangle \otimes |0\rangle_4\)</span>.</p>
<ol>
<li><span class="arithmatex">\(H_1|00000\rangle = |0\rangle_0 (\frac{|0\rangle+|1\rangle}{\sqrt{2}})_1 |000\rangle_{234}\)</span></li>
<li><span class="arithmatex">\(CNOT_{12}\)</span> creates entanglement: <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|000\rangle+|011\rangle)_{012}|00\rangle_{34}\)</span></li>
<li><span class="arithmatex">\(CNOT_{10}\)</span> creates more entanglement: <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|000\rangle+|111\rangle)_{012}|00\rangle_{34}\)</span></li>
<li><span class="arithmatex">\(CNOT_{23}\)</span> creates a 4-qubit GHZ state: <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle)_{0123}|0\rangle_4\)</span>. Let&rsquo;s call the data qubit state <span class="arithmatex">\(|\psi_L\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle)\)</span>. This is the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state.</li>
<li><span class="arithmatex">\(CNOT_{34}\)</span> acts on <span class="arithmatex">\(|\psi_L\rangle|0\rangle_4\)</span>: <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|00000\rangle+|11111\rangle)\)</span>.</li>
<li><span class="arithmatex">\(CNOT_{04}\)</span> acts: <span class="arithmatex">\(\frac{1}{\sqrt{2}}(CNOT_{04}|00000\rangle + CNOT_{04}|11111\rangle) = \frac{1}{\sqrt{2}}(|00000\rangle+|11110\rangle)\)</span>.</li>
<li>The state just before measurement is <span class="arithmatex">\(|\Psi_{ideal}\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) \otimes |0\rangle_4 = |\psi_L\rangle \otimes |0\rangle_4\)</span>.</li>
<li>The measurement <span class="arithmatex">\(M_4\)</span> on the ancilla qubit yields <span class="arithmatex">\(|0\rangle\)</span> with probability 1. The state of the data qubits remains <span class="arithmatex">\(|\psi_L\rangle\)</span>.</li>
</ol>
<p>The ideal final state of the data qubits is <span class="arithmatex">\(|\psi_L\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle)\)</span>, which is the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state. Its stabilizer group is <span class="arithmatex">\(\mathcal{S}_L = \langle XXXX, Z_0Z_1, Z_1Z_2, Z_2Z_3 \rangle\)</span>.</p>
<p><strong>2. Logical Fidelity and Error Analysis</strong></p>
<p>The logical fidelity under post-selection is <span class="arithmatex">\(F_L = F_{phys} / P_{success}\)</span>. A single error event occurs with probability <span class="arithmatex">\(p\)</span>. For small <span class="arithmatex">\(p\)</span>, the dominant contribution to infidelity comes from single error events. The logical infidelity is <span class="arithmatex">\(1 - F_L \approx \frac{p}{15}N_{logical\_err}\)</span>, where <span class="arithmatex">\(N_{logical\_err}\)</span> is the number of single two-qubit Pauli errors (out of <span class="arithmatex">\(15 \times 5 = 75\)</span> possibilities) that cause a logical error.</p>
<p>A single error event causes a logical error if the propagated error operator <span class="arithmatex">\(\tilde{P}\)</span> satisfies all of the following conditions:</p>
<ol>
<li><strong>Undetected by Ancilla:</strong> The error does not cause the ancilla to measure <span class="arithmatex">\(|1\rangle\)</span>. The measurement part of the circuit (<span class="arithmatex">\(CNOT_{04}CNOT_{34}\)</span> with ancilla input <span class="arithmatex">\(|0\rangle\)</span>) is designed to measure the operator <span class="arithmatex">\(Z_0Z_3\)</span> on the data qubits. An error occurring before this block is undetected by the ancilla if it commutes with <span class="arithmatex">\(Z_0Z_3\)</span>.</li>
<li><strong>Undetected by Code Stabilizers:</strong> The error on the data qubits must commute with the code stabilizers <span class="arithmatex">\(S_1=XXXX\)</span> and <span class="arithmatex">\(S_2=ZZZZ\)</span>.</li>
<li><strong>Causes a Logical State Change:</strong> The error must not be a stabilizer of the ideal logical state <span class="arithmatex">\(|\psi_L\rangle\)</span>.</li>
</ol>
<p>We count the number of such logical errors (<span class="arithmatex">\(N_k\)</span>) for each of the 5 CNOT gates.</p>
<ul>
<li>
<p><strong>Gate 1: <span class="arithmatex">\(CNOT_{12}\)</span></strong>
    An error <span class="arithmatex">\(P_{12}\)</span> is propagated by <span class="arithmatex">\(U_{prop} = C_{23}C_{10}\)</span>.
    An error undetectable by code stabilizers must be in the set <span class="arithmatex">\(\{X_1X_2, Y_1Y_2, Z_1Z_2\}\)</span>.</p>
<ul>
<li><span class="arithmatex">\(P=X_1X_2 \implies \tilde{P} = C_{23}C_{10}X_1X_2C_{10}^\dagger C_{23}^\dagger = C_{23}X_0X_1X_2C_{23}^\dagger = X_0X_1X_2X_3\)</span>. This is the stabilizer <span class="arithmatex">\(S_1=XXXX\)</span> (up to a phase), which is in <span class="arithmatex">\(\mathcal{S}_L\)</span>. Not a logical error.</li>
<li><span class="arithmatex">\(P=Y_1Y_2 \implies \tilde{P} = X_0Y_1Z_2Y_3\)</span>. This anticommutes with <span class="arithmatex">\(S_1=XXXX\)</span> and is therefore detected by the stabilizer measurement.</li>
<li><span class="arithmatex">\(P=Z_1Z_2\)</span>. This propagates to <span class="arithmatex">\(\tilde{P}=Z_1Z_2\)</span>, which is a stabilizer of the state, <span class="arithmatex">\(Z_1Z_2 \in \mathcal{S}_L\)</span>. Not a logical error.
Thus, <span class="arithmatex">\(N_1=0\)</span>.</li>
</ul>
</li>
<li>
<p><strong>Gate 2: <span class="arithmatex">\(CNOT_{10}\)</span></strong>
    An error <span class="arithmatex">\(P_{10}\)</span> is propagated by <span class="arithmatex">\(U_{prop} = C_{23}\)</span>.
    Undetectable-by-stabilizer errors are <span class="arithmatex">\(\{X_0X_1, Y_0Y_1, Z_0Z_1\}\)</span>.</p>
<ul>
<li><span class="arithmatex">\(P=X_0X_1 \implies \tilde{P}=X_0X_1\)</span>. Commutes with <span class="arithmatex">\(Z_0Z_3\)</span> (ancilla check pass). Not in <span class="arithmatex">\(\mathcal{S}_L\)</span>. This is a logical error.</li>
<li><span class="arithmatex">\(P=Y_0Y_1 \implies \tilde{P}=Y_0Y_1\)</span>. Commutes with <span class="arithmatex">\(Z_0Z_3\)</span>. Not in <span class="arithmatex">\(\mathcal{S}_L\)</span>. This is a logical error.</li>
<li><span class="arithmatex">\(P=Z_0Z_1 \implies \tilde{P}=Z_0Z_1\)</span>. This is in <span class="arithmatex">\(\mathcal{S}_L\)</span>. Not a logical error.
Thus, <span class="arithmatex">\(N_2=2\)</span>.</li>
</ul>
</li>
<li>
<p><strong>Gate 3: <span class="arithmatex">\(CNOT_{23}\)</span></strong>
    No propagation before ancilla measurement, <span class="arithmatex">\(\tilde{P}=P_{23}\)</span>.
    Undetectable-by-stabilizer errors are <span class="arithmatex">\(\{X_2X_3, Y_2Y_3, Z_2Z_3\}\)</span>.</p>
<ul>
<li><span class="arithmatex">\(P=X_2X_3\)</span>. Antico with <span class="arithmatex">\(Z_0Z_3\)</span>. Detected by ancilla.</li>
<li><span class="arithmatex">\(P=Y_2Y_3\)</span>. Antico with <span class="arithmatex">\(Z_0Z_3\)</span>. Detected by ancilla.</li>
<li><span class="arithmatex">\(P=Z_2Z_3\)</span>. Commutes with <span class="arithmatex">\(Z_0Z_3\)</span>. This is in <span class="arithmatex">\(\mathcal{S}_L\)</span>. Not a logical error.
Thus, <span class="arithmatex">\(N_3=0\)</span>.</li>
</ul>
</li>
<li>
<p><strong>Gate 4: <span class="arithmatex">\(CNOT_{34}\)</span></strong>
    An error <span class="arithmatex">\(P_{34}\)</span> is propagated by <span class="arithmatex">\(C_{04}\)</span>. The final error operator on the 5-qubit space is <span class="arithmatex">\(\tilde{P} = C_{04} P_{34} C_{04}^\dagger\)</span>. The ancilla measurement must be <span class="arithmatex">\(|0\rangle\)</span> and the data part of the error must pass stabilizer checks but not be in <span class="arithmatex">\(\mathcal{S}_L\)</span>.</p>
<ul>
<li><span class="arithmatex">\(P=X_3X_4 \implies \tilde{P}=X_3X_0X_4\)</span>. Data part is <span class="arithmatex">\(X_0X_3\)</span>. Undetectable by stabilizers. Not in <span class="arithmatex">\(\mathcal{S}_L\)</span>. Logical error.</li>
<li><span class="arithmatex">\(P=X_3Y_4 \implies \tilde{P}=X_3Y_0Z_4\)</span>. Data part is <span class="arithmatex">\(X_3Y_0\)</span>. Undetectable by stabilizers. Not in <span class="arithmatex">\(\mathcal{S}_L\)</span>. Logical error.</li>
<li><span class="arithmatex">\(P=Y_3X_4 \implies \tilde{P}=Y_3X_0Z_4\)</span>. Data part is <span class="arithmatex">\(Y_3X_0\)</span>. Undetectable by stabilizers. Not in <span class="arithmatex">\(\mathcal{S}_L\)</span>. Logical error.</li>
<li><span class="arithmatex">\(P=Y_3Y_4 \implies \tilde{P}=Y_3Y_0\)</span>. Data part is <span class="arithmatex">\(Y_0Y_3\)</span>. Undetectable by stabilizers. Not in <span class="arithmatex">\(\mathcal{S}_L\)</span>. Logical error.
(Other errors are either detected or are state stabilizers).
Thus, <span class="arithmatex">\(N_4=4\)</span>.</li>
</ul>
</li>
<li>
<p><strong>Gate 5: <span class="arithmatex">\(CNOT_{04}\)</span></strong>
    The error <span class="arithmatex">\(P_{04}\)</span> occurs at the end. An error <span class="arithmatex">\(P_0 \otimes P_4\)</span> is undetectable if <span class="arithmatex">\(P_4 \in \{I_4, Z_4\}\)</span> and the data part <span class="arithmatex">\(P_0\)</span> is undetectable by stabilizers. However, no single-qubit Pauli error <span class="arithmatex">\(P_0\)</span> is undetectable by both <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>. Therefore, no error of the form <span class="arithmatex">\(P_0 \otimes P_4\)</span> can be a logical error. We need to check two-qubit errors on {0,4}. A detailed check shows none of these survive all checks to become logical errors. For example, for <span class="arithmatex">\(P=X_0X_4\)</span>, the ancilla flips, detecting the error. For <span class="arithmatex">\(P=X_0Z_4\)</span>, the data part is <span class="arithmatex">\(X_0\)</span>, which is detected by stabilizers.
    Thus, <span class="arithmatex">\(N_5=0\)</span>.</p>
</li>
</ul>
<p><strong>3. Final Fidelity Calculation</strong></p>
<p>The total count of single-Pauli error events that cause a logical error is:</p>
<div class="arithmatex">\[
N_{logical\_err} = N_1 + N_2 + N_3 + N_4 + N_5 = 0 + 2 + 0 + 4 + 0 = 6
\]</div>
<p>The logical infidelity to first order in <span class="arithmatex">\(p\)</span> is the probability of one of these events occurring:</p>
<div class="arithmatex">\[
1 - F_L(p) \approx \frac{N_{logical\_err}}{15} p = \frac{6}{15}p = \frac{2}{5}p
\]</div>
<p>Therefore, the logical fidelity is:</p>
<div class="arithmatex">\[
F_L(p) \approx 1 - \frac{2}{5}p
\]</div>
<p>Final Answer:
The logical state fidelity of the final 2-qubit logical state is <span class="arithmatex">\(F_L(p) = 1 - \frac{2}{5}p + O(p^2)\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.743426
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>