<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>Let me work through this problem step by step.</p>
<p>First, let me understand the [[4,2,2]] code:
- 4 physical qubits labeled 0, 1, 2, 3
- 2 logical qubits labeled A, B
- Stabilizers: XXXX and ZZZZ
- Logical operators:
  - <span class="arithmatex">\(X_A = XIXI\)</span>
  - <span class="arithmatex">\(X_B = XXII\)</span>
  - <span class="arithmatex">\(Z_A = ZZII\)</span>
  - <span class="arithmatex">\(Z_B = ZIZI\)</span></p>
<p>The goal is to prepare the logical GHZ state <span class="arithmatex">\((|00\rangle_{AB} + |11\rangle_{AB})/\sqrt{2}\)</span> using the circuit:
<span class="arithmatex">\((CNOT_{03})(H_0)(CNOT_{21})(H_2)\)</span></p>
<p>Since this is written in matrix multiplication order, the circuit runs from right to left:</p>
<ol>
<li><span class="arithmatex">\(H_2\)</span> (Hadamard on qubit 2)</li>
<li><span class="arithmatex">\(CNOT_{21}\)</span> (control on qubit 2, target on qubit 1)</li>
<li><span class="arithmatex">\(H_0\)</span> (Hadamard on qubit 0)</li>
<li><span class="arithmatex">\(CNOT_{03}\)</span> (control on qubit 0, target on qubit 3)</li>
</ol>
<p>Each CNOT gate has a two-qubit depolarizing error channel after it with error probability <span class="arithmatex">\(p\)</span>.</p>
<p>Let me first work out what the ideal circuit does (without errors).</p>
<p>Starting state: <span class="arithmatex">\(|0000\rangle\)</span></p>
<p>After <span class="arithmatex">\(H_2\)</span>:
<span class="arithmatex">\(|000\rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)\)</span></p>
<p>After <span class="arithmatex">\(CNOT_{21}\)</span> (control on 2, target on 1):</p>
<p><span class="arithmatex">\(\frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\)</span></p>
<p>After <span class="arithmatex">\(H_0\)</span>, the state becomes more complex. I&rsquo;ll apply the Hadamard gate to the first qubit, creating a superposition that doubles the number of basis states. This transforms the previous state into a linear combination of four basis states, with equal amplitudes of <span class="arithmatex">\(\frac{1}{2}\)</span>. </p>
<p>The resulting state spans four computational basis states, showing how the Hadamard gate introduces quantum superposition across the first qubit.</p>
<p>After <span class="arithmatex">\(CNOT_{03}\)</span>, the entanglement between qubits becomes more intricate. The control-not operation creates correlations between specific qubits, further manipulating the quantum state&rsquo;s structure.</p>
<p>The ideal final state represents a carefully constructed quantum configuration, suggesting a specific quantum error correction strategy involving entangled qubits across different computational basis states.</p>
<p>I&rsquo;m exploring the logical computational basis states, focusing on how stabilizer operators XXXX and ZZZZ interact with the quantum system to define the code space&rsquo;s fundamental properties.</p>
<p>The state requires precise alignment of qubits, where specific two-qubit combinations must maintain consistent quantum relationships under stabilizer transformations.</p>
<p>For the ZZZZ stabilizer, the constraint demands an even parity across all four qubits. This means the total number of 1s must be divisible by 2, creating a specific subset of computational basis states that preserve the quantum code&rsquo;s structural integrity.</p>
<p>The XXXX stabilizer introduces an additional layer of complexity, flipping qubit states in a systematic manner that further constrains the allowable quantum configurations.</p>
<p>The resulting code space contains four distinct orthonormal states, effectively encoding two logical qubits within a four-dimensional Hilbert space. These states exhibit precise symmetry properties under global bit flips.</p>
<p>When applying the <span class="arithmatex">\(Z_A\)</span> and <span class="arithmatex">\(Z_B\)</span> logical operators, I observe interesting eigenvalue behaviors. Some states remain invariant with +1 eigenvalues, while others acquire -1 eigenvalues, revealing intricate relationships between the computational basis representations.</p>
<p>My next step involves mapping these code states to specific logical qubit computational basis states, which will illuminate the encoding mechanism&rsquo;s underlying quantum logic.</p>
<p>The first code state <span class="arithmatex">\((|0000\rangle + |1111\rangle)/\sqrt{2}\)</span> appears to correspond directly to the <span class="arithmatex">\(|00\rangle_{AB}\)</span> logical qubit state, demonstrating a symmetric superposition across the entire four-qubit register.</p>
<p>The logical GHZ state emerges by combining specific basis states with equal amplitudes, creating an entangled quantum configuration that spans the computational basis. By normalizing the superposition, we construct a quantum state representing maximal entanglement between two logical qubits.</p>
<p>The mathematical representation reveals intricate quantum correlations, where the state&rsquo;s symmetry ensures balanced probability distributions across different computational paths.</p>
<p>Investigating potential errors, we examine two-qubit depolarizing channels that introduce probabilistic noise. These channels model quantum decoherence by randomly perturbing the quantum state through a weighted sum of Pauli operators, capturing the probabilistic nature of quantum system degradation.</p>
<p>The error model requires precise tracking of which qubits experience noise, suggesting a nuanced approach to understanding quantum error propagation across the circuit&rsquo;s computational landscape.</p>
<p>I&rsquo;ll trace the quantum state evolution, carefully noting how initial pure states transform under Hadamard and CNOT operations, while tracking potential error mechanisms that could disrupt the desired quantum information processing.</p>
<p>The state begins as <span class="arithmatex">\(|0000\rangle\)</span> and progressively evolves through quantum gates and potential error channels. After applying Hadamard on qubit 2 and a controlled-NOT operation between qubits 2 and 1, the system enters a superposition state. </p>
<p>The critical step involves introducing noise through an error channel, which probabilistically perturbs the quantum state. This error channel acts on qubits 2 and 1, mixing the original state with potential error configurations according to a defined probability distribution.</p>
<p>Subsequent Hadamard and CNOT operations continue transforming the quantum state, with each gate potentially interacting with the probabilistic errors introduced earlier.</p>
<p>The goal is to compute the physical state fidelity, which requires carefully tracking how quantum gates and noise channels modify the system&rsquo;s density matrix at each stage of the quantum computation.</p>
<p>I&rsquo;ll analyze the circuit by breaking down the unitary transformations and depolarizing channels. Two CNOT gates are key, with Hadamard gates remaining error-free. The actual circuit involves complex error propagation through controlled operations and noise channels.</p>
<p>The unitary transformation involves sequential CNOT and Hadamard gates, with depolarizing noise introduced between specific quantum operations. This means tracking how errors accumulate and transform the initial quantum state through the computational process.</p>
<p>By examining the state evolution step-by-step, I can trace how quantum information changes under noisy conditions, revealing how depolarizing channels impact the quantum computation&rsquo;s fidelity.</p>
<p>The process involves applying a Hadamard gate, performing a controlled-NOT operation, and then introducing noise through a two-qubit depolarizing channel. This channel probabilistically transforms the quantum state, mixing it with random Pauli operations to simulate decoherence.</p>
<p>I&rsquo;ll analyze how the quantum state transforms, tracking its probabilistic evolution through different quantum gates and noise processes.</p>
<p>Specifically, I&rsquo;m examining the effects of Pauli operators <span class="arithmatex">\(IX\)</span>, <span class="arithmatex">\(IY\)</span>, and <span class="arithmatex">\(IZ\)</span> on the density matrix, which reveal how quantum information gets scrambled and partially preserved under noisy conditions. Each Pauli operation produces a distinct probabilistic transformation of the quantum state&rsquo;s basis components.</p>
<p>The calculations show subtle changes in state probabilities, with some basis states maintaining their relative amplitudes while others experience phase or magnitude shifts due to the channel&rsquo;s stochastic nature.</p>
<p>I&rsquo;ll focus on tracing the ideal state&rsquo;s evolution, using the fidelity metric to quantify how closely the final state matches the intended quantum computation. The key insight is tracking how quantum information gets redistributed through the error channel.</p>
<p>The ideal final state represents a superposition of four basis states, suggesting a complex quantum state that requires careful analysis to understand its transformation under noise.</p>
<p>I&rsquo;m considering the probabilistic nature of quantum errors, specifically how depolarizing channels introduce uncertainty into the quantum circuit&rsquo;s evolution. The <span class="arithmatex">\((1-p)^2\)</span> probability represents the clean path where no errors disrupt the quantum computation.</p>
<p>The two-qubit depolarizing channel introduces intriguing complexity, potentially creating interesting state mixtures that deviate from the original quantum information.</p>
<p>I&rsquo;ll need to carefully analyze how these error probabilities transform the quantum state, tracking the potential divergence from the ideal quantum trajectory.</p>
<p>The two-qubit depolarizing channel introduces errors across 15 non-identity Pauli operators, with each error occurring at probability <span class="arithmatex">\(p/15\)</span>. This means the quantum state can deviate through multiple potential error pathways during circuit evolution.</p>
<p>Starting from <span class="arithmatex">\(|0000\rangle\)</span>, the Hadamard gate on the second qubit creates a superposition state, which then becomes entangled through the CNOT operation. Each quantum gate introduces potential error channels that could fundamentally alter the quantum state&rsquo;s coherence and probability amplitudes.</p>
<p>The subsequent depolarizing channel on qubits 2 and 1 probabilistically transforms the quantum state, mixing the original pure state with potential Pauli error transformations. This process maintains overall state normalization while introducing controlled quantum noise.</p>
<p>Subsequent Hadamard and CNOT operations continue to manipulate the quantum state, with each gate potentially interacting with the probabilistic errors introduced by the depolarizing channel.</p>
<p>I&rsquo;ll compute the final state evolution by tracking how quantum operations and noise channels interact, focusing on how errors propagate through the quantum circuit. The goal is to understand how these probabilistic transformations ultimately affect the quantum computation&rsquo;s fidelity.</p>
<p>The final state emerges from a complex composition of quantum operations and noise channels, representing the accumulated quantum transformations and potential errors throughout the circuit&rsquo;s execution.</p>
<p>The sequence involves Hadamard gates, controlled-NOT operations, and depolarizing noise channels applied at specific qubit locations, capturing the intricate dynamics of quantum information processing under realistic noise conditions.</p>
<p>I&rsquo;ll carefully track the quantum state transformations through precise unitary and channel operations, noting the systematic progression of quantum state evolution.</p>
<p>The initial state preparation begins with a pure zero state, followed by strategic quantum gates and noise interactions across different qubit pairs.</p>
<p>Specifically, the process involves Hadamard rotations, controlled-NOT entanglement operations, and depolarizing channels with probability parameter p, which introduces controlled probabilistic noise into specific two-qubit subspaces.</p>
<p>The depolarizing channel <span class="arithmatex">\(\mathcal{E}_{21}\)</span> applies a mixed state transformation where the original state is preserved with probability (1-p), while random Pauli perturbations are introduced with probability p/15 across the quantum subsystem.</p>
<p>These quantum operations progressively modify the initial quantum state, introducing controlled entanglement and probabilistic noise channels that will ultimately impact the final state&rsquo;s fidelity.</p>
<p>The computational strategy involves systematically tracking state transformations through density matrix representations, enabling precise quantum noise modeling across multiple qubit interactions.</p>
<p>I&rsquo;ll methodically compute Pauli operator effects on the initial quantum state, tracking how each transformation modifies the quantum system&rsquo;s probabilistic configuration. The process requires carefully tracking each Pauli operator&rsquo;s impact on the quantum state vector.</p>
<p>For the first set of Pauli operators, I&rsquo;ll compute their specific transformations, noting how <span class="arithmatex">\(X\)</span>, <span class="arithmatex">\(Y\)</span>, and <span class="arithmatex">\(Z\)</span> gates modify the initial quantum state <span class="arithmatex">\(|\psi_2\rangle\)</span> through distinct phase and basis rotations.</p>
<p>The initial state transformations reveal intricate quantum state manipulations, showing how different Pauli operators generate unique quantum state representations through precise computational steps.</p>
<p>Specific operator effects include phase shifts and basis state redistributions, demonstrating the quantum computational complexity inherent in these precise transformations.</p>
<p>The quantum state manipulations reveal intricate interactions between different Pauli gates, showing how single-qubit operations can generate nuanced quantum state modifications with predictable amplitude and phase changes.</p>
<p>Systematic gate applications demonstrate precise quantum state engineering techniques, highlighting the fundamental mechanisms of quantum information processing through controlled unitary transformations.</p>
<p>Some Pauli error operations exhibit symmetry properties, specifically cases where gate sequences return states to near-identical configurations, either preserving the original state or introducing a phase inversion.</p>
<p>Certain error combinations like <span class="arithmatex">\(X_2X_1\)</span>, <span class="arithmatex">\(Y_2Y_1\)</span>, and <span class="arithmatex">\(Z_2Z_1\)</span> fundamentally maintain the quantum state&rsquo;s core structure. These transformations essentially preserve the state&rsquo;s essential quantum information, with only minor global phase variations that become inconsequential in density matrix representations.</p>
<p>I observe intriguing symmetries where independent single-qubit operations produce equivalent state transformations, suggesting potential computational simplifications in error analysis.</p>
<p>The error scenarios can be systematically categorized based on their specific state modifications, revealing nuanced quantum state perturbation mechanisms across different error configurations.</p>
<p>The problem&rsquo;s underlying complexity emerges from two potential error locations, each carrying an independent error probability, which will ultimately determine the system&rsquo;s overall fidelity characteristics.</p>
<p>I&rsquo;ll break down the error probability distribution across three key scenarios: no errors, single errors, and double errors, each contributing distinctively to the final quantum state preservation metric.</p>
<p>The analysis suggests a probabilistic framework where error occurrence follows a binomial-like distribution, with probabilities <span class="arithmatex">\((1-p)^2\)</span>, <span class="arithmatex">\(2p(1-p)\)</span>, and <span class="arithmatex">\(p^2\)</span> representing zero, single, and double error states respectively.</p>
<p>The depolarizing channel transforms a quantum state through a probabilistic mixing process, where the original state is partially preserved and partially randomized based on the error probability <span class="arithmatex">\(p\)</span>. This involves a weighted combination of the initial state and a maximally mixed state across different Pauli error channels.</p>
<p>For pure states, the channel&rsquo;s action becomes particularly elegant: the state is partially preserved with probability <span class="arithmatex">\((1-p)\)</span>, while experiencing controlled randomization through Pauli error projections with probability <span class="arithmatex">\(\frac{p}{15}\)</span> across non-identity operators.</p>
<p>The fidelity calculation emerges from tracking how much of the original quantum information survives this probabilistic transformation, capturing the fundamental quantum noise dynamics.</p>
<p>I&rsquo;ll systematically decompose the quantum circuit evolution, defining specific unitary transformations and tracking state modifications through precise error channel interactions. The goal is to compute the final state fidelity by meticulously following each quantum operation.</p>
<p>The circuit evolution involves sequential unitary and error channel applications, with key transformations applied to different qubit subsets, ultimately revealing the quantum noise&rsquo;s cumulative impact on the initial state preparation.</p>
<p>I&rsquo;m tracking how Hadamard and CNOT gates interact with potential error channels, carefully noting how each transformation modifies the quantum state&rsquo;s probabilistic characteristics. The computational complexity increases with each error channel introduction, requiring careful mathematical tracking.</p>
<p>The current focus involves computing intermediate state representations, particularly examining how Hadamard gates transform error-affected states and how these transformations propagate through the quantum circuit&rsquo;s subsequent operations.</p>
<p>The computational approach demands precise mathematical manipulation, tracking both the ideal state trajectory and the probabilistic error contributions across different quantum gates and error channels.</p>
<p>I&rsquo;m systematically exploring computational strategies to simplify the fidelity calculation, recognizing the intricate interactions between quantum gates, error probabilities, and state transformations.</p>
<p>The key challenge involves developing an efficient method to compute state fidelity while accounting for multiple potential error scenarios across different circuit locations, balancing computational complexity with mathematical precision.</p>
<p>I&rsquo;ll methodically track state evolution through key transformations: initial state preparation, error channels, Hadamard gates, and controlled-NOT operations, carefully tracking how probabilistic errors modify quantum states.</p>
<p>My current approach involves decomposing the problem into discrete computational steps, examining how each quantum operation and potential error impacts the overall system state, with a focus on tracking state probabilities and transformations.</p>
<p>The computational strategy centers on understanding how depolarizing noise introduces controlled randomness into quantum state evolution, requiring a nuanced probabilistic framework to accurately model system dynamics.</p>
<p>I&rsquo;m tracking the state&rsquo;s transformation through multiple quantum gates and error channels, calculating how different error scenarios probabilistically modify the quantum state&rsquo;s fidelity and coherence.</p>
<p>The key insight involves mapping out the quantum state&rsquo;s evolution under different error scenarios, systematically computing how each potential error path contributes to the final state&rsquo;s characteristics.</p>
<p>I&rsquo;ll need to carefully compute the overlaps between the ideal quantum state and the various Pauli error operators across qubits 0 and 3, which will help determine the precise probabilistic contributions to state deviation.</p>
<p>The symmetry argument reveals an elegant insight about how the depolarizing channel uniformly distributes error probabilities across different Pauli transformations. By treating all non-identity Pauli errors equally, we can understand how quantum states probabilistically transform under noise.</p>
<p>The key observation involves how the channel introduces controlled randomness, where each potential Pauli error occurs with a specific probability proportional to the channel&rsquo;s noise parameter p.</p>
<p>I&rsquo;ll systematically explore the fidelity calculation, focusing on how the state evolves through probabilistic transformations. The mathematical structure suggests a nuanced approach to quantifying quantum state preservation under noisy conditions.</p>
<p>The no-error scenario provides a baseline probability contribution, representing the channel&rsquo;s ability to maintain the original quantum information with minimal perturbation.</p>
<p>I&rsquo;m investigating which two-qubit Pauli operators might leave the ideal state structurally unchanged. This requires carefully examining the symmetry properties of the quantum state, identifying transformations that preserve its fundamental characteristics.</p>
<p>The key insight involves understanding which Pauli operators can act on specific qubits without fundamentally altering the state&rsquo;s essential quantum configuration.</p>
<p>By systematically checking <span class="arithmatex">\(X_0\)</span>, <span class="arithmatex">\(Z_0\)</span>, <span class="arithmatex">\(X_3\)</span>, and <span class="arithmatex">\(Z_3\)</span>, I can determine which operators maintain the state&rsquo;s proportionality, revealing potential symmetry operations.</p>
<p>Interestingly, single-qubit Paulis do not preserve the state. However, the two-qubit operator <span class="arithmatex">\(X_0X_3\)</span> emerges as a symmetry generator, leaving <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span> invariant.</p>
<p>I&rsquo;ll continue investigating other two-qubit Pauli combinations to identify additional symmetry transformations.</p>
<p>The key symmetry operators include <span class="arithmatex">\(I\)</span>, <span class="arithmatex">\(X_0X_3\)</span>, <span class="arithmatex">\(Y_0Y_3\)</span>, and <span class="arithmatex">\(Z_0Z_3\)</span>, which maintain the quantum state&rsquo;s fundamental structure up to a phase factor.</p>
<p>For the error scenario at the second location, the probability calculation reveals a nuanced distribution across different quantum states.</p>
<p>I realize the previous calculation was incomplete. The error probability needs to account for scenarios without simultaneous errors at both locations, adjusting the mathematical model to capture the more precise error dynamics.</p>
<p>The analysis is becoming intricate, suggesting a need to explore alternative computational strategies that can systematically track error propagation and state fidelity.</p>
<p>I&rsquo;ll methodically examine each potential error configuration, calculating how individual qubit errors transform the quantum state through specific gate operations like <span class="arithmatex">\(H_0\)</span> and <span class="arithmatex">\(CNOT_{03}\)</span>. This involves tracking 15 distinct error scenarios, each contributing to the overall system fidelity.</p>
<p>The key challenge involves computing the complex transformations for each error pathway, requiring detailed quantum state evolution calculations that map how initial errors manifest through subsequent quantum gates.</p>
<p>For the specific case of <span class="arithmatex">\(P = I_2Z_1\)</span>, I track how this particular error propagates: starting with the initial state modification, then applying Hadamard and CNOT operations to see how the quantum state evolves under this error configuration.</p>
<p>The computation reveals zero overlap between the error-induced state and the ideal state, indicating this specific error path introduces significant quantum state deviation.</p>
<p>In contrast, for <span class="arithmatex">\(P = Z_2Z_1\)</span>, the error leaves the quantum state fundamentally unchanged, resulting in complete overlap and contributing a full unit to the error analysis.</p>
<p>I recognize that <span class="arithmatex">\(X_2X_1\)</span>, <span class="arithmatex">\(Y_2Y_1\)</span>, and <span class="arithmatex">\(Z_2Z_1\)</span> essentially preserve the quantum state&rsquo;s core structure, suggesting these error types minimally disrupt the quantum computation&rsquo;s intended progression.</p>
<p>This systematic error investigation suggests a nuanced understanding of how different error configurations impact quantum state fidelity, with some errors causing complete state disruption while others maintain near-perfect state preservation.</p>
<p>The analysis then shifts to exploring single and two-error scenarios, revealing complex probabilistic interactions between error locations and types, with certain error combinations producing negligible quantum state transformation.</p>
<p>I&rsquo;m considering computational strategies to manage the extensive combinatorial space, recognizing that direct numerical computation across 225 potential error configurations would be prohibitively complex. The challenge involves mapping quantum channel dynamics while tracking error probabilities and their nuanced interactions.</p>
<p>The quantum channel&rsquo;s mathematical representation requires careful decomposition, with initial attempts at characterizing the depolarizing channel revealing subtle modeling complexities that demand precise refinement.</p>
<p>The fundamental problem centers on computing physical state fidelity across different error probability scenarios, systematically breaking down potential error configurations and their respective probabilities.</p>
<p>Specifically, I&rsquo;m tracking error probabilities across zero, single, and double error scenarios, calculating weighted average fidelities that capture the probabilistic landscape of quantum state transformations.</p>
<p>The emerging fidelity calculation integrates multiple error probability contributions, progressively constructing a comprehensive representation of quantum channel performance under stochastic perturbations.</p>
<p>I&rsquo;m noticing the state&rsquo;s intricate stabilizer structure suggests deeper symmetries that might simplify the complex error probability computations I&rsquo;m currently navigating.</p>
<p>The [[4,2,2]] code&rsquo;s special quantum configuration hints at potential computational shortcuts for analyzing error propagation, potentially reducing the computational complexity of my current approach.</p>
<p>The state exhibits fascinating invariance properties under global <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> transformations, revealing fundamental symmetries that could provide insights into its error resilience and quantum information encoding characteristics.</p>
<p>At the second qubit location, I&rsquo;ve identified three key error-preserving operators: <span class="arithmatex">\(X_0X_3\)</span>, <span class="arithmatex">\(Y_0Y_3\)</span>, and <span class="arithmatex">\(Z_0Z_3\)</span>, which maintain the state&rsquo;s essential structure.</p>
<p>For the first error location, I&rsquo;m examining how different perturbations affect the quantum state. By applying <span class="arithmatex">\(I_2X_1\)</span>, I observe a transformation that shifts the quantum amplitudes, suggesting intricate relationships between qubit interactions and state preservation.</p>
<p>The Hadamard gate application further modifies the state&rsquo;s configuration, hinting at complex quantum dynamics that could be crucial for understanding error correction mechanisms.</p>
<p>Critically, these error explorations reveal that most perturbations at the first location generate states fundamentally orthogonal to the ideal quantum state, indicating a robust error detection strategy.</p>
<p>For two-error scenarios, only specific error combinations preserve the original quantum state&rsquo;s structure. These precise error pairs involve specific Pauli matrix interactions between qubits, with a calculated probability contribution of <span class="arithmatex">\(\frac{p^2}{25}\)</span> to the overall system fidelity.</p>
<p>The total fidelity calculation suggests a complex relationship between error probability and quantum state preservation, with the final expression seemingly truncated mid-calculation. <span class="arithmatex">\(F = 1 - \frac{8p}{5} + \frac{16p^2}{25}\)</span>, which simplifies the previous algebraic manipulation. The calculation checks out, confirming the expansion of <span class="arithmatex">\((1-p)^2\)</span> as <span class="arithmatex">\(1 - 2p + p^2\)</span>. The algebraic steps reveal a precise transformation of the original expression.</p>
<p>Examining the errors, I notice subtle variations in algebraic manipulations. Location 1 and 2 show equivalent transformations: <span class="arithmatex">\(p(1-p) \cdot \frac{1}{5}\)</span> reduces to <span class="arithmatex">\(\frac{p}{5} - \frac{p^2}{5}\)</span>. The second error involves squaring and scaling <span class="arithmatex">\(p^2\)</span> by <span class="arithmatex">\(\frac{1}{25}\)</span>, indicating a systematic approach to algebraic reduction.</p>
<p>The partial calculation suggests a complex algebraic decomposition, with multiple error locations revealing nuanced mathematical transformations.</p>
<p>Continuing the calculation, I see the equation evolving through strategic algebraic simplifications. The terms <span class="arithmatex">\(1 - 2p + \frac{2p}{5}\)</span> emerge, with <span class="arithmatex">\(p^2\)</span> being progressively refined through fractional adjustments.</p>
<p>The final steps involve consolidating fractional components, reducing <span class="arithmatex">\(p^2(1 - \frac{2}{5} + \frac{1}{25})\)</span> to <span class="arithmatex">\(p^2 \cdot \frac{16}{25}\)</span>, demonstrating a precise numerical manipulation.</p>
<p>The physical state fidelity <span class="arithmatex">\(F\)</span> resolves to <span class="arithmatex">\(1 - \frac{8p}{5} + \frac{16p^2}{25}\)</span>, capturing the intricate relationship between probability and quantum state transformation.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>Looking at the circuit and error model, I need to trace through the state evolution step by step, accounting for the depolarizing errors.</p>
<h2 id="step-1-identify-the-ideal-state-evolution">Step 1: Identify the ideal state evolution</h2>
<p>Starting from <span class="arithmatex">\(|0000\rangle\)</span>, the circuit operations (applied right to left) are:</p>
<ol>
<li><span class="arithmatex">\(H_2\)</span>: Creates <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)\)</span></li>
<li><span class="arithmatex">\(CNOT_{21}\)</span> (control=2, target=1): Creates <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\)</span></li>
<li><span class="arithmatex">\(H_0\)</span>: Creates <span class="arithmatex">\(\frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)\)</span></li>
<li><span class="arithmatex">\(CNOT_{03}\)</span> (control=0, target=3): Creates <span class="arithmatex">\(\frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)\)</span></li>
</ol>
<p>Therefore, the ideal final state is:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<h2 id="step-2-verify-this-is-the-logical-ghz-state">Step 2: Verify this is the logical GHZ state</h2>
<p>In the [[4,2,2]] code, the logical computational basis states are:
- <span class="arithmatex">\(|00\rangle_{AB} = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span>
- <span class="arithmatex">\(|01\rangle_{AB} = \frac{1}{\sqrt{2}}(|0011\rangle + |1100\rangle)\)</span>
- <span class="arithmatex">\(|10\rangle_{AB} = \frac{1}{\sqrt{2}}(|0101\rangle + |1010\rangle)\)</span>
- <span class="arithmatex">\(|11\rangle_{AB} = \frac{1}{\sqrt{2}}(|0110\rangle + |1001\rangle)\)</span></p>
<p>The logical GHZ state is:</p>
<div class="arithmatex">\[
\frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}} = \frac{1}{2}(|0000\rangle + |1111\rangle + |0110\rangle + |1001\rangle) = |\psi_{\text{ideal}}\rangle
\]</div>
<h2 id="step-3-analyze-the-error-channels">Step 3: Analyze the error channels</h2>
<p>Each CNOT gate is followed by a two-qubit depolarizing channel:</p>
<div class="arithmatex">\[
\mathcal{E}(\rho) = (1-p)\rho + \frac{p}{15}\sum_{P \neq II} P\rho P^{\dagger}
\]</div>
<p>where the sum is over the 15 non-identity two-qubit Paulis.</p>
<h2 id="step-4-calculate-fidelity-contributions">Step 4: Calculate fidelity contributions</h2>
<p>Let me analyze which errors preserve overlap with the ideal state.</p>
<p><strong>After the first CNOT (on qubits 2,1):</strong>
The state is <span class="arithmatex">\(|\psi_2\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\)</span></p>
<p>Checking which Paulis leave this invariant (up to phase):
- <span class="arithmatex">\(X_2X_1|\psi_2\rangle = |\psi_2\rangle\)</span> âœ“
- <span class="arithmatex">\(Y_2Y_1|\psi_2\rangle = -|\psi_2\rangle\)</span> âœ“
- <span class="arithmatex">\(Z_2Z_1|\psi_2\rangle = |\psi_2\rangle\)</span> âœ“</p>
<p>All other Paulis produce states orthogonal to the ideal final state after the remaining evolution.</p>
<p><strong>After the second CNOT (on qubits 0,3):</strong>
The state (if no prior error) is <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span></p>
<p>Checking which Paulis leave this invariant:
- <span class="arithmatex">\(X_0X_3|\psi_{\text{ideal}}\rangle = |\psi_{\text{ideal}}\rangle\)</span> âœ“
- <span class="arithmatex">\(Y_0Y_3|\psi_{\text{ideal}}\rangle = -|\psi_{\text{ideal}}\rangle\)</span> âœ“
- <span class="arithmatex">\(Z_0Z_3|\psi_{\text{ideal}}\rangle = |\psi_{\text{ideal}}\rangle\)</span> âœ“</p>
<h2 id="step-5-compute-total-fidelity">Step 5: Compute total fidelity</h2>
<p>The physical state fidelity has the following contributions:</p>
<ol>
<li>
<p><strong>No errors:</strong> Probability <span class="arithmatex">\((1-p)^2\)</span>, fidelity = 1</p>
</li>
<li>
<p><strong>One error at first location:</strong> Probability <span class="arithmatex">\(p(1-p)\)</span>, only 3 out of 15 errors contribute:</p>
</li>
</ol>
<div class="arithmatex">\[
F_1 = p(1-p) \cdot \frac{3}{15} = \frac{p(1-p)}{5}
\]</div>
<ol start="3">
<li><strong>One error at second location:</strong> Probability <span class="arithmatex">\((1-p)p\)</span>, only 3 out of 15 errors contribute:</li>
</ol>
<div class="arithmatex">\[
F_2 = (1-p)p \cdot \frac{3}{15} = \frac{p(1-p)}{5}
\]</div>
<ol start="4">
<li><strong>Two errors:</strong> Probability <span class="arithmatex">\(p^2\)</span>, only when both errors are from the special sets:</li>
</ol>
<div class="arithmatex">\[
F_{12} = p^2 \cdot \frac{3}{15} \cdot \frac{3}{15} = \frac{p^2}{25}
\]</div>
<h2 id="step-6-sum-all-contributions">Step 6: Sum all contributions</h2>
<div class="arithmatex">\[
F = (1-p)^2 + 2 \cdot \frac{p(1-p)}{5} + \frac{p^2}{25}
\]</div>
<p>Expanding:</p>
<div class="arithmatex">\[
F = 1 - 2p + p^2 + \frac{2p - 2p^2}{5} + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = 1 - 2p + \frac{2p}{5} + p^2\left(1 - \frac{2}{5} + \frac{1}{25}\right)
\]</div>
<div class="arithmatex">\[
F = 1 - p\left(2 - \frac{2}{5}\right) + p^2 \cdot \frac{16}{25}
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + \frac{16p^2}{25}
\]</div>
<p><strong>Final Answer:</strong> <span class="arithmatex">\(F = 1 - \frac{8p}{5} + \frac{16p^2}{25}\)</span></p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>Let me understand this problem. We need to find the logical state fidelity after post-selecting on no detectable errors.</p>
<p>First, I need to understand what are detectable errors in the [[4,2,2]] code. The stabilizers are XXXX and ZZZZ. Errors are detectable if they anti-commute with at least one stabilizer.</p>
<p>Let me think about which errors are undetectable. An error is undetectable if it commutes with all stabilizers. For errors to commute with both XXXX and ZZZZ:
- If the error has X on any qubit, it must have X on an even number of qubits (to commute with ZZZZ)
- If the error has Z on any qubit, it must have Z on an even number of qubits (to commute with XXXX)
- Y = iXZ, so if we have Y on a qubit, we have both X and Z on that qubit</p>
<p>So undetectable errors are those with:
- Even number of X&rsquo;s (including Y&rsquo;s)
- Even number of Z&rsquo;s (including Y&rsquo;s)</p>
<p>The logical operators are:
- <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B = XXII\)</span>
- <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span></p>
<p>And the stabilizers are <span class="arithmatex">\(S_1 = XXXX\)</span> and <span class="arithmatex">\(S_2 = ZZZZ\)</span>.</p>
<p>The undetectable errors are exactly the group generated by the logical operators and stabilizers. This group has 16 elements:
- <span class="arithmatex">\(I\)</span> (identity)
- <span class="arithmatex">\(S_1 = XXXX\)</span>
- <span class="arithmatex">\(S_2 = ZZZZ\)</span>
- <span class="arithmatex">\(S_1 S_2 = YYYY\)</span>
- <span class="arithmatex">\(X_A = XIXI\)</span>
- <span class="arithmatex">\(X_B = XXII\)</span>
- <span class="arithmatex">\(X_A X_B = IXII\)</span></p>
<ul>
<li><span class="arithmatex">\(Z_A = ZZII\)</span></li>
<li><span class="arithmatex">\(Z_B = ZIZI\)</span></li>
<li><span class="arithmatex">\(Z_A Z_B = IZII\)</span></li>
<li><span class="arithmatex">\(X_A Z_A = YIYI\)</span></li>
<li><span class="arithmatex">\(X_B Z_B = YYII\)</span></li>
<li><span class="arithmatex">\(X_A Z_B = YXYX\)</span></li>
<li><span class="arithmatex">\(X_B Z_A = YYII\)</span></li>
</ul>
<p>I&rsquo;m carefully examining the relationships between these logical operators. The group structure reveals intricate interactions between X and Z operations across different qubits.</p>
<p>The stabilizer group contains specific constraints. With <span class="arithmatex">\(S_1 = XXXX\)</span> and <span class="arithmatex">\(S_2 = ZZZZ\)</span>, I&rsquo;m investigating how undetectable errors might emerge. These errors must preserve the code space&rsquo;s fundamental properties while maintaining specific commutation relationships.</p>
<p>An undetectable error requires precise conditions: it must commute with stabilizers and either act trivially or represent a logical operator transformation. This demands a nuanced understanding of the quantum error correction&rsquo;s underlying symmetries.</p>
<p>For the specific qubit pair (2,1), undetectable errors emerge under strict parity constraints. These include the trivial identity operation, <span class="arithmatex">\(XX\)</span>, and <span class="arithmatex">\(YY\)</span> - each satisfying the critical requirement of maintaining stabilizer commutation while avoiding detection mechanisms.</p>
<p>Extending this analysis to qubits (0,3) reveals an identical pattern of undetectable errors: <span class="arithmatex">\(II\)</span>, <span class="arithmatex">\(XX\)</span>, <span class="arithmatex">\(YY\)</span>, and <span class="arithmatex">\(ZZ\)</span>. These specific error types preserve the quantum state&rsquo;s fundamental structure without triggering stabilizer anti-commutation.</p>
<p>The circuit&rsquo;s CNOT(2,1) operation introduces fascinating dynamics where certain two-qubit Pauli errors maintain the quantum state&rsquo;s essential characteristics. Specifically, <span class="arithmatex">\(XX\)</span>, <span class="arithmatex">\(YY\)</span>, and <span class="arithmatex">\(ZZ\)</span> errors on qubits 2,1 can propagate through the quantum computation without disrupting the underlying quantum information.</p>
<p>I&rsquo;ll trace the error propagation systematically, focusing on how different error types interact with the quantum state. The goal is to understand which errors remain undetected and how they might impact the final quantum computation.</p>
<p>For the first CNOT error scenario, specific Pauli errors like <span class="arithmatex">\(XX\)</span>, <span class="arithmatex">\(YY\)</span>, and <span class="arithmatex">\(ZZ\)</span> preserve the overall state structure, rendering them undetectable. However, any other Pauli error would create an orthogonal state, making the error immediately identifiable.</p>
<p>In the second CNOT error case, starting from the ideal state, similar patterns emerge. Certain two-qubit errors like <span class="arithmatex">\(XX\)</span> and <span class="arithmatex">\(YY\)</span> maintain the state&rsquo;s fundamental characteristics, effectively becoming invisible to the error detection mechanism. These undetectable errors could potentially introduce subtle computational inaccuracies.</p>
<p>The key insight is that not all errors disrupt the quantum state equally. Some errors seamlessly blend into the computation, while others fundamentally alter the quantum information, triggering immediate detection.</p>
<p>For post-selection, the probability calculation becomes nuanced. We&rsquo;re essentially tracking scenarios with no errors or only specific undetectable errors. The probability breaks down into four key components: zero errors, single undetectable errors at different locations, and two undetectable errors.</p>
<p>The final probability expression captures this complexity: <span class="arithmatex">\((1-p)^2 + \frac{2p(1-p)}{5} + \frac{p^2}{25}\)</span>, representing the likelihood of maintaining quantum coherence through the error correction process.</p>
<p>The undetectable errors introduce subtle state transformations. Some errors leave the logical state unchanged, while others potentially introduce phase variations. The key insight is that these errors can generate either the ideal state or its phase-inverted counterpart, which doesn&rsquo;t impact fidelity calculations.</p>
<p>I&rsquo;ll systematically analyze how these errors interact with the logical state. Undetectable errors fall into three fundamental categories: stabilizer-like behaviors, logical operator effects, or combinations of stabilizers and logical operators. </p>
<p>Examining specific error patterns on different qubit pairs reveals nuanced interactions with the logical GHZ state structure. The systematic exploration helps understand how these errors might propagate or modify the quantum information without compromising the overall logical state integrity.</p>
<p>The key observation centers on post-selection, where only states without detectable errors survive. This means the logical state remains remarkably robust, preserving its essential <span class="arithmatex">\((|00\rangle_{AB} + |11\rangle_{AB})/\sqrt{2}\)</span> configuration.</p>
<p>I need to carefully trace how each potential undetectable error transforms the logical quantum state, ensuring I capture the precise mechanisms of error preservation.</p>
<p>For the <span class="arithmatex">\(IIXX\)</span> error, I systematically verify its action across different basis states. Critically, this error leaves the logical GHZ state invariant, effectively acting as an identity transformation on the encoded quantum information.</p>
<p>The analysis suggests a deeper pattern of error resilience, where specific error configurations maintain the fundamental logical state structure without introducing significant perturbations.</p>
<p>I&rsquo;m now exploring how to characterize these undetectable errors using the stabilizer group and logical Pauli operators, seeking a more fundamental representation of their transformational properties.</p>
<p>By manipulating <span class="arithmatex">\(X_A\)</span> and <span class="arithmatex">\(X_B\)</span>, I&rsquo;ve discovered an interesting relationship: <span class="arithmatex">\(X_B S_1\)</span> generates <span class="arithmatex">\(IIXX\)</span>, which implies <span class="arithmatex">\(IIXX\)</span> acts as <span class="arithmatex">\(X_B\)</span> on the code space. This reveals a systematic way to understand how certain Pauli operators interact within the quantum error correction framework.</p>
<p>The complexity emerges from carefully tracking how these operators combine and transform, requiring precise algebraic manipulation to uncover their underlying structure. I&rsquo;m exploring quantum error interactions, focusing on how specific gate operations and error combinations affect quantum states. My current calculation attempts involve manipulating Pauli operators across different qubits, trying to understand their transformative effects. </p>
<p>I&rsquo;m realizing the complexity requires a more nuanced approach. The key insight is that not all error combinations are equivalent, and the specific circuit&rsquo;s structure constrains possible undetectable error pathways. Some error products might seem interchangeable but actually have subtle distinctions that matter at the quantum level.</p>
<p>My strategy shifts to examining explicit error scenarios systematically, tracking how different two-qubit error combinations propagate through the quantum circuit and potentially preserve or alter the encoded quantum information. I carefully examine the quantum state transformations, noting the <span class="arithmatex">\(XX\)</span> operation on qubits 2,1 produces unexpected results. The state evolution doesn&rsquo;t preserve the initial quantum configuration as I previously assumed. </p>
<p>The transformation reveals critical discrepancies in my earlier logical state analysis. Specifically, applying <span class="arithmatex">\(XX\)</span> to <span class="arithmatex">\(|\psi_2\rangle\)</span> generates a different quantum state, challenging my initial conclusions about post-selection and state fidelity.</p>
<p>I need to meticulously re-evaluate the quantum operations and their precise effects on the initial state, paying close attention to how each gate transformation impacts the quantum system&rsquo;s configuration. I&rsquo;ll continue the quantum error analysis, focusing on the remaining error combinations for qubits 2 and 1:</p>
<ul>
<li><span class="arithmatex">\(IZ\)</span> introduces a phase change, flipping the sign of one basis state</li>
<li><span class="arithmatex">\(ZI\)</span> returns to the original state <span class="arithmatex">\(|\psi_2\rangle\)</span></li>
<li><span class="arithmatex">\(ZZ\)</span> similarly creates a phase inversion</li>
<li><span class="arithmatex">\(XY\)</span> and <span class="arithmatex">\(YX\)</span> introduce complex phase rotations, mixing basis states with imaginary coefficients</li>
</ul>
<p>These error scenarios demonstrate how different single and two-qubit errors can transform the quantum state, revealing the intricate quantum error dynamics.</p>
<p>Only two error combinations preserve the original state&rsquo;s fundamental structure, highlighting the delicate nature of quantum information preservation.</p>
<p>The qubits follow a specific labeling with a controlled-NOT gate operating between qubit 2 and 1. After applying Hadamard on qubit 2, the state transforms through precise quantum operations. The CNOT gate introduces conditional state modifications, flipping the target qubit under specific control qubit conditions.</p>
<p>The resulting state reveals intricate quantum interactions, demonstrating how minimal quantum gates can dramatically alter quantum information while maintaining specific symmetries.</p>
<p>I&rsquo;ll explore the error scenarios systematically, tracking how different single-qubit error configurations modify the quantum state&rsquo;s probabilistic representation.</p>
<p>After applying Hadamard and CNOT gates, the state involves a superposition where qubit 2&rsquo;s uncertainty propagates through the entangled configuration. By introducing localized errors on qubits 2 and 1, I can systematically map potential quantum state transformations.</p>
<p>The key observation involves tracking how Pauli operators <span class="arithmatex">\(P_2\)</span> and <span class="arithmatex">\(P_1\)</span> interact with the entangled quantum state, potentially introducing subtle probabilistic variations in the quantum information encoding.</p>
<p>For the specific <span class="arithmatex">\(XX\)</span> error scenario, I notice an intriguing symmetry where the quantum state remains invariant under certain two-qubit Pauli transformations, suggesting robust quantum information preservation mechanisms.</p>
<p>I&rsquo;m preparing to methodically explore the complete set of non-trivial two-qubit Pauli error interactions to understand their comprehensive quantum state dynamics.</p>
<p>The first few transformations reveal nuanced state modifications:
- <span class="arithmatex">\(IX\)</span> generates a superposition between <span class="arithmatex">\(|0010\rangle\)</span> and <span class="arithmatex">\(|0100\rangle\)</span>
- <span class="arithmatex">\(XI\)</span> similarly creates a probabilistic quantum state transition
- <span class="arithmatex">\(XX\)</span> maintains the original quantum state&rsquo;s fundamental structure</p>
<p>I&rsquo;ll continue systematically analyzing each potential two-qubit Pauli interaction to map out their precise quantum state transformations.</p>
<p>The next interactions (<span class="arithmatex">\(IY\)</span> and <span class="arithmatex">\(YI\)</span>) introduce complex phase shifts, demonstrating intricate quantum mechanical behavior. Specifically:
- <span class="arithmatex">\(IY\)</span> rotates states with imaginary coefficients
- <span class="arithmatex">\(YI\)</span> produces complementary phase-shifted quantum states</p>
<p>The <span class="arithmatex">\(YY\)</span> interaction reveals fascinating symmetry, effectively negating the original quantum state through complex exponential transformations. Notably, the result directly inverts <span class="arithmatex">\(|\psi_2\rangle\)</span> through quantum mechanical phase manipulation.</p>
<p>The sequence concludes with <span class="arithmatex">\(IZ\)</span>, which preserves the initial quantum state without modification.</p>
<p>Subsequent interactions like <span class="arithmatex">\(ZI\)</span> and <span class="arithmatex">\(ZZ\)</span> further explore quantum state preservation mechanisms, revealing subtle phase relationships that maintain the fundamental quantum configuration.</p>
<p>The analysis identifies specific quantum gate combinations that preserve <span class="arithmatex">\(|\psi_2\rangle\)</span> up to phase, highlighting the delicate quantum mechanical principles governing state invariance.</p>
<p>Continuing the quantum circuit evolution demonstrates how precise gate sequences transform quantum states, with <span class="arithmatex">\(H_0\)</span> and <span class="arithmatex">\(CNOT_{03}\)</span> generating a complex entangled state <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span> through controlled quantum manipulations.</p>
<p>The symmetry between qubits 0 and 3 suggests a systematic approach to investigating error preservation, indicating potential robust quantum information encoding strategies.</p>
<p>Post-selection scenarios reveal nuanced state transformations under specific error conditions, showing how <span class="arithmatex">\(XX\)</span>, <span class="arithmatex">\(YY\)</span>, and <span class="arithmatex">\(ZZ\)</span> errors interact with the quantum state&rsquo;s fundamental structure.</p>
<p>The key observation is that most error scenarios preserve the logical state&rsquo;s essential quantum information, either returning the ideal state or its phase-inverted equivalent. This suggests robust quantum error resilience within the system&rsquo;s design.</p>
<p>I&rsquo;ll need to investigate the stabilizer commutation relationships to determine which errors might remain undetectable, as this could reveal critical vulnerabilities in the quantum error correction strategy.</p>
<p>Starting with the <span class="arithmatex">\(XX\)</span> error on specific qubits, I&rsquo;m systematically checking its interaction with stabilizer operators. By examining commutation relationships, I can determine whether this particular error disrupts the quantum state&rsquo;s integrity or remains masked by the system&rsquo;s protective mechanisms.</p>
<p>The initial calculations reveal nuanced interactions: while the error commutes with one stabilizer, it generates non-zero commutation with another, indicating potential detectability. This methodical analysis will help map out the error detection landscape for this quantum system.</p>
<p>Investigating <span class="arithmatex">\(YY\)</span> and <span class="arithmatex">\(ZZ\)</span> errors follows a similar computational strategy, revealing distinct commutation properties that distinguish their potential for detection or concealment within the quantum code.</p>
<p>The precise algebraic manipulations - tracking sign changes, tracking operator interactions - provide critical insights into the quantum error correction protocol&rsquo;s fundamental behavior.</p>
<p>Pauli matrix interactions become key: their anti-commutation relationships fundamentally determine error characteristics, with subtle phase considerations determining whether an error remains hidden or becomes detectable.</p>
<p>Carefully tracking each qubit&rsquo;s transformation reveals complex interactions. When different Pauli matrices multiply, their signs and imaginary coefficients shift dramatically, creating intricate phase dynamics that can mask or reveal quantum errors.</p>
<p>The precise sequence of matrix operations demands meticulous tracking, where each qubit&rsquo;s transformation contributes to the overall quantum state&rsquo;s evolution.</p>
<p>Commutation rules emerge as a critical insight: operators interact differently based on their relative positions and specific matrix characteristics. This suggests a systematic approach to analyzing quantum error detection might require examining each qubit&rsquo;s transformation methodically.</p>
<p>An error across two qubits involves specific Pauli operator combinations, with detectability determined by interactions with stabilizer matrices. The key lies in understanding how different Pauli operators relate when applied simultaneously, particularly their commutation properties.</p>
<p>Specifically, the commutator relationship between error operators and stabilizer matrices reveals critical information about potential undetectable quantum errors, with the interaction between <span class="arithmatex">\(X\)</span>, <span class="arithmatex">\(Y\)</span>, <span class="arithmatex">\(Z\)</span>, and <span class="arithmatex">\(I\)</span> operators playing a fundamental role in this analysis.</p>
<p>The conditions for an undetectable error require precise balancing of operator types, ensuring an even distribution of certain Pauli operators to maintain commutation with stabilizer matrices.</p>
<p>Undetectable errors are limited to specific two-qubit Pauli operators like <span class="arithmatex">\(XX\)</span>, <span class="arithmatex">\(YY\)</span>, and <span class="arithmatex">\(ZZ\)</span> on particular qubit pairs, which preserve the quantum state&rsquo;s fundamental structure.</p>
<p>These specific error patterns emerge from careful analysis of quantum error detection mechanisms, revealing subtle symmetries in quantum information preservation.</p>
<p>When such undetectable errors occur, the final quantum state remains essentially unchanged, maintaining <span class="arithmatex">\(\pm|\psi_{ideal}\rangle\)</span> through post-selection processes that filter out detectable error signatures.</p>
<p>I&rsquo;ll examine how specific errors like <span class="arithmatex">\(XX\)</span> on particular qubit combinations impact the logical GHZ state representation, which fundamentally encodes the quantum information as <span class="arithmatex">\((|00\rangle_{AB} + |11\rangle_{AB})/\sqrt{2}\)</span>.</p>
<p>Analyzing the <span class="arithmatex">\(IXXI\)</span> transformation reveals intriguing state modifications across logical basis configurations, showing how local error patterns can subtly redistribute quantum amplitudes without fundamentally disrupting the core quantum information.</p>
<p>The transformation suggests complex interactions between physical and logical quantum representations, where seemingly straightforward operations produce nuanced state evolutions that preserve underlying quantum coherence.</p>
<p><span class="arithmatex">\(IXXI\)</span> demonstrates an intriguing symmetry: it systematically maps between <span class="arithmatex">\(|00\rangle_{AB}\)</span> and <span class="arithmatex">\(|11\rangle_{AB}\)</span> states while maintaining quantum state integrity. The operator effectively swaps computational basis states while preserving the fundamental quantum superposition structure.</p>
<p>By mapping <span class="arithmatex">\(|0110\rangle\)</span> and <span class="arithmatex">\(|1001\rangle\)</span> to <span class="arithmatex">\(|11\rangle_{AB}\)</span>, and conversely mapping <span class="arithmatex">\(|0000\rangle\)</span> and <span class="arithmatex">\(|1111\rangle\)</span> to <span class="arithmatex">\(|00\rangle_{AB}\)</span>, the operator reveals a precise quantum mechanical transformation that maintains the essential quantum information.</p>
<p>This symmetry suggests deeper quantum mechanical principles governing state preservation and transformation across different computational representations. <span class="arithmatex">\(IZZI\)</span> flips the sign for <span class="arithmatex">\(|0110\rangle\)</span> and <span class="arithmatex">\(|1001\rangle\)</span>, creating a phase change between specific basis states. When applied to Bell states, <span class="arithmatex">\(IZZI\)</span> transforms <span class="arithmatex">\((|00\rangle_{AB} + |11\rangle_{AB})/\sqrt{2}\)</span> to <span class="arithmatex">\((|00\rangle_{AB} - |11\rangle_{AB})/\sqrt{2}\)</span>, indicating a non-trivial action on the quantum state.</p>
<p>I suspect the problem lies in <span class="arithmatex">\(IZZI\)</span>&rsquo;s measurement properties. Comparing <span class="arithmatex">\(IZZI\)</span> with <span class="arithmatex">\(XXXX\)</span> reveals a potential discrepancy at the first qubit position, where a <span class="arithmatex">\(Z\)</span> gate differs from an <span class="arithmatex">\(X\)</span> gate.</p>
<p>This suggests the quantum operation might not behave as initially expected, potentially challenging the assumptions about state preservation or undetectability. <span class="arithmatex">\(IZZI\)</span> acts as a logical <span class="arithmatex">\(Z\)</span> operator between qubits <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span>, flipping the sign of the Bell state depending on the initial state. This means undetectable errors can subtly transform quantum states through logical operations, not just trivial actions. The error <span class="arithmatex">\(IZZI\)</span> specifically maps the symmetric Bell state to its antisymmetric counterpart by applying a sign change based on the initial state&rsquo;s configuration.</p>
<p>For <span class="arithmatex">\(XIII\)</span> errors on different qubit positions, the mapping reveals complex transformations across computational basis states. The operator permutes states in a symmetric manner, exchanging <span class="arithmatex">\(|0000\rangle\)</span> with <span class="arithmatex">\(|1111\rangle\)</span> and <span class="arithmatex">\(|0110\rangle\)</span> with <span class="arithmatex">\(|1001\rangle\)</span>, demonstrating how local errors can induce global state rearrangements.</p>
<p>These transformations preserve the logical GHZ state&rsquo;s fundamental structure, maintaining entanglement while shuffling individual qubit configurations. The symmetry suggests robustness against specific two-qubit error patterns.</p>
<p><span class="arithmatex">\(ZIIZ\)</span> acts consistently across different basis states, introducing sign changes that preserve overall quantum state relationships. The operation appears equivalent to <span class="arithmatex">\(Z_B\)</span>, indicating a fundamental symmetry in the quantum error correction code&rsquo;s logical operations.</p>
<p>The pattern reveals intricate interactions between quantum gates and logical states, demonstrating how carefully designed transformations can maintain quantum information integrity.</p>
<p>Two distinct logical states emerge through post-selection, each with unique probabilistic characteristics determined by specific error configurations.</p>
<p>I&rsquo;m reconsidering the operator placement and error calculations. The <span class="arithmatex">\(ZIIZ\)</span> operator requires careful analysis to determine its logical status and potential undetectability. Checking its commutation relationships with key stabilizers reveals complex interactions that challenge straightforward classification.</p>
<p>Investigating its behavior against fundamental stabilizer generators shows nuanced commutation properties, suggesting this might represent a non-trivial error syndrome that doesn&rsquo;t cleanly map to standard logical operators.</p>
<p>The systematic exploration involves decomposing <span class="arithmatex">\(ZIIZ\)</span> through various group generator combinations to understand its fundamental characteristics and potential role in quantum error correction.</p>
<p>I&rsquo;ve systematically examined products of logical operators and stabilizers, attempting to express <span class="arithmatex">\(ZIIZ\)</span> through different algebraic manipulations. Despite multiple approaches - combining <span class="arithmatex">\(Z_A\)</span>, <span class="arithmatex">\(Z_B\)</span> with stabilizers <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span> - I haven&rsquo;t yet definitively characterized this specific error pattern.</p>
<p>The key insight emerging is that not all undetectable two-qubit errors might be directly reachable through simple products of logical operators, suggesting a more complex underlying group structure.</p>
<p>The undetectable error group contains stabilizers and logical operators, but its complete characterization remains an open investigation requiring further algebraic analysis.</p>
<p>Specifically for the [[4,2,2]] code, I&rsquo;m now focusing on understanding how different undetectable errors - <span class="arithmatex">\(II\)</span>, <span class="arithmatex">\(XX\)</span>, <span class="arithmatex">\(YY\)</span>, <span class="arithmatex">\(ZZ\)</span> on different qubit pairs - transform the logical quantum state, systematically mapping their precise effects.</p>
<p>I&rsquo;ve already tracked several key transformations:
- <span class="arithmatex">\(IXXI\)</span> preserves the logical GHZ state
- <span class="arithmatex">\(IYYI\)</span> introduces a phase change
- <span class="arithmatex">\(IZZI\)</span> generates a specific logical operator transformation</p>
<p>Now I&rsquo;m carefully examining <span class="arithmatex">\(ZIIZ\)</span>, meticulously calculating its action on the initial logical state, noting potential discrepancies in my previous calculations and preparing to resolve computational nuances in the quantum error correction encoding.</p>
<p>The computation reveals subtle interactions between error operators and logical quantum states, demanding precise mathematical tracking of phase and state transformations. The post-selection yields two potential quantum states: a symmetric and an antisymmetric Bell state involving qubits A and B. </p>
<p>Error pathways leading to the target GHZ state include zero-error scenarios and specific two-qubit gate errors like <span class="arithmatex">\(XX\)</span> and <span class="arithmatex">\(YY\)</span> on different qubit pairs, excluding <span class="arithmatex">\(ZZ\)</span> interactions. These error combinations preserve the desired quantum configuration.</p>
<p>Conversely, <span class="arithmatex">\(ZZ\)</span> interactions on specific qubit pairs generate an alternative quantum state, suggesting a different error-induced outcome.</p>
<p>I&rsquo;ll calculate the probabilities for achieving the correct logical state, considering various error scenarios across different qubit positions. The probability calculation involves combinations of no errors, single-site errors, and multi-site error interactions, each weighted by the error probability <span class="arithmatex">\(p\)</span>.</p>
<p>The probability computation breaks down the likelihood of maintaining the target quantum state through precise error management, revealing the delicate balance between quantum coherence and decoherence.</p>
<p>Key probability components include perfect state preservation, single-site error occurrences, and correlated error patterns across different qubit locations. The total probability integrates these nuanced scenarios, capturing the quantum system&rsquo;s resilience and vulnerability to noise.</p>
<p>The mathematical expression synthesizes these probabilities, providing a comprehensive view of quantum state fidelity under error conditions.</p>
<p>Calculating the post-selection probability reveals a complex interplay between error rates and state preservation, demonstrating the delicate balance of quantum information processing.</p>
<p>The conditional probability of obtaining the correct logical state involves a nuanced fraction where the numerator and denominator reflect different error scenarios and post-selection outcomes. I&rsquo;ll carefully analyze the intricate relationship between these probabilities, showing how quantum error correction mechanisms can enhance state fidelity.</p>
<p>The derived expression captures the probabilistic landscape of quantum state recovery, balancing the raw error probability with sophisticated post-selection techniques.</p>
<p>Interestingly, the quantum state mixture introduces two distinct basis states - the standard GHZ state and its alternative configuration - which suggests a complex probabilistic reconstruction strategy.</p>
<p>The fidelity calculation reveals a direct relationship between the post-selection probability and state recovery. By computing the inner product between these quantum states, I find the fidelity simplifies to the post-selection probability <span class="arithmatex">\(q\)</span>, indicating a straightforward measurement outcome interpretation.</p>
<p>The inner product calculation shows orthogonality between the two states, which critically determines the fidelity&rsquo;s elegant linear dependence on the selection probability.</p>
<p>I&rsquo;ll now factor and simplify the complex probability expression, focusing on finding a common denominator to streamline the algebraic manipulation.</p>
<p>By factoring the numerator and denominator, I discover elegant squared terms: <span class="arithmatex">\((15 - 13p)^2\)</span> and <span class="arithmatex">\((5 - 4p)^2\)</span>. This allows me to rewrite the fidelity expression in a more compact form.</p>
<p>The simplified fidelity equation becomes <span class="arithmatex">\(F = \frac{(15 - 13p)^2}{9(5 - 4p)^2}\)</span>, which reveals a clean relationship between the squared terms and provides a more transparent view of the probability calculation.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>Looking at this problem, I need to find the logical state fidelity after post-selecting on no detectable errors in the [[4,2,2]] code.</p>
<h2 id="step-1-identify-detectable-vs-undetectable-errors">Step 1: Identify detectable vs undetectable errors</h2>
<p>In the [[4,2,2]] code with stabilizers <span class="arithmatex">\(S_1 = XXXX\)</span> and <span class="arithmatex">\(S_2 = ZZZZ\)</span>, an error is detectable if it anti-commutes with at least one stabilizer.</p>
<p>For a two-qubit Pauli error <span class="arithmatex">\(P_i P_j\)</span> on qubits <span class="arithmatex">\((i,j)\)</span> to be undetectable, it must commute with both stabilizers. This requires:
- Even number of <span class="arithmatex">\(X,Y\)</span> operators (to commute with <span class="arithmatex">\(ZZZZ\)</span>)<br />
- Even number of <span class="arithmatex">\(Z,Y\)</span> operators (to commute with <span class="arithmatex">\(XXXX\)</span>)</p>
<p>For two-qubit errors, the undetectable non-identity errors are: <span class="arithmatex">\(XX\)</span>, <span class="arithmatex">\(YY\)</span>, <span class="arithmatex">\(ZZ\)</span>.</p>
<h2 id="step-2-track-state-evolution-with-undetectable-errors">Step 2: Track state evolution with undetectable errors</h2>
<p>From the previous subproblem, after the circuit without errors, we get:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<p>For errors on qubits (2,1):
- <span class="arithmatex">\(XX\)</span> (operator <span class="arithmatex">\(IXXI\)</span>): Preserves <span class="arithmatex">\(|\psi_2\rangle\)</span>, leads to <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span>
- <span class="arithmatex">\(YY\)</span> (operator <span class="arithmatex">\(IYYI\)</span>): Maps <span class="arithmatex">\(|\psi_2\rangle \to -|\psi_2\rangle\)</span>, leads to <span class="arithmatex">\(-|\psi_{\text{ideal}}\rangle\)</span>
- <span class="arithmatex">\(ZZ\)</span> (operator <span class="arithmatex">\(IZZI\)</span>): Preserves <span class="arithmatex">\(|\psi_2\rangle\)</span>, leads to <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span></p>
<p>For errors on qubits (0,3), similar analysis shows they map <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> to <span class="arithmatex">\(\pm|\psi_{\text{ideal}}\rangle\)</span> or a different logical state.</p>
<h2 id="step-3-determine-logical-action-of-undetectable-errors">Step 3: Determine logical action of undetectable errors</h2>
<p>Let me check what these undetectable errors do at the logical level:</p>
<p>For <span class="arithmatex">\(IXXI\)</span> (XX on qubits 2,1):
- <span class="arithmatex">\(IXXI|00\rangle_{AB} = IXXI \cdot \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle) = \frac{1}{\sqrt{2}}(|0110\rangle + |1001\rangle) = |11\rangle_{AB}\)</span>
- <span class="arithmatex">\(IXXI|11\rangle_{AB} = |00\rangle_{AB}\)</span>
- So <span class="arithmatex">\(IXXI\)</span> swaps logical basis states and preserves the GHZ state.</p>
<p>For <span class="arithmatex">\(IZZI\)</span> (ZZ on qubits 2,1):
- <span class="arithmatex">\(IZZI = Z_A Z_B\)</span> (product of logical Z operators)
- <span class="arithmatex">\(Z_A Z_B|00\rangle_{AB} = |00\rangle_{AB}\)</span>
- <span class="arithmatex">\(Z_A Z_B|11\rangle_{AB} = -|11\rangle_{AB}\)</span>
- Maps GHZ state to <span class="arithmatex">\((|00\rangle_{AB} - |11\rangle_{AB})/\sqrt{2}\)</span></p>
<p>Similarly, <span class="arithmatex">\(ZIIZ\)</span> (ZZ on qubits 0,3) also equals <span class="arithmatex">\(Z_A Z_B\)</span>.</p>
<h2 id="step-4-calculate-probabilities-after-post-selection">Step 4: Calculate probabilities after post-selection</h2>
<p>The possible outcomes after post-selection are:</p>
<p><strong>Target GHZ state</strong> <span class="arithmatex">\((|00\rangle_{AB} + |11\rangle_{AB})/\sqrt{2}\)</span>:
- No error: <span class="arithmatex">\((1-p)^2\)</span>
- XX or YY on (2,1) only: <span class="arithmatex">\(\frac{2p(1-p)}{15}\)</span>
- XX or YY on (0,3) only: <span class="arithmatex">\(\frac{2p(1-p)}{15}\)</span>
- XX/YY on both (4 combinations): <span class="arithmatex">\(\frac{4p^2}{225}\)</span></p>
<p>Total probability: <span class="arithmatex">\((1-p)^2 + \frac{4p(1-p)}{15} + \frac{4p^2}{225}\)</span></p>
<p><strong>Wrong state</strong> <span class="arithmatex">\((|00\rangle_{AB} - |11\rangle_{AB})/\sqrt{2}\)</span>:
- ZZ on (2,1) only: <span class="arithmatex">\(\frac{p(1-p)}{15}\)</span>
- ZZ on (0,3) only: <span class="arithmatex">\(\frac{p(1-p)}{15}\)</span>
- ZZ on both: <span class="arithmatex">\(\frac{p^2}{225}\)</span>
- ZZ on one, XX/YY on other: <span class="arithmatex">\(\frac{4p^2}{225}\)</span></p>
<p>Total probability: <span class="arithmatex">\(\frac{2p(1-p)}{15} + \frac{5p^2}{225}\)</span></p>
<h2 id="step-5-compute-logical-state-fidelity">Step 5: Compute logical state fidelity</h2>
<p>The probability of passing post-selection is:</p>
<div class="arithmatex">\[
P_{\text{pass}} = (1-p)^2 + \frac{6p(1-p)}{15} + \frac{9p^2}{225} = (1-p)^2 + \frac{2p(1-p)}{5} + \frac{p^2}{25}
\]</div>
<p>The logical state fidelity is the probability of getting the correct GHZ state given post-selection:</p>
<div class="arithmatex">\[
F = \frac{(1-p)^2 + \frac{4p(1-p)}{15} + \frac{4p^2}{225}}{(1-p)^2 + \frac{2p(1-p)}{5} + \frac{p^2}{25}}
\]</div>
<p>Simplifying the numerator:</p>
<div class="arithmatex">\[
= \frac{225(1-p)^2 + 60p(1-p) + 4p^2}{225} = \frac{225 - 390p + 169p^2}{225} = \frac{(15-13p)^2}{225}
\]</div>
<p>Simplifying the denominator:</p>
<div class="arithmatex">\[
= \frac{25(1-p)^2 + 10p(1-p) + p^2}{25} = \frac{25 - 40p + 16p^2}{25} = \frac{(5-4p)^2}{25}
\]</div>
<p>Therefore:</p>
<div class="arithmatex">\[
F = \frac{(15-13p)^2}{225} \cdot \frac{25}{(5-4p)^2} = \frac{(15-13p)^2}{9(5-4p)^2}
\]</div>
<p><strong>Final Answer:</strong> <span class="arithmatex">\(F = \frac{(15-13p)^2}{9(5-4p)^2}\)</span></p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>The user wants me to populate the final answer into the code template. From my previous calculation, the logical state fidelity is:</p>
<div class="arithmatex">\[
F = \frac{(15-13p)^2}{9(5-4p)^2}
\]</div>
<p>I need to express this as a SymPy expression. This is:
- Numerator: <span class="arithmatex">\((15-13p)^2\)</span>
- Denominator: <span class="arithmatex">\(9(5-4p)^2\)</span></p>
<p>So the expression should be: (15 - 13<em>p)</em><em>2 / (9 * (5 - 4</em>p)**2)</p>
                      </div>
                    </details>
<div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span> <span class="o">-</span> <span class="mi">13</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.143206
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>