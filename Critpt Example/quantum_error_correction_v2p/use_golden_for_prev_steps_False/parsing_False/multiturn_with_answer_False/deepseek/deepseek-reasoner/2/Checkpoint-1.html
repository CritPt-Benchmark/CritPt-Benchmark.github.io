<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">üåì</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?&rdquo;</p>
<p>Interpretation: We have a circuit that prepares a state. But then we have errors on the CNOT gates. The circuit has two CNOT gates: CNOT_{21} and CNOT_{03}. Also two Hadamard gates: H_0 and H_2. But note: The circuit order: The equation is given as: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). But then note: &ldquo;the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation)&rdquo;. So the actual circuit order is: Start with initial state? Typically, we start with all qubits in |0&gt;? But problem doesn&rsquo;t explicitly say initial state? But since it&rsquo;s state preparation, likely initial state is |0000&gt;? But then we apply gates: first H_2, then CNOT_{21}, then H_0, then CNOT_{03}. So circuit: 
Step 1: H on qubit 2.
Step 2: CNOT with control qubit 2, target qubit 1.
Step 3: H on qubit 0.
Step 4: CNOT with control qubit 0, target qubit 3.</p>
<p>We want to prepare logical GHZ state: (|00&gt;_AB + |11&gt;_AB)/‚àö2. But careful: The code is [[4,2,2]]. The logical states? The code encodes two qubits. The logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI. So what are the logical basis states? They are defined as states that are +1 eigenstates of the stabilizers? Actually, the code is a stabilizer code with stabilizers: S1 = XXXX, S2 = ZZZZ. And then logical operators. So the logical states are: 
|00&gt;_L, |01&gt;_L, |10&gt;__L, |11&gt;_L. They are defined up to phase. But here we want a GHZ state on the logical qubits: (|00&gt;_AB + |11&gt;_AB)/‚àö2. That is a state in the code space? Possibly yes.</p>
<p>Let&rsquo;s check: The circuit: H_2, CNOT_{21}, H_0, CNOT_{03}. Applied to initial state |0000&gt;? 
Qubits: 0,1,2,3.
After H_2: state becomes |0&gt;0, |0&gt;1, H|0&gt;2 = (|0&gt;+|1&gt;)/‚àö2, |0&gt;3. So state: (|0000&gt; + |0010&gt;)/‚àö2.
Then CNOT_{21}: control qubit 2, target qubit 1. So:
|0000&gt; becomes |0000&gt; because control=0.
|0010&gt; becomes |0010&gt;? Actually careful: CNOT_{21}: if qubit2 is |1&gt;, then flip qubit1. So |0010&gt; becomes |0110&gt;? But wait: qubits order: 0,1,2,3. So state: |q0,q1,q2,q3&gt;. So |0010&gt; means: q0=0, q1=0, q2=1, q3=0. Under CNOT_{21}: control is q2, target is q1. So if q2=1, then flip q1. So |0010&gt; becomes |0110&gt;? But then q1 becomes 1. So state becomes (|0000&gt; + |0110&gt;)/‚àö2.
Then H_0: Hadamard on qubit 0. So:
|0000&gt; -&gt; H on qubit0: (|0&gt;+|1&gt;)/‚àö2 on qubit0, so becomes (|0000&gt; + |1000&gt;)/‚àö2.
|0110&gt; -&gt; H on qubit0: (|0110&gt; + |1110&gt;)/‚àö2? But careful: H on qubit0: |0&gt; -&gt; (|0&gt;+|1&gt;)/‚àö2, |1&gt; -&gt; (|0&gt;-|1&gt;)/‚àö2. But here qubit0 is 0 in |0000&gt; and 0 in |0110&gt;? Actually, check: In |0110&gt;, qubit0 is 0? Because it&rsquo;s 0,1,1,0. So indeed qubit0=0. So then H_0 gives: (|0&gt;+|1&gt;)/‚àö2 on qubit0. So |0110&gt; becomes (|0110&gt; + |1110&gt;)/‚àö2.
So overall state after H_0: = 1/‚àö2 * [ (|0000&gt;+|1000&gt;)/‚àö2 + (|0110&gt;+|1110&gt;)/‚àö2 ] = 1/2 (|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;).
Then CNOT_{03}: control qubit 0, target qubit 3.
Apply CNOT_{03}:
For each term:
|0000&gt;: control=0 so no flip: remains |0000&gt;.
|1000&gt;: control=1 so flip qubit3: becomes |1001&gt;.
|0110&gt;: control=0 so no flip: remains |0110&gt;.
|1110&gt;: control=1 so flip qubit3: becomes |1111&gt;.
So final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>Now, is that the logical GHZ state? The logical states: 
We have logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI.
What are the logical basis states? They are defined as eigenvectors of Z_A and Z_B. 
Z_A = ZZII. So its eigenvalues: For state |0000&gt;, Z_A: Z on qubit0 and qubit1: both 0 so product? Actually, careful: Z on qubit0 and qubit1: Z‚äóZ on qubits 0 and 1. For |00&gt;, eigenvalue +1. So |0000&gt; gives +1. For |1001&gt;: qubits0 and1: |10&gt; gives -1? Actually, Z‚äóZ: eigenvalues: if both same then +1, if different then -1. So |10&gt; gives -1. So |1001&gt; gives eigenvalue -1 for Z_A. Similarly, |0110&gt;: qubits0 and1: |01&gt; gives -1. |1111&gt;: gives +1.
So Z_A: |0000&gt; and |1111&gt; are +1; |1001&gt; and |0110&gt; are -1.
Z_B = ZIZI. So on qubits: qubit0 and qubit2? Actually careful: Z_B = Z I Z I. So it acts on qubit0 and qubit2. For |0000&gt;: qubits0 and2: |00&gt; gives +1. For |1001&gt;: qubits0 and2: |10&gt; gives -1. For |0110&gt;: qubits0 and2: |01&gt; gives -1. For |1111&gt;: qubits0 and2: |11&gt; gives +1.
So indeed, the states: 
|0000&gt; corresponds to Z_A=+1, Z_B=+1 so that is logical |00&gt;_L.
|1111&gt; corresponds to Z_A=+1, Z_B=+1? Actually check: |1111&gt;: Z_A: on qubits0,1: both 1 so product +1; Z_B: on qubits0,2: both 1 so product +1. So |1111&gt; is also logical |00&gt;_L? But wait, then they are not orthogonal? But they are in the code space? Actually, the code space is 4-dimensional. The logical states are defined modulo the stabilizers. The stabilizers are XXXX and ZZZZ. Check: XXXX on |0000&gt; gives +1? Actually, XXXX|0000&gt; = |1111&gt;? That is not necessarily an eigenstate? Actually, stabilizer means that the code space is the subspace that is +1 eigenvector of both stabilizers. So for a state to be in the code space, it must satisfy S1|œà&gt; = |œà&gt; and S2|œà&gt; = |œà&gt;. Our state: |0000&gt; is not necessarily in the code space because S1|0000&gt; = |1111&gt; which is not proportional to |0000&gt;. So the code space is not simply these basis states. Actually, the [[4,2,2]] code is a stabilizer code. The stabilizers are XXXX and ZZZZ. So the code space is the subspace of the 4-qubit Hilbert space that is invariant under these operators. The dimension is 2^4 / 2^2 = 4. So the logical states are superpositions. In fact, the logical states are usually given by:
|00&gt;_L = (|0000&gt;+|1111&gt;)/‚àö2? But then check stabilizers: XXXX on that gives (|1111&gt;+|0000&gt;)/‚àö2 = same, so +1. ZZZZ on that gives (|0000&gt;+(-1)^4|1111&gt;)/‚àö2 = (|0000&gt;+|1111&gt;)/‚àö2, so +1. So that is a valid state. And then |01&gt;_L = (|0011&gt;+|1100&gt;)/‚àö2? But then our state we got is 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). That is not obviously a logical state. But wait, the problem says: &ldquo;prepare a logical two-qubit GHZ state (|00&gt;_AB + |11&gt;_AB)/‚àö2&rdquo;. That is a state on two logical qubits. But note: The logical qubits are encoded in 4 physical qubits. So the GHZ state is: (|00&gt;_L + |11&gt;_L)/‚àö2. And what are |00&gt;_L and |11&gt;_L? They are states in the code space. Typically, for the [[4,2,2]] code, one representation is:
|00&gt;_L = (|0000&gt;+|1111&gt;)/‚àö2,
|01&gt;_L = (|0011&gt;+|1100&gt;)/‚àö2,
|10&gt;_L = (|0101&gt;+|1010&gt;)/‚àö2,
|11&gt;__L = (|0110&gt;+|1001&gt;)/‚àö2.
Check: Then Z_A = ZZII. On |00&gt;_L: (|0000&gt;+|1111&gt;)/‚àö2, Z_A gives: on first two qubits: for |00&gt;, product +1; for |11&gt;, product +1. So eigenvalue +1. On |11&gt;_L: (|0110&gt;+|1001&gt;)/‚àö2, Z_A: on |01&gt; gives -1, on |10&gt; gives -1, so eigenvalue -1. And Z_B = ZIZI: on |00&gt;_L: qubits0 and2: |00&gt; gives +1, |11&gt; gives +1; on |11&gt;_L: |01&gt; gives -1, |10&gt; gives -1. So that works. And also stabilizers: XXXX on |00&gt;_L gives (|1111&gt;+|0000&gt;)/‚àö2 = |00&gt;_L; on |11&gt;_L gives (|1001&gt;+|0110&gt;)/‚àö2 = |11&gt;_L. So indeed, these are valid logical states.
Then our prepared state is: 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;) = 1/2 [ (|0000&gt;+|1111&gt;) + (|1001&gt;+|0110&gt;) ] = 1/‚àö2 * (|00&gt;_L + |11&gt;_L)/‚àö2? Actually, careful: |00&gt;_L = (|0000&gt;+|1111&gt;)/‚àö2, so that part is ‚àö2 * |00&gt;_L. And |11&gt;_L = (|1001&gt;+|0110&gt;)/‚àö2, so that part is ‚àö2 * |11&gt;_L. So then state = 1/2 (‚àö2|00&gt;_L + ‚àö2|11&gt;_L) = 1/‚àö2 (|00&gt;_L + |11&gt;_L). So indeed, the circuit prepares the logical GHZ state perfectly if no errors.</p>
<p>Now, we introduce errors. The errors occur on the CNOT gates. There are two CNOT gates: CNOT_{21} and CNOT_{03}. Each CNOT gate is followed by a two-qubit depolarizing error channel on the two qubits involved. That error channel: With probability p, an error occurs. And if an error occurs, it is uniformly distributed among the 15 non-identity two-qubit Paulis. So each CNOT gate&rsquo;s error model: After the ideal CNOT, we apply with probability p/15 each of the 15 Pauli errors on the two qubits (the ones that are not identity on both). And with probability 1-p, no error.</p>
<p>We want: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; 
Interpretation: The fidelity between the ideal state (which is the state we would get if no errors) and the actual state that comes out from the circuit with errors. But careful: The circuit has two CNOT gates. Each CNOT gate is followed by an error channel. So the overall transformation is: 
Start with initial state: presumably |0000&gt;? Yes.
Then apply: H_2 (no error on single-qubit gates? Problem says: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. So only CNOT gates have errors. So Hadamard gates are perfect.)
So steps:</p>
<ol>
<li>H_2: perfect.</li>
<li>CNOT_{21} followed by error channel on qubits 2 and 1. So after this step, the state is: E_{21} ‚àò CNOT_{21} applied to state after H_2.</li>
<li>H_0: perfect.</li>
<li>CNOT_{03} followed by error channel on qubits 0 and 3.</li>
</ol>
<p>We want the fidelity of the final state relative to the ideal state (which is the state we computed without errors: |œà_ideal&gt; = 1/‚àö2 (|00&gt;_L + |11&gt;_L) = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;)).</p>
<p>But careful: The error channels are applied after each CNOT. They are quantum channels. So the final state is a mixed state. We want the fidelity between that mixed state and the ideal pure state. Fidelity F = sqrt(&lt;œà|œÅ|œà&gt;). But maybe they mean the state fidelity? Often &ldquo;physical state fidelity&rdquo; might mean the overlap between the actual state and the ideal state. But since the actual state is mixed, fidelity is defined as F(œÅ, œÉ) = Tr(‚àö(‚àöœÅ œÉ ‚àöœÅ)) but if œÉ is pure, then F = ‚àö(‚ü®œà|œÅ|œà‚ü©). So we want ‚ü®œà_ideal| œÅ_final |œà_ideal‚ü©.</p>
<p>So we need to compute the final density matrix œÅ. It is obtained by applying the channels in sequence. Since the errors are Pauli errors, we can compute the probability that the overall error is a certain Pauli on the 4 qubits. And then the final state will be a mixture of states that are the ideal state acted by some Pauli errors. And because the ideal state might be invariant under some Paulis? But careful: The errors occur at different steps. They act on different qubits. And they are applied after the gates. So we need to propagate these errors through subsequent gates. But maybe we can compute the effect by tracking the cumulative error operator. Alternatively, we can compute the fidelity as: F = probability that no error occurs that changes the state from the ideal? But careful: Some errors might act trivially on the ideal state? That is, if an error operator E is such that E|œà_ideal&gt; = |œà_ideal&gt; (up to phase), then that error does not reduce fidelity. But wait: The depolarizing channel gives a random Pauli. But these Paulis are applied at intermediate steps. But then they get propagated through subsequent gates. So we need to compute the overall effect: Let U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2. But careful: The errors occur after each CNOT. So the actual operation is: 
After step 1: state = H_2 |0000&gt;.
Step 2: Apply CNOT_{21} ideally, then apply an error Pauli on qubits 2 and 1. That error is one of the 15 Paulis on qubits 2 and 1. Let&rsquo;s denote that error as E^{(2)} on qubits (2,1). But note: The Paulis are products of Pauli X, Y, Z on these two qubits. So it is of the form P_i ‚äó P_j on qubits 2 and 1, where (P_i, P_j) is not (I,I). 
Step 3: Apply H_0. That acts on qubit 0 only.
Step 4: Apply CNOT_{03} ideally, then apply an error Pauli on qubits 0 and 3. That error is on qubits (0,3). Denote it as F^{(4)}.</p>
<p>So overall, the final state (if we fix a particular error pattern) is: 
|œà_final&gt; = F^{(4)} * CNOT_{03} * H_0 * E^{(2)} * CNOT_{21} * H_2 |0000&gt;.
But note: The errors are random. So the final density matrix is: 
œÅ = Sum over errors (probability) * |œà_final&gt;&lt;œà_final|.</p>
<p>We want &lt;œà_ideal| œÅ |œà_ideal&gt; = average over errors of |&lt;œà_ideal|œà_final&gt;|^2.</p>
<p>Now, note that the ideal state is: |œà_ideal&gt; = U_total |0000&gt; where U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2.
So if there were no errors, we get that.
Now, if there is an error pattern, then |œà_final&gt; = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2 |0000&gt;, but careful: The error E is applied after the first CNOT, so it comes before H_0 and CNOT_{03}. So we can write: 
|œà_final&gt; = F * CNOT_{03} * H_0 * E * (CNOT_{21} * H_2) |0000&gt;.
But note that U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2. So if we define V = CNOT_{21} * H_2, then U_total = CNOT_{03} * H_0 * V.
Then |œà_final&gt; = F * CNOT_{03} * H_0 * E * V |0000&gt;.
And |œà_ideal&gt; = CNOT_{03} * H_0 * V |0000&gt;.
So then &lt;œà_ideal|œà_final&gt; = &lt;0000| V^\dagger H_0^\dagger CNOT_{03}^\dagger * F * CNOT_{03} * H_0 * E * V |0000&gt;.
= &lt;0000| V^\dagger * (H_0^\dagger CNOT_{03}^\dagger F CNOT_{03} H_0) * E * V |0000&gt;.
But note that H_0 and CNOT_{03} act on qubits 0 and 3. And F is a Pauli on qubits 0 and 3. And H_0 and CNOT_{03} will conjugate Paulis on qubits 0 and 3 into other Paulis. So let&rsquo;s define: For a Pauli on qubits 0 and 3, after conjugation by CNOT_{03} and H_0? But careful: The order: H_0^\dagger CNOT_{03}^\dagger F CNOT_{03} H_0. But note: H_0 acts only on qubit 0. And CNOT_{03} acts on qubits 0 and 3. So we can compute the conjugation of Paulis on qubits 0 and 3 under these gates. But maybe we can compute the overall effect by tracking the errors through the circuit. Alternatively, we can compute the fidelity by considering that the errors are Pauli errors and the ideal state is a stabilizer state? Actually, the ideal state is a specific state in the code space. But note: The circuit is not necessarily fault-tolerant? But we want the physical fidelity. That is the overlap between the actual state and the ideal state.</p>
<p>Maybe we can compute the probability that the final state is exactly the ideal state. That is: The fidelity F = probability that no error occurs that changes the state? But careful: Some errors might act as identity on the state? That is, if an error operator (after propagation) becomes an element of the stabilizer of the ideal state, then it will leave the state invariant. So then the fidelity would be the sum of probabilities of errors that are either identity or in the stabilizer group of the ideal state. But is that true? If we have a Pauli error E such that E|œà_ideal&gt; = |œà_ideal&gt; (up to phase), then if that error occurs, the final state is still |œà_ideal&gt;. So then that error pattern gives fidelity 1. But wait: But careful: The errors occur at different times. They propagate through the circuit. So we want to know: What is the overall operator that acts on the initial state? That is: O = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2. And we want to know when does O|0000&gt; equal |œà_ideal&gt; (up to global phase)? That is equivalent to: O U_total^\dagger |œà_ideal&gt; = |œà_ideal&gt;? Actually, since |œà_ideal&gt; = U_total|0000&gt;, we want O = U_total * (something that acts as identity on |0000&gt;)? Actually, we want: O|0000&gt; = |œà_ideal&gt; = U_total|0000&gt;. So we want U_total^\dagger O to act as identity on |0000&gt;. But |0000&gt; is not necessarily invariant under all Paulis? But note: The initial state is |0000&gt;. So if U_total^\dagger O is a Pauli that fixes |0000&gt;? But |0000&gt; is an eigenstate of Z on each qubit. So if U_total^\dagger O is a Pauli that is a product of Z&rsquo;s? Actually, careful: |0000&gt; is the state where all qubits are 0. That state is stabilized by Z_i. So if a Pauli operator P acts on |0000&gt;, it will give a phase if P is a product of Z&rsquo;s? Actually, if P contains any X or Y, then it will flip some qubits and will not give |0000&gt;. So for P to leave |0000&gt; invariant (up to phase), P must be a product of Z&rsquo;s and I&rsquo;s. But wait: Could it be that P|0000&gt; = |0000&gt;? For example, Z_0|0000&gt; = |0000&gt; because |0&gt; is eigenvalue +1. So indeed, if P is a Pauli that is only Z&rsquo;s and I&rsquo;s, then P|0000&gt; = |0000&gt; (since Z|0&gt;=|0&gt;). But if there is an X, then it flips to |1&gt; so not invariant. So the condition for the error to not affect the final state (i.e., the final state is still the ideal state) is that the overall error operator (after propagating through the circuit) is an operator that acts as identity on the initial state |0000&gt;. But careful: The overall operator is U_total^\dagger O. But O = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2. And U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2. So U_total^\dagger O = (H_2^\dagger CNOT_{21}^\dagger H_0^\dagger CNOT_{03}^\dagger) * (F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2) = H_2^\dagger CNOT_{21}^\dagger H_0^\dagger (CNOT_{03}^\dagger F CNOT_{03}) H_0 E CNOT_{21} H_2.
That is messy.</p>
<p>Maybe it&rsquo;s easier to compute the fidelity directly by averaging over error patterns. The fidelity is: F = ‚àë_{error patterns} (probability) * |&lt;œà_ideal|œà_final&gt;|^2.
And &lt;œà_ideal|œà_final&gt; = &lt;0000| U_total^\dagger O |0000&gt;.
So if we can compute the operator U_total^\dagger O. But O depends on errors E and F. Let&rsquo;s denote:
E: error on qubits 2 and 1 after first CNOT. It is a Pauli on qubits 2 and 1. There are 15 possibilities plus identity.
F: error on qubits 0 and 3 after second CNOT. Pauli on qubits 0 and 3.
And these are independent? Actually, they occur with probabilities: For first CNOT: with probability 1-p, no error; with probability p, an error occurs, and then uniformly among 15 Paulis. So probability for a specific non-identity Pauli on {2,1} is p/15. Similarly for second CNOT: probability for a specific non-identity on {0,3} is p/15, and probability no error is 1-p.</p>
<p>So then overall, the fidelity is: 
F = (1-p)^2 * 1 (when both errors are identity) 
+ plus cases where either error is non-identity but the overall effect is such that U_total^\dagger O acts as identity on |0000&gt;? But careful: Even if the overall operator is not identity, it might still have overlap with identity? But wait: |&lt;œà_ideal|œà_final&gt;|^2 = |&lt;0000| U_total^\dagger O |0000&gt;|^2. And U_total^\dagger O is a unitary operator (since it&rsquo;s a product of unitaries). So its matrix element with |0000&gt; is some complex number. But if U_total^\dagger O is a Pauli operator (because all gates are Clifford and errors are Pauli, so overall, U_total^\dagger O is a Clifford transformation of Pauli errors? Actually, check: U_total is a Clifford circuit? It consists of Hadamards and CNOTs. So it is Clifford. And errors are Pauli. So U_total^\dagger O will be a Pauli operator (up to maybe a phase) because Clifford gates map Paulis to Paulis. So indeed, U_total^\dagger O is a Pauli operator on the 4 qubits. Let&rsquo;s check: 
O = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2.
U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2.
So U_total^\dagger O = (H_2^\dagger CNOT_{21}^\dagger H_0^\dagger CNOT_{03}^\dagger) * (F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2)
= H_2^\dagger CNOT_{21}^\dagger H_0^\dagger (CNOT_{03}^\dagger F CNOT_{03}) H_0 E CNOT_{21} H_2.
Now, F is a Pauli on qubits 0 and 3. CNOT_{03}^\dagger F CNOT_{03} is also a Pauli on qubits 0 and 3 (because CNOT is Clifford). Then H_0^\dagger (that) H_0 is a Pauli on qubits 0 and 3? Actually, H_0 acts only on qubit 0. So it will map Paulis on qubit 0 to other Paulis. So overall, the product inside becomes a Pauli on qubits 0 and 3. Then we have E which is a Pauli on qubits 2 and 1. So the product is a Pauli on qubits 0,3 and 2,1? But careful: They act on disjoint sets? Actually, qubits: 0,1,2,3. The first part acts on qubits 0 and 3. E acts on qubits 2 and 1. So they commute. So then we have: U_total^\dagger O = H_2^\dagger CNOT_{21}^\dagger (P_{03} * E) CNOT_{21} H_2, where P_{03} = H_0^\dagger (CNOT_{03}^\dagger F CNOT_{03}) H_0. And note that CNOT_{21} acts on qubits 2 and 1. And H_2 acts on qubit 2. So then thisÊï¥‰Ωì is a Pauli operator on all qubits? Because Clifford conjugation of a Pauli is a Pauli. So indeed, U_total^\dagger O is a Pauli operator on the 4 qubits. Let&rsquo;s denote it as Q. So then &lt;0000| Q |0000&gt; is nonzero only if Q is a Pauli that is diagonal in the computational basis and does not flip any qubit. That is, Q must be a product of I and Z&rsquo;s. And even then, it might give a phase. But |&lt;0000|Q|0000&gt;|^2 will be 1 if Q acts as a phase on |0000&gt; (since |0&gt; is eigenvector of Z with eigenvalue 1). But wait: If Q = Z_i, then &lt;0|Z|0&gt;=1, so that&rsquo;s fine. But if Q contains any X or Y, then it will flip some qubit and the overlap with |0000&gt; is 0. So the fidelity for a given error pattern is 1 if the overall Pauli Q (which is U_total^\dagger O) is such that it only has factors I and Z on the qubits. And if it has any X or Y, then the overlap is 0. But is that exactly true? Check: If Q = X_0, then &lt;0000|X_0|0000&gt; = &lt;0000|1000&gt; = 0. So yes.
So then the fidelity F = probability that the overall error operator Q is in the set of Paulis that are products of I and Z on each qubit. But careful: There might be a phase factor? But |&lt;0000|Q|0000&gt;|^2 = 1 if Q|0000&gt; = ¬±|0000&gt;. And that happens if Q is a product of Z&rsquo;s and I&rsquo;s. Because Z|0&gt;=|0&gt;, so indeed. So condition: Q should have no X or Y on any qubit. So we need to compute: For given errors E (on qubits 2,1) and F (on qubits 0,3), what is Q = U_total^\dagger O? And we want that Q is a Pauli operator that only contains I and Z on each qubit.</p>
<p>Maybe we can compute this by propagating the errors through the circuit. Alternatively, we can compute the effect of each error on the final state directly. That is: The final state with errors: |œà_final&gt; = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2 |0000&gt;. And we want the overlap with |œà_ideal&gt; = CNOT_{03} * H_0 * CNOT_{21} * H_2 |0000&gt;. So that overlap is &lt;0000| H_2^\dagger CNOT_{21}^\dagger H_0^\dagger CNOT_{03}^\dagger F CNOT_{03} H_0 E CNOT_{21} H_2 |0000&gt;. That is as before.</p>
<p>Maybe it&rsquo;s easier to compute by simulating the effect of errors on the state. But the state is a superposition. Alternatively, we can compute the probability that the final state is exactly the ideal state. That is: The errors are Pauli errors. They will transform the state to some Pauli applied to the ideal state? Actually, note: The circuit is Clifford. So if we have an error Pauli at some point, then the overall effect is that the final state is some Pauli (which is a function of the error) applied to the ideal state. But careful: The errors occur at different times. But because the circuit is Clifford, the overall effect is that the final state is: |œà_final&gt; = P |œà_ideal&gt; for some Pauli P that depends on the errors. And then the fidelity is |&lt;œà_ideal|P|œà_ideal&gt;|^2. And that is 1 if P is in the stabilizer of |œà_ideal&gt;, and 0 otherwise? But is that true? For a stabilizer state, if P is a Pauli that is not in the stabilizer, then typically &lt;œà|P|œà&gt; = 0. But wait: There might be cases where P is not in the stabilizer but still has nonzero overlap? For a stabilizer state, the expectation value of any Pauli is either ¬±1 or 0. Actually, for a stabilizer state, if P is in the stabilizer group, then &lt;œà|P|œà&gt; = 1. If P is not in the stabilizer, then it anticommutes with some stabilizer, so the expectation is 0. So indeed, if the final state is P|œà_ideal&gt;, then the fidelity is 1 if P is in the stabilizer of |œà_ideal&gt;, and 0 otherwise. But wait: Could it be that P is not exactly a Pauli? But we argued that overall, the effect is a Pauli operator on the initial state? Actually, careful: The errors are applied at intermediate steps. But because the circuit is Clifford, the overall operation from initial state to final state is: O = (error at end?) Actually, consider: The ideal circuit is U. With errors, we have: O = (F) * U_2 * (E) * U_1, where U_1 and U_2 are parts of U. But U is Clifford. But is it true that O = P U for some Pauli P? That would be if the errors commute through the gates in a nice way. But here, the errors are applied after some gates. So O = F * U_2 * E * U_1. And U = U_2 * U_1. So O = F * U_2 * E * U_2^\dagger * U_2 * U_1 = (F * (U_2 E U_2^\dagger)) * U. So indeed, if we define P = F * (U_2 E U_2^\dagger), then O = P U, provided that U_2 E U_2^\dagger commutes with F? But careful: U_2 here is: U_2 = CNOT_{03} * H_0. And E acts on qubits 2 and 1. And U_2 acts on qubits 0 and 3 and also H_0 on qubit 0. But wait, U_2 and E act on disjoint sets? Actually, E acts on qubits 2 and 1. U_2 acts on qubits 0 and 3 and also H_0 on qubit 0. So they commute? Actually, they act on different qubits, so they commute. So indeed, U_2 E U_2^\dagger = E because U_2 does not affect qubits 2 and 1? But careful: U_2 includes H_0. H_0 acts on qubit 0, but that is separate from qubits 2 and 1. So yes, they commute. So then O = F * U_2 * E * U_1 = F * E * U_2 * U_1 = (F E) * U, because F and E act on different qubits? But wait: F acts on qubits 0 and 3, E acts on qubits 2 and 1. So they commute. So indeed, O = (F E) U. That is much simpler! Check: The circuit: 
U = CNOT_{03} * H_0 * CNOT_{21} * H_2.
And errors: After first CNOT, we apply E on qubits 2,1. After second CNOT, we apply F on qubits 0,3.
But careful: The order: The actual operation is: 
Step: H_2 (perfect)
Then: CNOT_{21} then error E on (2,1)
Then: H_0 (perfect)
Then: CNOT_{03} then error F on (0,3)
So overall: O = F * CNOT_{03} * H_0 * (E * CNOT_{21} * H_2) but note: E commutes with H_0? H_0 acts on qubit 0, E on qubits 2,1, so yes. And E commutes with CNOT_{03}? CNOT_{03} acts on qubits 0,3, so yes. So then O = F * CNOT_{03} * H_0 * CNOT_{21} * H_2 * E? But careful: E is applied after CNOT_{21}, so it is: CNOT_{21} then E. But do CNOT_{21} and E commute? E is on qubits 2,1. CNOT_{21} is on qubits 2,1 as well. They do not necessarily commute. So we cannot simply move E to the end. Let&rsquo;s do it step by step:
O = F * CNOT_{03} * H_0 * (E * CNOT_{21}) * H_2. 
Now, note that E and H_0 commute because they act on different qubits. So O = F * CNOT_{03} * (H_0 * E) * CNOT_{21} * H_2 = F * CNOT_{03} * (E * H_0) * CNOT_{21} * H_2 = F * CNOT_{03} * E * H_0 * CNOT_{21} * H_2.
Now, does E commute with CNOT_{03}? CNOT_{03} acts on qubits 0 and 3. E acts on qubits 2 and 1. So yes, they commute. So O = F * E * CNOT_{03} * H_0 * CNOT_{21} * H_2 = F * E * U.
So indeed, O = (F E) U. That is very nice.
So the overall effect is that the errors simply multiply as Pauli operators on the final state. But wait: Is that always true? Check with a simple example: Suppose only error E occurs. Then O = E * CNOT_{21} * H_2? Actually, careful: The circuit: H_2, then CNOT_{21} then error E, then H_0, then CNOT_{03}. That gives O = CNOT_{03} * H_0 * (E * CNOT_{21} * H_2) = CNOT_{03} * H_0 * E * CNOT_{21} * H_2? But then we argued that E commutes with H_0 and CNOT_{03}? Yes, because E acts on qubits 2,1 and H_0 acts on qubit 0, and CNOT_{03} acts on qubits 0,3. So then O = E * CNOT_{03} * H_0 * CNOT_{21} * H_2 = E * U. So that works.
And if only error F occurs: O = F * CNOT_{03} * H_0 * CNOT_{21} * H_2 = F * U. So indeed, overall, O = (F E) U. But careful: What about the order? F and E act on disjoint sets, so they commute. So the overall error operator is just the product of the two errors. So then the final state (if there is a specific error pattern) is: |œà_final&gt; = (F E) U |0000&gt; = (F E) |œà_ideal&gt;.
So then the fidelity for that error pattern is: |&lt;œà_ideal| F E |œà_ideal&gt;|^2.
And since F and E are Pauli operators on disjoint sets, F E is a Pauli operator on the 4 qubits. And as argued, for a stabilizer state, the overlap is 1 if F E is in the stabilizer group of |œà_ideal&gt;, and 0 otherwise.
So we need to determine the stabilizer of |œà_ideal&gt;. |œà_ideal&gt; is the logical GHZ state: (|00&gt;_L + |11&gt;_L)/‚àö2. But careful: That state is not necessarily a stabilizer state of the code? Actually, it is a state in the code space? But its stabilizer group? The code space itself has stabilizers: XXXX and ZZZZ. But |œà_ideal&gt; is a specific state within that space. Its stabilizer group will be larger than the code&rsquo;s stabilizer? Actually, for a given state, the stabilizer is the set of Paulis that leave it invariant. For the GHZ state, typically there are generators. But we can compute: |œà_ideal&gt; = 1/‚àö2 (|00&gt;_L + |11&gt;_L) = 1/2 (|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;). What Paulis leave this state invariant? 
Check: XXXX: XXXX|œà_ideal&gt; = ? XXXX applied to each term: |0000&gt; -&gt; |1111&gt;; |1111&gt; -&gt; |0000&gt;; |0110&gt; -&gt; |1001&gt;; |1001&gt; -&gt; |0110&gt;. So XXXX|œà_ideal&gt; = |œà_ideal&gt;. So XXXX is a stabilizer.
ZZZZ: ZZZZ|œà_ideal&gt; =? Z on each: |0000&gt; -&gt; |0000&gt;; |1111&gt; -&gt; (-1)^4|1111&gt;=|1111&gt;; |0110&gt; -&gt;? Actually, careful: ZZZZ means Z on each qubit. For |0110&gt;: qubits: 0:0 -&gt; +1, 1:1 -&gt; -1, 2:1 -&gt; -1, 3:0 -&gt; +1, so product = (+1)<em>(-1)</em>(-1)<em>(+1)=+1? Actually, (-1)</em>(-1)=+1, so overall +1. For |1001&gt;: qubit0:1 -&gt; -1, qubit1:0 -&gt; +1, qubit2:0 -&gt; +1, qubit3:1 -&gt; -1, product = (-1)<em>(+1)</em>(+1)<em>(-1)=+1. So ZZZZ also gives +1. So both stabilizers of the code act as +1 on |œà_ideal&gt;. But are there others? 
Also, consider the logical operators? For instance, Z_A ‚äó Z_B? But Z_A = ZZII, Z_B = ZIZI. Their product? Actually, careful: The state is |00&gt;_L + |11&gt;_L. That state is stabilized by Z_A ‚äó Z_B? Because on |00&gt;_L, Z_A and Z_B are both +1 so product +1; on |11&gt;_L, Z_A and Z_B are both -1 so product +1. So indeed, Z_A Z_B (which is ZZII * ZIZI = Z Z I I? Actually, careful: Z_A = Z on qubit0 and qubit1? Actually, Z_A = ZZII means: Z on qubit0, Z on qubit1, I on qubit2, I on qubit3.
Z_B = ZIZI means: Z on qubit0, I on qubit1, Z on qubit2, I on qubit3.
So Z_A Z_B = (Z on qubit0)^2? Actually, product: on qubit0: Z * Z = I? Wait, careful: Pauli multiplication: Z_A = Z_0 Z_1, Z_B = Z_0 Z_2. So their product is Z_0 Z_1 * Z_0 Z_2 = (Z_0^2) Z_1 Z_2 = I * Z_1 Z_2 = Z_1 Z_2. So Z_A Z_B = Z_1 Z_2. So that operator: Z on qubit1 and Z on qubit2. Does that stabilize |œà_ideal&gt;? Check: On |0000&gt;, Z_1 Z_2 gives +1. On |1111&gt;, qubit1 and qubit2 are 1 so product +1. On |0110&gt;, qubit1=1, qubit2=1 so product +1. On |1001&gt;, qubit1=0, qubit2=0 so product +1. So yes, Z_1 Z_2 is a stabilizer of |œà_ideal&gt;.
Also, what about X_A X_B? X_A = XIXI = X on qubit0 and I on qubit1? Actually, X_A = XIXI means: X on qubit0, I on qubit1, X on qubit2? Wait: X_A = XIXI: indices: qubit0: X, qubit1: I, qubit2: X, qubit3: I. And X_B = XXII: qubit0: X, qubit1: X, qubit2: I, qubit3: I.
So X_A X_B = (X on qubit0 from both gives X^2 = I? Actually, careful: X_A X_B = (X_0 I_1 X_2 I_3) * (X_0 X_1 I_2 I_3) = (X_0^2) (I_1 X_1) (X_2 I_2) (I_3 I_3) = I * X_1 * X_2 * I = X_1 X_2. So X_A X_B = X_1 X_2. Does that stabilize |œà_ideal&gt;? Check: X_1 X_2 on |0000&gt; gives |0000&gt;? Actually, X_1 X_2|0000&gt; = |0&gt;0 * (X|0&gt;1) * (X|0&gt;2) * |0&gt;3 = |0&gt;0 |1&gt;1 |1&gt;2 |0&gt;3 = |0110&gt;? That is not |0000&gt;. So X_1 X_2 does not necessarily stabilize the state? But wait, the GHZ state is stabilized by X_A X_B? Actually, for a GHZ state |00&gt;+|11&gt;, the stabilizer includes X‚äóX. But here X_A X_B would be X on both logical qubits. And on |00&gt;_L + |11&gt;_L, X‚äóX swaps them, so that gives the same state. So indeed, X_A X_B should stabilize the state. But we computed X_A X_B as X_1 X_2. But then applying X_1 X_2 to |0000&gt; gives |0110&gt;, and that is part of the state. But then the state is a superposition. So we need to check: X_1 X_2 |œà_ideal&gt; = 1/2 (X_1 X_2|0000&gt; + X_1 X_2|1111&gt; + X_1 X_2|0110&gt; + X_1 X_2|1001&gt;) = 1/2 (|0110&gt; + |1001&gt; + |0000&gt; + |1111&gt;) = |œà_ideal&gt;. So yes, X_1 X_2 is also a stabilizer.
Also, what about? There might be more. The full stabilizer of the GHZ state? Actually, the state |œà_ideal&gt; is a stabilizer state on 4 qubits? But wait, it is a state in a 4-qubit Hilbert space. Its stabilizer group will have 4 generators? Actually, for a pure state, the stabilizer subgroup of the Pauli group that fixes it has size? For n qubits, a stabilizer state is defined by n independent generators. So here n=4, so the stabilizer group should have 4 generators. We already have: S1 = XXXX, S2 = ZZZZ, S3 = Z_1 Z_2, S4 = X_1 X_2. Check if these commute? 
XXXX and ZZZZ commute? They anticommute? Actually, XXXX and ZZZZ: product of X and Z on each qubit gives -1 each, so overall sign? Actually, careful: For each qubit, X and Z anticommute. So product over 4 qubits: (X1 Z1) &hellip; = (-1)^4? Actually, if we take two Paulis, they commute if the number of qubits where they are different and both non-identity is even. For XXXX and ZZZZ, on each qubit, both are non-identity, so that&rsquo;s 4 qubits, and 4 is even, so they commute. So that&rsquo;s fine.
Z_1 Z_2 commutes with XXXX? On qubits 1 and 2, X and Z anticommute? Actually, check: XXXX has X on qubit1 and X on qubit2. Z_1 Z_2 has Z on qubit1 and Z on qubit2. On qubit1, X and Z anticommute, so that gives a minus sign. On qubit2, similarly minus sign. So overall, they commute. And with ZZZZ? They commute because Z&rsquo;s commute. 
X_1 X_2 commutes with XXXX? Obviously. With ZZZZ? On qubits 1 and 2, Z and X anticommute, so two minus signs give plus. So these four are independent? They generate a group of size 16. So the stabilizer of |œà_ideal&gt; is the group generated by {XXXX, ZZZZ, Z1Z2, X1X2}. But wait, are there relations? For example, (XXXX)(X1X2) =? That gives X on qubits 0,3 and I on 1,2? That is not necessarily in the group. So indeed, the stabilizer group has 4 generators, so size 16.
But careful: The condition for fidelity to be 1 is that the overall error operator F E is in the stabilizer of |œà_ideal&gt;. But wait: Is that sufficient? Because if F E is in the stabilizer, then F E |œà_ideal&gt; = |œà_ideal&gt;. So yes.
But also, could it be that F E is not in the stabilizer but still gives a nonzero overlap? For a stabilizer state, if a Pauli is not in the stabilizer, then its expectation is 0. So indeed, fidelity is 1 if F E is in the stabilizer, and 0 otherwise.
But wait: There is also the possibility that F E is the identity? That is included in the stabilizer.
So then the fidelity F (the physical state fidelity) is the probability that the combined error operator (F E) is an element of the stabilizer group of |œà_ideal&gt;. But careful: F and E are independent. But note: F acts on qubits 0 and 3. E acts on qubits 2 and 1. So F E is a Pauli on all 4 qubits. And we want it to be in the stabilizer group S of |œà_ideal&gt;. What is S? S is generated by: 
S1 = XXXX
S2 = ZZZZ
S3 = Z1Z2
S4 = X1X2.
But note: F acts on qubits 0 and 3. E acts on qubits 2 and 1. So F E will have the form: (something on qubits 0,3) times (something on qubits 2,1). And the stabilizer elements: They are products of these generators. In general, an element of S will be of the form: (X0 X3)^a? Actually, let&rsquo;s write the generators in terms of qubits separately:
S1 = X0 X1 X2 X3.
S2 = Z0 Z1 Z2 Z3.
S3 = Z1 Z2.
S4 = X1 X2.
So any element of S can be written as: 
S = (S1)^(a) (S2)^(b) (S3)^(c) (S4)^(d) with a,b,c,d in {0,1} (since Pauli group mod phases, we consider ¬±1, but we only care about the Pauli operator up to phase? But careful: The stabilizer condition is that S|œà&gt; = |œà&gt;. That means that the phase must be +1. But if we take a product, it might come with a phase. But since we are considering Pauli errors, they are defined up to phase? Actually, the depolarizing channel: It applies one of the 15 non-identity Paulis. But those Paulis are defined as matrices? They include phases? Typically, Pauli group elements are I, X, Y, Z with factors i sometimes? But usually, the depolarizing channel is defined with the Pauli operators without phases? Actually, the depolarizing channel on a single qubit: It applies I with probability 1-p, and X, Y, Z each with probability p/3. So they are the Pauli matrices. And they are Hermitian. So we take X, Y, Z as the ones with eigenvalues ¬±1. And similarly for two-qubit, the 15 errors are all tensor products of Pauli matrices from {I, X, Y, Z} excluding I‚äóI. And these are all Hermitian. So they have real eigenvalues ¬±1. So when we talk about Pauli errors, we mean these specific matrices. So then the stabilizer group elements that actually stabilize |œà_ideal&gt; are those Paulis that have +1 eigenvalue on |œà_ideal&gt;. But if we take a product of generators, we might get a minus sign? For example, S1 S2? That is XXXX * ZZZZ = (XZ)(XZ)(XZ)(XZ) = ( -i Y)(-i Y)(-i Y)(-i Y) = (i^4? Actually, careful: X Z = -i Y. So product on one qubit: X Z = -i Y. So S1 S2 = (-i)^4 (Y Y Y Y) = (1) (YYYY) = YYYY. But is YYYY a stabilizer? Check: YYYY|œà_ideal&gt;? For |0000&gt;, Y|0&gt; = i|1&gt;, so YYYY|0000&gt; = i^4|1111&gt; = |1111&gt;. For |1111&gt;, Y|1&gt; = -i|0&gt;, so YYYY|1111&gt; = (-i)^4|0000&gt; = |0000&gt;. For |0110&gt;, Y|0&gt;=i|1&gt;, Y|1&gt;=-i|0&gt;, so might give? Actually, it likely gives the state. But wait, could there be a phase? Actually, the stabilizer group is defined as the set of Pauli operators that leave the state invariant. They are not necessarily all products of the generators with coefficients 0,1? Because if you take S1 and S2, they commute and are independent. But S1 S2 is also in the group? But then its eigenvalue on |œà_ideal&gt;? Let&rsquo;s check explicitly: |œà_ideal&gt; = 1/2(|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;). Compute YYYY|œà_ideal&gt;. Y on a qubit: Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;. So for |0000&gt;, YYYY gives (i)^4|1111&gt; = |1111&gt;.
For |1111&gt;, YYYY gives (-i)^4|0000&gt; = |0000&gt;.
For |0110&gt;, qubits: 0:0 -&gt; i|1&gt;, 1:1 -&gt; -i|0&gt;, 2:1 -&gt; -i|0&gt;, 3:0 -&gt; i|1&gt;. So product: i * (-i) * (-i) * i = (i</em>(-i))=1, (-i)<em>(-i)= -1? Let&rsquo;s do carefully: 
On qubit0: factor i.
On qubit1: factor -i.
On qubit2: factor -i.
On qubit3: factor i.
Multiply: i * (-i) = 1, so then 1 * (-i) = -i, then (-i)</em> i = -i^2 = 1. So overall factor 1. And the state becomes: from |0110&gt;, flipping all: becomes |1001&gt;. So that gives |1001&gt;.
Similarly, |1001&gt; becomes |0110&gt;. So indeed, YYYY|œà_ideal&gt; = |œà_ideal&gt;. So it is a stabilizer. So it seems that all products of the generators will give a stabilizer element? But careful: There might be phases. For example, consider S1 S3? That is XXXX * Z1Z2 = X0 X1 X2 X3 * Z1 Z2. On qubit1: X Z = -i Y, on qubit2: X Z = -i Y, so overall factor (-i)<em>(-i)= -1. So S1 S3 = - (X0 X3 Y1 Y2). That operator, if we apply it to |œà_ideal&gt;, might give a minus sign? Let&rsquo;s check: S1 S3|œà_ideal&gt;. Alternatively, we know that S1 and S3 commute? They do commute? Check: S1 and S3: On qubit1, X and Z anticommute, so that gives a minus; on qubit2, similarly minus; so overall they commute. So S1 and S3 are both stabilizers. But their product is also a stabilizer? But then it would have to have eigenvalue +1. But we got a factor of -1 from the multiplication? That -1 is just a phase in the representation of the Pauli group. Actually, the Pauli group elements are defined up to a phase ¬±1, ¬±i. But when we say a Pauli operator P is in the stabilizer of a state, we mean that P|œà&gt; = |œà&gt;. That imposes a condition on the phase. So if we take the generators as given: S1 = XXXX, S2 = ZZZZ, S3 = Z1Z2, S4 = X1X2. These are chosen such that they indeed satisfy S_i|œà&gt; = |œà&gt;. Then any product of these will also give |œà&gt; if the phase is adjusted appropriately. But when we multiply them as matrices, we might get an extra phase. For example, S1 S3: 
S1 = X0 X1 X2 X3.
S3 = Z1 Z2.
Their product: On qubit1: X1 Z1 = -i Y1.
On qubit2: X2 Z2 = -i Y2.
On qubits 0 and 3: X0 and X3 remain.
So S1 S3 = (-i)</em>(-i) X0 (Y1) (Y2) X3 = (-1) X0 Y1 Y2 X3? Actually, (-i)<em>(-i)= i^2 = -1. So S1 S3 = - X0 X3 Y1 Y2. So if we want this to be a stabilizer, we need that - X0 X3 Y1 Y2 |œà&gt; = |œà&gt;. That means that X0 X3 Y1 Y2 |œà&gt; = -|œà&gt;. So actually, X0 X3 Y1 Y2 is not a stabilizer; its eigenvalue is -1. So careful: The stabilizer group is not simply all products of the generators? Actually, the stabilizer group is the set of Pauli operators (with phase ¬±1, but we consider them as operators on the state) that leave the state invariant. The generators are chosen such that they have eigenvalue +1. Then any element of the group (which is a subgroup of the Pauli group modulo phases? Actually, the stabilizer group is usually defined as a set of operators that commute and have eigenvalue +1. If S1 and S3 are in the stabilizer, then their product is also in the stabilizer. So S1 S3 should have eigenvalue +1. But our computation gave S1 S3 = - X0 X3 Y1 Y2. So that would imply that X0 X3 Y1 Y2 has eigenvalue -1. But is that true? Let&rsquo;s check X0 X3 Y1 Y2 on |œà_ideal&gt;. 
Take |0000&gt;: X0 X3 Y1 Y2|0000&gt; = X0|0&gt; * X3|0&gt; * Y1|0&gt; * Y2|0&gt; = |1&gt; * |1&gt; * (i|1&gt;) * (i|1&gt;) = i</em>i |1111&gt; = -|1111&gt;.
|1111&gt;: X0 X3 Y1 Y2|1111&gt; = X0|1&gt; * X3|1&gt; * Y1|1&gt; * Y2|1&gt; = |0&gt; * |0&gt; * (-i|0&gt;) * (-i|0&gt;) = (-i)<em>(-i)|0000&gt; = -|0000&gt;.
|0110&gt;: X0 X3 Y1 Y2|0110&gt; = qubit0:0 -&gt; X0|0&gt;=|1&gt;; qubit1:1 -&gt; Y1|1&gt; = -i|0&gt;; qubit2:1 -&gt; Y2|1&gt; = -i|0&gt;; qubit3:0 -&gt; X3|0&gt;=|1&gt;; so product: factors: from qubit1 and2: (-i)</em>(-i)= -1; so state becomes |1,0,0,1&gt; = |1001&gt;.
|1001&gt;: similarly gives |0110&gt;.
So then X0 X3 Y1 Y2|œà_ideal&gt; = 1/2(-|1111&gt; - |0000&gt; + |1001&gt; + |0110&gt;) = -1/2(|0000&gt;+|1111&gt;) + 1/2(|0110&gt;+|1001&gt;) = - (|00&gt;_L) + (|11&gt;_L)? Actually, |00&gt;_L = (|0000&gt;+|1111&gt;)/‚àö2, |11&gt;_L = (|0110&gt;+|1001&gt;)/‚àö2. So this equals -‚àö2/2 |00&gt;_L + ‚àö2/2 |11&gt;_L = 1/‚àö2 (|11&gt;_L - |00&gt;_L). That is not equal to ¬±|œà_ideal&gt; because |œà_ideal&gt; = 1/‚àö2 (|00&gt;_L+|11&gt;_L). So indeed, X0 X3 Y1 Y2 does not stabilize |œà_ideal&gt;. So then S1 S3 is not actually in the stabilizer? But wait, S1 and S3 are stabilizers. Their product should be in the stabilizer group. There is a phase issue: The stabilizer group is usually defined as a set of operators that commute and that have the state as an eigenvector with eigenvalue +1. If S1 and S3 are such operators, then S1 S3 will also have eigenvalue +1. So there is a consistency condition. Let&rsquo;s check S1 and S3 on |œà_ideal&gt; directly:
S1 = XXXX. We already checked: S1|œà_ideal&gt; = |œà_ideal&gt;.
S3 = Z1Z2. Check: Z1Z2|0000&gt; = |0000&gt;; Z1Z2|1111&gt; = (since qubit1 and2 are 1, so Z gives -1 each, product +1) so |1111&gt;; |0110&gt;: qubit1=1, qubit2=1, so +1; |1001&gt;: qubit1=0, qubit2=0, so +1. So S3|œà_ideal&gt; = |œà_ideal&gt;.
Now, what is S1 S3? That is the operator product. But careful: When we multiply operators, we have to be careful with the order? But since they commute, S1 S3 is well-defined. Let&rsquo;s compute S1 S3|œà_ideal&gt; by applying S3 then S1? But since they commute, it&rsquo;s the same as S1 then S3. So S1 S3|œà_ideal&gt; = S1(S3|œà_ideal&gt;) = S1|œà_ideal&gt; = |œà_ideal&gt;. So indeed, S1 S3 should act as the identity on |œà_ideal&gt;. But our matrix multiplication gave S1 S3 = - X0 X3 Y1 Y2. So there is a discrepancy: It must be that the actual operator S1 S3 is not - X0 X3 Y1 Y2 but rather something that gives a +1 phase. That means that our representation of S1 and S3 as Pauli matrices might have an overall phase choice. In fact, the stabilizer group is defined up to phases. We can choose the phases of the generators such that their products also have phase +1. For example, if we take S1 = XXXX and S3 = Z1Z2, then S1 S3 computed as matrices: 
X0 X1 X2 X3 * Z1 Z2. On qubit1, X1 Z1 = -i Y1. On qubit2, X2 Z2 = -i Y2. So that gives (-i)<em>(-i) = -1 times X0 X3 Y1 Y2. So S1 S3 = - X0 X3 Y1 Y2. So to have S1 S3 be a stabilizer (i.e., act as +1 on |œà_ideal&gt;), we would need to define S3&rsquo; = -Z1Z2? But then check S3&rsquo;|œà_ideal&gt;: -Z1Z2|œà_ideal&gt; would give -|œà_ideal&gt; if Z1Z2 gives +1? Actually, Z1Z2 gives +1, so -Z1Z2 gives -1. So that doesn&rsquo;t work either.
Maybe we can adjust S1? If we take S1&rsquo; = -XXXX, then S1&rsquo;|œà_ideal&gt;? -XXXX|œà_ideal&gt; = -|œà_ideal&gt;, so that doesn&rsquo;t work.
So actually, the product of two stabilizers is determined by their action. We computed S1 S3|œà_ideal&gt; should be |œà_ideal&gt;. But our matrix multiplication gives S1 S3 = - X0 X3 Y1 Y2. So then we must have that X0 X3 Y1 Y2|œà_ideal&gt; = -|œà_ideal&gt;. But we computed X0 X3 Y1 Y2|œà_ideal&gt; and got something that is not proportional to |œà_ideal&gt;? Let&rsquo;s recompute X0 X3 Y1 Y2 carefully on each basis state in the support of |œà_ideal&gt;:
The support is: |0000&gt;, |1111&gt;, |0110&gt;, |1001&gt;.
For |0000&gt;:
X0|0&gt;=|1&gt;, X3|0&gt;=|1&gt;, Y1|0&gt;= i|1&gt;, Y2|0&gt;= i|1&gt;. So product = i</em>i |1,1,1,1&gt; = -|1111&gt;.
For |1111&gt;:
X0|1&gt;=|0&gt;, X3|1&gt;=|0&gt;, Y1|1&gt;= -i|0&gt;, Y2|1&gt;= -i|0&gt;. So product = (-i)<em>(-i) |0,0,0,0&gt; = (-1)|0000&gt;? Actually, (-i)</em>(-i)= i^2 = -1. So gives -|0000&gt;.
For |0110&gt;:
q0:0 -&gt; X0|0&gt;=|1&gt;
q1:1 -&gt; Y1|1&gt;= -i|0&gt;
q2:1 -&gt; Y2|1&gt;= -i|0&gt;
q3:0 -&gt; X3|0&gt;=|1&gt;
So product: factors: (-i)<em>(-i)= -1, so state becomes |1,0,0,1&gt; = |1001&gt;.
For |1001&gt;:
q0:1 -&gt; X0|1&gt;=|0&gt;
q1:0 -&gt; Y1|0&gt;= i|1&gt;
q2:0 -&gt; Y2|0&gt;= i|1&gt;
q3:1 -&gt; X3|1&gt;=|0&gt;
Product: i</em>i = -1, so state becomes |0,1,1,0&gt; = |0110&gt;.
So then X0 X3 Y1 Y2|œà_ideal&gt; = 1/2( -|1111&gt; - |0000&gt; + |1001&gt; + |0110&gt; ) = -1/2(|0000&gt;+|1111&gt;) + 1/2(|0110&gt;+|1001&gt;) = - (|00&gt;_L)/‚àö2 + (|11&gt;_L)/‚àö2 = 1/‚àö2 (|11&gt;_L - |00&gt;_L). That is not equal to -|œà_ideal&gt; because |œà_ideal&gt; = 1/‚àö2 (|00&gt;_L+|11&gt;_L). So indeed, X0 X3 Y1 Y2|œà_ideal&gt; is orthogonal to |œà_ideal&gt;? Actually, the inner product between (|11&gt;_L - |00&gt;_L) and (|00&gt;_L+|11&gt;_L) is 0. So S1 S3|œà_ideal&gt; would be - times that, so it is also orthogonal to |œà_ideal&gt;. That means that S1 and S3 do not commute? But they should commute because they act on different sets? Actually, S1 acts on all qubits, S3 acts on qubits 1 and 2. They should commute? Check: S1 = X0X1X2X3, S3 = Z1Z2. On qubit1, X and Z anticommute, so that gives a sign. On qubit2, similarly sign. So overall, they commute because two anticommutations give a positive sign. So they commute. Then if both stabilize |œà_ideal&gt;, then their product should also stabilize |œà_ideal&gt;. There is a inconsistency. Let&rsquo;s check S1 and S3 directly on |œà_ideal&gt; without using the product form. 
We know S1|œà_ideal&gt; = |œà_ideal&gt;.
S3|œà_ideal&gt; = |œà_ideal&gt;.
So then S1 S3|œà_ideal&gt; = S1(S3|œà_ideal&gt;) = S1|œà_ideal&gt; = |œà_ideal&gt;. So it must be that S1 S3|œà_ideal&gt; = |œà_ideal&gt;. 
Now, let&rsquo;s compute S1 S3|œà_ideal&gt; by applying S3 then S1 to each term manually.
|œà_ideal&gt; = 1/2(|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;).
First, apply S3 = Z1Z2.
Z1Z2|0000&gt; = (Z1|0&gt;)(Z2|0&gt;)|00&gt; = (+1)(+1)|0000&gt; = |0000&gt;.
Z1Z2|1111&gt; = on qubits1 and2 are 1, so Z|1&gt; = -|1&gt;, so product (-1)<em>(-1)=+1, so |1111&gt;.
Z1Z2|0110&gt; = qubit1=1 -&gt; -1, qubit2=1 -&gt; -1, product +1, so |0110&gt;.
Z1Z2|1001&gt; = qubit1=0 -&gt; +1, qubit2=0 -&gt; +1, so |1001&gt;.
So S3|œà_ideal&gt; = |œà_ideal&gt;.
Then apply S1 = X0X1X2X3.
X0X1X2X3|0000&gt; = |1111&gt;.
X0X1X2X3|1111&gt; = |0000&gt;.
X0X1X2X3|0110&gt; = X0|0&gt; X1|1&gt; X2|1&gt; X3|0&gt; = |1&gt; * |0&gt; * |0&gt; * |1&gt; = |1001&gt;.
X0X1X2X3|1001&gt; = |0110&gt;.
So S1(S3|œà_ideal&gt;) = 1/2(|1111&gt;+|0000&gt;+|1001&gt;+|0110&gt;) = |œà_ideal&gt;. So indeed, S1 S3|œà_ideal&gt; = |œà_ideal&gt;. 
Now, what is the Pauli operator for S1 S3? S1 is X0X1X2X3. S3 is Z1Z2. When we multiply these as matrices, we get: On qubit0: X0.
On qubit1: X1 Z1 =? But careful: The order matters because they act on different qubits, so the product is the tensor product: (X0) ‚äó (X1Z1) ‚äó (X2Z2) ‚äó (X3). But X1Z1 is not simply a Pauli matrix because X and Z do not commute. Actually, wait: Since they act on different qubits, the overall operator is: S1 S3 = (X0) (X1) (X2) (X3) * (Z1)(Z2) but careful: These operators commute across different qubits? Actually, they act on different qubits, so the order doesn&rsquo;t matter. So we can write S1 S3 = X0 X1 X2 X3 * Z1 Z2. But then on qubit1, we have X1 and Z1. But these operators do not commute on the same qubit. However, since they are acting on different qubits, the product is well-defined as: (X0)(X3) * (X1Z1) * (X2Z2). And X1Z1 is not a Pauli matrix because X1Z1 = -i Y1 if we consider the usual Pauli matrices? But wait, Pauli matrices are defined such that X, Y, Z are Hermitian. And we have that X Z = -i Y. So indeed, X1Z1 = -i Y1. So then S1 S3 = X0 * (-i Y1) * (-i Y2) * X3 = X0 X3 * (-i)</em>(-i) Y1 Y2 = X0 X3 * (-1) Y1 Y2 = - X0 X3 Y1 Y2. So that is what we got. So according to this, S1 S3 should be - X0 X3 Y1 Y2. But then we computed its action on |œà_ideal&gt; and got that it gives |œà_ideal&gt;? Let&rsquo;s compute - X0 X3 Y1 Y2 on |œà_ideal&gt; carefully:
For |0000&gt;: - X0X3Y1Y2|0000&gt; = - (|1&gt; from X0)(|1&gt; from X3)(i|1&gt; from Y1)(i|1&gt; from Y2) = - (i<em>i)|1111&gt; = -(-1)|1111&gt; = |1111&gt;.
For |1111&gt;: - X0X3Y1Y2|1111&gt; = - (|0&gt;)(|0&gt;)(-i|0&gt;)(-i|0&gt;) = - ((-i)</em>(-i))|0000&gt; = - (-1)|0000&gt; = |0000&gt;.
For |0110&gt;: - X0X3Y1Y2|0110&gt; = - (|1&gt;)(|1&gt;)(-i|0&gt;)(-i|0&gt;) = - ((-i)<em>(-i))|1001&gt; = - (-1)|1001&gt; = |1001&gt;.
For |1001&gt;: - X0X3Y1Y2|1001&gt; = - (|0&gt;)(|0&gt;)(i|1&gt;)(i|1&gt;) = - (i</em>i)|0110&gt; = - (-1)|0110&gt; = |0110&gt;.
So indeed, - X0 X3 Y1 Y2|œà_ideal&gt; = 1/2(|1111&gt;+|0000&gt;+|1001&gt;+|0110&gt;) = |œà_ideal&gt;. So it works! I earlier computed X0X3Y1Y2 without the minus sign. So the correct operator is S1S3 = - X0X3Y1Y2. And that does stabilize |œà_ideal&gt;. So everything is consistent if we include the phases properly. So the stabilizer group S is actually the set of all Pauli operators (with phases ¬±1, ¬±i) that satisfy P|œà_ideal&gt; = |œà_ideal&gt;. But since we are considering errors that are from the set of Pauli matrices (which are Hermitian and have eigenvalues ¬±1), they will have real phases? Actually, the Pauli matrices are usually taken as X, Y, Z where Y = iœÉ_y? Actually, careful: The Pauli matrices are often defined as: X = [[0,1],[1,0]], Y = [[0,-i],[i,0]], Z = [[1,0],[0,-1]]. So these are Hermitian. Then indeed, XZ = -iY, so that is not Hermitian. So when we multiply Pauli matrices, we might get factors of i. But the errors are only the ones that are Hermitian. So the errors are only those Pauli operators that are products of I, X, Y, Z with overall phase 1 (because if you take a product of Hermitian operators, it is Hermitian if they commute? Actually, product of two Hermitian operators is Hermitian if they commute, but if they anticommute, then the product is anti-Hermitian? Let&rsquo;s check: X and Z are Hermitian. Their product XZ is not Hermitian because (XZ)^‚Ä† = ZX = -XZ. So indeed, the Pauli group elements that are usually considered as errors are those that are Hermitian. And those are exactly the ones with real coefficients (¬±1) because if there is an i, then (iP)^‚Ä† = -i P^‚Ä† = -i P, so that is not equal to iP unless P=0. So the errors are from the set {I, X, Y, Z} on each qubit, and the overall operator is the tensor product, and we consider it with a phase of either +1 or -1 such that it is Hermitian. For example, XZ is not Hermitian because (XZ)^‚Ä† = ZX = -XZ. So the Hermitian Pauli operators are those that are either I, X, Y, Z on each qubit with the understanding that Y is defined as iœÉ_y? Actually, wait: Y is defined as [[0,-i],[i,0]]. That is Hermitian. But then XZ =? XZ = [[0,1],[1,0]] [[1,0],[0,-1]] = [[0,-1],[1,0]] which is i * [[0,i],[-i,0]]? I&rsquo;m getting confused with phases. Let&rsquo;s not go too deep into phases. The important thing is: The errors that occur are from the set of 15 two-qubit Pauli errors. These are operators on two qubits that are tensor products of Pauli matrices from {I, X, Y, Z} but not both I. And these operators are Hermitian. So when we have an error on qubits 2 and 1, it is something like: E = P_2 ‚äó P_1, where P_2, P_1 ‚àà {I, X, Y, Z} and not both I. And similarly for F on qubits 0 and 3: F = Q_0 ‚äó Q_3, with Q_0, Q_3 ‚àà {I, X, Y, Z} not both I.
Then the overall error is F E. This is a Pauli operator on 4 qubits. It will be Hermitian. We want this operator to be in the stabilizer of |œà_ideal&gt;. But careful: The stabilizer of |œà_ideal&gt; consists of Pauli operators that leave |œà_ideal&gt; invariant. But these stabilizer elements might not be Hermitian? Actually, if they stabilize a state, they must be unitary. But they can have phases? However, since |œà_ideal&gt; is a state, if P|œà&gt; = |œà&gt;, then also P^\dagger|œà&gt; = |œà&gt;. So likely the stabilizer elements can be taken to be Hermitian as well. So we want to know: For which Pauli operators P (on the 4 qubits, Hermitian) does P|œà_ideal&gt; = |œà_ideal&gt; hold? And then the fidelity is the probability that F E is such a Pauli.
And as argued, because the circuit overall gives O = (F E) U, the final state is (F E)|œà_ideal&gt;. So the fidelity is 1 if F E is in the stabilizer, and 0 otherwise.
But wait: Could it be that F E has a nonzero overlap even if it is not in the stabilizer? For a stabilizer state, if a Pauli is not in the stabilizer, then its expectation is 0. So yes, fidelity becomes 0.</p>
<p>So then we need to determine the condition on F and E such that F E is in the stabilizer of |œà_ideal&gt;. 
F acts on qubits 0 and 3. E acts on qubits 2 and 1.
Let&rsquo;s denote:
F = (on qubit0: something, on qubit3: something) but careful: F is a two-qubit Pauli on qubits 0 and 3. So it can be written as: F = Œ± * (A_0 ‚äó B_3) where A, B ‚àà {I, X, Y, Z} and Œ± is ¬±1 chosen to make it Hermitian? Actually, typically, the Pauli matrices themselves are Hermitian. So if we take, say, X‚äóZ, that is Hermitian because X and Z are Hermitian and they act on different qubits, so the tensor product is Hermitian. So actually, any product of Pauli matrices (without any additional factors) is Hermitian. Because (P‚äóQ)^‚Ä† = P‚Ä†‚äóQ‚Ä† = P‚äóQ. So indeed, if we take Pauli matrices from {I, X, Y, Z} (with the standard definitions where X, Y, Z are Hermitian), then any tensor product is Hermitian. But wait: Check: X‚äóZ is Hermitian? X is Hermitian, Z is Hermitian, so yes. So then the errors are simply products of these matrices. So we can write:
E = E_2 ‚äó E_1, where E_2, E_1 ‚àà {I, X, Y, Z} and not both I.
F = F_0 ‚äó F_3, where F_0, F_3 ‚àà {I, X, Y, Z} and not both I.
And then the overall error is: F E = (F_0 ‚äó I ‚äó I ‚äó F_3) * (I ‚äó E_1 ‚äó E_2 ‚äó I) = F_0 ‚äó E_1 ‚äó E_2 ‚äó F_3. (Since they act on different qubits, the order doesn&rsquo;t matter.)
So the overall error operator is a Pauli operator on each qubit independently. So we want this operator to be in the stabilizer of |œà_ideal&gt;. The stabilizer of |œà_ideal&gt; we determined has generators: 
S1 = X0 X1 X2 X3
S2 = Z0 Z1 Z2 Z3
S3 = Z1 Z2   (I believe, but careful: We want these to be Hermitian. S3 = Z1Z2 is Hermitian.)
S4 = X1 X2   (Hermitian)
But wait, are these all stabilizers? Check S4: X1X2|œà_ideal&gt; =? We did that earlier, it works.
So any element of the stabilizer will be of the form: 
S = (S1)^a (S2)^b (S3)^c (S4)^d, with a,b,c,d ‚àà {0,1}. But careful: These products might not be Hermitian? They will be Hermitian because each is Hermitian and they commute? Actually, if two Hermitian operators commute, their product is Hermitian. So yes.
So an element S in the stabilizer will act on qubits as:
On qubit0: from S1: if a=1, then X0; from S2: if b=1, then Z0; so on qubit0, it will be either I, X, Z, or XZ which is actually iY up to phase? But wait, X0Z0 is not Hermitian because (XZ)^‚Ä† = ZX = -XZ. So actually, if both a and b are 1, then on qubit0 we get X0Z0. But that is not Hermitian. So there is a phase issue: S1 and S2 are Hermitian. Their product S1S2 is also Hermitian? Check: (S1S2)^‚Ä† = S2S1 = S1S2 since they commute. So S1S2 is Hermitian. But S1S2 on qubit0 gives X0Z0. But X0Z0 is not Hermitian as an operator on qubit0 alone because (XZ)^‚Ä† = ZX = -XZ. So how can that be? The resolution is that when we take the tensor product, the overall phase might come out such that the product is Hermitian. For example, S1S2 = (X0X1X2X3)(Z0Z1Z2Z3) = (X0Z0)(X1Z1)(X2Z2)(X3Z3). Now, each X_iZ_i is not Hermitian. But the product of four such terms: (X0Z0)(X1Z1)(X2Z2)(X3Z3). Is that Hermitian? Let&rsquo;s check: (X0Z0)^‚Ä† = Z0X0 = -X0Z0. So each factor is anti-Hermitian. The product of an even number of anti-Hermitian operators can be Hermitian. Specifically, if A and B are anti-Hermitian, then (AB)^‚Ä† = B^‚Ä†A^‚Ä† = B A = (-A)(-B)? I need to do carefully:
For a single qubit, XZ is anti-Hermitian because (XZ)^‚Ä† = Z^‚Ä†X^‚Ä† = ZX = -XZ.
Now, consider two qubits: (X1Z1)(X2Z2). Its adjoint is (X2Z2)^‚Ä† (X1Z1)^‚Ä† = (Z2X2)(Z1X1) = ( -X2Z2)(-X1Z1) = X2Z2 X1Z1 = X1Z1 X2Z2 (since they commute across different qubits). So indeed, the product of two anti-Hermitian operators is Hermitian. So for four qubits, S1S2 is Hermitian. So when writing the stabilizer element in terms of its action on each qubit, we cannot simply separate it into independent factors because there can be correlated signs. So it&rsquo;s better to determine the condition for a Pauli operator P = P0 ‚äó P1 ‚äó P2 ‚äó P3 (where each P_i is either I, X, Y, or Z) to be in the stabilizer of |œà_ideal&gt;. The condition is that P|œà_ideal&gt; = |œà_ideal&gt;. And |œà_ideal&gt; = 1/2(|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;). For P to stabilize this state, it must map each basis state in the support to itself up to a phase that is the same for all? Actually, careful: If P is a Pauli, it will act on each computational basis state by flipping some bits and multiplying by a phase. For P to leave |œà_ideal&gt; invariant, it must that the action on each basis state gives another basis state that is in the support, and the phases must be such that the overall state is unchanged. So let&rsquo;s derive conditions. Write P = P0 ‚äó P1 ‚äó P2 ‚äó P3. Consider its action on |0000&gt;. P|0000&gt; will be something like: if P0 is I or Z, then qubit0 remains 0; if P0 is X or Y, then qubit0 becomes 1 (with phase factors). So let&rsquo;s denote for each qubit i, the effect: 
If P_i = I or Z, then it leaves |0&gt; as |0&gt; times something? Actually, Z|0&gt;=|0&gt;, I|0&gt;=|0&gt;. So if P_i is I or Z, then it acts as +1 on |0&gt;.
If P_i = X or Y, then X|0&gt;=|1&gt;, Y|0&gt;= i|1&gt;? But careful: Y|0&gt; = i|1&gt; because Y = [[0,-i],[i,0]] so Y|0&gt; = i|1&gt;. So there is a phase. So we might need to be careful with phases. But maybe we can determine the stabilizer conditions by noting that |œà_ideal&gt; is also the result of applying the circuit to |0000&gt;. And we know that the errors become overall Pauli errors. And we want that overall Pauli error to be such that it acts trivially on |0000&gt;? Actually, wait: We had O = (F E) U. So the final state is (F E)|œà_ideal&gt;. For this to equal |œà_ideal&gt;, we need F E to be in the stabilizer of |œà_ideal&gt;. So we need to know which Paulis stabilize |œà_ideal&gt;. We can determine them by using the fact that |œà_ideal&gt; is stabilized by the following operators (I will check them directly):
We already know that XXXX stabilizes it.
ZZZZ stabilizes it.
Z1Z2 stabilizes it.
X1X2 stabilizes it.
What about something like X0X3? Does that stabilize? Check: X0X3|0000&gt; = |1010&gt; which is not in the support. So no.
What about Z0Z3? Z0Z3|0000&gt; = |0000&gt;; Z0Z3|1111&gt; = |1111&gt;; but Z0Z3|0110&gt; =? |0110&gt; because qubit0=0 so Z gives +1, qubit3=0 so +1; Z0Z3|1001&gt; = |1001&gt; because qubit0=1 -&gt; -1, qubit3=1 -&gt; -1, product +1. So actually, Z0Z3 seems to stabilize each term? But wait, check phase: For |1001&gt;, Z0 gives -1, Z3 gives -1, product = +1. So Z0Z3|œà_ideal&gt; = |œà_ideal&gt;. So Z0Z3 is also a stabilizer? But is it independent? Note that Z0Z3 = (ZZZZ)(Z1Z2) because ZZZZ * Z1Z2 = Z0Z1Z2Z3 * Z1Z2 = Z0Z3. So indeed, Z0Z3 is in the stabilizer group. Similarly, X0X3? X0X3|0000&gt; = |1010&gt; not in support. So no.
What about Y0Y3? Possibly not.
So the stabilizer group has 16 elements. They are all products of S1, S2, S3, S4. So an element S will have the form: S = (XXXX)^a (ZZZZ)^b (Z1Z2)^c (X1X2)^d, with a,b,c,d in {0,1}. Let&rsquo;s write what that does on each qubit:
Qubit0: from S1: if a=1, then X0; from S2: if b=1, then Z0; so on qubit0, the Pauli is: I if (a,b)=(0,0); X if (1,0); Z if (0,1); and if (1,1), then we get X0Z0. But as noted, X0Z0 is not itself a Pauli matrix because XZ is proportional to Y up to a phase? Actually, XZ = -iY. So if we want to express this as a Pauli matrix (I, X, Y, Z), then we would have Y times a phase. But careful: The overall operator S will have phases from the multiplication across qubits. Let&rsquo;s actually compute S for a given (a,b,c,d) and see what it is as a tensor product of Pauli matrices on each qubit (up to an overall phase that makes it Hermitian). 
S = (XXXX)^a (ZZZZ)^b (Z1Z2)^c (X1X2)^d.
Write it as: 
On qubit0: contribution from S1^a: X0^a; from S2^b: Z0^b. So on qubit0, the operator is X0^a Z0^b. But note that X0 and Z0 anticommute, so X0Z0 = -Z0X0, but since they are powers, careful: if a=1 and b=1, then we have X0Z0. But as an operator, X0Z0 is not equal to ¬±Y0 because Y0 is defined as iœÉ_y usually? Actually, standard Pauli matrices: œÉ_x, œÉ_y, œÉ_z. And we have œÉ_x œÉ_z = -i œÉ_y. So X0Z0 = -i Y0. So if we want to write the operator on qubit0 in terms of I, X, Y, Z, we would have to absorb phases. So it might be easier to determine the condition for F E to be in the stabilizer by using the fact that F E = F_0 ‚äó E_1 ‚äó E_2 ‚äó F_3. And we want this to equal some S in the stabilizer. So that means that there should exist a,b,c,d such that:
F_0 = (on qubit0 from S) which is determined by a and b.
E_1 = (on qubit1 from S) determined by a,b,c,d.
E_2 = (on qubit2 from S) determined by a,b,c,d.
F_3 = (on qubit3 from S) determined by a,b.
And also, the phases must match up to make the overall operator Hermitian. But since F and E are given as Pauli matrices (I,X,Y,Z) without any additional phases, we can determine the conditions directly by requiring that (F E) |œà_ideal&gt; = |œà_ideal&gt;. And since |œà_ideal&gt; is a specific state, we can compute the action of a Pauli on it conditions. Maybe there is a simpler approach: The fidelity is the probability that no error occurs that changes the state. And errors occur independently on the two CNOT gates. And the errors are depolarizing channels. So the probability that the overall error is identity is (1-p)^2. But wait, could there be errors that are not identity but still leave the state invariant? Yes, if they are in the stabilizer. So we need to count how many error patterns (F and E) yield an overall error that is in the stabilizer.
F is on qubits 0 and 3. There are 15 possible errors for F (non-identity) and also the identity case. So total outcomes for F: 16 outcomes, but with probabilities: identity probability = 1-p, and each non-identity probability = p/15.
Similarly for E: 16 outcomes.
So total outcomes: 256 outcomes. Among these, those that yield F E in the stabilizer will give fidelity 1. Others give fidelity 0.
So the fidelity F = Sum_{(F,E) such that F E in S} Prob(F)*Prob(E).</p>
<p>So we need to determine for which pairs (F, E) is F E in the stabilizer S of |œà_ideal&gt;.
Write F = F_0 ‚äó F_3, where F_0, F_3 ‚àà {I, X, Y, Z} but not both I? Actually, careful: F is the error on the CNOT_{03} gate. The error channel says that with probability p, an error occurs, and that error is one of the 15 non-identity two-qubit Paulis. So if no error occurs, then F = I_{0} ‚äó I_{3}. So that is included. So F can be any Pauli on qubits 0 and 3? Actually, wait: The depolarizing channel: It applies with probability 1-p the identity, and with probability p, it applies one of the 15 non-identity Paulis uniformly. So indeed, F can be any Pauli on qubits 0 and 3? But careful: The Pauli group on two qubits has 16 elements. So F takes one of these 16 outcomes. Similarly, E takes one of 16 outcomes on qubits 2 and 1.
So we want to know: For a given F (which is determined by F_0 and F_3) and E (determined by E_2 and E_1), when is the product operator P = F_0 ‚äó E_1 ‚äó E_2 ‚äó F_3 in the stabilizer S of |œà_ideal&gt;?</p>
<p>Now, what is the stabilizer S? S is the set of Pauli operators that leave |œà_ideal&gt; invariant. We know that S is generated by:
S1 = X0 X1 X2 X3
S2 = Z0 Z1 Z2 Z3
S3 = Z1 Z2
S4 = X1 X2
So any element of S can be written as: S = (S1)^a (S2)^b (S3)^c (S4)^d, where a,b,c,d ‚àà {0,1}. But careful with phases: As discussed, these products will be Hermitian Pauli operators. Let&rsquo;s actually list the stabilizer elements in terms of their action on each qubit. They are 16 in number. They are determined by the conditions that they preserve the state |œà_ideal&gt;. Notice that |œà_ideal&gt; has support on states where qubits 0 and 3 are either both 0 or both 1, and qubits 1 and 2 are either both 0 or both 1? Actually, from the state: |0000&gt;, |1111&gt;, |0110&gt;, |1001&gt;. So indeed, in the support, we have: qubit0 and qubit3 are the same? Check: In |0000&gt;, they are both 0. In |1111&gt;, both 1. In |0110&gt;, qubit0=0, qubit3=0? Actually, |0110&gt;: qubit0=0, qubit3=0. In |1001&gt;: qubit0=1, qubit3=1. So yes, qubit0 and qubit3 are always equal. Also, qubit1 and qubit2: In |0000&gt;, they are both 0. In |1111&gt;, both 1. In |0110&gt;, both 1. In |1001&gt;, both 0. So qubit1 and qubit2 are also always equal. So the state |œà_ideal&gt; is actually a state that is concentrated on the subspace where qubit0 = qubit3 and qubit1 = qubit2. So any Pauli operator that stabilizes |œà_ideal&gt; must commute with the projectors onto these conditions? Actually, if P is to leave |œà_ideal&gt; invariant, it should map this subspace to itself. So likely the condition for P to be in the stabilizer is that its action on qubits 0 and 3 is such that it does not flip the parity between qubit0 and qubit3? And on qubits 1 and 2, it should not flip the parity between qubit1 and qubit2? But wait, consider S1 = XXXX. That flips all qubits. Then qubit0 and qubit3 remain equal because both flip. So that&rsquo;s fine. What about an operator that is X0 alone? That would take |0000&gt; to |1000&gt;, but |1000&gt; is not in the support because then qubit0=1, qubit3=0, so they are not equal. So likely a necessary and sufficient condition for a Pauli operator P = P0‚äóP1‚äóP2‚äóP3 to stabilize |œà_ideal&gt; is that it preserves the conditions: P0 and P3 must be such that they either both act as identity or both act as X or both act as Z? But careful: What about Y? Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;. So if acting on a state where qubit0 and qubit3 are both 0, if we apply Y0 and Y3, then we get (i|1&gt;)(i|1&gt;) = -|11&gt; so that gives both 1, so that works actually. So maybe the condition is that the Pauli actions on qubit0 and qubit3 should be the same type? Because then they will either both flip or both not flip? But consider: If on qubit0 we have Z and on qubit3 we have I. Then on |0000&gt;, Z0 I3 gives |0000&gt; still, so that might be okay? But wait, check: Z0 I3|œà_ideal&gt; =? For |0000&gt;, gives |0000&gt;. For |1111&gt;, gives -|1111&gt; because Z on qubit0 gives -1 when qubit0=1. For |0110&gt;, gives |0110&gt; because qubit0=0 so Z gives +1. For |1001&gt;, gives -|1001&gt; because qubit0=1 gives -1. So then the state becomes 1/2(|0000&gt; - |1111&gt; + |0110&gt; - |1001&gt;) which is not equal to |œà_ideal&gt;. So that operator is not in the stabilizer. So indeed, for qubits 0 and 3, the Pauli actions must be either both I, both X, both Y, or both Z? But wait, check: X0 and Z3 would that work? likely not. So condition: P0 and P3 must be either both I, both X, both Y, or both Z. But is that sufficient? Let&rsquo;s test: If P0 = X and P3 = X, then that is S1-like? Actually, that alone is not enough because it also acts on qubits 1 and 2. So overall, for P to be in the stabilizer, we need that on qubits 0 and 3, the Pauli actions are the same (i.e., P0 = P3 up to? Actually, they should be exactly the same Pauli matrix? But wait, could they be both Y? Yes, because YY will send |00&gt; to something like? Y|0&gt;=i|1&gt;, so Y‚äóY|00&gt; = -|11&gt;. So that gives a phase of -1 overall, but that might be okay if compensated by action on qubits 1 and 2? Let&rsquo;s check: Consider P = Y0 ‚äó I1 ‚äó I2 ‚äó Y3. Does that stabilize |œà_ideal&gt;? 
|0000&gt; -&gt; Y0Y3|0000&gt; = (i|1&gt;)(i|1&gt;) = -|1111&gt;.
|1111&gt; -&gt; Y0Y3|1111&gt; = (-i|0&gt;)(-i|0&gt;) = -|0000&gt;.
|0110&gt; -&gt; Y0Y3|0110&gt; = (I on qubit1? Actually, careful: P = Y0 ‚äó I1 ‚äó I2 ‚äó Y3. On |0110&gt;: qubit0=0 -&gt; Y gives i|1&gt;; qubit3=0 -&gt; Y gives i|1&gt;; so becomes -|1110&gt;? But wait, |1110&gt; is not in the support because qubit1=1 but qubit2=0? Actually, |1110&gt; would mean qubits: 1,1,1,0. That is not in the support because for support, qubit1 and qubit2 should be equal. So this operator would take |0110&gt; to something outside the support. So that suggests that the condition is not simply that P0 and P3 are the same type independently. They must also be related to the action on qubits 1 and 2. Because the stabilizer conditions involve correlations across all qubits. So we should use the stabilizer generators directly.</p>
<p>Maybe it&rsquo;s easier to determine the effect of an error on the final state by actually computing the state after errors and then taking the fidelity. Since the errors are Pauli, the final state will be a mixture of states that are Pauli errors applied to |œà_ideal&gt;. And the fidelity is the probability that the applied Pauli is in the stabilizer. So we need to count how many Pauli operators on qubits 0,3 and 2,1 yield an overall Pauli that is in the stabilizer.
Let&rsquo;s denote the Pauli on qubits 0 and 3 as F. There are 16 possibilities for F. Similarly, 16 for E.
We want to know for which pairs (F, E) is F E ‚àà S.
Now, note that S is a subgroup of the Pauli group of order 16. So there are 16 elements in S.
Also, note that F and E act on disjoint sets. So the map (F, E) -&gt; F E is actually a group isomorphism from the direct product of the Pauli groups on {0,3} and {2,1} to the full Pauli group on 4 qubits? Actually, careful: The Pauli group on two qubits has order 16. So the direct product has order 16<em>16=256, and that maps onto the Pauli group on 4 qubits which has order 16^2=256 as well (ignoring phases). So this map is bijective. So essentially, every Pauli operator on 4 qubits can be uniquely written as F E with F acting on {0,3} and E acting on {2,1}. So then the condition that F E is in S is that F E is one of the 16 elements of S. So out of the 256 pairs, exactly 16 will yield F E in S. But wait, is that true? Because the map (F,E) -&gt; F E is a bijection between the set of pairs and the set of 4-qubit Paulis. So there are exactly 16 pairs that give any particular Pauli. So the number of pairs such that F E is in S is 16 * (number of elements in S) but careful: That would be 16</em>16 = 256 if every Pauli in S could be represented? But wait, the map is bijective: For each Pauli P in the full group, there is exactly one pair (F,E) such that F E = P. So if S has 16 elements, then there are exactly 16 pairs (F,E) that yield an outcome in S. Is that right? Let&rsquo;s check: Take the identity operator. Identity can be written as (I_{0}‚äóI_{3}) * (I_{2}‚äóI_{1}). So that&rsquo;s one pair. What about another element of S, say S1 = XXXX. Can we write XXXX as F E where F acts on {0,3} and E acts on {2,1}? Yes: F = X0‚äóX3 and E = X2‚äóX1. So that is one pair. So indeed, for each element of S, there is exactly one pair (F,E) that gives that element. So total number of pairs that yield F E in S is exactly 16.
But wait, are there any pairs where F is identity? That gives identity if E is identity. So that&rsquo;s one.
So then the probability that the overall error is in the stabilizer is: Sum_{(F,E) such that F E in S} Prob(F)<em>Prob(E). But careful: F and E are independent. And their distributions are: For F: P(F) = if F is identity on {0,3} then probability = 1-p; if F is any of the 15 non-identity Paulis, probability = p/15 each.
Similarly for E.
So then the fidelity F = Œ£_{(F,E): F E in S} (Prob(F) * Prob(E)).
Now, this sum is over 16 pairs. These 16 pairs are different. They will have different probabilities depending on whether F is identity or not and whether E is identity or not.
So we need to know, for each element of S, what is its decomposition as F E? But wait, since the map is bijective, each element of S corresponds to a unique pair (F,E). So we need to list the 16 elements of S and determine for each, whether F is identity or not and whether E is identity or not.
S is generated by S1, S2, S3, S4. Let&rsquo;s list them in terms of their action on qubits 0,3 and 1,2. Write an element of S as: It will act on qubits 0 and 3 together and on qubits 1 and 2 together in a correlated way. Actually, note that |œà_ideal&gt; has the property that qubit0 and qubit3 are always equal, and qubit1 and qubit2 are always equal. So likely the stabilizer elements will also respect that structure. In fact, I suspect that for an element of S, the part acting on {0,3} must be either I‚äóI or X‚äóX or Y‚äóY or Z‚äóZ? And similarly for {1,2} must be either I‚äóI or X‚äóX or Y‚äóY or Z‚äóZ? But wait, check: S3 = Z1Z2 is indeed of that form (Z‚äóZ on {1,2}). S4 = X1X2 is X‚äóX on {1,2}. S1 = XXXX means on {0,3} it is X‚äóX and on {1,2} it is X‚äóX. S2 = ZZZZ means on {0,3} it is Z‚äóZ and on {1,2} it is Z‚äóZ.
What about something like S1S3 = XXXX * Z1Z2 = (X‚äóX on {0,3}) and (X‚äóX * Z‚äóZ on {1,2}) but careful: On {1,2}, that gives (X1X2)(Z1Z2) = (X1Z1)(X2Z2) = (-iY1)(-iY2) = (-1) Y1Y2? Actually, (-i)</em>(-i)= -1, so that gives - Y1Y2. But wait, is -Y1Y2 in the form? If we take Y‚äóY, that would be Y1Y2. So S1S3 would be (X‚äóX) ‚äó (-Y‚äóY). So that suggests that on {1,2}, the stabilizer element is actually -Y‚äóY. But can that be? If we act with -Y‚äóY on a state where qubit1 and qubit2 are both 0, we get - (Y|0&gt;)(Y|0&gt;) = - (i|1&gt;)(i|1&gt;) = -(-1)|11&gt; = |11&gt;? Actually, careful: Y|0&gt;= i|1&gt;, so Y‚äóY|00&gt; = i^2|11&gt; = -|11&gt;. So then -Y‚äóY|00&gt; = |11&gt;. So that works. So indeed, it seems that for any stabilizer element, the action on {0,3} will be either I‚äóI, X‚äóX, Y‚äóY, or Z‚äóZ times possibly a phase? And on {1,2} will be either I‚äóI, X‚äóX, Y‚äóY, or Z‚äóZ times a phase such that the overall phase makes the operator have eigenvalue +1 on |œà_ideal&gt;. Let&rsquo;s check: If on {0,3} we have X‚äóX and on {1,2} we have Y‚äóY, then the overall operator is X‚äóX ‚äó Y‚äóY. What is its action on |0000&gt;? That gives (X|0&gt;)(X|0&gt;) (Y|0&gt;)(Y|0&gt;) = (|1&gt;)(|1&gt;) (i|1&gt;)(i|1&gt;) = (1)(i^2)|1111&gt; = -|1111&gt;. On |1111&gt;, it gives (X|1&gt;)(X|1&gt;)(Y|1&gt;)(Y|1&gt;) = (|0&gt;)(|0&gt;)(-i|0&gt;)(-i|0&gt;) = ((-i)<em>(-i))|0000&gt; = (-1)|0000&gt; = -|0000&gt;. On |0110&gt;, it gives? This might not yield a consistent phase across all terms. So likely the stabilizer elements are exactly those where the action on {0,3} is one of {I‚äóI, X‚äóX, Z‚äóZ} and on {1,2} is one of {I‚äóI, X‚äóX, Z‚äóZ}? But wait, we already saw S1S3 gave rise to Y‚äóY on {1,2} actually. Let&rsquo;s determine systematically. An element of S is of the form: S = (S1)^a (S2)^b (S3)^c (S4)^d.
Write S1 = (X0X3) (X1X2)
S2 = (Z0Z3) (Z1Z2)
S3 = (I0I3) (Z1Z2)
S4 = (I0I3) (X1X2)
So then S = [ (X0X3)^a (Z0Z3)^b ] ‚äó [ (X1X2)^a (Z1Z2)^b (Z1Z2)^c (X1X2)^d ] but careful: They commute so order doesn&rsquo;t matter. So on {0,3}, we have: (X0X3)^a (Z0Z3)^b. So that is: if (a,b)=(0,0) -&gt; I‚äóI.
(a,b)=(1,0) -&gt; X‚äóX.
(a,b)=(0,1) -&gt; Z‚äóZ.
(a,b)=(1,1) -&gt; (X0X3)(Z0Z3) = X0Z0 X3Z3. But as noted, X0Z0 = -i Y0, and X3Z3 = -i Y3, so product = (-i)</em>(-i) Y0Y3 = (-1) Y0Y3. So that gives - Y0Y3. So on {0,3}, if (a,b)=(1,1), we get - Y‚äóY.
On {1,2}, we have: (X1X2)^a (Z1Z2)^b (Z1Z2)^c (X1X2)^d = (X1X2)^(a+d) (Z1Z2)^(b+c). So similarly, on {1,2}, we can get I‚äóI, X‚äóX, Z‚äóZ, or if (a+d, b+c) both 1 then we get - Y‚äóY.
So indeed, the stabilizer elements are determined by two independent choices for the {0,3} part and the {1,2} part. But wait, are all these 4*4=16 actually stabilizers? They will be if the overall phase works out to give +1 on |œà_ideal&gt;. Let&rsquo;s check an element where on {0,3} is -Y‚äóY and on {1,2} is -Y‚äóY. Then S = (-Y0Y3)(-Y1Y2) = Y0Y1Y2Y3. What is that on |0000&gt;? Y|0&gt;= i|1&gt;, so product = i^4|1111&gt; = |1111&gt;. On |1111&gt;, Y|1&gt; = -i|0&gt;, so product = (-i)^4|0000&gt; = |0000&gt;. On |0110&gt;, likely it gives |0110&gt;? So that works. So indeed, the stabilizer group S consists of operators that act on {0,3} as either I‚äóI, X‚äóX, Z‚äóZ, or -Y‚äóY? But wait, could it be that sometimes it is Y‚äóY instead of -Y‚äóY? Let&rsquo;s determine the phase carefully. We want S|œà_ideal&gt; = |œà_ideal&gt;. Consider an element where on {0,3} is given by something and on {1,2} is given by something. Since |œà_ideal&gt; is an equal superposition of states where qubit0=qubit3 and qubit1=qubit2, it might be that the phase condition forces that the operator on each pair must actually be either I, X, Z, or actually Y but with a specific sign. I will trust the generator method. So then, the stabilizer elements are exactly those for which the action on {0,3} is one of: I‚äóI, X‚äóX, Z‚äóZ, or -Y‚äóY; and the action on {1,2} is one of: I‚äóI, X‚äóX, Z‚äóZ, or -Y‚äóY. But wait, could there be an element where on {0,3} is, say, X‚äóX and on {1,2} is -Y‚äóY? That would be S1S3 perhaps. We already computed that works. So yes.
So then, if an overall error P = F E is in S, then its restriction to {0,3} must be one of these four types, and its restriction to {1,2} must be one of these four types. But careful: P = F E means that the part on {0,3} is exactly F (since E acts trivially on {0,3}) and the part on {1,2} is exactly E (since F acts trivially on {1,2}). So for P to be in S, we need that:
F must be one of: I‚äóI, X‚äóX, Z‚äóZ, or -Y‚äóY on qubits 0 and 3.
And E must be one of: I‚äóI, X‚äóX, Z‚äóZ, or -Y‚äóY on qubits 2 and 1. (Note: careful with order: E acts on qubits 2 and 1. So E should be such that it is either I2‚äóI1, X2‚äóX1, Z2‚äóZ1, or -Y2‚äóY1.)</p>
<p>But wait, are these all? Let&rsquo;s check: If F = I‚äóI and E = I‚äóI, then that&rsquo;s identity, works.
If F = X‚äóX and E = X‚äóX, then that gives XXXX, works.
If F = Z‚äóZ and E = Z‚äóZ, then that gives ZZZZ, works.
If F = -Y‚äóY and E = -Y‚äóY, then that gives YYYY? Actually, careful: -Y‚äóY means on qubit0: -Y, on qubit3: Y? Actually, when we write F acting on qubits 0 and 3, F is a two-qubit Pauli. It can be written as F = Œ± * (P0 ‚äó Q3) where P,Q ‚àà {I,X,Y,Z} and Œ± is ¬±1 to make it Hermitian? Actually, wait: The Pauli matrices themselves are Hermitian. So if we take, say, Y‚äóY, that is Hermitian because Y is Hermitian and tensor product of Hermitian is Hermitian. So why would we have a minus sign? Because when we multiply generators, we got -Y‚äóY sometimes. So indeed, the stabilizer element is not necessarily just the tensor product of the same Pauli on each qubit; it might have an overall minus sign. So for example, consider the stabilizer element corresponding to (a,b)=(1,1) on {0,3} gives: (X0X3)(Z0Z3) = X0Z0 X3Z3. Now, X0Z0 = -i Y0, so that is (-i)(-i) Y0Y3 = (-1) Y0Y3. So that stabilizer element is actually - Y0Y3. So indeed, on {0,3}, the stabilizer element is -Y‚äóY, not Y‚äóY. So that means that if F itself is Y‚äóY (i.e., Y on qubit0 and Y on qubit3), then F would be Y‚äóY. But is Y‚äóY in the stabilizer? Let&rsquo;s check: Y‚äóY on {0,3} applied to a state where both are 0 gives Y|0&gt;‚äóY|0&gt; = (i|1&gt;)(i|1&gt;) = -|11&gt;. So that would send |00&gt; to -|11&gt;. But wait, could that be compensated by the action on {1,2}? If overall we want the state to be invariant, then if on {0,3} we have Y‚äóY, then on {1,2} we would need something that sends |00&gt; to -|00&gt; to cancel? Actually, let&rsquo;s determine: Suppose P = (Y0Y3) ‚äó (Y1Y2). Then on |0000&gt;, that gives (Y|0&gt;)^4 = (i)^4|1111&gt; = |1111&gt;. On |1111&gt;, gives (-i)^4|0000&gt; = |0000&gt;. On |0110&gt;, gives? This actually might work out to be |œà_ideal&gt; itself? Let&rsquo;s check properly: P = Y0Y1Y2Y3. Compute Y|0&gt;= i|1&gt;, Y|1&gt;=-i|0&gt;. So on |0000&gt;, we get i^4|1111&gt;=|1111&gt;. On |1111&gt;, (-i)^4|0000&gt;=|0000&gt;. On |0110&gt;, qubit0:0 -&gt; i|1&gt;; qubit1:1 -&gt; -i|0&gt;; qubit2:1 -&gt; -i|0&gt;; qubit3:0 -&gt; i|1&gt;; product phase = i * (-i) * (-i) * i = (i<em>(-i))=1, (-i)</em>(-i)= -1? Let&rsquo;s do carefully: phase = i * (-i) = 1 for first two? Actually, better: i * (-i) = -i^2 = 1. Then that result times (-i) = -i, then times i = -i^2 = 1. So actually, phase = 1. So |0110&gt; goes to |1001&gt;. And |1001&gt; goes to |0110&gt;. So indeed, YYYY|œà_ideal&gt; = |œà_ideal&gt;. So wait, that suggests that Y‚äóY on {0,3} actually would be if taken alone? But careful: Y‚äóY on {0,3} means just acting on qubits 0 and 3 with Y on each. That operator is Y0Y3. Is that in the stabilizer? If we take P = Y0Y3 ‚äó I1I2, then acting on |0000&gt; gives Y0Y3|00&gt; = i^2|11&gt; = -|11&gt;, so that gives -|1100&gt; which is not in the support because qubit1 and qubit2 are 0,0 actually that is |1100&gt; is not in the support because for support, qubit0 should equal qubit3? Actually, |1100&gt; means qubit0=1, qubit3=0, so that&rsquo;s not in the support. So indeed, the stabilizer conditions couple the two pairs. So the correct statement is: An overall Pauli P is in the stabilizer if and only if its restrictions to {0,3} and {1,2} are such that they are both of the form: either I‚äóI, or X‚äóX, or Z‚äóZ, or they could be Y‚äóY but then there must be a relative sign between them? Actually, from the generator method, we got that on {0,3}, the possibilities are: I‚äóI, X‚äóX, Z‚äóZ, and when (a,b)=(1,1) we get -Y‚äóY. So that means that if the {0,3} part is Y‚äóY, then it would actually be -Y‚äóY to be in the stabilizer? But wait, could there be an element where the {0,3} part is Y‚äóY itself? Let&rsquo;s see: If we take S1S2? S1S2 = (XXXX)(ZZZZ) = (XZ)(XZ)(XZ)(XZ) = (-iY)(-iY)(-iY)(-iY) = ( (-i)^4 ) (YYYY) = YYYY. So that would give on {0,3}: Y0Y3 and on {1,2}: Y1Y2. So that suggests that actually, Y‚äóY on {0,3} and Y‚äóY on {1,2} together give an element of the stabilizer? But careful: S1S2 = (XXXX)(ZZZZ). But wait, are both S1 and S2 stabilizers? Yes, they are. So S1S2 should be a stabilizer. And S1S2 =? Let&rsquo;s compute S1S2 explicitly as operators acting on each qubit independently. S1 = X0X1X2X3. S2 = Z0Z1Z2Z3. These commute so order doesn&rsquo;t matter. On qubit0, we have X0Z0. But X0Z0 is not simply Y0 because X0Z0 = -i Y0. So actually, S1S2 = (X0Z0)(X1Z1)(X2Z2)(X3Z3) = (-i)^4 (Y0Y1Y2Y3) = Y0Y1Y2Y3. So indeed, S1S2 = Y0Y1Y2Y3. So that means that if we take F such that its action on {0,3} is Y0Y3 (i.e., F = Y‚äóY) and E such that its action on {1,2} is Y1Y2 (i.e., E = Y‚äóY), then F E = Y0Y3 Y1Y2 = YYYY, which is S1S2. And does that stabilize |œà_ideal&gt;? We already checked YYYY does stabilize |œà_ideal&gt;. So that means that actually, for the {0,3} part, the stabilizer condition is that F should be either I‚äóI, X‚äóX, Z‚äóZ, or Y‚äóY? But wait, then what about the case we got from (a,b)=(1,1) which gave -Y‚äóY? That came from S1^1 S2^1? Actually, S1S2 would correspond to a=1,b=1,c=0,d=0. That gives on {0,3}: (X0X3)(Z0Z3) = we computed that as (-i)(-i) Y0Y3 = (-1) Y0Y3. So that suggests that S1S2 should be -Y0Y3 on {0,3} times something on {1,2}? I need to be very careful with phases. Let&rsquo;s determine the stabilizer elements explicitly using the generators with a specific phase convention. We want each generator to be Hermitian and to satisfy G|œà_ideal&gt; = |œà_ideal&gt;. We already know that:
S1 = X0X1X2X3. This is Hermitian. And we checked that S1|œà_ideal&gt; = |œà_ideal&gt;.
S2 = Z0Z1Z2Z3. Hermitian. works.
S3 = Z1Z2. Hermitian. works.
S4 = X1X2. Hermitian. works.
Now, any element of the stabilizer is of the form: S = (S1)^a (S2)^b (S3)^c (S4)^d. But careful: When multiplying these, they commute so order doesn&rsquo;t matter. Let&rsquo;s compute these products and determine their action on each qubit clearly.
Let‚Äôs denote an element by (a,b,c,d). Then S = S1^a S2^b S3^c S4^d.
Now, since these operators act on different qubits, we can separate them into qubit0,3 and qubit1,2 parts because S3 and S4 act only on 1,2 and S1 and S2 act on all but they factor as (on 0,3) and (on 1,2)). Specifically:
S1 = (X0X3) (X1X2)
S2 = (Z0Z3) (Z1Z2)
S3 = (I) (Z1Z2)
S4 = (I) (X1X2)
So then S = [ (X0X3)^a (Z0Z3)^b ] ‚äó [ (X1X2)^a (Z1Z2)^b (Z1Z2)^c (X1X2)^d ] = [ (X0X3)^a (Z0Z3)^b ] ‚äó [ (X1X2)^(a+d) (Z1Z2)^(b+c) ].
Now, let‚Äôs compute the factor on qubits 0 and 3. Let A = (X0X3)^a (Z0Z3)^b.
If (a,b) = (0,0): A = I.
(1,0): A = X0X3.
(0,1): A = Z0Z3.
(1,1): A = (X0X3)(Z0Z3) = X0Z0 X3Z3. Now, X0Z0 = -i Y0, and X3Z3 = -i Y3, so this product = (-i)*(-i) Y0Y3 = (-1) Y0Y3. So A = - Y0Y3.
So on qubits 0 and 3, the possible outcomes are: I, X0X3, Z0Z3, and -Y0Y3.
Now on qubits 1 and 2, let B = (X1X2)^(a+d) (Z1Z2)^(b+c).
So depending on (a+d) and (b+c), we get:
If (a+d, b+c) = (0,0): B = I.
(1,0): B = X1X2.
(0,1): B = Z1Z2.
(1,1): B = (X1X2)(Z1Z2) = X1Z1 X2Z2 = (-i)(-i) Y1Y2 = (-1) Y1Y2 = -Y1Y2.
So then S = A ‚äó B.
So the stabilizer elements are exactly those where:
On {0,3}: either I, X‚äóX, Z‚äóZ, or -Y‚äóY.
On {1,2}: either I, X‚äóX, Z‚äóZ, or -Y‚äóY.
Now check consistency with S1S2 that I earlier thought was YYYY. S1S2 corresponds to (a,b,c,d)=(1,1,0,0). Then A = -Y0Y3, B = -Y1Y2, so S = (-Y0Y3)(-Y1Y2) = Y0Y1Y2Y3. So that gives YYYY. Good.
So indeed, the stabilizer conditions are:
F must be such that its action on {0,3} is one of: I‚äóI, X‚äóX, Z‚äóZ, or -Y‚äóY.
And E must be such that its action on {1,2} is one of: I‚äóI, X‚äóX, Z‚äóZ, or -Y‚äóY.
But wait: F is the error on the second CNOT gate. F is applied directly to qubits 0 and 3. So F itself is a Pauli operator on these two qubits. So for F to contribute to a stabilizer overall, we need that F is one of these four operators: I0I3, X0X3, Z0Z3, or -Y0Y3. But careful: Is -Y0Y3 itself a Pauli operator? Yes, because Y0Y3 is Hermitian, so -Y0Y3 is also Hermitian. So these are valid Pauli operators. So on qubits 0 and 3, the stabilizer requires that F is either:
F = I0I3,
or F = X0X3,
or F = Z0Z3,
or F = -Y0Y3.
Similarly, on qubits 2 and 1, for E, we need that E is either:
E = I2I1,
or E = X2X1,
or E = Z2Z1,
or E = -Y2Y1.</p>
<p>Now, are there any other possibilities? What if F = Y0Y3 itself? Then that would not be in this list because that would be Y0Y3, not -Y0Y3. So indeed, the conditions are that:
F ‚àà { I‚äóI, X‚äóX, Z‚äóZ, -Y‚äóY } on qubits 0 and 3.
E ‚àà { I‚äóI, X‚äóX, Z‚äóZ, -Y‚äóY } on qubits 2 and 1.</p>
<p>Let&rsquo;s check one: If F = Y0Y3 (instead of -Y0Y3), then consider the pair where E = I. Then overall error = Y0Y3 ‚äó I1I2. Does that stabilize |œà_ideal&gt;? likely not. So that makes sense.</p>
<p>So then, the fidelity is the probability that F is in that set AND E is in that set such that their product gives an element of S? But wait, is it sufficient that F is in that set and E is in that set? If F is in that set and E is in that set, then F E will be something where on {0,3} is one of these and on {1,2} is one of these, which is exactly an element of S. So yes, the condition for F E to be in S is that F is one of these 4 operators on {0,3} and E is one of these 4 operators on {1,2}. But wait, is that also necessary? Suppose F is not in that set but still F E is in S. Since F E factors as (F)(E) and since these act on different qubits, if F E is in S, then its restriction to {0,3} must be one of those four. But that restriction is exactly F. So indeed, F must be in {I‚äóI, X‚äóX, Z‚äóZ, -Y‚äóY}. Similarly, E must be in {I‚äóI, X‚äóX, Z‚äóZ, -Y‚äóY}. So the condition is both.</p>
<p>Therefore, the number of favorable outcomes is: For F, there are 4 favorable outcomes out of 16. For E, there are 4 favorable outcomes out of 16. And they are independent. So total favorable outcomes = 4 * 4 = 16. That matches our earlier count from the bijection argument? Actually, wait, that would give 16 favorable outcomes if they were independent? But careful: The map (F,E) -&gt; F E is bijective. The stabilizer S has 16 elements. So there should be exactly 16 pairs that yield an element in S. If favorable outcomes were that F is in a set of size 4 and E is in a set of size 4, that would give 16 outcomes. So that is consistent. So indeed, the condition for fidelity to be 1 is that F is one of these 4 and E is one of these 4.</p>
<p>Now, what are the probabilities of these favorable outcomes?
For F: The depolarizing channel on two qubits: It gives identity with probability (1-p) and each of the 15 non-identity Paulis with probability p/15.
Among the favorable outcomes for F, the identity is one outcome. The other favorable outcomes are: X‚äóX, Z‚äóZ, and -Y‚äóY. But wait: Are these all non-identity? Yes, they are non-identity. So the probability that F is favorable is: Prob(F is identity) + Prob(F is X‚äóX) + Prob(F is Z‚äóZ) + Prob(F is -Y‚äóY). = (1-p) + 3*(p/15) = (1-p) + (3p/15) = (1-p) + (p/5) = 1 - p + p/5 = 1 - (4p/5).</p>
<p>Similarly, for E, the probability that E is favorable is also: 1 - (4p/5).</p>
<p>And since F and E are independent, the probability that both are favorable is [1 - (4p/5)]^2.</p>
<p>Therefore, the fidelity F = [1 - (4p/5)]^2.</p>
<p>But wait: Is that the physical state fidelity? Yes, because if the overall error is in the stabilizer, then the state is perfect. If not, then the state is orthogonal to the ideal state. So the fidelity is exactly that probability.</p>
<p>So the answer should be: Fidelity = (1 - 4p/5)^2.</p>
<p>But wait: Could there be any additional contributions from errors that are not in the stabilizer but still have some overlap? For a stabilizer state, if a Pauli is not in the stabilizer, then its expectation is 0. So no.</p>
<p>Thus, the physical state fidelity is (1 - 4p/5)^2.</p>
<p>I will double-check with a couple of examples:
If p=0, fidelity=1.
If p is small, fidelity ‚âà 1 - (8p/5) so infidelity scales as (8/5)p, which is more than p. That seems plausible because there are two gates each with error probability p, so baseline infidelity would be 2p if errors always caused Orthogonality. But here, some errors are harmless, so infidelity is reduced. Actually, wait, each gate has probability of error that is harmful = probability that the error is not in the favorable set. For a single gate, that probability is 1 - [1-p + 3*(p/15)] = 1 - [1-p+p/5] = 4p/5. So each gate independently has a harmful error probability of 4p/5. And since they are independent, the probability that both are okay is (1 - 4p/5)^2. So that makes sense.</p>
<p>Therefore, the answer is: 
Physical state fidelity = (1 - 4p/5)^2.</p>
<p>So final answer: 
\boxed{(1 - \frac{4p}{5})^2}</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-understand-the-circuit-and-the-ideal-state">Step 1. Understand the Circuit and the Ideal State</h3>
<p>The goal is to prepare the logical GHZ state:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{\sqrt{2}} \left( |00\rangle_{AB} + |11\rangle_{AB} \right)
\]</div>
<p>in the [[4,2,2]] code, where the two logical qubits (A and B) are encoded into four physical qubits (0,1,2,3). The circuit used is:</p>
<div class="arithmatex">\[
\text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2
\]</div>
<p>Operations are applied from right to left. Starting from the initial state <span class="arithmatex">\(|0000\rangle\)</span>, the circuit produces:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right)
\]</div>
<p>This is indeed the desired logical GHZ state.</p>
<hr />
<h3 id="step-2-model-the-errors">Step 2. Model the Errors</h3>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel:</p>
<ul>
<li>With probability <span class="arithmatex">\(1 - p\)</span>, no error occurs.</li>
<li>With probability <span class="arithmatex">\(p\)</span>, an error occurs, and it is uniformly distributed among the 15 non-identity two-qubit Pauli operators.</li>
</ul>
<p>Let:</p>
<ul>
<li><span class="arithmatex">\(E\)</span> be the error on qubits (2,1) after <span class="arithmatex">\(\text{CNOT}_{21}\)</span></li>
<li><span class="arithmatex">\(F\)</span> be the error on qubits (0,3) after <span class="arithmatex">\(\text{CNOT}_{03}\)</span></li>
</ul>
<p>Each error is a Pauli operator on its respective pair of qubits, chosen from the set of 16 possible operators (including identity).</p>
<hr />
<h3 id="step-3-overall-effect-of-errors">Step 3. Overall Effect of Errors</h3>
<p>The full circuit (including errors) acts as:</p>
<div class="arithmatex">\[
O = F \cdot \text{CNOT}_{03} \cdot H_0 \cdot E \cdot \text{CNOT}_{21} \cdot H_2
\]</div>
<p>Since the gates are Clifford operations and the errors are Pauli operators, the overall effect simplifies to:</p>
<div class="arithmatex">\[
O = (F E) \cdot U
\]</div>
<p>where <span class="arithmatex">\(U\)</span> is the ideal circuit. Therefore, the final state is:</p>
<div class="arithmatex">\[
|\psi_{\text{final}}\rangle = (F E) |\psi_{\text{ideal}}\rangle
\]</div>
<hr />
<h3 id="step-4-when-does-an-error-preserve-the-state">Step 4. When Does an Error Preserve the State?</h3>
<p>The fidelity is:</p>
<div class="arithmatex">\[
\mathcal{F} = \left| \langle \psi_{\text{ideal}} | \psi_{\text{final}} \rangle \right|^2 = \left| \langle \psi_{\text{ideal}} | F E | \psi_{\text{ideal}} \rangle \right|^2
\]</div>
<p>Since <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> is a stabilizer state, the overlap is 1 if <span class="arithmatex">\(F E\)</span> is in the stabilizer group <span class="arithmatex">\(S\)</span> of <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span>, and 0 otherwise.</p>
<p>The stabilizer group <span class="arithmatex">\(S\)</span> is generated by:</p>
<ul>
<li><span class="arithmatex">\(S_1 = X_0 X_1 X_2 X_3\)</span></li>
<li><span class="arithmatex">\(S_2 = Z_0 Z_1 Z_2 Z_3\)</span></li>
<li><span class="arithmatex">\(S_3 = Z_1 Z_2\)</span></li>
<li><span class="arithmatex">\(S_4 = X_1 X_2\)</span></li>
</ul>
<p>Any element of <span class="arithmatex">\(S\)</span> can be written as:</p>
<div class="arithmatex">\[
S = (S_1)^a (S_2)^b (S_3)^c (S_4)^d, \quad a,b,c,d \in \{0,1\}
\]</div>
<p>The group <span class="arithmatex">\(S\)</span> has 16 elements. The condition for <span class="arithmatex">\(F E\)</span> to be in <span class="arithmatex">\(S\)</span> is that:</p>
<ul>
<li><span class="arithmatex">\(F\)</span> acts on qubits (0,3) as one of:<br />
<span class="arithmatex">\(I \otimes I,\quad X \otimes X,\quad Z \otimes Z,\quad -Y \otimes Y\)</span></li>
<li><span class="arithmatex">\(E\)</span> acts on qubits (2,1) as one of:<br />
<span class="arithmatex">\(I \otimes I,\quad X \otimes X,\quad Z \otimes Z,\quad -Y \otimes Y\)</span></li>
</ul>
<hr />
<h3 id="step-5-compute-the-fidelity">Step 5. Compute the Fidelity</h3>
<p>The fidelity is the probability that both <span class="arithmatex">\(F\)</span> and <span class="arithmatex">\(E\)</span> are &ldquo;good&rdquo; (i.e., in the favorable sets above).</p>
<p>For a single two-qubit gate:</p>
<ul>
<li>Probability of identity (good): <span class="arithmatex">\(1 - p\)</span></li>
<li>Probability of a specific non-identity Pauli: <span class="arithmatex">\(\frac{p}{15}\)</span></li>
<li>Number of good non-identity Paulis: 3</li>
</ul>
<p>So, the probability that a given error is good is:</p>
<div class="arithmatex">\[
P(\text{good}) = (1 - p) + 3 \cdot \frac{p}{15} = 1 - p + \frac{p}{5} = 1 - \frac{4p}{5}
\]</div>
<p>Since <span class="arithmatex">\(F\)</span> and <span class="arithmatex">\(E\)</span> are independent:</p>
<div class="arithmatex">\[
\mathcal{F} = \left(1 - \frac{4p}{5} \right)^2
\]</div>
<hr />
<h3 id="final-answer">Final Answer</h3>
<div class="arithmatex">\[
\boxed{(1 - \frac{4p}{5})^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given that the fidelity is (1 - 4p/5)^2.
 We will use SymPy to return this expression.
 Note: We are to return a SymPy expression in terms of the symbol p.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>To solve this problem, we need to determine the physical state fidelity of the final 4-qubit state after applying the given quantum circuit with depolarizing errors on the CNOT gates. The fidelity is derived by analyzing the impact of these errors on the prepared logical GHZ state.</p>
<h3 id="approach">Approach</h3>
<ol>
<li><strong>Circuit Analysis</strong>: The circuit prepares the logical GHZ state <span class="arithmatex">\((|00\rangle_{AB} + |11\rangle_{AB})/\sqrt{2}\)</span> using Hadamard and CNOT gates.</li>
<li><strong>Error Model</strong>: Each CNOT gate is followed by a depolarizing error channel that applies a non-identity Pauli error with probability <span class="arithmatex">\(p\)</span>, distributed uniformly among the 15 possible errors.</li>
<li><strong>Error Propagation</strong>: Due to the Clifford nature of the gates, the overall effect of errors simplifies to a Pauli operator applied to the ideal state. The fidelity is 1 if this Pauli operator is in the stabilizer group of the ideal state, and 0 otherwise.</li>
<li><strong>Stabilizer Conditions</strong>: The stabilizer group of the ideal state requires that errors on specific qubit pairs must be of the form <span class="arithmatex">\(I \otimes I\)</span>, <span class="arithmatex">\(X \otimes X\)</span>, <span class="arithmatex">\(Z \otimes Z\)</span>, or <span class="arithmatex">\(-Y \otimes Y\)</span>.</li>
<li><strong>Probability Calculation</strong>: The probability that an error on a CNOT gate is harmless is <span class="arithmatex">\(1 - \frac{4p}{5}\)</span>. Since the errors are independent, the total fidelity is the product of the probabilities for both CNOT gates.</li>
</ol>
<h3 id="solution-code">Solution Code</h3>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div>

<h3 id="final-answer">Final Answer</h3>
<p>The physical state fidelity of the final 4-qubit state as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span> is given by:</p>
<div class="arithmatex">\[
\boxed{\left(1 - \frac{4p}{5}\right)^2}
\]</div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.739167
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>