<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?&rdquo;</p>
<p>Interpretation: We have a circuit that prepares a state. But then we have errors on the CNOT gates. The circuit has two CNOT gates: CNOT_{21} and CNOT_{03}. Also two Hadamard gates: H_0 and H_2. But note: The circuit order: The equation is given as: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). But then note: &ldquo;the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation)&rdquo;. So the actual circuit order is: Start with initial state? Typically, we start with all qubits in |0&gt;? But problem doesn&rsquo;t explicitly say initial state? But since it&rsquo;s state preparation, likely initial state is |0000&gt;? But then we apply gates: first H_2, then CNOT_{21}, then H_0, then CNOT_{03}. So circuit: 
Step 1: H on qubit 2.
Step 2: CNOT with control qubit 2, target qubit 1.
Step 3: H on qubit 0.
Step 4: CNOT with control qubit 0, target qubit 3.</p>
<p>We want to prepare logical GHZ state: (|00&gt;_AB + |11&gt;_AB)/√2. But careful: The code is [[4,2,2]]. The logical states? The code encodes two qubits. The logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI. So what are the logical basis states? They are defined as states that are +1 eigenstates of the stabilizers? Actually, the code is a stabilizer code with stabilizers: S1 = XXXX, S2 = ZZZZ. And then logical operators. So the logical states are: 
|00&gt;_L, |01&gt;_L, |10&gt;__L, |11&gt;_L. They are defined up to phase. But here we want a GHZ state on the logical qubits: (|00&gt;_AB + |11&gt;_AB)/√2. That is a state in the code space? Possibly yes.</p>
<p>Let&rsquo;s check: The circuit: H_2, CNOT_{21}, H_0, CNOT_{03}. Applied to initial state |0000&gt;? 
Qubits: 0,1,2,3.
After H_2: state becomes |0&gt;0, |0&gt;1, H|0&gt;2 = (|0&gt;+|1&gt;)/√2, |0&gt;3. So state: (|0000&gt; + |0010&gt;)/√2.
Then CNOT_{21}: control qubit 2, target qubit 1. So:
|0000&gt; becomes |0000&gt; because control=0.
|0010&gt; becomes |0010&gt;? Actually careful: CNOT_{21}: if qubit2 is |1&gt;, then flip qubit1. So |0010&gt; becomes |0110&gt;? But wait: qubits order: 0,1,2,3. So state: |q0,q1,q2,q3&gt;. So |0010&gt; means: q0=0, q1=0, q2=1, q3=0. Under CNOT_{21}: control is q2, target is q1. So if q2=1, then flip q1. So |0010&gt; becomes |0110&gt;? But then q1 becomes 1. So state becomes (|0000&gt; + |0110&gt;)/√2.
Then H_0: Hadamard on qubit 0. So:
|0000&gt; -&gt; H on qubit0: (|0&gt;+|1&gt;)/√2 on qubit0, so becomes (|0000&gt; + |1000&gt;)/√2.
|0110&gt; -&gt; H on qubit0: (|0110&gt; + |1110&gt;)/√2? But careful: H on qubit0: |0&gt; -&gt; (|0&gt;+|1&gt;)/√2, |1&gt; -&gt; (|0&gt;-|1&gt;)/√2. But here qubit0 is 0 in |0000&gt; and 0 in |0110&gt;? Actually, check: In |0110&gt;, qubit0 is 0? Because it&rsquo;s 0,1,1,0. So indeed qubit0=0. So then H_0 gives: (|0&gt;+|1&gt;)/√2 on qubit0. So |0110&gt; becomes (|0110&gt; + |1110&gt;)/√2.
So overall state after H_0: = 1/√2 * [ (|0000&gt;+|1000&gt;)/√2 + (|0110&gt;+|1110&gt;)/√2 ] = 1/2 (|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;).
Then CNOT_{03}: control qubit 0, target qubit 3.
Apply CNOT_{03}:
For each term:
|0000&gt;: control=0 so no flip: remains |0000&gt;.
|1000&gt;: control=1 so flip qubit3: becomes |1001&gt;.
|0110&gt;: control=0 so no flip: remains |0110&gt;.
|1110&gt;: control=1 so flip qubit3: becomes |1111&gt;.
So final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>Now, is that the logical GHZ state? The logical states: 
We have logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI.
What are the logical basis states? They are defined as eigenvectors of Z_A and Z_B. 
Z_A = ZZII. So its eigenvalues: For state |0000&gt;, Z_A: Z on qubit0 and qubit1: both 0 so product? Actually, careful: Z on qubit0 and qubit1: Z⊗Z on qubits 0 and 1. For |00&gt;, eigenvalue +1. So |0000&gt; gives +1. For |1001&gt;: qubits0 and1: |10&gt; gives -1? Actually, Z⊗Z: eigenvalues: if both same then +1, if different then -1. So |10&gt; gives -1. So |1001&gt; gives eigenvalue -1 for Z_A. Similarly, |0110&gt;: qubits0 and1: |01&gt; gives -1. |1111&gt;: gives +1.
So Z_A: |0000&gt; and |1111&gt; are +1; |1001&gt; and |0110&gt; are -1.
Z_B = ZIZI. So on qubits: qubit0 and qubit2? Actually careful: Z_B = Z I Z I. So it acts on qubit0 and qubit2. For |0000&gt;: qubits0 and2: |00&gt; gives +1. For |1001&gt;: qubits0 and2: |10&gt; gives -1. For |0110&gt;: qubits0 and2: |01&gt; gives -1. For |1111&gt;: qubits0 and2: |11&gt; gives +1.
So indeed, the states: 
|0000&gt; corresponds to Z_A=+1, Z_B=+1 so that is logical |00&gt;_L.
|1111&gt; corresponds to Z_A=+1, Z_B=+1? Actually check: |1111&gt;: Z_A: on qubits0,1: both 1 so product +1; Z_B: on qubits0,2: both 1 so product +1. So |1111&gt; is also logical |00&gt;_L? But wait, then they are not orthogonal? But they are in the code space? Actually, the code space is 4-dimensional. The logical states are defined modulo the stabilizers. The stabilizers are XXXX and ZZZZ. Check: XXXX on |0000&gt; gives +1? Actually, XXXX|0000&gt; = |1111&gt;? That is not necessarily an eigenstate? Actually, stabilizer means that the code space is the subspace that is +1 eigenvector of both stabilizers. So for a state to be in the code space, it must satisfy S1|ψ&gt; = |ψ&gt; and S2|ψ&gt; = |ψ&gt;. Our state: |0000&gt; is not necessarily in the code space because S1|0000&gt; = |1111&gt; which is not proportional to |0000&gt;. So the code space is not simply these basis states. Actually, the [[4,2,2]] code is a stabilizer code. The stabilizers are XXXX and ZZZZ. So the code space is the subspace of the 4-qubit Hilbert space that is invariant under these operators. The dimension is 2^4 / 2^2 = 4. So the logical states are superpositions. In fact, the logical states are usually given by:
|00&gt;_L = (|0000&gt;+|1111&gt;)/√2? But then check stabilizers: XXXX on that gives (|1111&gt;+|0000&gt;)/√2 = same, so +1. ZZZZ on that gives (|0000&gt;+(-1)^4|1111&gt;)/√2 = (|0000&gt;+|1111&gt;)/√2, so +1. So that is a valid state. And then |01&gt;_L = (|0011&gt;+|1100&gt;)/√2? But then our state we got is 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). That is not obviously a logical state. But wait, the problem says: &ldquo;prepare a logical two-qubit GHZ state (|00&gt;_AB + |11&gt;_AB)/√2&rdquo;. That is a state on two logical qubits. But note: The logical qubits are encoded in 4 physical qubits. So the GHZ state is: (|00&gt;_L + |11&gt;_L)/√2. And what are |00&gt;_L and |11&gt;_L? They are states in the code space. Typically, for the [[4,2,2]] code, one representation is:
|00&gt;_L = (|0000&gt;+|1111&gt;)/√2,
|01&gt;_L = (|0011&gt;+|1100&gt;)/√2,
|10&gt;_L = (|0101&gt;+|1010&gt;)/√2,
|11&gt;__L = (|0110&gt;+|1001&gt;)/√2.
Check: Then Z_A = ZZII. On |00&gt;_L: (|0000&gt;+|1111&gt;)/√2, Z_A gives: on first two qubits: for |00&gt;, product +1; for |11&gt;, product +1. So eigenvalue +1. On |11&gt;_L: (|0110&gt;+|1001&gt;)/√2, Z_A: on |01&gt; gives -1, on |10&gt; gives -1, so eigenvalue -1. And Z_B = ZIZI: on |00&gt;_L: qubits0 and2: |00&gt; gives +1, |11&gt; gives +1; on |11&gt;_L: |01&gt; gives -1, |10&gt; gives -1. So that works. And also stabilizers: XXXX on |00&gt;_L gives (|1111&gt;+|0000&gt;)/√2 = |00&gt;_L; on |11&gt;_L gives (|1001&gt;+|0110&gt;)/√2 = |11&gt;_L. So indeed, these are valid logical states.
Then our prepared state is: 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;) = 1/2 [ (|0000&gt;+|1111&gt;) + (|1001&gt;+|0110&gt;) ] = 1/√2 * (|00&gt;_L + |11&gt;_L)/√2? Actually, careful: |00&gt;_L = (|0000&gt;+|1111&gt;)/√2, so that part is √2 * |00&gt;_L. And |11&gt;_L = (|1001&gt;+|0110&gt;)/√2, so that part is √2 * |11&gt;_L. So then state = 1/2 (√2|00&gt;_L + √2|11&gt;_L) = 1/√2 (|00&gt;_L + |11&gt;_L). So indeed, the circuit prepares the logical GHZ state perfectly if no errors.</p>
<p>Now, we introduce errors. The errors occur on the CNOT gates. There are two CNOT gates: CNOT_{21} and CNOT_{03}. Each CNOT gate is followed by a two-qubit depolarizing error channel on the two qubits involved. That error channel: With probability p, an error occurs. And if an error occurs, it is uniformly distributed among the 15 non-identity two-qubit Paulis. So each CNOT gate&rsquo;s error model: After the ideal CNOT, we apply with probability p/15 each of the 15 Pauli errors on the two qubits (the ones that are not identity on both). And with probability 1-p, no error.</p>
<p>We want: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; 
Interpretation: The fidelity between the ideal state (which is the state we would get if no errors) and the actual state that comes out from the circuit with errors. But careful: The circuit has two CNOT gates. Each CNOT gate is followed by an error channel. So the overall transformation is: 
Start with initial state: presumably |0000&gt;? Yes.
Then apply: H_2 (no error on single-qubit gates? Problem says: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. So only CNOT gates have errors. So Hadamard gates are perfect.)
So steps:</p>
<ol>
<li>H_2: perfect.</li>
<li>CNOT_{21} followed by error channel on qubits 2 and 1. So after this step, the state is: E_{21} ∘ CNOT_{21} applied to state after H_2.</li>
<li>H_0: perfect.</li>
<li>CNOT_{03} followed by error channel on qubits 0 and 3.</li>
</ol>
<p>We want the fidelity of the final state relative to the ideal state (which is the state we computed without errors: |ψ_ideal&gt; = 1/√2 (|00&gt;_L + |11&gt;_L) = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;)).</p>
<p>But careful: The error channels are applied after each CNOT. They are quantum channels. So the final state is a mixed state. We want the fidelity between that mixed state and the ideal pure state. Fidelity F = sqrt(&lt;ψ|ρ|ψ&gt;). But maybe they mean the state fidelity? Often &ldquo;physical state fidelity&rdquo; might mean the overlap between the actual state and the ideal state. But since the actual state is mixed, fidelity is defined as F(ρ, σ) = Tr(√(√ρ σ √ρ)) but if σ is pure, then F = √(⟨ψ|ρ|ψ⟩). So we want ⟨ψ_ideal| ρ_final |ψ_ideal⟩.</p>
<p>So we need to compute the final density matrix ρ. It is obtained by applying the channels in sequence. Since the errors are Pauli errors, we can compute the probability that the overall error is a certain Pauli on the 4 qubits. And then the final state will be a mixture of states that are the ideal state acted by some Pauli errors. And because the ideal state might be invariant under some Paulis? But careful: The errors occur at different steps. They act on different qubits. And they are applied after the gates. So we need to propagate these errors through subsequent gates. But maybe we can compute the effect by tracking the cumulative error operator. Alternatively, we can compute the fidelity as: F = probability that no error occurs that changes the state from the ideal? But careful: Some errors might act trivially on the ideal state? That is, if an error operator E is such that E|ψ_ideal&gt; = |ψ_ideal&gt; (up to phase), then that error does not reduce fidelity. But wait: The depolarizing channel gives a random Pauli. But these Paulis are applied at intermediate steps. But then they get propagated through subsequent gates. So we need to compute the overall effect: Let U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2. But careful: The errors occur after each CNOT. So the actual operation is: 
After step 1: state = H_2 |0000&gt;.
Step 2: Apply CNOT_{21} ideally, then apply an error Pauli on qubits 2 and 1. That error is one of the 15 Paulis on qubits 2 and 1. Let&rsquo;s denote that error as E^{(2)} on qubits (2,1). But note: The Paulis are products of Pauli X, Y, Z on these two qubits. So it is of the form P_i ⊗ P_j on qubits 2 and 1, where (P_i, P_j) is not (I,I). 
Step 3: Apply H_0. That acts on qubit 0 only.
Step 4: Apply CNOT_{03} ideally, then apply an error Pauli on qubits 0 and 3. That error is on qubits (0,3). Denote it as F^{(4)}.</p>
<p>So overall, the final state (if we fix a particular error pattern) is: 
|ψ_final&gt; = F^{(4)} * CNOT_{03} * H_0 * E^{(2)} * CNOT_{21} * H_2 |0000&gt;.
But note: The errors are random. So the final density matrix is: 
ρ = Sum over errors (probability) * |ψ_final&gt;&lt;ψ_final|.</p>
<p>We want &lt;ψ_ideal| ρ |ψ_ideal&gt; = average over errors of |&lt;ψ_ideal|ψ_final&gt;|^2.</p>
<p>Now, note that the ideal state is: |ψ_ideal&gt; = U_total |0000&gt; where U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2.
So if there were no errors, we get that.
Now, if there is an error pattern, then |ψ_final&gt; = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2 |0000&gt;, but careful: The error E is applied after the first CNOT, so it comes before H_0 and CNOT_{03}. So we can write: 
|ψ_final&gt; = F * CNOT_{03} * H_0 * E * (CNOT_{21} * H_2) |0000&gt;.
But note that U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2. So if we define V = CNOT_{21} * H_2, then U_total = CNOT_{03} * H_0 * V.
Then |ψ_final&gt; = F * CNOT_{03} * H_0 * E * V |0000&gt;.
And |ψ_ideal&gt; = CNOT_{03} * H_0 * V |0000&gt;.
So then &lt;ψ_ideal|ψ_final&gt; = &lt;0000| V^\dagger H_0^\dagger CNOT_{03}^\dagger * F * CNOT_{03} * H_0 * E * V |0000&gt;.
= &lt;0000| V^\dagger * (H_0^\dagger CNOT_{03}^\dagger F CNOT_{03} H_0) * E * V |0000&gt;.
But note that H_0 and CNOT_{03} act on qubits 0 and 3. And F is a Pauli on qubits 0 and 3. And H_0 and CNOT_{03} will conjugate Paulis on qubits 0 and 3 into other Paulis. So let&rsquo;s define: For a Pauli on qubits 0 and 3, after conjugation by CNOT_{03} and H_0? But careful: The order: H_0^\dagger CNOT_{03}^\dagger F CNOT_{03} H_0. But note: H_0 acts only on qubit 0. And CNOT_{03} acts on qubits 0 and 3. So we can compute the conjugation of Paulis on qubits 0 and 3 under these gates. But maybe we can compute the overall effect by tracking the errors through the circuit. Alternatively, we can compute the fidelity by considering that the errors are Pauli errors and the ideal state is a stabilizer state? Actually, the ideal state is a specific state in the code space. But note: The circuit is not necessarily fault-tolerant? But we want the physical fidelity. That is the overlap between the actual state and the ideal state.</p>
<p>Maybe we can compute the probability that the final state is exactly the ideal state. That is: The fidelity F = probability that no error occurs that changes the state? But careful: Some errors might act as identity on the state? That is, if an error operator (after propagation) becomes an element of the stabilizer of the ideal state, then it will leave the state invariant. So then the fidelity would be the sum of probabilities of errors that are either identity or in the stabilizer group of the ideal state. But is that true? If we have a Pauli error E such that E|ψ_ideal&gt; = |ψ_ideal&gt; (up to phase), then if that error occurs, the final state is still |ψ_ideal&gt;. So then that error pattern gives fidelity 1. But wait: But careful: The errors occur at different times. They propagate through the circuit. So we want to know: What is the overall operator that acts on the initial state? That is: O = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2. And we want to know when does O|0000&gt; equal |ψ_ideal&gt; (up to global phase)? That is equivalent to: O U_total^\dagger |ψ_ideal&gt; = |ψ_ideal&gt;? Actually, since |ψ_ideal&gt; = U_total|0000&gt;, we want O = U_total * (something that acts as identity on |0000&gt;)? Actually, we want: O|0000&gt; = |ψ_ideal&gt; = U_total|0000&gt;. So we want U_total^\dagger O to act as identity on |0000&gt;. But |0000&gt; is not necessarily invariant under all Paulis? But note: The initial state is |0000&gt;. So if U_total^\dagger O is a Pauli that fixes |0000&gt;? But |0000&gt; is an eigenstate of Z on each qubit. So if U_total^\dagger O is a Pauli that is a product of Z&rsquo;s? Actually, careful: |0000&gt; is the state where all qubits are 0. That state is stabilized by Z_i. So if a Pauli operator P acts on |0000&gt;, it will give a phase if P is a product of Z&rsquo;s? Actually, if P contains any X or Y, then it will flip some qubits and will not give |0000&gt;. So for P to leave |0000&gt; invariant (up to phase), P must be a product of Z&rsquo;s and I&rsquo;s. But wait: Could it be that P|0000&gt; = |0000&gt;? For example, Z_0|0000&gt; = |0000&gt; because |0&gt; is eigenvalue +1. So indeed, if P is a Pauli that is only Z&rsquo;s and I&rsquo;s, then P|0000&gt; = |0000&gt; (since Z|0&gt;=|0&gt;). But if there is an X, then it flips to |1&gt; so not invariant. So the condition for the error to not affect the final state (i.e., the final state is still the ideal state) is that the overall error operator (after propagating through the circuit) is an operator that acts as identity on the initial state |0000&gt;. But careful: The overall operator is U_total^\dagger O. But O = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2. And U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2. So U_total^\dagger O = (H_2^\dagger CNOT_{21}^\dagger H_0^\dagger CNOT_{03}^\dagger) * (F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2) = H_2^\dagger CNOT_{21}^\dagger H_0^\dagger (CNOT_{03}^\dagger F CNOT_{03}) H_0 E CNOT_{21} H_2.
That is messy.</p>
<p>Maybe it&rsquo;s easier to compute the fidelity directly by averaging over error patterns. The fidelity is: F = ∑_{error patterns} (probability) * |&lt;ψ_ideal|ψ_final&gt;|^2.
And &lt;ψ_ideal|ψ_final&gt; = &lt;0000| U_total^\dagger O |0000&gt;.
So if we can compute the operator U_total^\dagger O. But O depends on errors E and F. Let&rsquo;s denote:
E: error on qubits 2 and 1 after first CNOT. It is a Pauli on qubits 2 and 1. There are 15 possibilities plus identity.
F: error on qubits 0 and 3 after second CNOT. Pauli on qubits 0 and 3.
And these are independent? Actually, they occur with probabilities: For first CNOT: with probability 1-p, no error; with probability p, an error occurs, and then uniformly among 15 Paulis. So probability for a specific non-identity Pauli on {2,1} is p/15. Similarly for second CNOT: probability for a specific non-identity on {0,3} is p/15, and probability no error is 1-p.</p>
<p>So then overall, the fidelity is: 
F = (1-p)^2 * 1 (when both errors are identity) 
+ plus cases where either error is non-identity but the overall effect is such that U_total^\dagger O acts as identity on |0000&gt;? But careful: Even if the overall operator is not identity, it might still have overlap with identity? But wait: |&lt;ψ_ideal|ψ_final&gt;|^2 = |&lt;0000| U_total^\dagger O |0000&gt;|^2. And U_total^\dagger O is a unitary operator (since it&rsquo;s a product of unitaries). So its matrix element with |0000&gt; is some complex number. But if U_total^\dagger O is a Pauli operator (because all gates are Clifford and errors are Pauli, so overall, U_total^\dagger O is a Clifford transformation of Pauli errors? Actually, check: U_total is a Clifford circuit? It consists of Hadamards and CNOTs. So it is Clifford. And errors are Pauli. So U_total^\dagger O will be a Pauli operator (up to maybe a phase) because Clifford gates map Paulis to Paulis. So indeed, U_total^\dagger O is a Pauli operator on the 4 qubits. Let&rsquo;s check: 
O = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2.
U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2.
So U_total^\dagger O = (H_2^\dagger CNOT_{21}^\dagger H_0^\dagger CNOT_{03}^\dagger) * (F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2)
= H_2^\dagger CNOT_{21}^\dagger H_0^\dagger (CNOT_{03}^\dagger F CNOT_{03}) H_0 E CNOT_{21} H_2.
Now, F is a Pauli on qubits 0 and 3. CNOT_{03}^\dagger F CNOT_{03} is also a Pauli on qubits 0 and 3 (because CNOT is Clifford). Then H_0^\dagger (that) H_0 is a Pauli on qubits 0 and 3? Actually, H_0 acts only on qubit 0. So it will map Paulis on qubit 0 to other Paulis. So overall, the product inside becomes a Pauli on qubits 0 and 3. Then we have E which is a Pauli on qubits 2 and 1. So the product is a Pauli on qubits 0,3 and 2,1? But careful: They act on disjoint sets? Actually, qubits: 0,1,2,3. The first part acts on qubits 0 and 3. E acts on qubits 2 and 1. So they commute. So then we have: U_total^\dagger O = H_2^\dagger CNOT_{21}^\dagger (P_{03} * E) CNOT_{21} H_2, where P_{03} = H_0^\dagger (CNOT_{03}^\dagger F CNOT_{03}) H_0. And note that CNOT_{21} acts on qubits 2 and 1. And H_2 acts on qubit 2. So then this整体 is a Pauli operator on all qubits? Because Clifford conjugation of a Pauli is a Pauli. So indeed, U_total^\dagger O is a Pauli operator on the 4 qubits. Let&rsquo;s denote it as Q. So then &lt;0000| Q |0000&gt; is nonzero only if Q is a Pauli that is diagonal in the computational basis and does not flip any qubit. That is, Q must be a product of I and Z&rsquo;s. And even then, it might give a phase. But |&lt;0000|Q|0000&gt;|^2 will be 1 if Q acts as a phase on |0000&gt; (since |0&gt; is eigenvector of Z with eigenvalue 1). But wait: If Q = Z_i, then &lt;0|Z|0&gt;=1, so that&rsquo;s fine. But if Q contains any X or Y, then it will flip some qubit and the overlap with |0000&gt; is 0. So the fidelity for a given error pattern is 1 if the overall Pauli Q (which is U_total^\dagger O) is such that it only has factors I and Z on the qubits. And if it has any X or Y, then the overlap is 0. But is that exactly true? Check: If Q = X_0, then &lt;0000|X_0|0000&gt; = &lt;0000|1000&gt; = 0. So yes.
So then the fidelity F = probability that the overall error operator Q is in the set of Paulis that are products of I and Z on each qubit. But careful: There might be a phase factor? But |&lt;0000|Q|0000&gt;|^2 = 1 if Q|0000&gt; = ±|0000&gt;. And that happens if Q is a product of Z&rsquo;s and I&rsquo;s. Because Z|0&gt;=|0&gt;, so indeed. So condition: Q should have no X or Y on any qubit. So we need to compute: For given errors E (on qubits 2,1) and F (on qubits 0,3), what is Q = U_total^\dagger O? And we want that Q is a Pauli operator that only contains I and Z on each qubit.</p>
<p>Maybe we can compute this by propagating the errors through the circuit. Alternatively, we can compute the effect of each error on the final state directly. That is: The final state with errors: |ψ_final&gt; = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2 |0000&gt;. And we want the overlap with |ψ_ideal&gt; = CNOT_{03} * H_0 * CNOT_{21} * H_2 |0000&gt;. So that overlap is &lt;0000| H_2^\dagger CNOT_{21}^\dagger H_0^\dagger CNOT_{03}^\dagger F CNOT_{03} H_0 E CNOT_{21} H_2 |0000&gt;. That is as before.</p>
<p>Maybe it&rsquo;s easier to compute by simulating the effect of errors on the state. But the state is a superposition. Alternatively, we can compute the probability that the final state is exactly the ideal state. That is: The errors are Pauli errors. They will transform the state to some Pauli applied to the ideal state? Actually, note: The circuit is Clifford. So if we have an error Pauli at some point, then the overall effect is that the final state is some Pauli (which is a function of the error) applied to the ideal state. But careful: The errors occur at different times. But because the circuit is Clifford, the overall effect is that the final state is: |ψ_final&gt; = P |ψ_ideal&gt; for some Pauli P that depends on the errors. And then the fidelity is |&lt;ψ_ideal|P|ψ_ideal&gt;|^2. And that is 1 if P is in the stabilizer of |ψ_ideal&gt;, and 0 otherwise? But is that true? For a stabilizer state, if P is a Pauli that is not in the stabilizer, then typically &lt;ψ|P|ψ&gt; = 0. But wait: There might be cases where P is not in the stabilizer but still has nonzero overlap? For a stabilizer state, the expectation value of any Pauli is either ±1 or 0. Actually, for a stabilizer state, if P is in the stabilizer group, then &lt;ψ|P|ψ&gt; = 1. If P is not in the stabilizer, then it anticommutes with some stabilizer, so the expectation is 0. So indeed, if the final state is P|ψ_ideal&gt;, then the fidelity is 1 if P is in the stabilizer of |ψ_ideal&gt;, and 0 otherwise. But wait: Could it be that P is not exactly a Pauli? But we argued that overall, the effect is a Pauli operator on the initial state? Actually, careful: The errors are applied at intermediate steps. But because the circuit is Clifford, the overall operation from initial state to final state is: O = (error at end?) Actually, consider: The ideal circuit is U. With errors, we have: O = (F) * U_2 * (E) * U_1, where U_1 and U_2 are parts of U. But U is Clifford. But is it true that O = P U for some Pauli P? That would be if the errors commute through the gates in a nice way. But here, the errors are applied after some gates. So O = F * U_2 * E * U_1. And U = U_2 * U_1. So O = F * U_2 * E * U_2^\dagger * U_2 * U_1 = (F * (U_2 E U_2^\dagger)) * U. So indeed, if we define P = F * (U_2 E U_2^\dagger), then O = P U, provided that U_2 E U_2^\dagger commutes with F? But careful: U_2 here is: U_2 = CNOT_{03} * H_0. And E acts on qubits 2 and 1. And U_2 acts on qubits 0 and 3 and also H_0 on qubit 0. But wait, U_2 and E act on disjoint sets? Actually, E acts on qubits 2 and 1. U_2 acts on qubits 0 and 3 and also H_0 on qubit 0. So they commute? Actually, they act on different qubits, so they commute. So indeed, U_2 E U_2^\dagger = E because U_2 does not affect qubits 2 and 1? But careful: U_2 includes H_0. H_0 acts on qubit 0, but that is separate from qubits 2 and 1. So yes, they commute. So then O = F * U_2 * E * U_1 = F * E * U_2 * U_1 = (F E) * U, because F and E act on different qubits? But wait: F acts on qubits 0 and 3, E acts on qubits 2 and 1. So they commute. So indeed, O = (F E) U. That is much simpler! Check: The circuit: 
U = CNOT_{03} * H_0 * CNOT_{21} * H_2.
And errors: After first CNOT, we apply E on qubits 2,1. After second CNOT, we apply F on qubits 0,3.
But careful: The order: The actual operation is: 
Step: H_2 (perfect)
Then: CNOT_{21} then error E on (2,1)
Then: H_0 (perfect)
Then: CNOT_{03} then error F on (0,3)
So overall: O = F * CNOT_{03} * H_0 * (E * CNOT_{21} * H_2) but note: E commutes with H_0? H_0 acts on qubit 0, E on qubits 2,1, so yes. And E commutes with CNOT_{03}? CNOT_{03} acts on qubits 0,3, so yes. So then O = F * CNOT_{03} * H_0 * CNOT_{21} * H_2 * E? But careful: E is applied after CNOT_{21}, so it is: CNOT_{21} then E. But do CNOT_{21} and E commute? E is on qubits 2,1. CNOT_{21} is on qubits 2,1 as well. They do not necessarily commute. So we cannot simply move E to the end. Let&rsquo;s do it step by step:
O = F * CNOT_{03} * H_0 * (E * CNOT_{21}) * H_2. 
Now, note that E and H_0 commute because they act on different qubits. So O = F * CNOT_{03} * (H_0 * E) * CNOT_{21} * H_2 = F * CNOT_{03} * (E * H_0) * CNOT_{21} * H_2 = F * CNOT_{03} * E * H_0 * CNOT_{21} * H_2.
Now, does E commute with CNOT_{03}? CNOT_{03} acts on qubits 0 and 3. E acts on qubits 2 and 1. So yes, they commute. So O = F * E * CNOT_{03} * H_0 * CNOT_{21} * H_2 = F * E * U.
So indeed, O = (F E) U. That is very nice.
So the overall effect is that the errors simply multiply as Pauli operators on the final state. But wait: Is that always true? Check with a simple example: Suppose only error E occurs. Then O = E * CNOT_{21} * H_2? Actually, careful: The circuit: H_2, then CNOT_{21} then error E, then H_0, then CNOT_{03}. That gives O = CNOT_{03} * H_0 * (E * CNOT_{21} * H_2) = CNOT_{03} * H_0 * E * CNOT_{21} * H_2? But then we argued that E commutes with H_0 and CNOT_{03}? Yes, because E acts on qubits 2,1 and H_0 acts on qubit 0, and CNOT_{03} acts on qubits 0,3. So then O = E * CNOT_{03} * H_0 * CNOT_{21} * H_2 = E * U. So that works.
And if only error F occurs: O = F * CNOT_{03} * H_0 * CNOT_{21} * H_2 = F * U. So indeed, overall, O = (F E) U. But careful: What about the order? F and E act on disjoint sets, so they commute. So the overall error operator is just the product of the two errors. So then the final state (if there is a specific error pattern) is: |ψ_final&gt; = (F E) U |0000&gt; = (F E) |ψ_ideal&gt;.
So then the fidelity for that error pattern is: |&lt;ψ_ideal| F E |ψ_ideal&gt;|^2.
And since F and E are Pauli operators on disjoint sets, F E is a Pauli operator on the 4 qubits. And as argued, for a stabilizer state, the overlap is 1 if F E is in the stabilizer group of |ψ_ideal&gt;, and 0 otherwise.
So we need to determine the stabilizer of |ψ_ideal&gt;. |ψ_ideal&gt; is the logical GHZ state: (|00&gt;_L + |11&gt;_L)/√2. But careful: That state is not necessarily a stabilizer state of the code? Actually, it is a state in the code space? But its stabilizer group? The code space itself has stabilizers: XXXX and ZZZZ. But |ψ_ideal&gt; is a specific state within that space. Its stabilizer group will be larger than the code&rsquo;s stabilizer? Actually, for a given state, the stabilizer is the set of Paulis that leave it invariant. For the GHZ state, typically there are generators. But we can compute: |ψ_ideal&gt; = 1/√2 (|00&gt;_L + |11&gt;_L) = 1/2 (|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;). What Paulis leave this state invariant? 
Check: XXXX: XXXX|ψ_ideal&gt; = ? XXXX applied to each term: |0000&gt; -&gt; |1111&gt;; |1111&gt; -&gt; |0000&gt;; |0110&gt; -&gt; |1001&gt;; |1001&gt; -&gt; |0110&gt;. So XXXX|ψ_ideal&gt; = |ψ_ideal&gt;. So XXXX is a stabilizer.
ZZZZ: ZZZZ|ψ_ideal&gt; =? Z on each: |0000&gt; -&gt; |0000&gt;; |1111&gt; -&gt; (-1)^4|1111&gt;=|1111&gt;; |0110&gt; -&gt;? Actually, careful: ZZZZ means Z on each qubit. For |0110&gt;: qubits: 0:0 -&gt; +1, 1:1 -&gt; -1, 2:1 -&gt; -1, 3:0 -&gt; +1, so product = (+1)<em>(-1)</em>(-1)<em>(+1)=+1? Actually, (-1)</em>(-1)=+1, so overall +1. For |1001&gt;: qubit0:1 -&gt; -1, qubit1:0 -&gt; +1, qubit2:0 -&gt; +1, qubit3:1 -&gt; -1, product = (-1)<em>(+1)</em>(+1)<em>(-1)=+1. So ZZZZ also gives +1. So both stabilizers of the code act as +1 on |ψ_ideal&gt;. But are there others? 
Also, consider the logical operators? For instance, Z_A ⊗ Z_B? But Z_A = ZZII, Z_B = ZIZI. Their product? Actually, careful: The state is |00&gt;_L + |11&gt;_L. That state is stabilized by Z_A ⊗ Z_B? Because on |00&gt;_L, Z_A and Z_B are both +1 so product +1; on |11&gt;_L, Z_A and Z_B are both -1 so product +1. So indeed, Z_A Z_B (which is ZZII * ZIZI = Z Z I I? Actually, careful: Z_A = Z on qubit0 and qubit1? Actually, Z_A = ZZII means: Z on qubit0, Z on qubit1, I on qubit2, I on qubit3.
Z_B = ZIZI means: Z on qubit0, I on qubit1, Z on qubit2, I on qubit3.
So Z_A Z_B = (Z on qubit0)^2? Actually, product: on qubit0: Z * Z = I? Wait, careful: Pauli multiplication: Z_A = Z_0 Z_1, Z_B = Z_0 Z_2. So their product is Z_0 Z_1 * Z_0 Z_2 = (Z_0^2) Z_1 Z_2 = I * Z_1 Z_2 = Z_1 Z_2. So Z_A Z_B = Z_1 Z_2. So that operator: Z on qubit1 and Z on qubit2. Does that stabilize |ψ_ideal&gt;? Check: On |0000&gt;, Z_1 Z_2 gives +1. On |1111&gt;, qubit1 and qubit2 are 1 so product +1. On |0110&gt;, qubit1=1, qubit2=1 so product +1. On |1001&gt;, qubit1=0, qubit2=0 so product +1. So yes, Z_1 Z_2 is a stabilizer of |ψ_ideal&gt;.
Also, what about X_A X_B? X_A = XIXI = X on qubit0 and I on qubit1? Actually, X_A = XIXI means: X on qubit0, I on qubit1, X on qubit2? Wait: X_A = XIXI: indices: qubit0: X, qubit1: I, qubit2: X, qubit3: I. And X_B = XXII: qubit0: X, qubit1: X, qubit2: I, qubit3: I.
So X_A X_B = (X on qubit0 from both gives X^2 = I? Actually, careful: X_A X_B = (X_0 I_1 X_2 I_3) * (X_0 X_1 I_2 I_3) = (X_0^2) (I_1 X_1) (X_2 I_2) (I_3 I_3) = I * X_1 * X_2 * I = X_1 X_2. So X_A X_B = X_1 X_2. Does that stabilize |ψ_ideal&gt;? Check: X_1 X_2 on |0000&gt; gives |0000&gt;? Actually, X_1 X_2|0000&gt; = |0&gt;0 * (X|0&gt;1) * (X|0&gt;2) * |0&gt;3 = |0&gt;0 |1&gt;1 |1&gt;2 |0&gt;3 = |0110&gt;? That is not |0000&gt;. So X_1 X_2 does not necessarily stabilize the state? But wait, the GHZ state is stabilized by X_A X_B? Actually, for a GHZ state |00&gt;+|11&gt;, the stabilizer includes X⊗X. But here X_A X_B would be X on both logical qubits. And on |00&gt;_L + |11&gt;_L, X⊗X swaps them, so that gives the same state. So indeed, X_A X_B should stabilize the state. But we computed X_A X_B as X_1 X_2. But then applying X_1 X_2 to |0000&gt; gives |0110&gt;, and that is part of the state. But then the state is a superposition. So we need to check: X_1 X_2 |ψ_ideal&gt; = 1/2 (X_1 X_2|0000&gt; + X_1 X_2|1111&gt; + X_1 X_2|0110&gt; + X_1 X_2|1001&gt;) = 1/2 (|0110&gt; + |1001&gt; + |0000&gt; + |1111&gt;) = |ψ_ideal&gt;. So yes, X_1 X_2 is also a stabilizer.
Also, what about? There might be more. The full stabilizer of the GHZ state? Actually, the state |ψ_ideal&gt; is a stabilizer state on 4 qubits? But wait, it is a state in a 4-qubit Hilbert space. Its stabilizer group will have 4 generators? Actually, for a pure state, the stabilizer subgroup of the Pauli group that fixes it has size? For n qubits, a stabilizer state is defined by n independent generators. So here n=4, so the stabilizer group should have 4 generators. We already have: S1 = XXXX, S2 = ZZZZ, S3 = Z_1 Z_2, S4 = X_1 X_2. Check if these commute? 
XXXX and ZZZZ commute? They anticommute? Actually, XXXX and ZZZZ: product of X and Z on each qubit gives -1 each, so overall sign? Actually, careful: For each qubit, X and Z anticommute. So product over 4 qubits: (X1 Z1) &hellip; = (-1)^4? Actually, if we take two Paulis, they commute if the number of qubits where they are different and both non-identity is even. For XXXX and ZZZZ, on each qubit, both are non-identity, so that&rsquo;s 4 qubits, and 4 is even, so they commute. So that&rsquo;s fine.
Z_1 Z_2 commutes with XXXX? On qubits 1 and 2, X and Z anticommute? Actually, check: XXXX has X on qubit1 and X on qubit2. Z_1 Z_2 has Z on qubit1 and Z on qubit2. On qubit1, X and Z anticommute, so that gives a minus sign. On qubit2, similarly minus sign. So overall, they commute. And with ZZZZ? They commute because Z&rsquo;s commute. 
X_1 X_2 commutes with XXXX? Obviously. With ZZZZ? On qubits 1 and 2, Z and X anticommute, so two minus signs give plus. So these four are independent? They generate a group of size 16. So the stabilizer of |ψ_ideal&gt; is the group generated by {XXXX, ZZZZ, Z1Z2, X1X2}. But wait, are there relations? For example, (XXXX)(X1X2) =? That gives X on qubits 0,3 and I on 1,2? That is not necessarily in the group. So indeed, the stabilizer group has 4 generators, so size 16.
But careful: The condition for fidelity to be 1 is that the overall error operator F E is in the stabilizer of |ψ_ideal&gt;. But wait: Is that sufficient? Because if F E is in the stabilizer, then F E |ψ_ideal&gt; = |ψ_ideal&gt;. So yes.
But also, could it be that F E is not in the stabilizer but still gives a nonzero overlap? For a stabilizer state, if a Pauli is not in the stabilizer, then its expectation is 0. So indeed, fidelity is 1 if F E is in the stabilizer, and 0 otherwise.
But wait: There is also the possibility that F E is the identity? That is included in the stabilizer.
So then the fidelity F (the physical state fidelity) is the probability that the combined error operator (F E) is an element of the stabilizer group of |ψ_ideal&gt;. But careful: F and E are independent. But note: F acts on qubits 0 and 3. E acts on qubits 2 and 1. So F E is a Pauli on all 4 qubits. And we want it to be in the stabilizer group S of |ψ_ideal&gt;. What is S? S is generated by: 
S1 = XXXX
S2 = ZZZZ
S3 = Z1Z2
S4 = X1X2.
But note: F acts on qubits 0 and 3. E acts on qubits 2 and 1. So F E will have the form: (something on qubits 0,3) times (something on qubits 2,1). And the stabilizer elements: They are products of these generators. In general, an element of S will be of the form: (X0 X3)^a? Actually, let&rsquo;s write the generators in terms of qubits separately:
S1 = X0 X1 X2 X3.
S2 = Z0 Z1 Z2 Z3.
S3 = Z1 Z2.
S4 = X1 X2.
So any element of S can be written as: 
S = (S1)^(a) (S2)^(b) (S3)^(c) (S4)^(d) with a,b,c,d in {0,1} (since Pauli group mod phases, we consider ±1, but we only care about the Pauli operator up to phase? But careful: The stabilizer condition is that S|ψ&gt; = |ψ&gt;. That means that the phase must be +1. But if we take a product, it might come with a phase. But since we are considering Pauli errors, they are defined up to phase? Actually, the depolarizing channel: It applies one of the 15 non-identity Paulis. But those Paulis are defined as matrices? They include phases? Typically, Pauli group elements are I, X, Y, Z with factors i sometimes? But usually, the depolarizing channel is defined with the Pauli operators without phases? Actually, the depolarizing channel on a single qubit: It applies I with probability 1-p, and X, Y, Z each with probability p/3. So they are the Pauli matrices. And they are Hermitian. So we take X, Y, Z as the ones with eigenvalues ±1. And similarly for two-qubit, the 15 errors are all tensor products of Pauli matrices from {I, X, Y, Z} excluding I⊗I. And these are all Hermitian. So they have real eigenvalues ±1. So when we talk about Pauli errors, we mean these specific matrices. So then the stabilizer group elements that actually stabilize |ψ_ideal&gt; are those Paulis that have +1 eigenvalue on |ψ_ideal&gt;. But if we take a product of generators, we might get a minus sign? For example, S1 S2? That is XXXX * ZZZZ = (XZ)(XZ)(XZ)(XZ) = ( -i Y)(-i Y)(-i Y)(-i Y) = (i^4? Actually, careful: X Z = -i Y. So product on one qubit: X Z = -i Y. So S1 S2 = (-i)^4 (Y Y Y Y) = (1) (YYYY) = YYYY. But is YYYY a stabilizer? Check: YYYY|ψ_ideal&gt;? For |0000&gt;, Y|0&gt; = i|1&gt;, so YYYY|0000&gt; = i^4|1111&gt; = |1111&gt;. For |1111&gt;, Y|1&gt; = -i|0&gt;, so YYYY|1111&gt; = (-i)^4|0000&gt; = |0000&gt;. For |0110&gt;, Y|0&gt;=i|1&gt;, Y|1&gt;=-i|0&gt;, so might give? Actually, it likely gives the state. But wait, could there be a phase? Actually, the stabilizer group is defined as the set of Pauli operators that leave the state invariant. They are not necessarily all products of the generators with coefficients 0,1? Because if you take S1 and S2, they commute and are independent. But S1 S2 is also in the group? But then its eigenvalue on |ψ_ideal&gt;? Let&rsquo;s check explicitly: |ψ_ideal&gt; = 1/2(|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;). Compute YYYY|ψ_ideal&gt;. Y on a qubit: Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;. So for |0000&gt;, YYYY gives (i)^4|1111&gt; = |1111&gt;.
For |1111&gt;, YYYY gives (-i)^4|0000&gt; = |0000&gt;.
For |0110&gt;, qubits: 0:0 -&gt; i|1&gt;, 1:1 -&gt; -i|0&gt;, 2:1 -&gt; -i|0&gt;, 3:0 -&gt; i|1&gt;. So product: i * (-i) * (-i) * i = (i</em>(-i))=1, (-i)<em>(-i)= -1? Let&rsquo;s do carefully: 
On qubit0: factor i.
On qubit1: factor -i.
On qubit2: factor -i.
On qubit3: factor i.
Multiply: i * (-i) = 1, so then 1 * (-i) = -i, then (-i)</em> i = -i^2 = 1. So overall factor 1. And the state becomes: from |0110&gt;, flipping all: becomes |1001&gt;. So that gives |1001&gt;.
Similarly, |1001&gt; becomes |0110&gt;. So indeed, YYYY|ψ_ideal&gt; = |ψ_ideal&gt;. So it is a stabilizer. So it seems that all products of the generators will give a stabilizer element? But careful: There might be phases. For example, consider S1 S3? That is XXXX * Z1Z2 = X0 X1 X2 X3 * Z1 Z2. On qubit1: X Z = -i Y, on qubit2: X Z = -i Y, so overall factor (-i)<em>(-i)= -1. So S1 S3 = - (X0 X3 Y1 Y2). That operator, if we apply it to |ψ_ideal&gt;, might give a minus sign? Let&rsquo;s check: S1 S3|ψ_ideal&gt;. Alternatively, we know that S1 and S3 commute? They do commute? Check: S1 and S3: On qubit1, X and Z anticommute, so that gives a minus; on qubit2, similarly minus; so overall they commute. So S1 and S3 are both stabilizers. But their product is also a stabilizer? But then it would have to have eigenvalue +1. But we got a factor of -1 from the multiplication? That -1 is just a phase in the representation of the Pauli group. Actually, the Pauli group elements are defined up to a phase ±1, ±i. But when we say a Pauli operator P is in the stabilizer of a state, we mean that P|ψ&gt; = |ψ&gt;. That imposes a condition on the phase. So if we take the generators as given: S1 = XXXX, S2 = ZZZZ, S3 = Z1Z2, S4 = X1X2. These are chosen such that they indeed satisfy S_i|ψ&gt; = |ψ&gt;. Then any product of these will also give |ψ&gt; if the phase is adjusted appropriately. But when we multiply them as matrices, we might get an extra phase. For example, S1 S3: 
S1 = X0 X1 X2 X3.
S3 = Z1 Z2.
Their product: On qubit1: X1 Z1 = -i Y1.
On qubit2: X2 Z2 = -i Y2.
On qubits 0 and 3: X0 and X3 remain.
So S1 S3 = (-i)</em>(-i) X0 (Y1) (Y2) X3 = (-1) X0 Y1 Y2 X3? Actually, (-i)<em>(-i)= i^2 = -1. So S1 S3 = - X0 X3 Y1 Y2. So if we want this to be a stabilizer, we need that - X0 X3 Y1 Y2 |ψ&gt; = |ψ&gt;. That means that X0 X3 Y1 Y2 |ψ&gt; = -|ψ&gt;. So actually, X0 X3 Y1 Y2 is not a stabilizer; its eigenvalue is -1. So careful: The stabilizer group is not simply all products of the generators? Actually, the stabilizer group is the set of Pauli operators (with phase ±1, but we consider them as operators on the state) that leave the state invariant. The generators are chosen such that they have eigenvalue +1. Then any element of the group (which is a subgroup of the Pauli group modulo phases? Actually, the stabilizer group is usually defined as a set of operators that commute and have eigenvalue +1. If S1 and S3 are in the stabilizer, then their product is also in the stabilizer. So S1 S3 should have eigenvalue +1. But our computation gave S1 S3 = - X0 X3 Y1 Y2. So that would imply that X0 X3 Y1 Y2 has eigenvalue -1. But is that true? Let&rsquo;s check X0 X3 Y1 Y2 on |ψ_ideal&gt;. 
Take |0000&gt;: X0 X3 Y1 Y2|0000&gt; = X0|0&gt; * X3|0&gt; * Y1|0&gt; * Y2|0&gt; = |1&gt; * |1&gt; * (i|1&gt;) * (i|1&gt;) = i</em>i |1111&gt; = -|1111&gt;.
|1111&gt;: X0 X3 Y1 Y2|1111&gt; = X0|1&gt; * X3|1&gt; * Y1|1&gt; * Y2|1&gt; = |0&gt; * |0&gt; * (-i|0&gt;) * (-i|0&gt;) = (-i)<em>(-i)|0000&gt; = -|0000&gt;.
|0110&gt;: X0 X3 Y1 Y2|0110&gt; = qubit0:0 -&gt; X0|0&gt;=|1&gt;; qubit1:1 -&gt; Y1|1&gt; = -i|0&gt;; qubit2:1 -&gt; Y2|1&gt; = -i|0&gt;; qubit3:0 -&gt; X3|0&gt;=|1&gt;; so product: factors: from qubit1 and2: (-i)</em>(-i)= -1; so state becomes |1,0,0,1&gt; = |1001&gt;.
|1001&gt;: similarly gives |0110&gt;.
So then X0 X3 Y1 Y2|ψ_ideal&gt; = 1/2(-|1111&gt; - |0000&gt; + |1001&gt; + |0110&gt;) = -1/2(|0000&gt;+|1111&gt;) + 1/2(|0110&gt;+|1001&gt;) = - (|00&gt;_L) + (|11&gt;_L)? Actually, |00&gt;_L = (|0000&gt;+|1111&gt;)/√2, |11&gt;_L = (|0110&gt;+|1001&gt;)/√2. So this equals -√2/2 |00&gt;_L + √2/2 |11&gt;_L = 1/√2 (|11&gt;_L - |00&gt;_L). That is not equal to ±|ψ_ideal&gt; because |ψ_ideal&gt; = 1/√2 (|00&gt;_L+|11&gt;_L). So indeed, X0 X3 Y1 Y2 does not stabilize |ψ_ideal&gt;. So then S1 S3 is not actually in the stabilizer? But wait, S1 and S3 are stabilizers. Their product should be in the stabilizer group. There is a phase issue: The stabilizer group is usually defined as a set of operators that commute and that have the state as an eigenvector with eigenvalue +1. If S1 and S3 are such operators, then S1 S3 will also have eigenvalue +1. So there is a consistency condition. Let&rsquo;s check S1 and S3 on |ψ_ideal&gt; directly:
S1 = XXXX. We already checked: S1|ψ_ideal&gt; = |ψ_ideal&gt;.
S3 = Z1Z2. Check: Z1Z2|0000&gt; = |0000&gt;; Z1Z2|1111&gt; = (since qubit1 and2 are 1, so Z gives -1 each, product +1) so |1111&gt;; |0110&gt;: qubit1=1, qubit2=1, so +1; |1001&gt;: qubit1=0, qubit2=0, so +1. So S3|ψ_ideal&gt; = |ψ_ideal&gt;.
Now, what is S1 S3? That is the operator product. But careful: When we multiply operators, we have to be careful with the order? But since they commute, S1 S3 is well-defined. Let&rsquo;s compute S1 S3|ψ_ideal&gt; by applying S3 then S1? But since they commute, it&rsquo;s the same as S1 then S3. So S1 S3|ψ_ideal&gt; = S1(S3|ψ_ideal&gt;) = S1|ψ_ideal&gt; = |ψ_ideal&gt;. So indeed, S1 S3 should act as the identity on |ψ_ideal&gt;. But our matrix multiplication gave S1 S3 = - X0 X3 Y1 Y2. So there is a discrepancy: It must be that the actual operator S1 S3 is not - X0 X3 Y1 Y2 but rather something that gives a +1 phase. That means that our representation of S1 and S3 as Pauli matrices might have an overall phase choice. In fact, the stabilizer group is defined up to phases. We can choose the phases of the generators such that their products also have phase +1. For example, if we take S1 = XXXX and S3 = Z1Z2, then S1 S3 computed as matrices: 
X0 X1 X2 X3 * Z1 Z2. On qubit1, X1 Z1 = -i Y1. On qubit2, X2 Z2 = -i Y2. So that gives (-i)<em>(-i) = -1 times X0 X3 Y1 Y2. So S1 S3 = - X0 X3 Y1 Y2. So to have S1 S3 be a stabilizer (i.e., act as +1 on |ψ_ideal&gt;), we would need to define S3&rsquo; = -Z1Z2? But then check S3&rsquo;|ψ_ideal&gt;: -Z1Z2|ψ_ideal&gt; would give -|ψ_ideal&gt; if Z1Z2 gives +1? Actually, Z1Z2 gives +1, so -Z1Z2 gives -1. So that doesn&rsquo;t work either.
Maybe we can adjust S1? If we take S1&rsquo; = -XXXX, then S1&rsquo;|ψ_ideal&gt;? -XXXX|ψ_ideal&gt; = -|ψ_ideal&gt;, so that doesn&rsquo;t work.
So actually, the product of two stabilizers is determined by their action. We computed S1 S3|ψ_ideal&gt; should be |ψ_ideal&gt;. But our matrix multiplication gives S1 S3 = - X0 X3 Y1 Y2. So then we must have that X0 X3 Y1 Y2|ψ_ideal&gt; = -|ψ_ideal&gt;. But we computed X0 X3 Y1 Y2|ψ_ideal&gt; and got something that is not proportional to |ψ_ideal&gt;? Let&rsquo;s recompute X0 X3 Y1 Y2 carefully on each basis state in the support of |ψ_ideal&gt;:
The support is: |0000&gt;, |1111&gt;, |0110&gt;, |1001&gt;.
For |0000&gt;:
X0|0&gt;=|1&gt;, X3|0&gt;=|1&gt;, Y1|0&gt;= i|1&gt;, Y2|0&gt;= i|1&gt;. So product = i</em>i |1,1,1,1&gt; = -|1111&gt;.
For |1111&gt;:
X0|1&gt;=|0&gt;, X3|1&gt;=|0&gt;, Y1|1&gt;= -i|0&gt;, Y2|1&gt;= -i|0&gt;. So product = (-i)<em>(-i) |0,0,0,0&gt; = (-1)|0000&gt;? Actually, (-i)</em>(-i)= i^2 = -1. So gives -|0000&gt;.
For |0110&gt;:
q0:0 -&gt; X0|0&gt;=|1&gt;
q1:1 -&gt; Y1|1&gt;= -i|0&gt;
q2:1 -&gt; Y2|1&gt;= -i|0&gt;
q3:0 -&gt; X3|0&gt;=|1&gt;
So product: factors: (-i)<em>(-i)= -1, so state becomes |1,0,0,1&gt; = |1001&gt;.
For |1001&gt;:
q0:1 -&gt; X0|1&gt;=|0&gt;
q1:0 -&gt; Y1|0&gt;= i|1&gt;
q2:0 -&gt; Y2|0&gt;= i|1&gt;
q3:1 -&gt; X3|1&gt;=|0&gt;
Product: i</em>i = -1, so state becomes |0,1,1,0&gt; = |0110&gt;.
So then X0 X3 Y1 Y2|ψ_ideal&gt; = 1/2( -|1111&gt; - |0000&gt; + |1001&gt; + |0110&gt; ) = -1/2(|0000&gt;+|1111&gt;) + 1/2(|0110&gt;+|1001&gt;) = - (|00&gt;_L)/√2 + (|11&gt;_L)/√2 = 1/√2 (|11&gt;_L - |00&gt;_L). That is not equal to -|ψ_ideal&gt; because |ψ_ideal&gt; = 1/√2 (|00&gt;_L+|11&gt;_L). So indeed, X0 X3 Y1 Y2|ψ_ideal&gt; is orthogonal to |ψ_ideal&gt;? Actually, the inner product between (|11&gt;_L - |00&gt;_L) and (|00&gt;_L+|11&gt;_L) is 0. So S1 S3|ψ_ideal&gt; would be - times that, so it is also orthogonal to |ψ_ideal&gt;. That means that S1 and S3 do not commute? But they should commute because they act on different sets? Actually, S1 acts on all qubits, S3 acts on qubits 1 and 2. They should commute? Check: S1 = X0X1X2X3, S3 = Z1Z2. On qubit1, X and Z anticommute, so that gives a sign. On qubit2, similarly sign. So overall, they commute because two anticommutations give a positive sign. So they commute. Then if both stabilize |ψ_ideal&gt;, then their product should also stabilize |ψ_ideal&gt;. There is a inconsistency. Let&rsquo;s check S1 and S3 directly on |ψ_ideal&gt; without using the product form. 
We know S1|ψ_ideal&gt; = |ψ_ideal&gt;.
S3|ψ_ideal&gt; = |ψ_ideal&gt;.
So then S1 S3|ψ_ideal&gt; = S1(S3|ψ_ideal&gt;) = S1|ψ_ideal&gt; = |ψ_ideal&gt;. So it must be that S1 S3|ψ_ideal&gt; = |ψ_ideal&gt;. 
Now, let&rsquo;s compute S1 S3|ψ_ideal&gt; by applying S3 then S1 to each term manually.
|ψ_ideal&gt; = 1/2(|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;).
First, apply S3 = Z1Z2.
Z1Z2|0000&gt; = (Z1|0&gt;)(Z2|0&gt;)|00&gt; = (+1)(+1)|0000&gt; = |0000&gt;.
Z1Z2|1111&gt; = on qubits1 and2 are 1, so Z|1&gt; = -|1&gt;, so product (-1)<em>(-1)=+1, so |1111&gt;.
Z1Z2|0110&gt; = qubit1=1 -&gt; -1, qubit2=1 -&gt; -1, product +1, so |0110&gt;.
Z1Z2|1001&gt; = qubit1=0 -&gt; +1, qubit2=0 -&gt; +1, so |1001&gt;.
So S3|ψ_ideal&gt; = |ψ_ideal&gt;.
Then apply S1 = X0X1X2X3.
X0X1X2X3|0000&gt; = |1111&gt;.
X0X1X2X3|1111&gt; = |0000&gt;.
X0X1X2X3|0110&gt; = X0|0&gt; X1|1&gt; X2|1&gt; X3|0&gt; = |1&gt; * |0&gt; * |0&gt; * |1&gt; = |1001&gt;.
X0X1X2X3|1001&gt; = |0110&gt;.
So S1(S3|ψ_ideal&gt;) = 1/2(|1111&gt;+|0000&gt;+|1001&gt;+|0110&gt;) = |ψ_ideal&gt;. So indeed, S1 S3|ψ_ideal&gt; = |ψ_ideal&gt;. 
Now, what is the Pauli operator for S1 S3? S1 is X0X1X2X3. S3 is Z1Z2. When we multiply these as matrices, we get: On qubit0: X0.
On qubit1: X1 Z1 =? But careful: The order matters because they act on different qubits, so the product is the tensor product: (X0) ⊗ (X1Z1) ⊗ (X2Z2) ⊗ (X3). But X1Z1 is not simply a Pauli matrix because X and Z do not commute. Actually, wait: Since they act on different qubits, the overall operator is: S1 S3 = (X0) (X1) (X2) (X3) * (Z1)(Z2) but careful: These operators commute across different qubits? Actually, they act on different qubits, so the order doesn&rsquo;t matter. So we can write S1 S3 = X0 X1 X2 X3 * Z1 Z2. But then on qubit1, we have X1 and Z1. But these operators do not commute on the same qubit. However, since they are acting on different qubits, the product is well-defined as: (X0)(X3) * (X1Z1) * (X2Z2). And X1Z1 is not a Pauli matrix because X1Z1 = -i Y1 if we consider the usual Pauli matrices? But wait, Pauli matrices are defined such that X, Y, Z are Hermitian. And we have that X Z = -i Y. So indeed, X1Z1 = -i Y1. So then S1 S3 = X0 * (-i Y1) * (-i Y2) * X3 = X0 X3 * (-i)</em>(-i) Y1 Y2 = X0 X3 * (-1) Y1 Y2 = - X0 X3 Y1 Y2. So that is what we got. So according to this, S1 S3 should be - X0 X3 Y1 Y2. But then we computed its action on |ψ_ideal&gt; and got that it gives |ψ_ideal&gt;? Let&rsquo;s compute - X0 X3 Y1 Y2 on |ψ_ideal&gt; carefully:
For |0000&gt;: - X0X3Y1Y2|0000&gt; = - (|1&gt; from X0)(|1&gt; from X3)(i|1&gt; from Y1)(i|1&gt; from Y2) = - (i<em>i)|1111&gt; = -(-1)|1111&gt; = |1111&gt;.
For |1111&gt;: - X0X3Y1Y2|1111&gt; = - (|0&gt;)(|0&gt;)(-i|0&gt;)(-i|0&gt;) = - ((-i)</em>(-i))|0000&gt; = - (-1)|0000&gt; = |0000&gt;.
For |0110&gt;: - X0X3Y1Y2|0110&gt; = - (|1&gt;)(|1&gt;)(-i|0&gt;)(-i|0&gt;) = - ((-i)<em>(-i))|1001&gt; = - (-1)|1001&gt; = |1001&gt;.
For |1001&gt;: - X0X3Y1Y2|1001&gt; = - (|0&gt;)(|0&gt;)(i|1&gt;)(i|1&gt;) = - (i</em>i)|0110&gt; = - (-1)|0110&gt; = |0110&gt;.
So indeed, - X0 X3 Y1 Y2|ψ_ideal&gt; = 1/2(|1111&gt;+|0000&gt;+|1001&gt;+|0110&gt;) = |ψ_ideal&gt;. So it works! I earlier computed X0X3Y1Y2 without the minus sign. So the correct operator is S1S3 = - X0X3Y1Y2. And that does stabilize |ψ_ideal&gt;. So everything is consistent if we include the phases properly. So the stabilizer group S is actually the set of all Pauli operators (with phases ±1, ±i) that satisfy P|ψ_ideal&gt; = |ψ_ideal&gt;. But since we are considering errors that are from the set of Pauli matrices (which are Hermitian and have eigenvalues ±1), they will have real phases? Actually, the Pauli matrices are usually taken as X, Y, Z where Y = iσ_y? Actually, careful: The Pauli matrices are often defined as: X = [[0,1],[1,0]], Y = [[0,-i],[i,0]], Z = [[1,0],[0,-1]]. So these are Hermitian. Then indeed, XZ = -iY, so that is not Hermitian. So when we multiply Pauli matrices, we might get factors of i. But the errors are only the ones that are Hermitian. So the errors are only those Pauli operators that are products of I, X, Y, Z with overall phase 1 (because if you take a product of Hermitian operators, it is Hermitian if they commute? Actually, product of two Hermitian operators is Hermitian if they commute, but if they anticommute, then the product is anti-Hermitian? Let&rsquo;s check: X and Z are Hermitian. Their product XZ is not Hermitian because (XZ)^† = ZX = -XZ. So indeed, the Pauli group elements that are usually considered as errors are those that are Hermitian. And those are exactly the ones with real coefficients (±1) because if there is an i, then (iP)^† = -i P^† = -i P, so that is not equal to iP unless P=0. So the errors are from the set {I, X, Y, Z} on each qubit, and the overall operator is the tensor product, and we consider it with a phase of either +1 or -1 such that it is Hermitian. For example, XZ is not Hermitian because (XZ)^† = ZX = -XZ. So the Hermitian Pauli operators are those that are either I, X, Y, Z on each qubit with the understanding that Y is defined as iσ_y? Actually, wait: Y is defined as [[0,-i],[i,0]]. That is Hermitian. But then XZ =? XZ = [[0,1],[1,0]] [[1,0],[0,-1]] = [[0,-1],[1,0]] which is i * [[0,i],[-i,0]]? I&rsquo;m getting confused with phases. Let&rsquo;s not go too deep into phases. The important thing is: The errors that occur are from the set of 15 two-qubit Pauli errors. These are operators on two qubits that are tensor products of Pauli matrices from {I, X, Y, Z} but not both I. And these operators are Hermitian. So when we have an error on qubits 2 and 1, it is something like: E = P_2 ⊗ P_1, where P_2, P_1 ∈ {I, X, Y, Z} and not both I. And similarly for F on qubits 0 and 3: F = Q_0 ⊗ Q_3, with Q_0, Q_3 ∈ {I, X, Y, Z} not both I.
Then the overall error is F E. This is a Pauli operator on 4 qubits. It will be Hermitian. We want this operator to be in the stabilizer of |ψ_ideal&gt;. But careful: The stabilizer of |ψ_ideal&gt; consists of Pauli operators that leave |ψ_ideal&gt; invariant. But these stabilizer elements might not be Hermitian? Actually, if they stabilize a state, they must be unitary. But they can have phases? However, since |ψ_ideal&gt; is a state, if P|ψ&gt; = |ψ&gt;, then also P^\dagger|ψ&gt; = |ψ&gt;. So likely the stabilizer elements can be taken to be Hermitian as well. So we want to know: For which Pauli operators P (on the 4 qubits, Hermitian) does P|ψ_ideal&gt; = |ψ_ideal&gt; hold? And then the fidelity is the probability that F E is such a Pauli.
And as argued, because the circuit overall gives O = (F E) U, the final state is (F E)|ψ_ideal&gt;. So the fidelity is 1 if F E is in the stabilizer, and 0 otherwise.
But wait: Could it be that F E has a nonzero overlap even if it is not in the stabilizer? For a stabilizer state, if a Pauli is not in the stabilizer, then its expectation is 0. So yes, fidelity becomes 0.</p>
<p>So then we need to determine the condition on F and E such that F E is in the stabilizer of |ψ_ideal&gt;. 
F acts on qubits 0 and 3. E acts on qubits 2 and 1.
Let&rsquo;s denote:
F = (on qubit0: something, on qubit3: something) but careful: F is a two-qubit Pauli on qubits 0 and 3. So it can be written as: F = α * (A_0 ⊗ B_3) where A, B ∈ {I, X, Y, Z} and α is ±1 chosen to make it Hermitian? Actually, typically, the Pauli matrices themselves are Hermitian. So if we take, say, X⊗Z, that is Hermitian because X and Z are Hermitian and they act on different qubits, so the tensor product is Hermitian. So actually, any product of Pauli matrices (without any additional factors) is Hermitian. Because (P⊗Q)^† = P†⊗Q† = P⊗Q. So indeed, if we take Pauli matrices from {I, X, Y, Z} (with the standard definitions where X, Y, Z are Hermitian), then any tensor product is Hermitian. But wait: Check: X⊗Z is Hermitian? X is Hermitian, Z is Hermitian, so yes. So then the errors are simply products of these matrices. So we can write:
E = E_2 ⊗ E_1, where E_2, E_1 ∈ {I, X, Y, Z} and not both I.
F = F_0 ⊗ F_3, where F_0, F_3 ∈ {I, X, Y, Z} and not both I.
And then the overall error is: F E = (F_0 ⊗ I ⊗ I ⊗ F_3) * (I ⊗ E_1 ⊗ E_2 ⊗ I) = F_0 ⊗ E_1 ⊗ E_2 ⊗ F_3. (Since they act on different qubits, the order doesn&rsquo;t matter.)
So the overall error operator is a Pauli operator on each qubit independently. So we want this operator to be in the stabilizer of |ψ_ideal&gt;. The stabilizer of |ψ_ideal&gt; we determined has generators: 
S1 = X0 X1 X2 X3
S2 = Z0 Z1 Z2 Z3
S3 = Z1 Z2   (I believe, but careful: We want these to be Hermitian. S3 = Z1Z2 is Hermitian.)
S4 = X1 X2   (Hermitian)
But wait, are these all stabilizers? Check S4: X1X2|ψ_ideal&gt; =? We did that earlier, it works.
So any element of the stabilizer will be of the form: 
S = (S1)^a (S2)^b (S3)^c (S4)^d, with a,b,c,d ∈ {0,1}. But careful: These products might not be Hermitian? They will be Hermitian because each is Hermitian and they commute? Actually, if two Hermitian operators commute, their product is Hermitian. So yes.
So an element S in the stabilizer will act on qubits as:
On qubit0: from S1: if a=1, then X0; from S2: if b=1, then Z0; so on qubit0, it will be either I, X, Z, or XZ which is actually iY up to phase? But wait, X0Z0 is not Hermitian because (XZ)^† = ZX = -XZ. So actually, if both a and b are 1, then on qubit0 we get X0Z0. But that is not Hermitian. So there is a phase issue: S1 and S2 are Hermitian. Their product S1S2 is also Hermitian? Check: (S1S2)^† = S2S1 = S1S2 since they commute. So S1S2 is Hermitian. But S1S2 on qubit0 gives X0Z0. But X0Z0 is not Hermitian as an operator on qubit0 alone because (XZ)^† = ZX = -XZ. So how can that be? The resolution is that when we take the tensor product, the overall phase might come out such that the product is Hermitian. For example, S1S2 = (X0X1X2X3)(Z0Z1Z2Z3) = (X0Z0)(X1Z1)(X2Z2)(X3Z3). Now, each X_iZ_i is not Hermitian. But the product of four such terms: (X0Z0)(X1Z1)(X2Z2)(X3Z3). Is that Hermitian? Let&rsquo;s check: (X0Z0)^† = Z0X0 = -X0Z0. So each factor is anti-Hermitian. The product of an even number of anti-Hermitian operators can be Hermitian. Specifically, if A and B are anti-Hermitian, then (AB)^† = B^†A^† = B A = (-A)(-B)? I need to do carefully:
For a single qubit, XZ is anti-Hermitian because (XZ)^† = Z^†X^† = ZX = -XZ.
Now, consider two qubits: (X1Z1)(X2Z2). Its adjoint is (X2Z2)^† (X1Z1)^† = (Z2X2)(Z1X1) = ( -X2Z2)(-X1Z1) = X2Z2 X1Z1 = X1Z1 X2Z2 (since they commute across different qubits). So indeed, the product of two anti-Hermitian operators is Hermitian. So for four qubits, S1S2 is Hermitian. So when writing the stabilizer element in terms of its action on each qubit, we cannot simply separate it into independent factors because there can be correlated signs. So it&rsquo;s better to determine the condition for a Pauli operator P = P0 ⊗ P1 ⊗ P2 ⊗ P3 (where each P_i is either I, X, Y, or Z) to be in the stabilizer of |ψ_ideal&gt;. The condition is that P|ψ_ideal&gt; = |ψ_ideal&gt;. And |ψ_ideal&gt; = 1/2(|0000&gt;+|1111&gt;+|0110&gt;+|1001&gt;). For P to stabilize this state, it must map each basis state in the support to itself up to a phase that is the same for all? Actually, careful: If P is a Pauli, it will act on each computational basis state by flipping some bits and multiplying by a phase. For P to leave |ψ_ideal&gt; invariant, it must that the action on each basis state gives another basis state that is in the support, and the phases must be such that the overall state is unchanged. So let&rsquo;s derive conditions. Write P = P0 ⊗ P1 ⊗ P2 ⊗ P3. Consider its action on |0000&gt;. P|0000&gt; will be something like: if P0 is I or Z, then qubit0 remains 0; if P0 is X or Y, then qubit0 becomes 1 (with phase factors). So let&rsquo;s denote for each qubit i, the effect: 
If P_i = I or Z, then it leaves |0&gt; as |0&gt; times something? Actually, Z|0&gt;=|0&gt;, I|0&gt;=|0&gt;. So if P_i is I or Z, then it acts as +1 on |0&gt;.
If P_i = X or Y, then X|0&gt;=|1&gt;, Y|0&gt;= i|1&gt;? But careful: Y|0&gt; = i|1&gt; because Y = [[0,-i],[i,0]] so Y|0&gt; = i|1&gt;. So there is a phase. So we might need to be careful with phases. But maybe we can determine the stabilizer conditions by noting that |ψ_ideal&gt; is also the result of applying the circuit to |0000&gt;. And we know that the errors become overall Pauli errors. And we want that overall Pauli error to be such that it acts trivially on |0000&gt;? Actually, wait: We had O = (F E) U. So the final state is (F E)|ψ_ideal&gt;. For this to equal |ψ_ideal&gt;, we need F E to be in the stabilizer of |ψ_ideal&gt;. So we need to know which Paulis stabilize |ψ_ideal&gt;. We can determine them by using the fact that |ψ_ideal&gt; is stabilized by the following operators (I will check them directly):
We already know that XXXX stabilizes it.
ZZZZ stabilizes it.
Z1Z2 stabilizes it.
X1X2 stabilizes it.
What about something like X0X3? Does that stabilize? Check: X0X3|0000&gt; = |1010&gt; which is not in the support. So no.
What about Z0Z3? Z0Z3|0000&gt; = |0000&gt;; Z0Z3|1111&gt; = |1111&gt;; but Z0Z3|0110&gt; =? |0110&gt; because qubit0=0 so Z gives +1, qubit3=0 so +1; Z0Z3|1001&gt; = |1001&gt; because qubit0=1 -&gt; -1, qubit3=1 -&gt; -1, product +1. So actually, Z0Z3 seems to stabilize each term? But wait, check phase: For |1001&gt;, Z0 gives -1, Z3 gives -1, product = +1. So Z0Z3|ψ_ideal&gt; = |ψ_ideal&gt;. So Z0Z3 is also a stabilizer? But is it independent? Note that Z0Z3 = (ZZZZ)(Z1Z2) because ZZZZ * Z1Z2 = Z0Z1Z2Z3 * Z1Z2 = Z0Z3. So indeed, Z0Z3 is in the stabilizer group. Similarly, X0X3? X0X3|0000&gt; = |1010&gt; not in support. So no.
What about Y0Y3? Possibly not.
So the stabilizer group has 16 elements. They are all products of S1, S2, S3, S4. So an element S will have the form: S = (XXXX)^a (ZZZZ)^b (Z1Z2)^c (X1X2)^d, with a,b,c,d in {0,1}. Let&rsquo;s write what that does on each qubit:
Qubit0: from S1: if a=1, then X0; from S2: if b=1, then Z0; so on qubit0, the Pauli is: I if (a,b)=(0,0); X if (1,0); Z if (0,1); and if (1,1), then we get X0Z0. But as noted, X0Z0 is not itself a Pauli matrix because XZ is proportional to Y up to a phase? Actually, XZ = -iY. So if we want to express this as a Pauli matrix (I, X, Y, Z), then we would have Y times a phase. But careful: The overall operator S will have phases from the multiplication across qubits. Let&rsquo;s actually compute S for a given (a,b,c,d) and see what it is as a tensor product of Pauli matrices on each qubit (up to an overall phase that makes it Hermitian). 
S = (XXXX)^a (ZZZZ)^b (Z1Z2)^c (X1X2)^d.
Write it as: 
On qubit0: contribution from S1^a: X0^a; from S2^b: Z0^b. So on qubit0, the operator is X0^a Z0^b. But note that X0 and Z0 anticommute, so X0Z0 = -Z0X0, but since they are powers, careful: if a=1 and b=1, then we have X0Z0. But as an operator, X0Z0 is not equal to ±Y0 because Y0 is defined as iσ_y usually? Actually, standard Pauli matrices: σ_x, σ_y, σ_z. And we have σ_x σ_z = -i σ_y. So X0Z0 = -i Y0. So if we want to write the operator on qubit0 in terms of I, X, Y, Z, we would have to absorb phases. So it might be easier to determine the condition for F E to be in the stabilizer by using the fact that F E = F_0 ⊗ E_1 ⊗ E_2 ⊗ F_3. And we want this to equal some S in the stabilizer. So that means that there should exist a,b,c,d such that:
F_0 = (on qubit0 from S) which is determined by a and b.
E_1 = (on qubit1 from S) determined by a,b,c,d.
E_2 = (on qubit2 from S) determined by a,b,c,d.
F_3 = (on qubit3 from S) determined by a,b.
And also, the phases must match up to make the overall operator Hermitian. But since F and E are given as Pauli matrices (I,X,Y,Z) without any additional phases, we can determine the conditions directly by requiring that (F E) |ψ_ideal&gt; = |ψ_ideal&gt;. And since |ψ_ideal&gt; is a specific state, we can compute the action of a Pauli on it conditions. Maybe there is a simpler approach: The fidelity is the probability that no error occurs that changes the state. And errors occur independently on the two CNOT gates. And the errors are depolarizing channels. So the probability that the overall error is identity is (1-p)^2. But wait, could there be errors that are not identity but still leave the state invariant? Yes, if they are in the stabilizer. So we need to count how many error patterns (F and E) yield an overall error that is in the stabilizer.
F is on qubits 0 and 3. There are 15 possible errors for F (non-identity) and also the identity case. So total outcomes for F: 16 outcomes, but with probabilities: identity probability = 1-p, and each non-identity probability = p/15.
Similarly for E: 16 outcomes.
So total outcomes: 256 outcomes. Among these, those that yield F E in the stabilizer will give fidelity 1. Others give fidelity 0.
So the fidelity F = Sum_{(F,E) such that F E in S} Prob(F)*Prob(E).</p>
<p>So we need to determine for which pairs (F, E) is F E in the stabilizer S of |ψ_ideal&gt;.
Write F = F_0 ⊗ F_3, where F_0, F_3 ∈ {I, X, Y, Z} but not both I? Actually, careful: F is the error on the CNOT_{03} gate. The error channel says that with probability p, an error occurs, and that error is one of the 15 non-identity two-qubit Paulis. So if no error occurs, then F = I_{0} ⊗ I_{3}. So that is included. So F can be any Pauli on qubits 0 and 3? Actually, wait: The depolarizing channel: It applies with probability 1-p the identity, and with probability p, it applies one of the 15 non-identity Paulis uniformly. So indeed, F can be any Pauli on qubits 0 and 3? But careful: The Pauli group on two qubits has 16 elements. So F takes one of these 16 outcomes. Similarly, E takes one of 16 outcomes on qubits 2 and 1.
So we want to know: For a given F (which is determined by F_0 and F_3) and E (determined by E_2 and E_1), when is the product operator P = F_0 ⊗ E_1 ⊗ E_2 ⊗ F_3 in the stabilizer S of |ψ_ideal&gt;?</p>
<p>Now, what is the stabilizer S? S is the set of Pauli operators that leave |ψ_ideal&gt; invariant. We know that S is generated by:
S1 = X0 X1 X2 X3
S2 = Z0 Z1 Z2 Z3
S3 = Z1 Z2
S4 = X1 X2
So any element of S can be written as: S = (S1)^a (S2)^b (S3)^c (S4)^d, where a,b,c,d ∈ {0,1}. But careful with phases: As discussed, these products will be Hermitian Pauli operators. Let&rsquo;s actually list the stabilizer elements in terms of their action on each qubit. They are 16 in number. They are determined by the conditions that they preserve the state |ψ_ideal&gt;. Notice that |ψ_ideal&gt; has support on states where qubits 0 and 3 are either both 0 or both 1, and qubits 1 and 2 are either both 0 or both 1? Actually, from the state: |0000&gt;, |1111&gt;, |0110&gt;, |1001&gt;. So indeed, in the support, we have: qubit0 and qubit3 are the same? Check: In |0000&gt;, they are both 0. In |1111&gt;, both 1. In |0110&gt;, qubit0=0, qubit3=0? Actually, |0110&gt;: qubit0=0, qubit3=0. In |1001&gt;: qubit0=1, qubit3=1. So yes, qubit0 and qubit3 are always equal. Also, qubit1 and qubit2: In |0000&gt;, they are both 0. In |1111&gt;, both 1. In |0110&gt;, both 1. In |1001&gt;, both 0. So qubit1 and qubit2 are also always equal. So the state |ψ_ideal&gt; is actually a state that is concentrated on the subspace where qubit0 = qubit3 and qubit1 = qubit2. So any Pauli operator that stabilizes |ψ_ideal&gt; must commute with the projectors onto these conditions? Actually, if P is to leave |ψ_ideal&gt; invariant, it should map this subspace to itself. So likely the condition for P to be in the stabilizer is that its action on qubits 0 and 3 is such that it does not flip the parity between qubit0 and qubit3? And on qubits 1 and 2, it should not flip the parity between qubit1 and qubit2? But wait, consider S1 = XXXX. That flips all qubits. Then qubit0 and qubit3 remain equal because both flip. So that&rsquo;s fine. What about an operator that is X0 alone? That would take |0000&gt; to |1000&gt;, but |1000&gt; is not in the support because then qubit0=1, qubit3=0, so they are not equal. So likely a necessary and sufficient condition for a Pauli operator P = P0⊗P1⊗P2⊗P3 to stabilize |ψ_ideal&gt; is that it preserves the conditions: P0 and P3 must be such that they either both act as identity or both act as X or both act as Z? But careful: What about Y? Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;. So if acting on a state where qubit0 and qubit3 are both 0, if we apply Y0 and Y3, then we get (i|1&gt;)(i|1&gt;) = -|11&gt; so that gives both 1, so that works actually. So maybe the condition is that the Pauli actions on qubit0 and qubit3 should be the same type? Because then they will either both flip or both not flip? But consider: If on qubit0 we have Z and on qubit3 we have I. Then on |0000&gt;, Z0 I3 gives |0000&gt; still, so that might be okay? But wait, check: Z0 I3|ψ_ideal&gt; =? For |0000&gt;, gives |0000&gt;. For |1111&gt;, gives -|1111&gt; because Z on qubit0 gives -1 when qubit0=1. For |0110&gt;, gives |0110&gt; because qubit0=0 so Z gives +1. For |1001&gt;, gives -|1001&gt; because qubit0=1 gives -1. So then the state becomes 1/2(|0000&gt; - |1111&gt; + |0110&gt; - |1001&gt;) which is not equal to |ψ_ideal&gt;. So that operator is not in the stabilizer. So indeed, for qubits 0 and 3, the Pauli actions must be either both I, both X, both Y, or both Z? But wait, check: X0 and Z3 would that work? likely not. So condition: P0 and P3 must be either both I, both X, both Y, or both Z. But is that sufficient? Let&rsquo;s test: If P0 = X and P3 = X, then that is S1-like? Actually, that alone is not enough because it also acts on qubits 1 and 2. So overall, for P to be in the stabilizer, we need that on qubits 0 and 3, the Pauli actions are the same (i.e., P0 = P3 up to? Actually, they should be exactly the same Pauli matrix? But wait, could they be both Y? Yes, because YY will send |00&gt; to something like? Y|0&gt;=i|1&gt;, so Y⊗Y|00&gt; = -|11&gt;. So that gives a phase of -1 overall, but that might be okay if compensated by action on qubits 1 and 2? Let&rsquo;s check: Consider P = Y0 ⊗ I1 ⊗ I2 ⊗ Y3. Does that stabilize |ψ_ideal&gt;? 
|0000&gt; -&gt; Y0Y3|0000&gt; = (i|1&gt;)(i|1&gt;) = -|1111&gt;.
|1111&gt; -&gt; Y0Y3|1111&gt; = (-i|0&gt;)(-i|0&gt;) = -|0000&gt;.
|0110&gt; -&gt; Y0Y3|0110&gt; = (I on qubit1? Actually, careful: P = Y0 ⊗ I1 ⊗ I2 ⊗ Y3. On |0110&gt;: qubit0=0 -&gt; Y gives i|1&gt;; qubit3=0 -&gt; Y gives i|1&gt;; so becomes -|1110&gt;? But wait, |1110&gt; is not in the support because qubit1=1 but qubit2=0? Actually, |1110&gt; would mean qubits: 1,1,1,0. That is not in the support because for support, qubit1 and qubit2 should be equal. So this operator would take |0110&gt; to something outside the support. So that suggests that the condition is not simply that P0 and P3 are the same type independently. They must also be related to the action on qubits 1 and 2. Because the stabilizer conditions involve correlations across all qubits. So we should use the stabilizer generators directly.</p>
<p>Maybe it&rsquo;s easier to determine the effect of an error on the final state by actually computing the state after errors and then taking the fidelity. Since the errors are Pauli, the final state will be a mixture of states that are Pauli errors applied to |ψ_ideal&gt;. And the fidelity is the probability that the applied Pauli is in the stabilizer. So we need to count how many Pauli operators on qubits 0,3 and 2,1 yield an overall Pauli that is in the stabilizer.
Let&rsquo;s denote the Pauli on qubits 0 and 3 as F. There are 16 possibilities for F. Similarly, 16 for E.
We want to know for which pairs (F, E) is F E ∈ S.
Now, note that S is a subgroup of the Pauli group of order 16. So there are 16 elements in S.
Also, note that F and E act on disjoint sets. So the map (F, E) -&gt; F E is actually a group isomorphism from the direct product of the Pauli groups on {0,3} and {2,1} to the full Pauli group on 4 qubits? Actually, careful: The Pauli group on two qubits has order 16. So the direct product has order 16<em>16=256, and that maps onto the Pauli group on 4 qubits which has order 16^2=256 as well (ignoring phases). So this map is bijective. So essentially, every Pauli operator on 4 qubits can be uniquely written as F E with F acting on {0,3} and E acting on {2,1}. So then the condition that F E is in S is that F E is one of the 16 elements of S. So out of the 256 pairs, exactly 16 will yield F E in S. But wait, is that true? Because the map (F,E) -&gt; F E is a bijection between the set of pairs and the set of 4-qubit Paulis. So there are exactly 16 pairs that give any particular Pauli. So the number of pairs such that F E is in S is 16 * (number of elements in S) but careful: That would be 16</em>16 = 256 if every Pauli in S could be represented? But wait, the map is bijective: For each Pauli P in the full group, there is exactly one pair (F,E) such that F E = P. So if S has 16 elements, then there are exactly 16 pairs (F,E) that yield an outcome in S. Is that right? Let&rsquo;s check: Take the identity operator. Identity can be written as (I_{0}⊗I_{3}) * (I_{2}⊗I_{1}). So that&rsquo;s one pair. What about another element of S, say S1 = XXXX. Can we write XXXX as F E where F acts on {0,3} and E acts on {2,1}? Yes: F = X0⊗X3 and E = X2⊗X1. So that is one pair. So indeed, for each element of S, there is exactly one pair (F,E) that gives that element. So total number of pairs that yield F E in S is exactly 16.
But wait, are there any pairs where F is identity? That gives identity if E is identity. So that&rsquo;s one.
So then the probability that the overall error is in the stabilizer is: Sum_{(F,E) such that F E in S} Prob(F)<em>Prob(E). But careful: F and E are independent. And their distributions are: For F: P(F) = if F is identity on {0,3} then probability = 1-p; if F is any of the 15 non-identity Paulis, probability = p/15 each.
Similarly for E.
So then the fidelity F = Σ_{(F,E): F E in S} (Prob(F) * Prob(E)).
Now, this sum is over 16 pairs. These 16 pairs are different. They will have different probabilities depending on whether F is identity or not and whether E is identity or not.
So we need to know, for each element of S, what is its decomposition as F E? But wait, since the map is bijective, each element of S corresponds to a unique pair (F,E). So we need to list the 16 elements of S and determine for each, whether F is identity or not and whether E is identity or not.
S is generated by S1, S2, S3, S4. Let&rsquo;s list them in terms of their action on qubits 0,3 and 1,2. Write an element of S as: It will act on qubits 0 and 3 together and on qubits 1 and 2 together in a correlated way. Actually, note that |ψ_ideal&gt; has the property that qubit0 and qubit3 are always equal, and qubit1 and qubit2 are always equal. So likely the stabilizer elements will also respect that structure. In fact, I suspect that for an element of S, the part acting on {0,3} must be either I⊗I or X⊗X or Y⊗Y or Z⊗Z? And similarly for {1,2} must be either I⊗I or X⊗X or Y⊗Y or Z⊗Z? But wait, check: S3 = Z1Z2 is indeed of that form (Z⊗Z on {1,2}). S4 = X1X2 is X⊗X on {1,2}. S1 = XXXX means on {0,3} it is X⊗X and on {1,2} it is X⊗X. S2 = ZZZZ means on {0,3} it is Z⊗Z and on {1,2} it is Z⊗Z.
What about something like S1S3 = XXXX * Z1Z2 = (X⊗X on {0,3}) and (X⊗X * Z⊗Z on {1,2}) but careful: On {1,2}, that gives (X1X2)(Z1Z2) = (X1Z1)(X2Z2) = (-iY1)(-iY2) = (-1) Y1Y2? Actually, (-i)</em>(-i)= -1, so that gives - Y1Y2. But wait, is -Y1Y2 in the form? If we take Y⊗Y, that would be Y1Y2. So S1S3 would be (X⊗X) ⊗ (-Y⊗Y). So that suggests that on {1,2}, the stabilizer element is actually -Y⊗Y. But can that be? If we act with -Y⊗Y on a state where qubit1 and qubit2 are both 0, we get - (Y|0&gt;)(Y|0&gt;) = - (i|1&gt;)(i|1&gt;) = -(-1)|11&gt; = |11&gt;? Actually, careful: Y|0&gt;= i|1&gt;, so Y⊗Y|00&gt; = i^2|11&gt; = -|11&gt;. So then -Y⊗Y|00&gt; = |11&gt;. So that works. So indeed, it seems that for any stabilizer element, the action on {0,3} will be either I⊗I, X⊗X, Y⊗Y, or Z⊗Z times possibly a phase? And on {1,2} will be either I⊗I, X⊗X, Y⊗Y, or Z⊗Z times a phase such that the overall phase makes the operator have eigenvalue +1 on |ψ_ideal&gt;. Let&rsquo;s check: If on {0,3} we have X⊗X and on {1,2} we have Y⊗Y, then the overall operator is X⊗X ⊗ Y⊗Y. What is its action on |0000&gt;? That gives (X|0&gt;)(X|0&gt;) (Y|0&gt;)(Y|0&gt;) = (|1&gt;)(|1&gt;) (i|1&gt;)(i|1&gt;) = (1)(i^2)|1111&gt; = -|1111&gt;. On |1111&gt;, it gives (X|1&gt;)(X|1&gt;)(Y|1&gt;)(Y|1&gt;) = (|0&gt;)(|0&gt;)(-i|0&gt;)(-i|0&gt;) = ((-i)<em>(-i))|0000&gt; = (-1)|0000&gt; = -|0000&gt;. On |0110&gt;, it gives? This might not yield a consistent phase across all terms. So likely the stabilizer elements are exactly those where the action on {0,3} is one of {I⊗I, X⊗X, Z⊗Z} and on {1,2} is one of {I⊗I, X⊗X, Z⊗Z}? But wait, we already saw S1S3 gave rise to Y⊗Y on {1,2} actually. Let&rsquo;s determine systematically. An element of S is of the form: S = (S1)^a (S2)^b (S3)^c (S4)^d.
Write S1 = (X0X3) (X1X2)
S2 = (Z0Z3) (Z1Z2)
S3 = (I0I3) (Z1Z2)
S4 = (I0I3) (X1X2)
So then S = [ (X0X3)^a (Z0Z3)^b ] ⊗ [ (X1X2)^a (Z1Z2)^b (Z1Z2)^c (X1X2)^d ] but careful: They commute so order doesn&rsquo;t matter. So on {0,3}, we have: (X0X3)^a (Z0Z3)^b. So that is: if (a,b)=(0,0) -&gt; I⊗I.
(a,b)=(1,0) -&gt; X⊗X.
(a,b)=(0,1) -&gt; Z⊗Z.
(a,b)=(1,1) -&gt; (X0X3)(Z0Z3) = X0Z0 X3Z3. But as noted, X0Z0 = -i Y0, and X3Z3 = -i Y3, so product = (-i)</em>(-i) Y0Y3 = (-1) Y0Y3. So that gives - Y0Y3. So on {0,3}, if (a,b)=(1,1), we get - Y⊗Y.
On {1,2}, we have: (X1X2)^a (Z1Z2)^b (Z1Z2)^c (X1X2)^d = (X1X2)^(a+d) (Z1Z2)^(b+c). So similarly, on {1,2}, we can get I⊗I, X⊗X, Z⊗Z, or if (a+d, b+c) both 1 then we get - Y⊗Y.
So indeed, the stabilizer elements are determined by two independent choices for the {0,3} part and the {1,2} part. But wait, are all these 4*4=16 actually stabilizers? They will be if the overall phase works out to give +1 on |ψ_ideal&gt;. Let&rsquo;s check an element where on {0,3} is -Y⊗Y and on {1,2} is -Y⊗Y. Then S = (-Y0Y3)(-Y1Y2) = Y0Y1Y2Y3. What is that on |0000&gt;? Y|0&gt;= i|1&gt;, so product = i^4|1111&gt; = |1111&gt;. On |1111&gt;, Y|1&gt; = -i|0&gt;, so product = (-i)^4|0000&gt; = |0000&gt;. On |0110&gt;, likely it gives |0110&gt;? So that works. So indeed, the stabilizer group S consists of operators that act on {0,3} as either I⊗I, X⊗X, Z⊗Z, or -Y⊗Y? But wait, could it be that sometimes it is Y⊗Y instead of -Y⊗Y? Let&rsquo;s determine the phase carefully. We want S|ψ_ideal&gt; = |ψ_ideal&gt;. Consider an element where on {0,3} is given by something and on {1,2} is given by something. Since |ψ_ideal&gt; is an equal superposition of states where qubit0=qubit3 and qubit1=qubit2, it might be that the phase condition forces that the operator on each pair must actually be either I, X, Z, or actually Y but with a specific sign. I will trust the generator method. So then, the stabilizer elements are exactly those for which the action on {0,3} is one of: I⊗I, X⊗X, Z⊗Z, or -Y⊗Y; and the action on {1,2} is one of: I⊗I, X⊗X, Z⊗Z, or -Y⊗Y. But wait, could there be an element where on {0,3} is, say, X⊗X and on {1,2} is -Y⊗Y? That would be S1S3 perhaps. We already computed that works. So yes.
So then, if an overall error P = F E is in S, then its restriction to {0,3} must be one of these four types, and its restriction to {1,2} must be one of these four types. But careful: P = F E means that the part on {0,3} is exactly F (since E acts trivially on {0,3}) and the part on {1,2} is exactly E (since F acts trivially on {1,2}). So for P to be in S, we need that:
F must be one of: I⊗I, X⊗X, Z⊗Z, or -Y⊗Y on qubits 0 and 3.
And E must be one of: I⊗I, X⊗X, Z⊗Z, or -Y⊗Y on qubits 2 and 1. (Note: careful with order: E acts on qubits 2 and 1. So E should be such that it is either I2⊗I1, X2⊗X1, Z2⊗Z1, or -Y2⊗Y1.)</p>
<p>But wait, are these all? Let&rsquo;s check: If F = I⊗I and E = I⊗I, then that&rsquo;s identity, works.
If F = X⊗X and E = X⊗X, then that gives XXXX, works.
If F = Z⊗Z and E = Z⊗Z, then that gives ZZZZ, works.
If F = -Y⊗Y and E = -Y⊗Y, then that gives YYYY? Actually, careful: -Y⊗Y means on qubit0: -Y, on qubit3: Y? Actually, when we write F acting on qubits 0 and 3, F is a two-qubit Pauli. It can be written as F = α * (P0 ⊗ Q3) where P,Q ∈ {I,X,Y,Z} and α is ±1 to make it Hermitian? Actually, wait: The Pauli matrices themselves are Hermitian. So if we take, say, Y⊗Y, that is Hermitian because Y is Hermitian and tensor product of Hermitian is Hermitian. So why would we have a minus sign? Because when we multiply generators, we got -Y⊗Y sometimes. So indeed, the stabilizer element is not necessarily just the tensor product of the same Pauli on each qubit; it might have an overall minus sign. So for example, consider the stabilizer element corresponding to (a,b)=(1,1) on {0,3} gives: (X0X3)(Z0Z3) = X0Z0 X3Z3. Now, X0Z0 = -i Y0, so that is (-i)(-i) Y0Y3 = (-1) Y0Y3. So that stabilizer element is actually - Y0Y3. So indeed, on {0,3}, the stabilizer element is -Y⊗Y, not Y⊗Y. So that means that if F itself is Y⊗Y (i.e., Y on qubit0 and Y on qubit3), then F would be Y⊗Y. But is Y⊗Y in the stabilizer? Let&rsquo;s check: Y⊗Y on {0,3} applied to a state where both are 0 gives Y|0&gt;⊗Y|0&gt; = (i|1&gt;)(i|1&gt;) = -|11&gt;. So that would send |00&gt; to -|11&gt;. But wait, could that be compensated by the action on {1,2}? If overall we want the state to be invariant, then if on {0,3} we have Y⊗Y, then on {1,2} we would need something that sends |00&gt; to -|00&gt; to cancel? Actually, let&rsquo;s determine: Suppose P = (Y0Y3) ⊗ (Y1Y2). Then on |0000&gt;, that gives (Y|0&gt;)^4 = (i)^4|1111&gt; = |1111&gt;. On |1111&gt;, gives (-i)^4|0000&gt; = |0000&gt;. On |0110&gt;, gives? This actually might work out to be |ψ_ideal&gt; itself? Let&rsquo;s check properly: P = Y0Y1Y2Y3. Compute Y|0&gt;= i|1&gt;, Y|1&gt;=-i|0&gt;. So on |0000&gt;, we get i^4|1111&gt;=|1111&gt;. On |1111&gt;, (-i)^4|0000&gt;=|0000&gt;. On |0110&gt;, qubit0:0 -&gt; i|1&gt;; qubit1:1 -&gt; -i|0&gt;; qubit2:1 -&gt; -i|0&gt;; qubit3:0 -&gt; i|1&gt;; product phase = i * (-i) * (-i) * i = (i<em>(-i))=1, (-i)</em>(-i)= -1? Let&rsquo;s do carefully: phase = i * (-i) = 1 for first two? Actually, better: i * (-i) = -i^2 = 1. Then that result times (-i) = -i, then times i = -i^2 = 1. So actually, phase = 1. So |0110&gt; goes to |1001&gt;. And |1001&gt; goes to |0110&gt;. So indeed, YYYY|ψ_ideal&gt; = |ψ_ideal&gt;. So wait, that suggests that Y⊗Y on {0,3} actually would be if taken alone? But careful: Y⊗Y on {0,3} means just acting on qubits 0 and 3 with Y on each. That operator is Y0Y3. Is that in the stabilizer? If we take P = Y0Y3 ⊗ I1I2, then acting on |0000&gt; gives Y0Y3|00&gt; = i^2|11&gt; = -|11&gt;, so that gives -|1100&gt; which is not in the support because qubit1 and qubit2 are 0,0 actually that is |1100&gt; is not in the support because for support, qubit0 should equal qubit3? Actually, |1100&gt; means qubit0=1, qubit3=0, so that&rsquo;s not in the support. So indeed, the stabilizer conditions couple the two pairs. So the correct statement is: An overall Pauli P is in the stabilizer if and only if its restrictions to {0,3} and {1,2} are such that they are both of the form: either I⊗I, or X⊗X, or Z⊗Z, or they could be Y⊗Y but then there must be a relative sign between them? Actually, from the generator method, we got that on {0,3}, the possibilities are: I⊗I, X⊗X, Z⊗Z, and when (a,b)=(1,1) we get -Y⊗Y. So that means that if the {0,3} part is Y⊗Y, then it would actually be -Y⊗Y to be in the stabilizer? But wait, could there be an element where the {0,3} part is Y⊗Y itself? Let&rsquo;s see: If we take S1S2? S1S2 = (XXXX)(ZZZZ) = (XZ)(XZ)(XZ)(XZ) = (-iY)(-iY)(-iY)(-iY) = ( (-i)^4 ) (YYYY) = YYYY. So that would give on {0,3}: Y0Y3 and on {1,2}: Y1Y2. So that suggests that actually, Y⊗Y on {0,3} and Y⊗Y on {1,2} together give an element of the stabilizer? But careful: S1S2 = (XXXX)(ZZZZ). But wait, are both S1 and S2 stabilizers? Yes, they are. So S1S2 should be a stabilizer. And S1S2 =? Let&rsquo;s compute S1S2 explicitly as operators acting on each qubit independently. S1 = X0X1X2X3. S2 = Z0Z1Z2Z3. These commute so order doesn&rsquo;t matter. On qubit0, we have X0Z0. But X0Z0 is not simply Y0 because X0Z0 = -i Y0. So actually, S1S2 = (X0Z0)(X1Z1)(X2Z2)(X3Z3) = (-i)^4 (Y0Y1Y2Y3) = Y0Y1Y2Y3. So indeed, S1S2 = Y0Y1Y2Y3. So that means that if we take F such that its action on {0,3} is Y0Y3 (i.e., F = Y⊗Y) and E such that its action on {1,2} is Y1Y2 (i.e., E = Y⊗Y), then F E = Y0Y3 Y1Y2 = YYYY, which is S1S2. And does that stabilize |ψ_ideal&gt;? We already checked YYYY does stabilize |ψ_ideal&gt;. So that means that actually, for the {0,3} part, the stabilizer condition is that F should be either I⊗I, X⊗X, Z⊗Z, or Y⊗Y? But wait, then what about the case we got from (a,b)=(1,1) which gave -Y⊗Y? That came from S1^1 S2^1? Actually, S1S2 would correspond to a=1,b=1,c=0,d=0. That gives on {0,3}: (X0X3)(Z0Z3) = we computed that as (-i)(-i) Y0Y3 = (-1) Y0Y3. So that suggests that S1S2 should be -Y0Y3 on {0,3} times something on {1,2}? I need to be very careful with phases. Let&rsquo;s determine the stabilizer elements explicitly using the generators with a specific phase convention. We want each generator to be Hermitian and to satisfy G|ψ_ideal&gt; = |ψ_ideal&gt;. We already know that:
S1 = X0X1X2X3. This is Hermitian. And we checked that S1|ψ_ideal&gt; = |ψ_ideal&gt;.
S2 = Z0Z1Z2Z3. Hermitian. works.
S3 = Z1Z2. Hermitian. works.
S4 = X1X2. Hermitian. works.
Now, any element of the stabilizer is of the form: S = (S1)^a (S2)^b (S3)^c (S4)^d. But careful: When multiplying these, they commute so order doesn&rsquo;t matter. Let&rsquo;s compute these products and determine their action on each qubit clearly.
Let’s denote an element by (a,b,c,d). Then S = S1^a S2^b S3^c S4^d.
Now, since these operators act on different qubits, we can separate them into qubit0,3 and qubit1,2 parts because S3 and S4 act only on 1,2 and S1 and S2 act on all but they factor as (on 0,3) and (on 1,2)). Specifically:
S1 = (X0X3) (X1X2)
S2 = (Z0Z3) (Z1Z2)
S3 = (I) (Z1Z2)
S4 = (I) (X1X2)
So then S = [ (X0X3)^a (Z0Z3)^b ] ⊗ [ (X1X2)^a (Z1Z2)^b (Z1Z2)^c (X1X2)^d ] = [ (X0X3)^a (Z0Z3)^b ] ⊗ [ (X1X2)^(a+d) (Z1Z2)^(b+c) ].
Now, let’s compute the factor on qubits 0 and 3. Let A = (X0X3)^a (Z0Z3)^b.
If (a,b) = (0,0): A = I.
(1,0): A = X0X3.
(0,1): A = Z0Z3.
(1,1): A = (X0X3)(Z0Z3) = X0Z0 X3Z3. Now, X0Z0 = -i Y0, and X3Z3 = -i Y3, so this product = (-i)*(-i) Y0Y3 = (-1) Y0Y3. So A = - Y0Y3.
So on qubits 0 and 3, the possible outcomes are: I, X0X3, Z0Z3, and -Y0Y3.
Now on qubits 1 and 2, let B = (X1X2)^(a+d) (Z1Z2)^(b+c).
So depending on (a+d) and (b+c), we get:
If (a+d, b+c) = (0,0): B = I.
(1,0): B = X1X2.
(0,1): B = Z1Z2.
(1,1): B = (X1X2)(Z1Z2) = X1Z1 X2Z2 = (-i)(-i) Y1Y2 = (-1) Y1Y2 = -Y1Y2.
So then S = A ⊗ B.
So the stabilizer elements are exactly those where:
On {0,3}: either I, X⊗X, Z⊗Z, or -Y⊗Y.
On {1,2}: either I, X⊗X, Z⊗Z, or -Y⊗Y.
Now check consistency with S1S2 that I earlier thought was YYYY. S1S2 corresponds to (a,b,c,d)=(1,1,0,0). Then A = -Y0Y3, B = -Y1Y2, so S = (-Y0Y3)(-Y1Y2) = Y0Y1Y2Y3. So that gives YYYY. Good.
So indeed, the stabilizer conditions are:
F must be such that its action on {0,3} is one of: I⊗I, X⊗X, Z⊗Z, or -Y⊗Y.
And E must be such that its action on {1,2} is one of: I⊗I, X⊗X, Z⊗Z, or -Y⊗Y.
But wait: F is the error on the second CNOT gate. F is applied directly to qubits 0 and 3. So F itself is a Pauli operator on these two qubits. So for F to contribute to a stabilizer overall, we need that F is one of these four operators: I0I3, X0X3, Z0Z3, or -Y0Y3. But careful: Is -Y0Y3 itself a Pauli operator? Yes, because Y0Y3 is Hermitian, so -Y0Y3 is also Hermitian. So these are valid Pauli operators. So on qubits 0 and 3, the stabilizer requires that F is either:
F = I0I3,
or F = X0X3,
or F = Z0Z3,
or F = -Y0Y3.
Similarly, on qubits 2 and 1, for E, we need that E is either:
E = I2I1,
or E = X2X1,
or E = Z2Z1,
or E = -Y2Y1.</p>
<p>Now, are there any other possibilities? What if F = Y0Y3 itself? Then that would not be in this list because that would be Y0Y3, not -Y0Y3. So indeed, the conditions are that:
F ∈ { I⊗I, X⊗X, Z⊗Z, -Y⊗Y } on qubits 0 and 3.
E ∈ { I⊗I, X⊗X, Z⊗Z, -Y⊗Y } on qubits 2 and 1.</p>
<p>Let&rsquo;s check one: If F = Y0Y3 (instead of -Y0Y3), then consider the pair where E = I. Then overall error = Y0Y3 ⊗ I1I2. Does that stabilize |ψ_ideal&gt;? likely not. So that makes sense.</p>
<p>So then, the fidelity is the probability that F is in that set AND E is in that set such that their product gives an element of S? But wait, is it sufficient that F is in that set and E is in that set? If F is in that set and E is in that set, then F E will be something where on {0,3} is one of these and on {1,2} is one of these, which is exactly an element of S. So yes, the condition for F E to be in S is that F is one of these 4 operators on {0,3} and E is one of these 4 operators on {1,2}. But wait, is that also necessary? Suppose F is not in that set but still F E is in S. Since F E factors as (F)(E) and since these act on different qubits, if F E is in S, then its restriction to {0,3} must be one of those four. But that restriction is exactly F. So indeed, F must be in {I⊗I, X⊗X, Z⊗Z, -Y⊗Y}. Similarly, E must be in {I⊗I, X⊗X, Z⊗Z, -Y⊗Y}. So the condition is both.</p>
<p>Therefore, the number of favorable outcomes is: For F, there are 4 favorable outcomes out of 16. For E, there are 4 favorable outcomes out of 16. And they are independent. So total favorable outcomes = 4 * 4 = 16. That matches our earlier count from the bijection argument? Actually, wait, that would give 16 favorable outcomes if they were independent? But careful: The map (F,E) -&gt; F E is bijective. The stabilizer S has 16 elements. So there should be exactly 16 pairs that yield an element in S. If favorable outcomes were that F is in a set of size 4 and E is in a set of size 4, that would give 16 outcomes. So that is consistent. So indeed, the condition for fidelity to be 1 is that F is one of these 4 and E is one of these 4.</p>
<p>Now, what are the probabilities of these favorable outcomes?
For F: The depolarizing channel on two qubits: It gives identity with probability (1-p) and each of the 15 non-identity Paulis with probability p/15.
Among the favorable outcomes for F, the identity is one outcome. The other favorable outcomes are: X⊗X, Z⊗Z, and -Y⊗Y. But wait: Are these all non-identity? Yes, they are non-identity. So the probability that F is favorable is: Prob(F is identity) + Prob(F is X⊗X) + Prob(F is Z⊗Z) + Prob(F is -Y⊗Y). = (1-p) + 3*(p/15) = (1-p) + (3p/15) = (1-p) + (p/5) = 1 - p + p/5 = 1 - (4p/5).</p>
<p>Similarly, for E, the probability that E is favorable is also: 1 - (4p/5).</p>
<p>And since F and E are independent, the probability that both are favorable is [1 - (4p/5)]^2.</p>
<p>Therefore, the fidelity F = [1 - (4p/5)]^2.</p>
<p>But wait: Is that the physical state fidelity? Yes, because if the overall error is in the stabilizer, then the state is perfect. If not, then the state is orthogonal to the ideal state. So the fidelity is exactly that probability.</p>
<p>So the answer should be: Fidelity = (1 - 4p/5)^2.</p>
<p>But wait: Could there be any additional contributions from errors that are not in the stabilizer but still have some overlap? For a stabilizer state, if a Pauli is not in the stabilizer, then its expectation is 0. So no.</p>
<p>Thus, the physical state fidelity is (1 - 4p/5)^2.</p>
<p>I will double-check with a couple of examples:
If p=0, fidelity=1.
If p is small, fidelity ≈ 1 - (8p/5) so infidelity scales as (8/5)p, which is more than p. That seems plausible because there are two gates each with error probability p, so baseline infidelity would be 2p if errors always caused Orthogonality. But here, some errors are harmless, so infidelity is reduced. Actually, wait, each gate has probability of error that is harmful = probability that the error is not in the favorable set. For a single gate, that probability is 1 - [1-p + 3*(p/15)] = 1 - [1-p+p/5] = 4p/5. So each gate independently has a harmful error probability of 4p/5. And since they are independent, the probability that both are okay is (1 - 4p/5)^2. So that makes sense.</p>
<p>Therefore, the answer is: 
Physical state fidelity = (1 - 4p/5)^2.</p>
<p>So final answer: 
\boxed{(1 - \frac{4p}{5})^2}</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-understand-the-circuit-and-the-ideal-state">Step 1. Understand the Circuit and the Ideal State</h3>
<p>The goal is to prepare the logical GHZ state:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{\sqrt{2}} \left( |00\rangle_{AB} + |11\rangle_{AB} \right)
\]</div>
<p>in the [[4,2,2]] code, where the two logical qubits (A and B) are encoded into four physical qubits (0,1,2,3). The circuit used is:</p>
<div class="arithmatex">\[
\text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2
\]</div>
<p>Operations are applied from right to left. Starting from the initial state <span class="arithmatex">\(|0000\rangle\)</span>, the circuit produces:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right)
\]</div>
<p>This is indeed the desired logical GHZ state.</p>
<hr />
<h3 id="step-2-model-the-errors">Step 2. Model the Errors</h3>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel:</p>
<ul>
<li>With probability <span class="arithmatex">\(1 - p\)</span>, no error occurs.</li>
<li>With probability <span class="arithmatex">\(p\)</span>, an error occurs, and it is uniformly distributed among the 15 non-identity two-qubit Pauli operators.</li>
</ul>
<p>Let:</p>
<ul>
<li><span class="arithmatex">\(E\)</span> be the error on qubits (2,1) after <span class="arithmatex">\(\text{CNOT}_{21}\)</span></li>
<li><span class="arithmatex">\(F\)</span> be the error on qubits (0,3) after <span class="arithmatex">\(\text{CNOT}_{03}\)</span></li>
</ul>
<p>Each error is a Pauli operator on its respective pair of qubits, chosen from the set of 16 possible operators (including identity).</p>
<hr />
<h3 id="step-3-overall-effect-of-errors">Step 3. Overall Effect of Errors</h3>
<p>The full circuit (including errors) acts as:</p>
<div class="arithmatex">\[
O = F \cdot \text{CNOT}_{03} \cdot H_0 \cdot E \cdot \text{CNOT}_{21} \cdot H_2
\]</div>
<p>Since the gates are Clifford operations and the errors are Pauli operators, the overall effect simplifies to:</p>
<div class="arithmatex">\[
O = (F E) \cdot U
\]</div>
<p>where <span class="arithmatex">\(U\)</span> is the ideal circuit. Therefore, the final state is:</p>
<div class="arithmatex">\[
|\psi_{\text{final}}\rangle = (F E) |\psi_{\text{ideal}}\rangle
\]</div>
<hr />
<h3 id="step-4-when-does-an-error-preserve-the-state">Step 4. When Does an Error Preserve the State?</h3>
<p>The fidelity is:</p>
<div class="arithmatex">\[
\mathcal{F} = \left| \langle \psi_{\text{ideal}} | \psi_{\text{final}} \rangle \right|^2 = \left| \langle \psi_{\text{ideal}} | F E | \psi_{\text{ideal}} \rangle \right|^2
\]</div>
<p>Since <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> is a stabilizer state, the overlap is 1 if <span class="arithmatex">\(F E\)</span> is in the stabilizer group <span class="arithmatex">\(S\)</span> of <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span>, and 0 otherwise.</p>
<p>The stabilizer group <span class="arithmatex">\(S\)</span> is generated by:</p>
<ul>
<li><span class="arithmatex">\(S_1 = X_0 X_1 X_2 X_3\)</span></li>
<li><span class="arithmatex">\(S_2 = Z_0 Z_1 Z_2 Z_3\)</span></li>
<li><span class="arithmatex">\(S_3 = Z_1 Z_2\)</span></li>
<li><span class="arithmatex">\(S_4 = X_1 X_2\)</span></li>
</ul>
<p>Any element of <span class="arithmatex">\(S\)</span> can be written as:</p>
<div class="arithmatex">\[
S = (S_1)^a (S_2)^b (S_3)^c (S_4)^d, \quad a,b,c,d \in \{0,1\}
\]</div>
<p>The group <span class="arithmatex">\(S\)</span> has 16 elements. The condition for <span class="arithmatex">\(F E\)</span> to be in <span class="arithmatex">\(S\)</span> is that:</p>
<ul>
<li><span class="arithmatex">\(F\)</span> acts on qubits (0,3) as one of:<br />
<span class="arithmatex">\(I \otimes I,\quad X \otimes X,\quad Z \otimes Z,\quad -Y \otimes Y\)</span></li>
<li><span class="arithmatex">\(E\)</span> acts on qubits (2,1) as one of:<br />
<span class="arithmatex">\(I \otimes I,\quad X \otimes X,\quad Z \otimes Z,\quad -Y \otimes Y\)</span></li>
</ul>
<hr />
<h3 id="step-5-compute-the-fidelity">Step 5. Compute the Fidelity</h3>
<p>The fidelity is the probability that both <span class="arithmatex">\(F\)</span> and <span class="arithmatex">\(E\)</span> are &ldquo;good&rdquo; (i.e., in the favorable sets above).</p>
<p>For a single two-qubit gate:</p>
<ul>
<li>Probability of identity (good): <span class="arithmatex">\(1 - p\)</span></li>
<li>Probability of a specific non-identity Pauli: <span class="arithmatex">\(\frac{p}{15}\)</span></li>
<li>Number of good non-identity Paulis: 3</li>
</ul>
<p>So, the probability that a given error is good is:</p>
<div class="arithmatex">\[
P(\text{good}) = (1 - p) + 3 \cdot \frac{p}{15} = 1 - p + \frac{p}{5} = 1 - \frac{4p}{5}
\]</div>
<p>Since <span class="arithmatex">\(F\)</span> and <span class="arithmatex">\(E\)</span> are independent:</p>
<div class="arithmatex">\[
\mathcal{F} = \left(1 - \frac{4p}{5} \right)^2
\]</div>
<hr />
<h3 id="final-answer">Final Answer</h3>
<div class="arithmatex">\[
\boxed{(1 - \frac{4p}{5})^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are asked: &ldquo;What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate p, assuming the state is post-selected on all detectable errors in the code?&rdquo;</p>
<p>Interpretation: We have the same circuit as before. But now we post-select on detectable errors. The [[4,2,2]] code is an error detection code. It can detect any single-qubit error? Actually, [[4,2,2]] code has distance 2, so it can detect any single-qubit error? Actually, distance 2 means it can detect any error on one qubit? But careful: The stabilizers are XXXX and ZZZZ. So any single-qubit error will anti-commute with at least one stabilizer? Actually, check: A single-qubit X error on qubit 0: It will anti-commute with ZZZZ? Actually, ZZZZ and X on qubit0: They anti-commute? So yes, it will be detected. So any single-qubit error is detectable. But wait: The errors here are two-qubit errors from CNOT gates. But they act on two qubits. They might be detectable or not. We want to post-select on all detectable errors. That means if an error occurs that is detectable by the code, we discard the state. So we only keep states that have no error or errors that are not detectable? Actually &ldquo;post-selected on all detectable errors&rdquo; means that we measure the stabilizers and if we get a non-trivial syndrome, we discard the state. So we only keep states that are in the code space? But careful: The code space is stabilized by XXXX and ZZZZ. So if the state is in the code space, then the syndrome is trivial. But wait: There might be errors that are not detectable? The code has distance 2, so it can detect any error of weight 1. But errors of weight 2 might be undetectable if they are logical operators? Actually, for a stabilizer code, an error is detectable if it does not commute with at least one stabilizer. So an error is undetectable if it commutes with all stabilizers. That means it is in the normalizer of the stabilizer group. That includes the stabilizer itself and the logical operators. So errors that are in the stabilizer group are not detected because they leave the state in the code space. And errors that are logical operators (but not stabilizers) will take the state to a different logical state, but they commute with the stabilizers? Actually, logical operators commute with the stabilizers by definition. So they are undetectable. So post-selection: We measure the stabilizers. If we get any non-trivial syndrome, we discard. So we only keep states that are in the code space. But wait: There is also the possibility that an error occurs that is exactly a stabilizer? That would not change the state, so it&rsquo;s fine. But if an error is a logical operator (non-identity logical operator), then the state might be changed but still be in the code space? Actually, if an error is a logical operator, it will map the code space to itself. But it will change the logical state. So such errors are not detected by the stabilizer measurements because they commute with the stabilizers. So post-selection only discards states that are outside the code space. So then the logical fidelity after post-selection is: Given that we only keep states that are in the code space, what is the fidelity of the logical state? That is: Conditional on the state being in the code space, what is the probability that it is the correct logical state?</p>
<p>So we need to compute: Probability that the state is the ideal state given that it is in the code space. That is: F_logical = P(no error or error in stabilizer) / P(state in code space). But careful: Errors that are logical operators will put the state in the code space but change the logical state. So they reduce fidelity.</p>
<p>So we need to analyze the errors from the two CNOT gates. As before, the overall effect is that the final state is (F E) |ψ_ideal&gt;, where F acts on qubits 0,3 and E acts on qubits 2,1. And we want to know when does (F E) leave the state in the code space? That is when (F E) commutes with the stabilizers? Actually, the state is in the code space if and only if it is stabilized by XXXX and ZZZZ. But if an error occurs that is not in the normalizer of the stabilizer group, then the state will be outside the code space. So post-selection means we only keep states for which (F E) is in the normalizer of the stabilizer group. The normalizer of the stabilizer group for the [[4,2,2]] code is the set of Pauli operators that commute with XXXX and ZZZZ. What are those? They are Pauli operators that have an even number of X&rsquo;s and Z&rsquo;s? Actually, check: A Pauli operator will commute with XXXX if it has an even number of Pauli&rsquo;s that anticommute with X? Actually, more systematically: The stabilizer group is generated by S1=XXXX and S2=ZZZZ. A Pauli operator P will commute with S1 if the number of qubits where P has either Y or Z? Actually, easier: The normalizer of the stabilizer group is the set of Pauli operators that can be written as products of the stabilizers and the logical operators. The logical operators are: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI. So the normalizer group (ignoring phases) has size? The stabilizer group has 4 elements? Actually, the stabilizer group has 4 generators? Wait, the stabilizer group for [[4,2,2]] is actually of order 4? Actually, the code has 4 physical qubits, 2 stabilizers, so the stabilizer group has 2^2=4 elements? But careful: The stabilizer group is {I, XXXX, ZZZZ, XXXX ZZZZ} but note that XXXX and ZZZZ commute? They do commute because the number of places where they are both non-identity is 4, which is even. So the stabilizer group is of order 4. Then the logical operators: There are 4 logical Paulis? Actually, for 2 logical qubits, the logical Pauli group has 16 elements. So the normalizer of the stabilizer group in the Pauli group (mod phases) will have size 4 * 16 = 64. But we are interested in which errors (F E) will keep the state in the code space. That is exactly those errors that are in the normalizer of the stabilizer group. But wait: Is that correct? If an error E is in the normalizer, then E|ψ&gt; is still in the code space because the stabilizers will act on it as something? Actually, if E is in the normalizer, then for any stabilizer S, S E|ψ&gt; = E S&rsquo;|ψ&gt; = E|ψ&gt; if S&rsquo;=±S? Actually, careful: If E is in the normalizer, then for each stabilizer S, there is a sign such that E S = ± S E. But if |ψ&gt; is in the code space, then S|ψ&gt;=|ψ&gt;. So then S (E|ψ&gt;) = ± E S|ψ&gt; = ± E|ψ&gt;. So for E|ψ&gt; to be in the code space, we need that the sign is +1 for all stabilizers. So actually, the condition for E to map the code space to itself is that E commutes with all stabilizers. So we need E to be in the centralizer of the stabilizer group. The centralizer is the set of Paulis that commute with every element of the stabilizer group. That is actually the normalizer since the stabilizer group is abelian. So yes, errors that are in the normalizer will map the code space to itself. So post-selection: We measure the stabilizers. If the state is not in the code space, we discard. So we only keep states for which (F E) is in the normalizer of the stabilizer group. That is, (F E) must commute with XXXX and ZZZZ.</p>
<p>Now, what are the conditions for a Pauli operator P on 4 qubits to commute with XXXX? XXXX is the product of X on all qubits. A Pauli operator will commute with XXXX if and only if it has an even number of Pauli matrices that anticommute with X. Which Paulis anticommute with X? Z and Y anticommute with X, while I and X commute with X. So the condition is that the number of qubits where P is either Z or Y must be even. Similarly, to commute with ZZZZ, the number of qubits where P is either X or Y must be even (since X and Y anticommute with Z). So for P to be in the normalizer, it must have an even number of Z/Y and an even number of X/Y across the 4 qubits.</p>
<p>But we also have the structure: P = F E, where F acts on qubits 0 and 3, and E acts on qubits 2 and 1. So we can analyze separately.</p>
<p>Let&rsquo;s denote:
F is a Pauli on qubits 0 and 3. Write F = F_0 ⊗ F_3.
E is a Pauli on qubits 2 and 1. Write E = E_2 ⊗ E_1.
Then P = F_0 ⊗ E_1 ⊗ E_2 ⊗ F_3.</p>
<p>We want P to commute with XXXX. That means that the number of qubits among {0,1,2,3} where the Pauli is Z or Y must be even.
Similarly, for ZZZZ: number of qubits where the Pauli is X or Y must be even.</p>
<p>Now, after post-selection, we only keep states where P is in the normalizer. Among these, some will leave the logical state unchanged (if P is in the stabilizer group itself) and some will change the logical state (if P is a logical operator that is not in the stabilizer).</p>
<p>We want the logical fidelity. That is the probability that the logical state is correct given that the state is in the code space. That is: 
F_logical = (Probability that P is in the stabilizer) / (Probability that P is in the normalizer).</p>
<p>But careful: Could there be cases where P is not in the normalizer but still the state is in the code space? Actually, if P is not in the normalizer, then the state will be outside the code space because the stabilizers will detect it. So post-selection discards those. So indeed, we only consider P in the normalizer.</p>
<p>So we need to compute: 
P(normalizer) = probability that (F E) is in the normalizer.
P(stabilizer) = probability that (F E) is in the stabilizer group (which is a subgroup of the normalizer).</p>
<p>Then fidelity = P(stabilizer) / P(normalizer).</p>
<p>But wait: Is that correct? If P is in the normalizer but not in the stabilizer, then it will act as a logical operator on the code space. But could it act as identity on the logical state? Possibly if it is a logical operator that is actually the identity on the logical qubits? But the logical operators are defined modulo stabilizers. So if P is in the normalizer, then its action on the logical state is given by its equivalence class in the normalizer modulo the stabilizer. So we want that the logical action is identity. That means that P is in the stabilizer group. So yes, fidelity = probability that P is in the stabilizer given that it is in the normalizer.</p>
<p>So we need to compute these probabilities as functions of p.</p>
<p>As before, F and E are independent. Each comes from a depolarizing channel on two qubits: 
With probability 1-p, it is identity (I⊗I).
With probability p, it is one of the 15 non-identity Paulis, each with probability p/15.</p>
<p>So we need to count: For a two-qubit Pauli on a specific pair (say qubits 0 and 3 for F), how many of these 16 operators are in the normalizer condition? But careful: The normalizer condition is on the full 4-qubit operator P = F E. But since F and E act on disjoint sets, the condition decouples? Actually, the conditions for P to be in the normalizer are:
(1) The number of qubits among {0,1,2,3} with Pauli being Z or Y is even.
(2) The number of qubits with Pauli being X or Y is even.</p>
<p>Now, F acts on qubits 0 and 3. E acts on qubits 1 and 2 (but careful: E acts on qubits 2 and 1, but order: qubits: 0,1,2,3. So E gives operators on qubit 2 and qubit 1. So it&rsquo;s fine.)</p>
<p>So let&rsquo;s denote:
For F on qubits 0 and 3, let’s determine the conditions that F must satisfy such that there exists an E that makes P in the normalizer? But wait, F and E are independent. We want to compute the probability that P is in the normalizer. That is: Sum over F and E that satisfy the conditions: (even number of Z/Y overall) and (even number of X/Y overall).</p>
<p>Because F and E are independent, we can compute the probability for a given F that it allows E to be such that the total is even? Actually, careful: The conditions are on the combined operator. So we can compute: 
P(normalizer) = Sum_{F} Prob(F) * (Sum_{E such that (F,E) satisfies conditions} Prob(E) ).</p>
<p>And similarly, P(stabilizer) = Sum_{F} Prob(F) * (Sum_{E such that (F,E) is in stabilizer} Prob(E) ).</p>
<p>But maybe we can compute these totals by symmetry. Alternatively, we can count the number of pairs (F,E) that yield P in the normalizer and those that yield P in the stabilizer.</p>
<p>As before, the map (F,E) -&gt; P is a bijection from the set of pairs to the set of 4-qubit Paulis (16*16=256). So the number of pairs that yield a given Pauli P is exactly 1. So then:
Number of pairs that yield P in the normalizer = number of Paulis in the normalizer.
Number of pairs that yield P in the stabilizer = number of Paulis in the stabilizer.</p>
<p>We already know the stabilizer group has size 4? Wait, careful: The stabilizer group of the code is generated by XXXX and ZZZZ. That group has order 4? Actually, the stabilizer group is {I, XXXX, ZZZZ, XXXX ZZZZ}. But wait, is that all? What about products like XXXX * something? Actually, the stabilizer group is the set of operators that leave every state in the code space invariant. For a stabilizer code, the stabilizer group is abelian and does not include logical operators. For the [[4,2,2]] code, the stabilizers are indeed XXXX and ZZZZ. But then the group they generate is of order 4 because XXXX and ZZZZ commute and are independent? But then what about the operators we earlier considered like Z1Z2 and X1X2? Those are logical operators? Actually, check: Z1Z2. Does it commute with XXXX? Yes. Does it commute with ZZZZ? Yes. So Z1Z2 is in the normalizer. But is it in the stabilizer? That would require that Z1Z2 acts as identity on the code space. But does it? Consider a state in the code space. For example, |00&gt;_L = (|0000&gt;+|1111&gt;)/√2. Z1Z2 on that gives? On |0000&gt;, Z1Z2 gives +1. On |1111&gt;, Z1Z2 gives (+1) because both are 1? Actually, careful: Z|1&gt; = -|1&gt;, so Z1Z2 on |1111&gt; gives (-1)*(-1)=+1. So Z1Z2 acts as identity on |00&gt;_L. On |01&gt;_L, maybe it acts as -1? So Z1Z2 is not necessarily a stabilizer because a stabilizer must act as +1 on all code states. So the stabilizer group is only the set of operators that are products of the generators that actually fix every code state. The generators are XXXX and ZZZZ. So the stabilizer group is {I, XXXX, ZZZZ, XXXX ZZZZ}. But wait, check: XXXX ZZZZ =? That is actually YYYY times a phase? Actually, XXXX ZZZZ = (XZ)(XZ)(XZ)(XZ) = (-iY)(-iY)(-iY)(-iY) = (-i)^4 YYYY = YYYY. So the stabilizer group is {I, XXXX, ZZZZ, YYYY}? But are these all? What about something like XXII? That is not in the stabilizer because it might not commute with ZZZZ? Actually, XXII commutes with ZZZZ? Check: XXII and ZZZZ: On qubit0, X and Z anticommute, so that gives a sign; on qubit1, X and Z anticommute, so another sign; so overall they commute. So XXII is in the normalizer. But is it in the stabilizer? It would need to act as identity on the code space. But on |00&gt;_L = (|0000&gt;+|1111&gt;)/√2, XXII gives? On |0000&gt;, XXII gives |1100&gt; which is not in the code space? Actually, wait, if it is a stabilizer, it should map the code space to itself. But |1100&gt; is not necessarily in the code space because the code space is 4-dimensional. So the stabilizer group is only the set of operators that are actually in the center of the normalizer? I need to be careful.</p>
<p>The stabilizer group S of a code is defined as the set of Pauli operators that fix every state in the code space. For the [[4,2,2]] code, the code space is the simultaneous +1 eigenspace of XXXX and ZZZZ. So if an operator is in the stabilizer group, it must commute with XXXX and ZZZZ (so it is in the normalizer) and it must act as +1 on the code space. The generators are XXXX and ZZZZ. So any product of these will act as +1 on the code space. So the stabilizer group is actually the group generated by XXXX and ZZZZ. That group has order 4 because XXXX and ZZZZ are independent and commute. So S = {I, XXXX, ZZZZ, XXXX ZZZZ}. But wait, is XXXX ZZZZ equal to YYYY? Yes, up to a phase? Actually, XXXX ZZZZ = (XZ)(XZ)(XZ)(XZ) = (-iY)(-iY)(-iY)(-iY) = (-i)^4 YYYY = YYYY. So S = {I, XXXX, ZZZZ, YYYY}. So the stabilizer group has 4 elements.</p>
<p>But earlier, when we computed the fidelity without post-selection, we found that the condition for the state to be correct was that F E is in the stabilizer of the state |ψ_ideal&gt;, not the stabilizer of the code. And that stabilizer had order 16. So careful: There is a difference between the stabilizer of the code and the stabilizer of the particular state |ψ_ideal&gt;. The code stabilizer is the set of operators that fix every state in the code space. The state |ψ_ideal&gt; is a specific state within the code space. Its stabilizer (as a state) is larger. For example, consider Z1Z2. Does it fix |ψ_ideal&gt;? We computed that Z1Z2|ψ_ideal&gt; = |ψ_ideal&gt;. So Z1Z2 is in the stabilizer of |ψ_1\rangle} but it is not in the stabilizer of the code because it does not fix all code states. So for logical fidelity, we care about whether the logical state is correct. That means that the error should act as identity on the logical qubits. That is equivalent to the error being in the stabilizer of the logical state? Actually, if the error is a logical operator that is not the identity on the logical qubits, it will change the logical state. So for the logical state to be correct, the error must be such that its action on the logical qubits is identity. That means that the error is in the normalizer of the code stabilizer but its logical action is trivial. That is exactly the code stabilizer itself? Actually, wait: The code stabilizer S_code acts trivially on the code space. But there are other operators in the normalizer that act trivially on the code space? For example, consider Z1Z2. Does it act trivially on the code space? Let&rsquo;s check on a basis of the code space. The code space has logical basis |00&gt;_L, |01&gt;_L, |10&gt;_L, |11&gt;_L. What is the action of Z1Z2 on these? We can determine the logical operators. We have: Z_A = ZZII, Z_B = ZIZI. So Z1Z2 is not necessarily a logical operator? Actually, Z1Z2 = (Z1I2)(I1Z2) but that&rsquo;s not directly a logical operator. Let&rsquo;s compute: On |00&gt;_L = (|0000&gt;+|1111&gt;)/√2, Z1Z2 gives +1. On |01&gt;_L = (|0011&gt;+|1100&gt;)/√2, Z1Z2: on |0011&gt;, qubit1=0 so Z=+1, qubit2=1 so Z=-1, so product -1; on |1100&gt;, qubit1=1 -&gt; -1, qubit2=0 -&gt; +1, product -1; so Z1Z2|01&gt;_L = -|01&gt;_L. So Z1Z2 acts as -1 on |01&gt;_L. So it is not in the code stabilizer because code stabilizer must act as +1 on all code states. So indeed, the only operators that act as identity on the entire code space are those in the code stabilizer S_code. So for the logical state to be correct, the error must be in S_code. But wait, could there be an error that is not in S_code but still leaves the particular state |ψ_ideal&gt; unchanged? Yes, as we saw, Z1Z2 leaves |ψ_ideal&gt; unchanged because |ψ_ideal&gt; is a superposition of |00&gt;_L and |11&gt;_L, and on |11&gt;_L, Z1Z2 gives? |11&gt;_L = (|0110&gt;+|1001&gt;)/√2. On |0110&gt;, qubit1=1 -&gt; -1, qubit2=1 -&gt; -1, product +1; on |1001&gt;, qubit1=0 -&gt; +1, qubit2=0 -&gt; +1; so actually Z1Z2|11&gt;_L = |11&gt;_L. So indeed, Z1Z2 fixes |ψ_ideal&gt;. But that is because |ψ_ideal&gt; is not a full basis state of the code space; it&rsquo;s a specific state. However, if we are only concerned with the logical state fidelity, we want the logical state to be exactly |ψ_ideal&gt;. That means that if an error acts as a logical operator that is not identity but happens to fix |ψ_ideal&gt;, that would still give fidelity 1. But wait, is that possible? Consider a logical operator that is not identity on the logical qubits. For example, consider the logical operator X_A. That would flip the first logical qubit. Would that fix |ψ_ideal&gt;? |ψ_ideal&gt; = (|00&gt;+|11&gt;)/√2. X_A would send it to (|10&gt;+|01&gt;)/√2, which is different. So not that.
What about Z_A? Z_A would send |00&gt; to |00&gt; and |11&gt; to -|11&gt;, so that would give (|00&gt; - |11&gt;)/√2, which is not the same state unless there is a phase overall? Actually, that state is orthogonal to |ψ_ideal&gt; because inner product is 0. So indeed, for the logical state to be correct, the error must act as identity on the logical state. That means that the error must be in the set of Paulis that stabilize |ψ_ideal&gt;. And that set we determined earlier has size 16. But wait, is that the code stabilizer? The code stabilizer is only 4 elements. So there are additional operators that stabilize |ψ_ideal&gt; but are not in the code stabilizer. For example, Z1Z2 stabilizes |ψ_ideal&gt; but is not in the code stabilizer because it does not stabilize all code states. However, if we are post-selecting on the code space, then we only keep states that are in the code space. But if an error is not in the code stabilizer but stabilizes |ψ_ideal&gt;, then will the resulting state be in the code space? Let&rsquo;s check: Take error = Z1Z2. This error commutes with the stabilizers? Z1Z2 commutes with XXXX? Check: XXXX and Z1Z2: On qubit1, X and Z anticommute; on qubit2, X and Z anticommute; so overall they commute. And with ZZZZ, they commute because Z&rsquo;s commute. So Z1Z2 is in the normalizer. So if we apply Z1Z2 to |ψ_ideal&gt;, the state remains in the code space because Z1Z2 is in the normalizer. And we already checked that Z1Z2|ψ_ideal&gt; = |ψ_ideal&gt;. So actually, errors that are in the stabilizer of |ψ_1\rangle} but not in the code stabilizer will still yield the correct logical state. So for logical fidelity after post-selection, we want that the error is in the set of Paulis that stabilize |ψ_ideal&gt;. But wait, is that always true? Consider an error that is in the normalizer but not in the stabilizer of |ψ_ideal&gt;. That error will map |ψ_ideal&gt; to some other state in the code space. That other state will be an eigenstate of the logical operators with different eigenvalues? So that would be an error on the logical state. So indeed, after post-selection, the logical state is correct if and only if the error is in the stabilizer of |ψ_ideal&gt; (which we determined has 16 elements). But careful: Is that entire set contained in the normalizer? Yes, because if it stabilizes |ψ_ideal&gt;, then it must commute with the code stabilizers? Actually, not necessarily: An operator that stabilizes a particular state does not have to commute with the stabilizers of the code? But if |ψ_ideal&gt; is in the code space, then for any stabilizer S of the code, S|ψ_ideal&gt;=|ψ_ideal&gt;. If E stabilizes |ψ_ideal&gt;, then S E|ψ_ideal&gt; = S|ψ_ideal&gt; = |ψ_ideal&gt;. But also E S|ψ_ideal&gt; = E|ψ_ideal&gt; = |ψ_1\rangle}. So that doesn&rsquo;t force commutation. Actually, wait: Consider an operator E that stabilizes |ψ_ideal&gt; but does not commute with some stabilizer S. Then S E|ψ_ideal&gt; = S|ψ_ideal&gt; = |ψ_ideal&gt;. But E S|ψ_ideal&gt; = E|ψ_ideal&gt; = |ψ_ideal&gt;. So that is fine. But could it be that E does not commute with S? For example, take a single qubit code? I need to check: For the [[4,2,2]] code, the stabilizer of |ψ_ideal&gt; that we found earlier were those operators that act on {0,3} as one of {I, X⊗X, Z⊗Z, -Y⊗Y} and on {1,2} as one of {I, X⊗X, Z⊗Z, -Y⊗Y}. Do these commute with XXXX? Let&rsquo;s check one: F = X⊗X on {0,3} and E = I⊗I on {1,2} gives overall X0X3. Does that commute with XXXX? X0X3 and XXXX: On qubit0, they commute; on qubit3, commute; on qubits1 and2, XXXX has X&rsquo;s and X0X3 has I&rsquo;s, so they commute. So yes. What about F = -Y⊗Y on {0,3} and E = I⊗I on {1,2} gives -Y0Y3. That with XXXX: On qubit0, Y and X anticommute; on qubit3, Y and X anticommute; so two anticommutations give commute overall. So indeed, these operators commute with XXXX. Similarly, they commute with ZZZZ? Check: For F = X⊗X, with ZZZZ: On qubit0, X and Z anticommute; on qubit3, anticommute; so commute overall. So yes, they are in the normalizer. So the stabilizer of |ψ_ideal&gt; is a subgroup of the normalizer. Its size is 16. And the code stabilizer is a subgroup of that of size 4. So then, after post-selection, we only keep states where the error is in the normalizer. Among those, the ones that yield the correct logical state are those in the stabilizer of |ψ_ideal&gt;, which has 16 elements out of the normalizer. But wait, what is the size of the normalizer? The normalizer of the stabilizer group in the Pauli group on 4 qubits (ignoring phases) is: The stabilizer group has 4 elements. The logical Pauli group for 2 qubits has 16 elements. So the normalizer has size 4 * 16 = 64. So there are 64 Pauli operators that map the code space to itself. Among these, 16 will stabilize |ψ_ideal&gt; (and thus leave the logical state unchanged), and the other 48 will change the logical state.</p>
<p>So then, the logical fidelity after post-selection is: 
F_logical = (Probability that error is in the stabilizer of |ψ_ideal&gt;) / (Probability that error is in the normalizer).</p>
<p>But careful: Is that conditional probability? Yes, because we post-select on being in the normalizer. So 
F_logical = [P(stabilizer of |ψ_ideal&gt;)] / [P(normalizer)].</p>
<p>Now, we need to compute these probabilities as functions of p. And since the errors come from independent depolarizing channels on the two CNOT gates, we can use the fact that the map (F,E) -&gt; P is a bijection between the 256 pairs and the 256 Pauli operators on 4 qubits (actually, careful: The Pauli group on 4 qubits has 4^4 = 256 elements if we ignore phases? Actually, the Pauli group on n qubits has 4^n elements if we consider Pauli matrices with phases ±1, ±i? But usually when we talk about Pauli errors, we consider them as operators up to phase? Actually, in error analysis, we often consider the set of Pauli operators as {I,X,Y,Z} on each qubit without overall phase factors because the depolarizing channel is defined with these. So indeed, there are 4^4 = 256 possible Pauli operators on 4 qubits. And our errors F and E are chosen from sets of size 16 each, so total 256 outcomes. So that bijection is correct.)</p>
<p>So then, the probability that the overall error P is a particular Pauli operator is exactly the probability of the unique pair (F,E) that gives that P. And since F and E are independent with distributions: 
P(F) = 1-p if F=I⊗I, and = p/15 for each of the 15 non-identity Paulis on {0,3}.
Similarly for E.</p>
<p>So then, the probability that P is in a certain set S is the sum over all P in S of the probability of the corresponding (F,E). And that sum is simply (number of elements in S) times something? But careful: Not all Paulis have the same probability because the probability depends on whether F is identity or not and whether E is identity or not. However, because of the bijection, each Pauli P corresponds to a unique pair (F,E). But different Paulis will have different probabilities because they come from different combinations of F and E. So we cannot simply say that the probability is (|S|/256) because the distribution is not uniform over the 256 Paulis. We need to compute the total probability that P is in the normalizer and the total probability that P is in the stabilizer of |ψ_ideal&gt;.</p>
<p>So we need to count: For each Pauli operator P on 4 qubits, what is its probability in terms of p? But wait, since the map is bijective, each P corresponds to a unique pair (F,E). And the probability of that pair is: 
If F is identity, that contributes factor (1-p). If F is non-identity, factor (p/15).
Similarly for E.
So the probability for a given P is: (1-p)^2 if both F and E are identity.
(1-p)*(p/15) if one is identity and the other is non-identity.
(p/15)^2 if both are non-identity.</p>
<p>So if we want to compute the total probability for P to be in some set S, we need to know how many of the Paulis in S come from pairs where F is identity and E is identity, how many come from F identity and E non-identity, how many come from F non-identity and E identity, and how many come from both non-identity.</p>
<p>So we need to determine the structure of the normalizer and the stabilizer of |ψ_ideal&gt; in terms of this decomposition.</p>
<p>Let&rsquo;s denote:
N = normalizer set, size 64.
S_psi = stabilizer of |ψ_ideal&gt;, size 16.</p>
<p>We want to compute:
P(N) = Sum_{P in N} Prob(P)
P(S_psi) = Sum_{P in S_psi} Prob(P)</p>
<p>And then fidelity = P(S_psi) / P(N).</p>
<p>Now, note that every Pauli P corresponds to a unique pair (F,E). And F acts on qubits 0 and 3, E acts on qubits 1 and 2.
So we can classify Paulis by what they are on these two pairs separately. Actually, any Pauli P can be written as P = P_{03} ⊗ P_{12}, where P_{03} is a Pauli on qubits 0 and 3, and P_{12} is a Pauli on qubits 1 and 2. But careful: This decomposition is not independent because the conditions for being in the normalizer involve both parts together? Actually, the conditions for being in the normalizer are conditions on the whole Pauli. But they can be stated in terms of the Paulis on the two pairs? Let&rsquo;s see: 
P is in the normalizer if:
(1) The number of qubits with Pauli being Z or Y is even.
(2) The number of qubits with Pauli being X or Y is even.
Now, if we separate into pairs {0,3} and {1,2}, these conditions become conditions on the two pairs jointly. Specifically, let for a two-qubit Pauli Q on two qubits, define:
n_z(Q) = number of qubits where Q is Z or Y (mod 2)
n_x(Q) = number of qubits where Q is X or Y (mod 2)
Then for P = P_{03} ⊗ P_{12}, the conditions are:
n_z(P_{03}) + n_z(P_{12}) is even.
n_x(P_{03}) + n_x(P_{12}) is even.
So that means that P_{03} and P_{12} must have the same parity for n_z and the same parity for n_x? Actually, even sum means they are both even or both odd. So conditions: 
n_z(P_{03}) and n_z(P_{12}) have the same parity.
n_x(P_{03}) and n_x(P_{12}) have the same parity.</p>
<p>Now, what about the stabilizer of |ψ_ideal&gt;? We determined that condition earlier: 
P is in the stabilizer of |ψ_ideal&gt; if and only if 
P_{03} is one of: I⊗I, X⊗X, Z⊗Z, -Y⊗Y
and 
P_{12} is one of: I⊗I, X⊗X, Z⊗Z, -Y⊗Y.
But wait, is that correct? Let&rsquo;s check: If P_{03} = X⊗X and P_{12} = I⊗I, then P = X0X3. Is that in the stabilizer of |ψ_ideal&gt;? We need to check if it fixes |ψ_ideal&gt;. |ψ_ideal&gt; = 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). X0X3 on |0000&gt; gives |1010&gt; which is not in the support? Actually, wait, that would give |1010&gt; but that state is not in the superposition. So that suggests that actually, the condition for stabilizing |ψ_ideal&gt; is not simply that the Pauli on {0,3} and {1,2} are of those forms independently. Because |ψ_ideal&gt; has correlations between the pairs. Let&rsquo;s derive the stabilizer of |ψ_ideal&gt; properly. 
|ψ_ideal&gt; = 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). 
We want Pauli P such that P|ψ_ideal&gt; = |ψ_ideal&gt;. 
Write P = P0 P1 P2 P3.
Consider its action on each basis state. For P to stabilize, it must map each basis state to another basis state in the support with a phase that is consistent across all. Actually, it might be easier to use the fact that we already know that the circuit gives O = (F E) U, and we determined that the condition for no error (fidelity=1) was that F E is in the set that we called earlier. And that set had size 16. And we determined that condition was that F is in {I⊗I, X⊗X, Z⊗Z, -Y⊗Y} on {0,3} and E is in {I⊗I, X⊗X, Z⊗Z, -Y⊗Y} on {1,2}. But wait, that was for the state fidelity without post-selection. But that is exactly the condition that (F E)|ψ_ideal&gt; = |ψ_ideal&gt;. So that means that the stabilizer of |ψ_1\rangle} is actually that set. And note that this set is not simply a product of conditions on {0,3} and {1,2} independently because if F = X⊗X and E = I⊗I, then that gives P = X0X3. Does that stabilize |ψ_ideal&gt;? Let&rsquo;s check: X0X3|0000&gt; = |1010&gt; which is not in the support. So wait, there is an inconsistency. I need to re-derive the condition for state fidelity from first principles carefully.</p>
<p>We have |ψ_ideal&gt; = U|0000&gt; where U = CNOT_{03} H_0 CNOT_{21} H_2.
And we found that if there are errors F and E, then the final state is (F E) U|0000&gt; = (F E)|ψ_ideal&gt;.
We want this to equal |ψ_ideal&gt;. So we want F E to be in the stabilizer of |ψ_ideal&gt;. 
Now, let&rsquo;s compute the stabilizer of |ψ_ideal&gt; directly from its form:
|ψ_ideal&gt; = 1/2(|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>Consider a Pauli operator P. For it to stabilize |ψ_ideal&gt;, it must satisfy P|ψ_ideal&gt; = |ψ_ideal&gt;. 
Let&rsquo;s take P = X0X3. Then:
X0X3|0000&gt; = |1010&gt;.
X0X3|1001&gt; = |0011&gt;.
X0X3|0110&gt; = |1110&gt;.
X0X3|1111&gt; = |0101&gt;.
None of these are in the support because the support only has states where qubit0=qubit3 and qubit1=qubit2. So clearly, X0X3 does not stabilize |ψ_ideal&gt;. 
What about P = X0X1? Then:
X0X1|0000&gt; = |1100&gt;.
X0X1|1001&gt; = |0101&gt;.
X0X1|0110&gt; = |1010&gt;.
X0X1|1111&gt; = |0011&gt;.
So no.
What about P = Z0Z3? 
Z0Z3|0000&gt; = |0000&gt;.
Z0Z3|1001&gt; = (-1)<em>(-1)|1001&gt; = |1001&gt;.
Z0Z3|0110&gt; = (+1)</em>(+1)|0110&gt; = |0110&gt;.
Z0Z3|1111&gt; = (-1)<em>(-1)|1111&gt; = |1111&gt;.
So Z0Z3 stabilizes |ψ_ideal&gt;. So that is in the stabilizer.
What about P = Z1Z2?
Z1Z2|0000&gt; = |0000&gt;.
Z1Z2|1001&gt; = (+1)</em>(+1)|1001&gt; = |1001&gt;.
Z1Z2|0110&gt; = (-1)<em>(-1)|0110&gt; = |0110&gt;.
Z1Z2|1111&gt; = (-1)</em>(-1)|1111&gt; = |1111&gt;.
So Z1Z2 stabilizes |ψ_ideal&gt;.
What about P = X0X1X2X3? That is XXXX. 
XXXX|0000&gt; = |1111&gt;.
XXXX|1001&gt; = |0110&gt;.
XXXX|0110&gt; = |1001&gt;.
XXXX|1111&gt; = |0000&gt;.
So XXXX stabilizes |ψ_ideal&gt;.
What about P = Z0Z1Z2Z3? 
ZZZZ|0000&gt; = |0000&gt;.
ZZZZ|1001&gt; = (-1)<em>(-1)</em>(-1)<em>(-1)|1001&gt; = |1001&gt;? Actually, careful: ZZZZ|1001&gt; = Z0|1&gt;Z1|0&gt;Z2|0&gt;Z3|1&gt; = (-1)</em>(+1)<em>(+1)</em>(-1)= (+1)|1001&gt;. So yes.
ZZZZ|0110&gt; = (+1)<em>(-1)</em>(-1)<em>(+1)= (+1)|0110&gt;.
ZZZZ|1111&gt; = (-1)</em>(-1)<em>(-1)</em>(-1)= (+1)|1111&gt;.
So ZZZZ stabilizes.
What about P = X0X3? We already did, no.
What about P = X1X2?
X1X2|0000&gt; = |0000&gt;? Actually, X1X2|0000&gt; = |0000&gt; because qubits1 and2 are 0 become 1? Wait, |0000&gt; means qubit1=0, qubit2=0, so X1X2|0000&gt; = |0110&gt; actually because flipping bits 1 and2 gives |0,1,1,0&gt; which is |0110&gt;. So that gives |0110&gt;. 
X1X2|1001&gt; = |1111&gt; because flipping bits1 and2 in |1001&gt; gives |1,1,0,1&gt;? Actually, careful: |1001&gt; means qubit1=0, qubit2=0? No, |1001&gt; means qubit0=1, qubit1=0, qubit2=0, qubit3=1. So flipping bits1 and2 gives |1,1,1,1&gt; = |1111&gt;.
X1X2|0110&gt; = |0000&gt;.
X1X2|1111&gt; = |1001&gt;.
So X1X2 actually maps |ψ_ideal&gt; to itself? Because then |ψ_ideal&gt; becomes 1/2(|0110&gt;+|1111&gt;+|0000&gt;+|1001&gt;) which is the same set. So X1X2 stabilizes |ψ_ideal&gt;. 
What about P = Y0Y3? 
Y0Y3|0000&gt; = Y0|0&gt;Y3|0&gt; = (i|1&gt;)(i|1&gt;) = -|1111&gt;.
Y0Y3|1001&gt; = Y0|1&gt;Y3|1&gt; = (-i|0&gt;)(-i|0&gt;) = -|0000&gt;.
Y0Y3|0110&gt; = Y0|0&gt;Y3|0&gt; = (i|1&gt;)(i|1&gt;) = -|1111&gt;? Wait, careful: |0110&gt; means qubit0=0, so Y0|0&gt;= i|1&gt;; qubit3=0, so Y3|0&gt;= i|1&gt;; product = -|1110&gt;? But wait, that would give state |1,1,1,0&gt; which is not in the support because qubit3=0 but qubit0=1, so actually that state is |1110&gt; is not in the support because support requires qubit0=qubit3. So likely Y0Y3 does not stabilize. Let&rsquo;s do properly:
For |0110&gt;, qubit0=0 -&gt; Y|0&gt;= i|1&gt;; qubit1=1 -&gt; Y|1&gt;= -i|0&gt;; qubit2=1 -&gt; Y|1&gt;= -i|0&gt;; qubit3=0 -&gt; Y|0&gt;= i|1&gt;. So overall, phase = i * (-i) * (-i) * i = (i<em>(-i))=1, (-i)</em>(-i)= -1? Let&rsquo;s do step: i * (-i) = 1, then 1 * (-i) = -i, then (-i)* i = -i^2 = 1. So actually, Y0Y1Y2Y3|0110&gt; = |1001&gt;? That is interesting. So maybe Y0Y3 alone is not enough. So the stabilizer of |ψ_ideal&gt; that we found earlier from the circuit analysis was that it requires that F is in {I, X⊗X, Z⊗Z, -Y⊗Y} and E is in {I, X⊗X, Z⊗Z, -Y⊗Y}. That would mean that overall, things like X0X3 would not be included because that would require F=X0X3 and E=I, but that is not in the list because X0X3 is not one of {I, X⊗X, Z⊗Z, -Y⊗Y}? But wait, X0X3 is actually X⊗X on {0,3}. So that would be included if that list were correct. But we just ruled out X0X3 because it gave states outside the support. So there is a mistake. Let&rsquo;s re-derive the condition from the circuit analysis carefully.</p>
<p>We had: O = F * CNOT_{03} * H_0 * E * CNOT_{21} * H_2.
And we found that this simplifies to O = (F E) U because we argued that F and E commute with the gates? But wait, that simplification assumed that E commutes with H_0 and CNOT_{03}. But does E commute with H_0? E acts on qubits 2 and 1. H_0 acts on qubit 0. So yes, they commute. And does E commute with CNOT_{03}? CNOT_{03} acts on qubits 0 and 3. E acts on qubits 2 and 1. So yes, they commute. So then O = F * CNOT_{03} * H_0 * CNOT_{21} * H_2 * E = U * E? That would be if also E commutes with CNOT_{21} and H_2? But careful: The order is: O = F * (CNOT_{03}) * (H_0) * (E) * (CNOT_{21}) * (H_2). We cannot simply move E past CNOT_{21} and H_2 because E acts on qubits 2 and 1 and CNOT_{21} acts on qubits 2 and 1 as well. So that commutation is not allowed. So my earlier simplification that led to O = (F E) U is actually not correct. I need to derive carefully.</p>
<p>Let&rsquo;s define:
U1 = H_2
U2 = CNOT_{21}
U3 = H_0
U4 = CNOT_{03}
So ideal U = U4 U3 U2 U1.
Errors: after U2, we apply E on qubits (2,1). after U4, we apply F on qubits (0,3).
So actual operator: O = F * U4 * U3 * E * U2 * U1. 
Now, can we simplify this? Notice that U3 acts on qubit 0 only. E acts on qubits 2,1. So U3 and E commute. So O = F * U4 * E * U3 * U2 * U1 = F * U4 * E * (U3 U2 U1). But careful: U3 U2 U1 is not U because U4 is separate. So O = F * U4 * E * (U3 U2 U1). 
Now, does E commute with U4? U4 acts on qubits 0 and 3. E acts on qubits 2 and 1. So yes, they commute. So O = F * E * U4 * U3 * U2 * U1 = F * E * U.
So actually, it does become O = (F E) U. I earlier worried about commutation with U2 and H_2 but that worry was because I moved E past U2 and U1? Let&rsquo;s check that step carefully:
O = F * U4 * U3 * E * U2 * U1.
U3 and E commute because they act on different qubits. So that gives = F * U4 * E * U3 * U2 * U1.
Now, does E commute with U4? U4 acts on qubits 0 and 3, E acts on qubits 2 and1, so yes. So = F * E * U4 * U3 * U2 * U1 = F E U.
So that seems correct. So then indeed, O = (F E) U. So the final state is (F E)|ψ_ideal&gt;. So then the condition for no error is that F E is in the stabilizer of |ψ_ideal&gt;. And that condition we determined earlier from that analysis led to that F must be in {I, X⊗X, Z⊗Z, -Y⊗Y} and E must be in {I, X⊗X, Z⊗Z, -Y⊗Y}. But wait, that would include the case F = X⊗X and E = I, which gives overall X0X3. But we already checked that X0X3 does not stabilize |ψ_ideal&gt;. So there is a tension. Let&rsquo;s check that case with the circuit method. Suppose only error is F = X0X3 happens on the second CNOT gate. Then the circuit is: 
Start with |0000&gt;. 
Apply H2 -&gt; becomes (|0000&gt;+|0010&gt;)/√2.
Apply CNOT21 -&gt; becomes (|0000&gt;+|0110&gt;)/√2.
Apply H0 -&gt; becomes 1/2(|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;).
Apply CNOT03 -&gt; becomes 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;)=|ψ_ideal&gt;. 
Then apply F = X0X3. So that would give X0X3|ψ_ideal&gt; = 1/2(X0X3|0000&gt; + X0X3|1001&gt; + X0X3|0110&gt; + X0X3|1111&gt;) = 1/2(|1010&gt;+|0011&gt;+|1110&gt;+|0101&gt;). Is that equal to |ψ_ideal&gt;? clearly not because |ψ_ideal&gt; has states where qubit0=qubit3 and qubit1=qubit2. Here, |1010&gt; has qubit0=1, qubit3=0 so no. So wait, then why did we get O = (F E) U? That would predict that if F=X0X3 and E=I, then the final state is X0X3|ψ_ideal&gt;. So there is a mistake in the commutation step. Let&rsquo;s check the commutation step carefully with this example. 
O = F * U4 * U3 * E * U2 * U1. For our case, F = X0X3, E=I.
So O = X0X3 * CNOT03 * H0 * I * CNOT21 * H2.
Now, does X0X3 commute with CNOT03? CNOT03 acts on qubits 0 and 3. X0X3 does not commute with CNOT03 because CNOT03 involves control on qubit0 and target on qubit3. Let&rsquo;s check: CNOT03 followed by X0X3 is not the same as X0X3 followed by CNOT03 generally. So actually, we cannot commute F with U4 because F acts on qubits that U4 acts on. So the step where I said does E commute with U4? That was fine because E acts on different qubits. But F acts on qubits 0 and 3, and U4 acts on qubits 0 and 3. So F and U4 do not commute generally. So then O = F * U4 * U3 * E * U2 * U1 is not equal to F * E * U4 * U3 * U2 * U1 because that would require that F commutes with U4, which it does not. So we cannot simplify to O = (F E) U. So we need to actually propagate errors through the circuit. So let&rsquo;s do that properly.</p>
<p>We have stages:
State after stage 1: |ψ1&gt; = H2 |0000&gt; = (|0000&gt;+|0010&gt;)/√2.
Stage 2: Apply CNOT21. So |ψ2&gt; = CNOT21 |ψ1&gt; = (|0000&gt;+|0110&gt;)/√2.
Then error E on qubits (2,1). So |ψ2&rsquo;&gt; = E |ψ2&gt;. 
Stage 3: Apply H0. So |ψ3&gt; = H0 |ψ2&rsquo;&gt;.
Stage 4: Apply CNOT03. So |ψ4&gt; = CNOT03 |ψ3&gt;.
Then error F on qubits (0,3). So final state |ψ_final&gt; = F |ψ4&gt;.</p>
<p>So errors occur at different points and then are affected by subsequent gates. So we need to determine the effective error on the state relative to |ψ_ideal&gt;. This is more involved.</p>
<p>Maybe there is a easier way using the fact that the circuit is Clifford and errors are Pauli. So we can determine the effective Pauli error on the initial state after propagation through the circuit. That is, take an error happening at a certain point, and determine what Pauli it becomes after the remaining gates. Then the final state will be that Pauli applied to |ψ_ideal&gt;. So then we can compute the conditions for that Pauli to be in the stabilizer of |ψ_ideal&gt; versus in the normalizer.</p>
<p>Let&rsquo;s do that. Let&rsquo;s consider errors separately.</p>
<p>We have two error locations: after CNOT21, error E on qubits (2,1). after CNOT03, error F on qubits (0,3).</p>
<p>Let&rsquo;s determine the effective error when propagated through the remaining circuit.</p>
<p>First, consider an error E on qubits (2,1) that happens after CNOT21. Then the remaining circuit is: H0, then CNOT03, then finally error F happens after that independently. But careful: errors happening later will also propagate. But since they are Pauli, the overall effect will be some Pauli. So let&rsquo;s first compute the propagation of an error E on (2,1) through the subsequent gates up to before the last error F. Then that effective error will then be multiplied by F itself on (0,3) at the end. So overall, the final state will be: F * ( propagation of E through H0 and CNOT03 ) applied to |ψ_ideal&gt;. But wait, careful: The ideal state is obtained when no errors occur. So if we have errors, the state is not simply some Pauli times |ψ_1\rangle} because the errors occur inside the circuit. However, since the circuit is Clifford, the effect of any Pauli error at any point can be accounted for by replacing it with an effective Pauli error at the end of the circuit acting on the ideal state. Is that true? Yes, for Clifford circuits, if you have a Pauli error at some point, you can propagate it through the subsequent gates and it will become some Pauli acting on the final state. So then the final state will be that Pauli times the ideal state. But careful: This is true if the error happens before the last gate? Actually, yes: For any Clifford circuit, if you have an Pauli error at any location, the resulting state is equivalent to the ideal state acted upon by some Pauli operator that depends on the error and its location. And if there are multiple errors, since they are Pauli, the overall effect is the product of the effective errors from each location. So we can compute effective errors for each error location.</p>
<p>Let&rsquo;s define the circuit gates clearly. The circuit is applied in order:</p>
<ol>
<li>H2</li>
<li>CNOT21</li>
<li>ERROR E on (2,1)</li>
<li>H0</li>
<li>CNOT03</li>
<li>ERROR F on (0,3)</li>
</ol>
<p>So let&rsquo;s compute the effective error from an error E on (2,1) that happens after step 2. We want to know what Pauli does it become after steps 4 and 5? because step 6 is another error that happens after, so that will just multiply independently. So let&rsquo;s compute: If an error E acts on (2,1) immediately after CNOT21, then what is the effective error after passing through H0 and CNOT03? But careful: H0 acts on qubit0 only. CNOT03 acts on qubits (0,3). So we need to see how an operator on qubits (2,1) transforms under H0 and CNOT03. Since H0 and CNOT03 act on different qubits than (2,1) normally commute with operators on (2,1) because they act on disjoint sets? Actually, H0 acts on qubit0 only. That is disjoint from {2,1}. So H0 will commute with any operator on {2,1}. Similarly, CNOT03 acts on {0,3} and will commute with any operator on {2,1} because they act on different qubits. So actually, wait: H0 and CNOT03 do not involve qubits 2 and 1 at all. So any error on qubits (2,1) will commute with H0 and CNOT03. So that means that if an error E happens on (2,1) after step 2, then after steps 4 and 5, it will still be the same Pauli acting on (2,1). So the effective error from E is just E itself acting on (2,1) at the end of the circuit before the last error F. But wait, is that always true? Check with an example: Suppose E = X2. Then after H0 and CNOT03, since these gates act on qubits 0 and 3, they commute with X2. So yes, effective error remains X2.
So then after step 5, the state is actually ( effective error from E ) applied to the state that would be there if no error occurred at step 3? But careful: The state after step 5 without any errors would be |ψ_ideal&gt;. So if only error E occurs, then after step 5, the state is E |ψ_ideal&gt;. Then step 6 applies F on (0,3). So overall, the final state is F * E |ψ_ideal&gt;. So wait, that is actually what we had before: O = F * E * U seems to be true if errors commute with the subsequent gates? But then we already ruled out that because of the example F=X0X3 alone should commute with U4? But wait, check that example: If only error is F on (0,3) happening after step 5. Then that error would commute with nothing because it happens at the very end. So then the final state is F |ψ_ideal&gt;. So that would mean that if only error is F, then effective error is F itself. So then overall, if both errors occur, the final state is F * E |ψ_ideal&gt;. So then my earlier commutation attempt would give O = F * E * U provided that F commutes with U4? But wait, does F commute with U4? U4 is CNOT03. F acts on (0,3). They do not commute generally. So why would that be? Let&rsquo;s check with only error F happening. That means after step 5, state is |ψ_ideal&gt;. Then we apply F on (0,3). So the final state is F |ψ_ideal&gt;. So that suggests that effective error from F is just F itself. So then if both errors occur, then the final state is F * E |ψ_ideal&gt;. But wait, is that always true? Consider the order: after step 2, we apply E. Then steps 3-5 are applied to that state. But since those steps commute with E because they act on different qubits, yes, after step 5, the state is E |ψ_ideal&gt;. Then step 6 applies F. So final state = F E |ψ_ideal&gt;. So actually, it seems that indeed, the final state is always F E |ψ_ideal&gt;. So then why did I earlier worry about commuting F with U4? That was when I tried to move F past U4 inside the circuit. But here, F happens after U4 already. So it&rsquo;s correct that the final state is F E |ψ_ideal&gt;. So then the condition for the state to be correct is that F E is in the stabilizer of |ψ_ideal&gt;. And that is what I initially thought. Then my counterexample was when F = X0X3 and E=I gives final state = X0X3|ψ_ideal&gt;. And I computed that explicitly and found it does not equal |ψ_ideal&gt;. So there is an inconsistency between that and the circuit steps. Let&rsquo;s compute that circuit explicitly with only error F=X0X3 happening at the end.
Circuit steps:</p>
<ol>
<li>H2 on |0000&gt; -&gt; becomes (|0000&gt;+|0010&gt;)/√2.</li>
<li>CNOT21 -&gt; becomes (|0000&gt;+|0110&gt;)/√2.</li>
<li>H0 -&gt; becomes 1/2(|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;).</li>
<li>CNOT03 -&gt; becomes 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;) = |ψ_ideal&gt;.</li>
<li>Apply F = X0X3. So final state = X0X3|ψ_ideal&gt; = 1/2(X0X3|0000&gt; + X0X3|1001&gt; + X0X3|0110&gt; + X0X3|1111&gt;).
Now, X0X3|0000&gt; = |1010&gt; because flip qubit0 and qubit3: becomes |1,0,0,1&gt; wait careful: X0X3 means apply X on qubit0 and X on qubit3. So on |0000&gt;, that gives |1001&gt; actually because qubit0 becomes 1, qubit3 becomes 1? No, wait: |0000&gt; means qubit0=0,1=0,2=0,3=0. X0 changes qubit0 to 1, X3 changes qubit3 to 1. So that gives |1001&gt;. So X0X3|0000&gt; = |1001&gt;.
Next, X0X3|1001&gt; = flip qubit0 and qubit3 on |1001&gt;. qubit0=1 -&gt; becomes 0, qubit3=1 -&gt; becomes 0, so becomes |0001&gt;? But careful: |1001&gt; means qubit0=1,1=0,2=0,3=1. After X0 and X3, qubit0 becomes 0, qubit3 becomes 0, so state becomes |0001&gt; but wait, that is |0,0,0,1&gt; actually that is |0001&gt;.
Next, X0X3|0110&gt; = |1110&gt; because qubit0=0-&gt;1, qubit3=0-&gt;1, so becomes |1,1,1,0&gt;.
Next, X0X3|1111&gt; = |0111&gt; because qubit0=1-&gt;0, qubit3=1-&gt;0, so becomes |0,1,1,1&gt;.
So the final state would be 1/2(|1001&gt;+|0001&gt;+|1110&gt;+|0111&gt;). That is not equal to |ψ_ideal&gt;. So that suggests that if only error is F=X0X3, then the final state is not simply X0X3|ψ_ideal&gt;? But wait, that is what I did: I applied X0X3 to |ψ_ideal&gt;. So it should be that. So then why would that happen? because after step 4, the state is |ψ_ideal&gt;. Then step 5 is applying F which is X0X3. So indeed, the final state is X0X3|ψ_ideal&gt;. So that seems correct. So then why did I get that earlier when I computed the circuit steps manually for only error F, I got something else? I need to recompute the circuit steps carefully for only error F=X0X3 happening at the end.</li>
</ol>
<p>Circuit for only error F:
Start: |0000&gt;
Apply H2: -&gt; state = H2|0000&gt; = 1/√2(|0&gt;+|1&gt;) on qubit2 times |0&gt; on others actually careful: H2 acts on qubit2 only. So state becomes = |00&gt;_{0,1} ⊗ (H|0&gt;_2) ⊗ |0&gt;_3 = |00&gt; ⊗ (|0&gt;+|1&gt;)/√2 ⊗ |0&gt; = (|0000&gt;+|0010&gt;)/√2.
Apply CNOT21: CNOT21 means control on qubit2, target on qubit1. So on |0000&gt;, control=0 so no flip -&gt; stays |0000&gt;. On |0010&gt;, control=1 so flip qubit1 -&gt; becomes |0110&gt;. So state becomes (|0000&gt;+|0110&gt;)/√2.
Apply H0: H0 acts on qubit0. So state becomes: H0|0000&gt; = (|0&gt;+|1&gt;)/√2 on qubit0 times |000&gt; -&gt; actually careful: |0000&gt; means qubit0=0, so H0|0&gt;= (|0&gt;+|1&gt;)/√2, so that gives (|0000&gt;+|1000&gt;)/√2. And H0|0110&gt; = since qubit0=0 in |0110&gt;, becomes (|0110&gt;+|1110&gt;)/√2. So overall state after H0 = 1/√2 * [ (|0000&gt;+|1000&gt;)/√2 + (|0110&gt;+|1110&gt;)/√2 ] = 1/2(|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;).
Apply CNOT03: CNOT03 means control on qubit0, target on qubit3.
On |0000&gt;: control=0 -&gt; no flip -&gt; stays |0000&gt;.
On |1000&gt;: control=1 -&gt; flip qubit3 -&gt; becomes |1001&gt;.
On |0110&gt;: control=0 -&gt; no flip -&gt; stays |0110&gt;.
On |1110&gt;: control=1 -&gt; flip qubit3 -&gt; becomes |1111&gt;.
So state becomes 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;) = |ψ_ideal&gt;. So that is correct.
Now apply error F = X0X3. So act with X0 and X3 on this state.
X0X3|0000&gt; = apply X0 and X3 to |0000&gt; gives |1001&gt; because qubit0 becomes 1, qubit3 becomes 1.
X0X3|1001&gt; = apply X0 and X3 to |1001&gt; gives |0000&gt; because qubit0:1-&gt;0, qubit3:1-&gt;0.
X0X3|0110&gt; = apply X0 and X3 to |0110&gt; gives |1110&gt; because qubit0:0-&gt;1, qubit3:0-&gt;1.
X0X3|1111&gt; = apply X0 and X3 to |1111&gt; gives |0111&gt; because qubit0:1-&gt;0, qubit3:1-&gt;0.
So final state = 1/2(|1001&gt;+|0000&gt;+|1110&gt;+|0111&gt;) = 1/2(|0000&gt;+|1001&gt;+|0111&gt;+|1110&gt;). 
Now, is that equal to |ψ_ideal&gt;? |ψ_ideal&gt; is 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). So they are different because third term: |0110&gt; vs |0111&gt; and fourth: |1111&gt; vs |1110&gt;. So indeed, final state is not |ψ_ideal&gt;. So that confirms that if only error is F=X0X3, then the final state is X0X3|ψ_ideal&gt; and that is not equal to |ψ_ideal&gt;. So then the condition for no error is that F E must be in the stabilizer of |ψ_ideal&gt;. And that stabilizer, based on this example, would not include X0X3 alone. So then what is the stabilizer of |ψ_ideal&gt;? We can determine it by looking for Paulis that leave |ψ_ideal&gt; invariant. Let&rsquo;s find them systematically. 
|ψ_ideal&gt; = 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). 
Let P be a Pauli. Write P = P0 P1 P2 P3.
For P to stabilize, it must map each basis state to another basis state in the set with a phase, and the phases must be such that the overall state is unchanged.
 because it&rsquo;s a Pauli, it will act on each computational basis state by flipping bits and multiplying by a phase. So let&rsquo;s denote the action on each term clearly. </p>
<p>term1: |0000&gt;
 term2: |1001&gt;
 term3: |0110&gt;
 term4: |1111&gt;</p>
<p>conditions. likely already known that Z0Z3, Z1Z2, XXXX, ZZZZ stabilize. What about X0X1? That would give:
X0X1|0000&gt; = |1100&gt; not in set.
So that doesn&rsquo;t.
What about X0X3? We already did: gives |1001&gt;, |0000&gt;, |1110&gt;, |0111&gt; so no.
What about X1X2? 
X1X2|0000&gt; = |0110&gt; phase? X1X2 on |0000&gt;: since acting on |00&gt; gives |11&gt; so actually careful: |0000&gt; -&gt; becomes |0,1,1,0&gt; = |0110&gt;. So that maps term1 to term3.
X1X2|1001&gt; = |1,0,0,1&gt; actually wait: |1001&gt; -&gt; X1X2 gives |1,1,1,1&gt;? Let&rsquo;s do: |1001&gt; means qubit1=0, qubit2=0 -&gt; become 1,1 so becomes |1111&gt;. So term2 -&gt; term4.
X1X2|0110&gt; = |0000&gt; because flip bits1 and2 of |0110&gt; gives |0000&gt;.
X1X2|1111&gt; = |1001&gt; because flip bits1 and2 of |1111&gt; gives |1001&gt;.
So X1X2 actually permutes the terms: 1&lt;-&gt;3 and 2&lt;-&gt;4. So that would leave the state invariant if phases are all +1. Check phases: 
X1X2|0000&gt; = no phase issues because X|0&gt;=|1&gt; has phase 1.
|1001&gt; -&gt; X1X2|1001&gt; = likely phase 1 because acting on |0&gt; gives |1&gt; and on |0&gt; gives |1&gt; so okay.
So X1X2 seems to stabilize |ψ_ideal&gt;. So that is in the stabilizer.
What about Y0Y1? That would give phases likely not all equal.
I recall that the stabilizer of a state like this should have order 8 maybe? Actually, wait, |ψ_ideal&gt; is a stabilizer state of itself? It is not necessarily a stabilizer state of the full Pauli group because it is entangled across 4 qubits. Actually, it is a stabilizer state because it can be prepared by a Clifford circuit. So its stabilizer should have size 2^4=16. So there should be 16 Paulis that stabilize it. So we need to find 16 Paulis. They are generated by 4 operators. likely they are: Z0Z3, Z1Z2, X0X1X2X3, and something else? But wait, check: Z0Z3 and Z1Z2 we already have. Their product is Z0Z1Z2Z3 which is ZZZZ. So that gives that. Then X0X1X2X3 is XXXX. So that gives that. So these 4 generate a group of size 16? Actually, Z0Z3 and Z1Z2 commute and are independent? But wait, do they commute? Z0Z3 and Z1Z2 act on different qubits so yes. So that gives 4 elements. Then with XXXX, that would give 8 elements. Then we need one more to get to 16. That additional generator could be X1X2 perhaps? But then check if X1X2 commutes with Z0Z3? Yes. Does it commute with Z1Z2? X1X2 and Z1Z2: on qubit1, X and Z anticommute; on qubit2, X and Z anticommute; so they commute overall. And with XXXX? likely yes. So then the group generated by {Z0Z3, Z1Z2, XXXX, X1X2} has size? Z0Z3 and Z1Z2 give 4, times XXXX gives 8, times X1X2 gives 16. So that is likely the stabilizer of |ψ_ideal&gt;. So then the stabilizer of |ψ_ideal&gt; is actually generated by these 4 operators. Let&rsquo;s check action of X1X2 we already did. So then what are the conditions for being in this stabilizer? If I take an arbitrary Pauli P = P0P1P2P3, for it to be in the stabilizer, it must commute with these generators and act as +1 on |ψ_ideal&gt;. actually wait, being in the stabilizer means that P itself fixes |ψ_ideal&gt;. So that is determined by its action on the basis states. I won&rsquo;t derive that fully here. Instead, I&rsquo;ll use the fact that since the circuit is Clifford, the effective error from any Pauli error at any location will be some Pauli acting on the final state. And that effective error can be computed by propagating the error through the subsequent gates. So maybe I should compute the effective errors for each error location separately.</p>
<p>Let&rsquo;s do that. We have two error locations: after CNOT21, error E on (2,1). after CNOT03, error F on (0,3).</p>
<p>Let&rsquo;s compute the effective error from an error E on (2,1) that happens after CNOT21. subsequent gates: H0 and then CNOT03. But careful: These gates act on qubits 0 and 3 only. So they commute with any operator on qubits 2 and 1? Actually, wait, H0 acts on qubit0 only. That commutes with operators on qubits 2 and because they act on different qubits. CNOT03 acts on qubits 0 and 3. That also commutes with operators on qubits 2 and 1 because those are different. So indeed, if an error happens on (2,1) at that point, then after H0 and CNOT03, it will still be the same Pauli on (2,1). So the effective error from E is just E itself acting on the final state. So that means that if only error E occurs, the final state is E|ψ_ideal&gt;. So then for that to be correct, E must be in the stabilizer of |ψ_ideal&gt;. So that gives conditions on E alone. So what are the Paulis on qubits (2,1) that stabilize |ψ_ideal&gt;? From our generators, likely that requires that E must be either I⊗I, Z⊗Z, X⊗X, or something else? Let&rsquo;s check: If E = Z1Z2, then that works because Z1Z2|ψ_ideal&gt;=|ψ_ideal&gt;. If E = X1X2, then that works as well because we checked X1X2 works. What about Y1Y2? Consider Y1Y2|ψ_ideal&gt;. Y1Y2|0000&gt; = Y1|0&gt;Y2|0&gt; = (i|1&gt;)(i|1&gt;)= -|1,1,0,0&gt; actually careful: |0000&gt; -&gt; becomes -|0110&gt;? because qubit1 and2 become 1 gives |0,1,1,0&gt; wait, that is |0110&gt; actually. So phase would be -1 times |0110&gt;. Then Y1Y2|1001&gt; would give? likely not all phases equal. So probably the only Paulis on (2,1) that stabilize are I, Z1Z2, X1X2, and maybe also something else? What about Z1 alone? That would not because it would give phases. So likely on qubits (2,1), the stabilizer conditions are that E must be either I⊗I, Z1Z2, X1X2, or their product which is -Y1Y2? because Z1Z2 * X1X2 = actually careful: Z1Z2 * X1X2 = (Z1X1)(Z2X2) = (-iY1)(-iY2)= (-1)Y1Y2. So yes, that would be -Y1Y2. So on (2,1), the stabilizer of |ψ_ideal&gt; requires that E is in {I⊗I, Z1Z2, X1X2, -Y1Y2}. </p>
<p>Now consider an error F on (0,3) that happens after CNOT03. subsequent gates: none actually because it happens at the end. So effective error from F is just F itself. So then if only error F occurs, the final state is F|ψ_ideal&gt;. So for that to be correct, F must be in the stabilizer of |ψ_1\rangle} on qubits (0,3). What are those? likely they are {I⊗I, Z0Z3, X0X3? But wait, check: Z0Z3 works because we checked. Does X0X3 work? We already ruled out X0X3 because it did not stabilize. What about something else? What about X0 alone? That would not. So likely on (0,3), the stabilizer conditions are that F must be in {I⊗I, Z0Z3} only? But wait, could there be another? What about something like X0X1? That acts on both pairs though. So for an error solely on (0,3), it would be products of Paulis on qubits 0 and 3 only. So we need to find all Paulis on qubits 0 and 3 that stabilize |ψ_ideal&gt;. Let&rsquo;s check manually:
|ψ_ideal&gt; = 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). 
Consider a Pauli on qubits 0 and 3 only. That means it acts as identity on qubits 1 and2.
So take P = A0 B3 where A,B ∈ {I,X,Y,Z} but not both I necessarily.
For this to stabilize, it must map each term to itself or to another term in the support with the same phase overall.
 term1: |0000&gt; -&gt; A0B3|0000&gt; = (A|0&gt;)(B|0&gt;) times |00&gt; on qubits1,2. 
 term2: |1001&gt; -&gt; A0B3|1001&gt; = (A|1&gt;)(B|1&gt;) times |00&gt; because qubits1,2 are 0 actually careful: |1001&gt; means qubit1=0,2=0.
 term3: |0110&gt; -&gt; A0B3|0110&gt; = (A|0&gt;)(B|0&gt;) times |11&gt; because qubits1,2 are 1,1.
 term4: |1111&gt; -&gt; A0B3|1111&gt; = (A|1&gt;)(B|1&gt;) times |11&gt;.</p>
<p>For these to be in the support, we need that the resulting state has qubits1,2 either both 0 or both 1. So that requires that for terms1 and2, that&rsquo;s fine because they become |00&gt; always. For terms3 and4, they become |11&gt; always. So that condition is okay actually for any A,B? Not quite: also the states on qubits0 and3 must match the pattern that qubit0 should equal qubit3 for terms1 and4? Actually, the support states are those where qubit0=qubit3 and qubit1=qubit2. So for term1, after action, we need that the resulting state on qubits0 and3 should have both 0 or both 1? Actually, term1 is |0000&gt; means qubit0=0,3=0. So after action, we need that become either |0000&gt; or |1111&gt; actually wait, careful: The support is not that qubit0=qubit3 necessarily? Yes, because look at the states: |0000&gt; has 0=0,3=0. |1001&gt; has 1 and0? Actually, |1001&gt; has qubit0=1, qubit3=1. |0110&gt; has qubit0=0, qubit3=0? Actually, |0110&gt; has qubit0=0, qubit3=0? No, |0110&gt; means qubit0=0,1=1,2=1,3=0. So actually, in |0110&gt;, qubit0=0 and qubit3=0. In |1111&gt;, qubit0=1,3=1. So indeed, in all support states, qubit0 = qubit3. So that means that after action of A0B3, for term1, we need that A|0&gt; and B|0&gt; are such that they are both |0&gt; or both |1&gt;. That means that A and B must be either both I or both Z actually because Z|0&gt;=|0&gt; times phase? actually Z|0&gt;=|0&gt; with phase +1. What about X? X|0&gt;=|1&gt;. So if A=X and B=X, then term1 becomes |1&gt; and |1&gt; so that works actually because then term1 becomes |1100&gt; wait careful: term1 is |0000&gt;. If A=X and B=X, then A|0&gt;=|1&gt;, B|0&gt;=|1&gt;, so that gives |11&gt; on qubits0,3, so that state becomes |1100&gt;. But |1100&gt; is not in the support because support requires that qubit1=qubit2 are 0 actually that is okay because |1100&gt; has qubit1=0,2=0, so that is actually in the support? But wait, support states are only these four: |0000&gt;,|1001&gt;,|0110&gt;,|1111&gt;. |1100&gt; is not one of these because it would require that qubit0=1,3=0 actually no, support requires that qubit0=qubit3. In |1100&gt;, qubit0=1 and qubit3=0, so that fails. So for term1, after action, we need that the state on qubits0 and3 becomes either |00&gt; or |11&gt;. So that means that A|0&gt; and B|0&gt; must be both |0&gt; or both |1&gt;. If A=X, then A|0&gt;=|1&gt;. So we need B|0&gt; to be |1&gt; as well, so B must be X. So that suggests that A=X,B=X might work? But then check term2: |1001&gt;. For term2, A|1&gt; and B|1&gt;. If A=X,B=X, then X|1&gt;=|0&gt;, so that gives |00&gt; on qubits0,3. So term2 becomes |0001&gt;? wait, careful: term2 is |1001&gt;. After applying X0X3, we get: X|1&gt;=|0&gt;, X|1&gt;=|0&gt;, so that gives |00&gt; on qubits0,3, so the state becomes |0001&gt; because qubits1,2 are still 0,0. But |0001&gt; is not in the support because support requires qubit0=qubit3 here that is 0 and 0 actually wait, |0001&gt; has qubit0=0, qubit3=1, so that fails. So X0X3 does not work. So likely on (0,3), the only possibilities are I⊗I and Z0Z3. What about Y0Y3? If A=Y,B=Y, then Y|0&gt;= i|1&gt;, so term1 becomes phase i^2|11&gt; = -|11&gt; so that gives state |1100&gt; which is not in support because that would require qubit0=1,3=0 actually wait, |1100&gt; means qubit0=1,3=0, so that&rsquo;s not allowed because support requires qubit0=qubit3. So indeed, on (0,3), the only stabilizers appear to be I and Z0Z3. What about X0Z3? That would give term1: X|0&gt;=|1&gt;, Z|0&gt;=|0&gt;, so that gives |10&gt; on qubits0,3, so not allowed. So yes, on (0,3), the stabilizer conditions are that F must be either I⊗I or Z0Z3.</p>
<p>Now, what about errors on (2,1)? As argued, they commute with subsequent gates, so effective error is itself. And we found that on (2,1), the stabilizer conditions are that E must be in {I⊗I, Z1Z2, X1X2, -Y1Y2} because that comes from the fact that Z1Z2 works, X1X2 works, and their product gives -Y1Y2 works likely. Let&rsquo;s check X1X2 works already. Check -Y1Y2: -Y1Y2|0000&gt; = - (Y|0&gt;)(Y|0&gt;) = - (i|1&gt;)(i|1&gt;)= -(-1)|11&gt;=|11&gt; actually careful: i<em>i=-1, so -(-1)=+1, so term1 becomes |0,1,1,0&gt; = |0110&gt;. Term2: -Y1Y2|1001&gt; = - (Y|0&gt;)(Y|1&gt;) wait, careful: |1001&gt; means qubit1=0, qubit2=0 actually because |1001&gt; is qubit0=1,1=0,2=0,3=1. So for term2, acting on qubits1 and2: Y|0&gt;= i|1&gt;, Y|0&gt;= i|1&gt;, product = i^2|11&gt; = -|11&gt;, times overall - gives +|11&gt;. So term2 becomes |1,1,1,1&gt; = |1111&gt;. Term3: -Y1Y2|0110&gt; = acting on qubits1 and2 of |0110&gt; means qubit1=1,2=1: Y|1&gt; = -i|0&gt;, Y|1&gt; = -i|0&gt;, product = (-i)</em>(-i)= i^2? Actually, (-i)<em>(-i)= -1? Let&rsquo;s do: (-i)</em>(-i)= i^2? Actually, i^2 = -1. So product = (-1) actually careful: (-i)<em>(-i) = i^2 = -1. So then -Y1Y2|0110&gt; = - ( product ) times state? Actually, careful: -Y1Y2 means multiply by -1 then apply Y1Y2. So for term3: Y1Y2|0110&gt; = (Y|1&gt;)(Y|1&gt;) = (-i|0&gt;)(-i|0&gt;)= (-i)</em>(-i)= i^2? I need to do this systematically with phases determined by the Pauli matrices themselves. Maybe it&rsquo;s easier to use the fact that the stabilizer of |ψ_ideal&gt; should have size 16. And we already have generators: Z0Z3, Z1Z2, XXXX, X1X2. So then any element of the stabilizer will be determined by its action on (0,3) and (1,2) separately? But wait, these generators do not factorize completely because XXXX involves both pairs. So actually, the stabilizer elements will have correlated actions on the two pairs. So then for an error that acts only on (0,3) to be in the stabilizer, it must be that its action on (0,3) is such that when combined with identity on (1,2), the overall operator is in the stabilizer. So that means that we need Pauli operators on (0,3) such that there exists something on (1,2) that is identity actually wait, if error is only on (0,3), then it is P_{03} ⊗ I_{12}. For this to be in the stabilizer, it must commute with the generators and act as +1 on |ψ_ideal&gt;. Let&rsquo;s check that. Take P = Z0Z3 ⊗ I. That works because that is actually one of the generators? Actually, Z0Z3 is not itself a generator because the generators are Z0Z3Z? No, wait, Z0Z3 alone would be because that would give on term1: Z0Z3|0000&gt;=|0000&gt;. term2: Z0Z3|1001&gt;= (-1)<em>(-1)|1001&gt;=|1001&gt;. term3: Z0Z3|0110&gt;= (+1)</em>(+1)|0110&gt;=|0110&gt;. term4: Z0Z3|1111&gt;= (-1)<em>(-1)|1111&gt;=|1111&gt;. So yes, Z0Z3 is in the stabilizer. What about X0X3 ⊗ I? That we already ruled out. What about I alone? works. So indeed, on (0,3), the only stabilizers are I and Z0Z3. What about on (1,2)? If we take P = I_{03} ⊗ something on (1,2). For that to be in the stabilizer, take something like Z1Z2 works. X1X2 works as we checked. What about Y1Y2? Consider I_{03} ⊗ Y1Y2. Then on term1: Y1Y2|0000&gt; = (Y|0&gt;)(Y|0&gt;)= (i|1&gt;)(i|1&gt;)= -|0110&gt; actually careful: that gives state |0,1,1,0&gt; = |0110&gt;, but with phase? actually, i</em>i = -1, so term1 becomes -|0110&gt;. term2: I⊗Y1Y2|1001&gt; = |1⟩ times Y1Y2|001&gt; wait, careful: |1001&gt; means qubit1=0,2=0 so becomes (Y|0&gt;)(Y|0&gt;)= -|1,1&gt; so term2 becomes -|1111&gt;. term3: I⊗Y1Y2|0110&gt; = acting on qubits1,2 which are both 1: Y|1&gt;= -i|0&gt;, so product = (-i)*(-i)= -1, so term3 becomes -|0000&gt;. term4: becomes -|1001&gt;. So overall, I⊗Y1Y2 would give -|ψ_ideal&gt; actually because it cycles the terms with a minus sign? Actually, check phases: term1 -&gt; -1, term2 -&gt; -1, term3 -&gt; -1, term4 -&gt; -1 would give overall -|ψ_1\rangle}. So wait, I⊗Y1Y2 might actually stabilize if it gives a constant phase of -1? But then that would mean that I⊗Y1Y2|ψ_ideal&gt; = -|ψ_ideal&gt;. But that is not allowed because stabilizer means it should give +1 times |ψ_ideal&gt;. So I⊗Y1Y2 is not in the stabilizer. What about -I⊗Y1Y2? That would give phase +1. So indeed, on (1,2), the stabilizer conditions are that the error must be either I, Z1Z2, X1X2, or -Y1Y2. So that matches our earlier guess.</p>
<p>So then, when both errors occur, the effective error is F * E. For this to be in the stabilizer of |ψ_ideal&gt;, we need that overall, the Pauli on (0,3) from F and on (1,2) from E combine such that the resulting operator is in the stabilizer. But careful: wait, could it be that F alone is not in the stabilizer but when multiplied by an E that is not in the stabilizer, they become in the stabilizer? For example, suppose F = X0X3 itself is not in the stabilizer. But if E is something that also acts on (1,2) such that the product becomes something like X0X3 * something might become in the stabilizer? But note that these act on different qubits, so the product factors as (F on (0,3)) ⊗ (E on (1,2)). For this to be in the stabilizer, we need that F on (0,3) must be either I or Z0Z3 because that&rsquo;s what we found for operators that act only on (0,3) to be in the stabilizer. Is it possible that an operator that is not of that form on (0,3) could become in the stabilizer when tensored with something on (1,2)? Suppose F = X0X3. Then consider E such that overall becomes X0X3 ⊗ something. For this to be in the stabilizer, it would have to commute with the generators conditions. But likely no because then would that operator stabilize |ψ_ideal&gt;? Let&rsquo;s check an example: If F = X0X3 and E = X1X2, then overall is X0X3X1X2 = XXXX actually. And XXXX is in the stabilizer. So wait, that is interesting: X0X3 is not in the stabilizer alone, but if combined with X1X2, then the product is X0X1X2X3 which is XXXX, which is in the stabilizer. So that means that effective error can be in the stabilizer even if individually F and E are not in their own stabilizer conditions. So we need to compute the conditions for F * E to be in the stabilizer of |ψ_ideal&gt;. Since these act on different qubits, any operator in the stabilizer will factor as something on (0,3) tensored something on (1,2). And from earlier, we determined that on (0,3), the only possibilities for an operator to be in the stabilizer when alone are I and Z0Z3. But wait, what about X0X3? Is it possible that X0X3 alone is in the stabilizer? We already ruled that out because it doesn&rsquo;t stabilize |ψ_ideal&gt;. So indeed, if an operator acts only on (0,3), it must be I or Z0Z3 to be in the stabilizer. However, when combined with something on (1,2), could it be that the product is in the stabilizer even if the (0,3) part is not I or Z0Z3? Let&rsquo;s check: Take operator = X0X3 ⊗ X1X2. That is XXXX, which is in the stabilizer. So that means that for the product to be in the stabilizer, it is not necessary that the (0,3) part alone is in the stabilizer. So then conditions become coupled between F and E. </p>
<p>Maybe it&rsquo;s easier to use the fact that the map (F,E) -&gt; effective error is actually a bijection onto the set of Pauli operators on 4 qubits. And then the probability that the effective error is in the stabilizer of |ψ_ideal&gt; is simply the sum over all Pauli operators in that stabilizer of their probabilities. And that probability depends on how many of those Paulis come from pairs where F is identity or not. So we need to know for each Pauli operator P in the stabilizer of |ψ_ideal&gt;, what is its decomposition as P = F * E with F acting on (0,3) and E acting on (1,2)? Since this is a bijection, each P corresponds to a unique pair (F,E). So then P(stabilizer) = Σ_{P in stabilizer} Prob(F)Prob(E) where that pair is the one that gives P.
Now, the stabilizer of |ψ_ideal&gt; has 16 elements. So we need to know how many of these 16 have F = identity? How many have F non-identity? etc. But wait, that requires knowing the stabilizer explicitly. The stabilizer is generated by: let&rsquo;s take generators: 
S1 = Z0Z3
S2 = Z1Z2
S3 = X0X1X2X3 (XXXX)
S4 = X1X2
So any element of the stabilizer can be written as (Z0Z3)^a (Z1Z2)^b (XXXX)^c (X1X2)^d, with a,b,c,d in {0,1}. So then an element is determined by (a,b,c,d). Let&rsquo;s express that in terms of action on (0,3) and (1,2). 
S1 acts only on (0,3) as Z0Z3.
S2 acts only on (1,2) as Z1Z2.
S3 acts on both: on (0,3) gives X0X3 and on (1,2) gives X1X2.
S4 acts only on (1,2) as X1X2.
So then an element is: on (0,3): from S1^a and S3^c gives: (Z0Z3)^a (X0X3)^c. on (1,2): from S2^b, S3^c, S4^d gives: (Z1Z2)^b (X1X2)^c (X1X2)^d = (Z1Z2)^b (X1X2)^(c+d).</p>
<p>So then the (0,3) part is determined by (a,c). The possible outcomes on (0,3):
If (a,c)=(0,0) -&gt; I.
(1,0) -&gt; Z0Z3.
(0,1) -&gt; X0X3.
(1,1) -&gt; (Z0Z3)(X0X3) = Z0X0 Z3X3 = ( -iY0)(-iY3) = (-1)Y0Y3? Actually, careful: Z0X0 = -iY0, so product = (-i)^2 Y0Y3 = (-1)Y0Y3. So that is -Y0Y3.
So on (0,3), the stabilizer elements have either I, Z0Z3, X0X3, or -Y0Y3.
On (1,2), determined by (b, c+d mod2). So outcomes:
If (b, c+d)=(0,0) -&gt; I.
(1,0) -&gt; Z1Z2.
(0,1) -&gt; X1X2.
(1,1) -&gt; (Z1Z2)(X1X2) = -Y1Y2.
So then indeed, the stabilizer elements are exactly those where the (0,3) part is in {I, Z0Z3, X0X3, -Y0Y3} and the (1,2) part is in {I, Z1Z2, X1X2, -Y1Y2}. And wait, is that independent? But careful: notice that the (0,3) part and (1,2) part are determined by separate parameters actually because (0,3) depends on (a,c) and (1,2) depends on (b, c+d). So for a given (0,3) part, that fixes (a,c) up to? actually, (0,3) part can be any of these 4. And for (1,2) part, it can be any of these 4 independently? But then that would give 16 elements. So indeed, the stabilizer of |ψ_ideal&gt; is actually that every Pauli of the form where on (0,3) is one of {I, Z0Z3, X0X3, -Y0Y3} and on (1,2) is one of {I, Z1Z2, X1X2, -Y1Y2} works. But wait, check that: Take (0,3) = X0X3 and (1,2)=I. That would be X0X3 alone. But we already ruled out X0X3 alone because it did not stabilize |ψ_ideal&gt;. So there is a catch: when I said stabilizer elements are determined by (a,b,c,d), that gives 16 elements. If I take (a,b,c,d) = (0,0,1,0), then that gives on (0,3): X0X3 and on (1,2): X1X2 from S3 actually wait, careful: (0,0,1,0) means a=0,b=0,c=1,d=0. Then that gives on (0,3): (Z0Z3)^0 (X0X3)^1 = X0X3. On (1,2): (Z1Z2)^0 (X1X2)^1 (X1X2)^0 = X1X2. So that product is X0X3X1X2 = XXXX, which is in the stabilizer. So wait, if I take (0,3)=X0X3 and (1,2)=I, that would require that from somewhere else? actually, notice that parameters (a,c) determine the (0,3) part uniquely. If (a,c)=(0,1), that gives X0X3. But then what is (1,2)? That depends on (b, c+d). For (0,1) with any d, c+d will be 1+d. If d=0, then c+d=1, so (1,2) becomes determined by (b,1). If b=0, then (1,2) becomes X1X2 actually because (0,1) gives X1X2. If b=1, then (1,2) becomes (Z1Z2)(X1X2) = -Y1Y2. So actually, when (a,c)=(0,1), it is not possible to have (1,2)=I because that would require that (b, c+d) = (0,0) or (1,0)? (0,0) would require b=0 and c+d=0, but c=1 so d would have to be 1 mod2? actually, c+d=0 means d=1 since c=1. So (0,0) is not possible because that would give actually wait, careful: (b, c+d) takes values in {0,1} for each. So if c=1, then to have c+d=0, we need d=1. So then (b, c+d)=(0,0) gives that would actually mean? If b=0 and d=1, then (1,2) becomes from formula: (Z1Z2)^0 (X1X2)^(1+1) wait, careful: formula is (Z1Z2)^b (X1X2)^(c+d). If b=0 and c+d=0 mod2, then that gives (X1X2)^0 = I. So actually, if (a,c)=(0,1) and (b,d)=(0,1), then that gives on (0,3): X0X3 and on (1,2): I because c+d=1+1=2 mod2=0. So that means that there is an element with (0,3)=X0X3 and (1,2)=I. That would be corresponding to (a,b,c,d)=(0,0,1,1). Let&rsquo;s check that element: S1^0 S2^0 S3^1 S4^1 = S3 S4 = (XXXX)(X1X2) = X0X3X1X2 * X1X2 actually careful: S3S4 = (X0X1X2X3)(X1X2) = X0X3 because X1X2 cancels with X1X2? Actually, wait, careful: S3 = X0X1X2X3. S4 = X1X2. So S3S4 = X0X1X2X3 * X1X2 = X0X3 because X1X1=I, X2X2=I. So indeed, S3S4 = X0X3. So that is in the stabilizer. But then does X0X3 stabilize |ψ_ideal&gt;? We already checked that X0X3 alone does not stabilize because it gave states outside the support. So there is a contradiction. Let&rsquo;s check S3S4 explicitly. S3S4 = X0X1X2X3 * X1X2 = X0X3 because the X1 and X2 cancel. So S3S4 = X0X3. Now act that on |ψ_ideal&gt;. 
|ψ_ideal&gt; = 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;).
S3S4|0000&gt; = X0X3|0000&gt; = |1001&gt; because that&rsquo;s what we computed earlier? Actually, careful: X0X3|0000&gt; should be |1001&gt;? Let&rsquo;s recompute: X0X3|0000&gt; means apply X on qubit0 and X on qubit3. |0000&gt; becomes |1001&gt; because qubit0 becomes 1, qubit3 becomes 1. So that gives |1001&gt;.
S3S4|1001&gt; = X0X3|1001&gt; = |0000&gt; because flip both gives back.
S3S4|0110&gt; = X0X3|0110&gt; = |1110&gt; because flip qubit0 and qubit3: |0 becomes1,0 becomes1&gt; so becomes |1110&gt;.
S3S4|1111&gt; = X0X3|1111&gt; = |0111&gt; because flip gives |0,1,1,1&gt;.
So then S3S4|ψ_ideal&gt; = 1/2(|1001&gt;+|0000&gt;+|1110&gt;+|0111&gt;) which is not equal to |ψ_ideal&gt; because that would require that third term is |0110&gt; and fourth is |1111&gt;. So actually, S3S4 does not stabilize |ψ_ideal&gt;. So that means that (a,b,c,d) = (0,0,1,1) does not yield a stabilizer element. So then my generator choice might be inconsistent. Let&rsquo;s determine the stabilizer of |ψ_ideal&gt; properly by actually finding Paulis that leave it invariant. </p>
<p>|ψ_ideal&gt; = 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). 
Let P = P0P1P2P3.
For P to stabilize, it must that for each basis state in the support, P maps it to another basis state in the support with a phase, and the phases must be equal for all terms because the state is evenly weighted.
So consider term1: |0000&gt;. term2: |1001&gt;. term3: |0110&gt;. term4: |1111&gt;.
 notice that these states have the property that qubit0 and qubit3 are equal, and qubit1 and qubit2 are equal.
So likely any stabilizer will preserve that property. So P must be such that it does not change the fact that qubit0=qubit3 and qubit1=qubit2. So that means that P should act on qubits0 and3 in a way that if it flips qubit0, it must also flip qubit3 similarly so that they remain equal. Similarly for qubits1 and2. So that suggests that P should be of the form where on qubits0 and3, it is either I⊗I, X⊗X, Z⊗Z, or something that flips both in the same way. What about Y⊗Y? Y|0&gt;= i|1&gt;, so that would give both become |1&gt; so that works actually because then they remain equal. But careful with phases: Y⊗Y|00&gt; = (i|1&gt;)(i|1&gt;)= -|11&gt;. So that would give a phase of -1 for that term. But then for consistency across terms, that phase would have to be the same for all terms. So it is possible that Y⊗Y appears with a overall sign maybe. So likely on each pair, the stabilizer conditions are that the operator on that pair must be either I, X⊗X, Z⊗Z, or Y⊗Y up to a sign. But wait, check X⊗X on pair (0,3) alone would take |00&gt; to |11&gt; and |11&gt; to |00&gt;. So that would preserve the property. So then why did X0X3 alone not work? Because when we act on |ψ_ideal&gt;, consider term3: |0110&gt;. That state has on pair (0,3): |00&gt; actually because qubit0=0,3=0. So X0X3 would take that to |11&gt; on pair (0,3), so that would give |1110&gt;. But wait, |1110&gt; does not have property that qubit1=qubit2? Actually, |1110&gt; has qubit1=1,2=1 actually yes it does because both are 1. So |1110&gt; would seem to have the property that qubit0=1,3=0 though wait, careful: |1110&gt; means qubit0=1,1=1,2=1,3=0. So that violates that qubit0 should equal qubit3 because here 1≠0. So actually, for term3, the state is |0110&gt;. Its pair (0,3) is actually (0,0) because qubit0=0,3=0. So that&rsquo;s fine. Under X0X3, that becomes (1,1) on pair (0,3) actually because X0 changes 0-&gt;1, X3 changes 0-&gt;1, so that gives (1,1). So then the state becomes |1,1,1,0&gt; wait careful: |0110&gt; means digits: 0,1,1,0. After X0 and X3, we get: qubit0:0-&gt;1, qubit3:0-&gt;1, so state becomes |1,1,1,1&gt; actually because qubit1 and2 remain 1,1. So |0110&gt; becomes |1111&gt;. That is in the support. Now check term4: |1111&gt; becomes under X0X3: qubit0:1-&gt;0, qubit3:1-&gt;0, so becomes |0111&gt; which is not in the support because that would be digits: 0,1,1,1 actually that does have property that qubit1=1,2=1, but wait, |0111&gt; means qubit0=0,3=1, so that violates that qubit0 should equal qubit3. So term4 becomes |0111&gt; which is not in the support. So why would that happen? Because when acting on |1111&gt;, the pair (0,3) is (1,1). X0X3 takes that to (0,0). So that would give state |0,1,1,1&gt; actually because careful: |1111&gt; digits: 1,1,1,1. Apply X0 and X3: becomes: qubit0:1-&gt;0, qubit3:1-&gt;0, so state becomes |0,1,1,0&gt; actually because wait, qubit1 and2 are still 1,1. So that gives |0110&gt;. So actually, term4 becomes |0110&gt;. So then overall, X0X3 would map: 
|0000&gt; -&gt; |1001&gt;
|1001&gt; -&gt; |0000&gt;
|0110&gt; -&gt; |1111&gt;
|1111&gt; -&gt; |0110&gt;
So that actually would leave the set invariant. Then the state would become 1/2(|1001&gt;+|0000&gt;+|1111&gt;+|0110&gt;) which is actually the same as |ψ_ideal&gt;. So wait, that suggests that X0X3 does stabilize |ψ_ideal&gt;! I earlier got that term4 became |0111&gt; but that was a mistake. Let&rsquo;s recompute X0X3 carefully on each term:
 term1: |0000&gt; -&gt; X0X3|0000&gt; = apply X on qubit0 and X on qubit3. So |0000&gt; becomes |1001&gt; because qubit0 becomes 1, qubit3 becomes 1. So term1 -&gt; |1001&gt;.
 term2: |1001&gt; -&gt; X0X3|1001&gt; = qubit0:1-&gt;0, qubit3:1-&gt;0, so becomes |0000&gt;.
 term3: |0110&gt; -&gt; X0X3|0110&gt; = qubit0:0-&gt;1, qubit3:0-&gt;1, so becomes |1111&gt;.
 term4: |1111&gt; -&gt; X0X3|1111&gt; = qubit0:1-&gt;0, qubit3:1-&gt;0, so becomes |0110&gt;.
So indeed, X0X3 just swaps term1 with term2 and term3 with term4. So that would leave |ψ_ideal&gt; invariant. So I earlier made a mistake in that term4 became |0111&gt;; that was when I did it without carefulness. So actually, X0X3 does stabilize |ψ_ideal&gt;. So then on (0,3), the stabilizer conditions are that F can be any of {I, X0X3, Z0Z3, Y0Y3} actually check Y0Y3: 
Y0Y3|0000&gt; = (Y|0&gt;)(Y|0&gt;)= (i|1&gt;)(i|1&gt;)= -|11&gt; so that gives -|1,0,0,1&gt; wait careful: Y0Y3|0000&gt; = phase i<em>i = -1 times |1,1&gt; on qubits0,3 actually because Y|0&gt;= i|1&gt;, so product = i^2 |11&gt; = -|11&gt;. So that would give state |-1,0,0,-1&gt; actually that is -|1001&gt; because qubits0 and3 become 1,1. So term1 -&gt; -|1001&gt;.
 term2: Y0Y3|1001&gt; = Y|1&gt;Y|1&gt; = (-i|0&gt;)(-i|0&gt;)= (-i)</em>(-i)= i^2? actually (-i)<em>(-i)= -1? Let&rsquo;s do: (-i)</em>(-i)= i^2? Actually, i^2 = -1. So (-i)<em>(-i) = (-1)</em>(i^2) wait, better: (-i)<em>(-i) = i^2 = -1. So term2 -&gt; -|0000&gt;.
 term3: Y0Y3|0110&gt; = Y|0&gt;Y|0&gt; on qubits0,3 gives phase -1 -&gt; becomes -|1111&gt;.
 term4: Y0Y3|1111&gt; = Y|1&gt;Y|1&gt; gives phase? Y|1&gt; = -i|0&gt;, so product = (-i)</em>(-i)= -1 -&gt; becomes -|0110&gt;.
So overall, Y0Y3 would give -|ψ_ideal&gt;. So actually, Y0Y3 gives a phase of -1. So if we take -Y0Y3, then that would give +1. So on (0,3), the stabilizer conditions are that F should be in {I, X0X3, Z0Z3, -Y0Y3}. 
Now check that with alone would that work? If only error is F and it is say X0X3, then effective error is X0X3 alone, and we just checked that stabilizes |ψ_ideal&gt;. So that means that actually, if only error is on (0,3), then for it to be in the stabilizer, F can be any of these 4. But wait, earlier I thought that Z0Z3 worked alone and that seemed right. And X0X3 we now see works alone. What about -Y0Y3 alone? If F = -Y0Y3 alone, then that would give phase? Let&rsquo;s check -Y0Y3 alone:
 term1: -Y0Y3|0000&gt; = - (Y0Y3|0000&gt;) = -(-|1001&gt;) = |1001&gt;.
 term2: -Y0Y3|1001&gt; = -(-|0000&gt;) = |0000&gt;.
 term3: -Y0Y3|0110&gt; = -(-|1111&gt;) = |1111&gt;.
 term4: -Y0Y3|1111&gt; = -(-|0110&gt;) = |0110&gt;.
So yes, that works alone too. So on (0,3), the stabilizer conditions are that F is in {I, X0X3, Z0Z3, -Y0Y3}. 
Now on (1,2), by similar reasoning, alone would require that E is in {I, X1X2, Z1Z2, -Y1Y2} because that would stabilize alone. And we already checked X1X2 alone works and Z1Z2 alone works. So then when both errors occur, the effective error is F * E. But careful: If both errors occur, then the effective error is actually F * E because they commute? But wait, they act on different qubits, so yes, the final state is F E |ψ_ideal&gt;. So then for that to be in the stabilizer, we need that F E is in the stabilizer. But if F is in the stabilizer on (0,3) alone and E is in the stabilizer on (1,2) alone, then clearly F E is in the stabilizer because it will stabilize since it&rsquo;s a product of stabilizers acting on different qubits. So that gives that if both F and E are in their own stabilizer sets, then overall is good. But wait, could it be that F is not in its own stabilizer set but when combined with an E that is not in its own set, they become in the stabilizer? For example, take F = X0X3 is in the stabilizer already actually. What about taking F = something else? The stabilizer set on (0,3) alone is actually all Paulis on (0,3) that stabilize |ψ_ideal&gt; when acting alone. And that set we determined seems to be of size 4. Is it possible that there is any Pauli on (0,3) that is not in {I, X0X3, Z0Z3, -Y0Y3} that could become part of a stabilizer when combined with something on (1,2)? Suppose take F = I alone is in that set. What about F = something like X0 alone? That would not because it would not preserve the property that qubit0=qubit3. So likely, the stabilizer of |ψ_1\rangle} actually factors as follows: any stabilizer operator must act on (0,3) and (1,2) independently because they act on different qubits. And since |ψ_ideal&gt; is actually a product state between these two pairs? Is |ψ_ideal&gt; a product state? |ψ_ideal&gt; = 1/2(|00&gt;|00&gt; + |11&gt;|00&gt;? No, careful: If I group qubits (0,3) and (1,2), then |ψ_ideal&gt; = 1/2(|00&gt;|00&gt; + |11&gt;|00&gt; that&rsquo;s not right because term2 is |1001&gt; means (0,3)=(1,1) and (1,2)=(0,0). Term3: (0,3)=(0,0) and (1,2)=(1,1). Term4: (0,3)=(1,1) and (1,2)=(1,1). So actually, |ψ_ideal&gt; = 1/2(|00&gt;|00&gt; + |11&gt;|00&gt; + |00&gt;|11&gt; + |11&gt;|11&gt;) wait that would be 1/2(|00&gt;+|11&gt;)<em>{03} ⊗ (|00&gt;+|11&gt;)</em>{12} actually that is product state between the two pairs. Yes! because that is exactly that. So |ψ_ideal&gt; is actually a product of two Bell states between qubits (0,3) and (1,2). Because |ψ_ideal&gt; = 1/2(|00&gt;|00&gt; + |11&gt;|00&gt;? Let&rsquo;s check: If I take the state (|00&gt;+|11&gt;)/√2 on pairs, then that state is 1/√2(|00&gt;+|11&gt;). The product of two such states would be 1/2(|00&gt;|00&gt; + |00&gt;|11&gt; + |11&gt;|00&gt; + |11&gt;|11&gt;). But that is not our state because our state has terms: |0000&gt;, |1001&gt;, |0110&gt;, |1111&gt;. If I pair as (0,3) and (1,2), then |0000&gt; means (0,3)=00, (1,2)=00. |1001&gt; means (0,3)=10? careful: qubit0=1, qubit3=1 actually so that is 11 wait, careful: when pairing, I should decide order within each pair. Let&rsquo;s pair qubits 0 and 3 together and qubits 1 and 2 together. Then state |0000&gt; means that on pair (0,3), we have bits: qubit0=0, qubit3=0 so that is |00&gt;. On pair (1,2), bits: qubit1=0, qubit2=0 so that is |00&gt;. So that term is |00&gt;|00&gt;.
|1001&gt; means: pair (0,3): qubit0=1, qubit3=1 -&gt; that is |11&gt; actually because if I take order (0,3) then that gives |11&gt;. Pair (1,2): qubit1=0, qubit2=0 -&gt; |00&gt;. So that term is |11&gt;|00&gt;.
|0110&gt; means: pair (0,3): qubit0=0, qubit3=0 -&gt; |00&gt;. Pair (1,2): qubit1=1, qubit2=1 -&gt; |11&gt;. So that is |00&gt;|11&gt;.
|1111&gt; means: pair (0,3): |11&gt;, pair (1,2): |11&gt;. So indeed, |ψ_ideal&gt; = 1/2(|00&gt;|00&gt; + |11&gt;|00&gt; + |00&gt;|11&gt; + |11&gt;|11&gt;) wait that is actually not product because product would be (|00&gt;+|11&gt;)/√2 tensored with (|00&gt;+|11&gt;)/√2 would give that same thing. So yes, |ψ_1\rangle} is actually a product of two Bell states between (0,3) and (1,2). So then the stabilizer of |ψ_ideal&gt; will be the product of the stabilizers of each Bell state. And the stabilizer of a Bell state on two qubits is well-known: for a Bell state say (|00&gt;+|11&gt;)/√2, the stabilizer is generated by XX and ZZ. So that means that on pair (0,3), the stabilizer conditions are that the operator must be in {I, X0X3, Z0Z3, -Y0Y3} because that is the stabilizer of a Bell state. And on pair (1,2), similarly, the stabilizer conditions are that the operator must be in {I, X1X2, Z1Z2, -Y1Y2}. And since these act on different pairs, the full stabilizer is the product of these two sets. So that means that actually, the stabilizer of |ψ_ideal&gt; has size 4*4=16. And it consists of operators of the form where on (0,3) is any of {I, X0X3, Z0Z3, -Y0Y3} and on (1,2) is any of {I, X1X2, Z1Z2, -Y1Y2}. So then that is clear now.
So then for the effective error to be in the stabilizer, we need that F (acting on (0,3)) is in that set and E (acting on (1,2)) is in that set. Because then F E will be in the stabilizer since it factors.
So then the condition for no logical error (i.e., fidelity 1) is that F is in S_{03} and E is in S_{12}, where 
S_{03} = {I⊗I, X0X3, Z0Z3, -Y0Y3} 
S_{12} = {I⊗I, X1X2, Z1Z2, -Y1Y2}.</p>
<p>Now, are these sets actually that? Let&rsquo;s check alone: If only error is F and F = X0X3, does that stabilize? Yes, as checked. If only error is F and F = Z0Z3, yes. If only error is F and F = -Y0Y3, yes.
So then that means that the probability that the effective error is in the stabilizer is simply: 
P(stabilizer) = [P(F in S_{03})] * [P(E in S_{12})] because they are independent.
Now, what is P(F in S_{03})? F is depolarizing on two qubits. outcomes for F: there are 16 possible Paulis on two qubits. how many of them are in S_{03}? That set has 4 elements. So probability that F is in S_{03} is: probability that F is identity (1-p) plus probability that F is one of the other 3 outcomes times (p/15 each). So that is = (1-p) + 3*(p/15) = 1-p + p/5 = 1 - (4p/5).
Similarly, P(E in S_{12}) = 1 - (4p/5).
So then P(stabilizer) = (1 - 4p/5)^2. That is actually the same as the physical fidelity we computed earlier. So that makes sense because if there is no post-selection, the fidelity is that probability. So that is correct.</p>
<p>Now, for post-selection, we only keep states that are in the code space. That means that the effective error must be in the normalizer of the code stabilizer. The code stabilizer is generated by XXXX and ZZZZ. wait, careful: The code stabilizer is for the [[4,2,2]] code. What is that? The code stabilizer is actually {I, XXXX, ZZZZ, XXXXZZZZ} actually that is only size 4. But wait, that is the stabilizer of the code space itself. So any state in the code space is stabilized by these operators. So for the state to be in the code space, we need that the effective error commutes with these stabilizers? Actually, if started with a state in the code space, after an error that is in the normalizer, the state will still be in the code space. So post-selection means we only keep outcomes where the effective error is in the normalizer of the code stabilizer. What is the normalizer of the code stabilizer? Since the code stabilizer has size 4, the normalizer will have size 4 * (logical Pauli group size) = 4<em>16=64. So there are 64 Pauli operators that map the code space to itself. these are exactly those Paulis that commute with XXXX and ZZZZ. What are those conditions? For a Pauli operator to commute with XXXX, it must have an even number of sites where it is either Z or Y. To commute with ZZZZ, it must have an even number of sites where it is either X or Y. Now, since our effective error factors as acting on (0,3) and (1,2) independently because that&rsquo;s how we&rsquo;ve been able to separate due to the structure of |ψ_ideal&gt; actually wait, careful: Is it true that any operator in the normalizer will factorize between (0,3) and (1,2)? Not necessarily because conditions involve both pairs together. But note that |ψ_ideal&gt; is within the code space. And actually, the code space itself factors between these pairs? Is that true? The code space of the [[4,2,2]] code is actually spanned by states that are products of Bell states between (0,3) and (1,2)? I think yes because often the [[4,2,2]] code is also known as the product of two Bell states. Actually, wait, the [[4,2,2]] code is exactly that: you take two Bell pairs. So yes, the code space is spanned by |00&gt;<em>{03}|00&gt;</em>{12}, |00&gt;<em>{03}|11&gt;</em>{12}, |11&gt;<em>{03}|00&gt;</em>{12}, |11&gt;<em>{03}|11&gt;</em>{12}. So that is correct. Then the stabilizer of the code space is generated by X0X3X1X2 and Z0Z3Z1Z2 actually careful: For a Bell state between qubits 0 and 3, the stabilizer is generated by X0X3 and Z0Z3. So then the stabilizer of the product would be generated by X0X3X1X2? Actually, if you take two independent Bell states, the stabilizer would be generated by X0X3, Z0Z3, X1X2, Z1Z2. But that would be size 4</em>4=16. But wait, that is for the product state itself. But the code space of the [[4,2,2]] code is actually 4-dimensional. If you take two Bell states, that gives a 4-dimensional space. So then the stabilizer of that space would be generated by these 4 operators? But then that would mean that the stabilizer group of the code would have order 2^4=16. But I recall that the [[4,2,2]] code has stabilizer group of order 4, not 16. because usually for an [[n,k,d]] code, the stabilizer group has order 2^(n-k). Here n=4, k=2, so order should be 2^2=4. So there is a discrepancy. actually, wait: If you take two Bell states, that state is not stabilized by X0X3 alone because that would stabilize the first Bell state but not necessarily the second Bell state independently? Actually, if you have a product of two Bell states, say |Φ+⟩<em>{03}⊗|Φ+⟩</em>{12}, then that state is stabilized by X0X3 alone? Check: X0X3|Φ+⟩<em>{03} = |Φ+⟩</em>{03} because that is stabilizer of the Bell state. So yes, actually, |Φ+⟩<em>{03} is stabilized by X0X3. So then the state |Φ+⟩</em>{03}⊗|Φ+⟩<em>{12} is stabilized by X0X3 and also by X1X2 independently. So that would give two stabilizers. Similarly, it is stabilized by Z0Z3 and Z1Z2 independently. So that would be 4 stabilizers. But wait, then the stabilizer group would have order 2^4=16. But that would mean that the code space is actually stabilized by 4 independent generators, which would imply that the code space has dimension 2^(4-4)=1. So that&rsquo;s not right. I recall that for a stabilizer code, the stabilizer group is abelian and does not include logical operators. For two Bell states, the state itself is not a stabilizer state of the code because the code space is larger than just that state. The code space is actually spanned by |00&gt;</em>{03}|00&gt;<em>{12}, |00&gt;</em>{03}|11&gt;<em>{12}, |11&gt;</em>{03}|00&gt;<em>{12}, |11&gt;</em>{03}|11&gt;<em>{12}. What are the stabilizers of that space? An operator that stabilizes the entire code space must act as identity on every state in the code space. Consider X0X3. Does it act as identity on every state in the code space? Take |00&gt;</em>{03}|00&gt;<em>{12}. X0X3 would give |11&gt;</em>{03}|00&gt;<em>{12}. That is actually in the code space because that is |11&gt;|00&gt;. But does it act as identity? Not necessarily because |11&gt;|00&gt; is different from |00&gt;|00&gt; unless they are the same state, which they are not. So X0X3 is not in the stabilizer of the code space. The stabilizer of the code space are those operators that leave every state in the code space invariant. likely they are X0X3X1X2 and Z0Z3Z1Z2. because then acting on |00&gt;|00&gt;, X0X3X1X2 gives |11&gt;|11&gt; which is not that state either wait that gives |11&gt;|11&gt; which is different from |00&gt;|00&gt;. So that doesn&rsquo;t work either. actually, wait, the stabilizer of a code is defined as the set of Pauli operators that act as identity on the code space. For the [[4,2,2]] code, the stabilizer is actually generated by XXXX and ZZZZ. So that means that for any state in the code space, XXXX|ψ&gt; = |ψ&gt; and ZZZZ|ψ&gt; = |ψ&gt;. So that is the stabilizer. So then coming back to post-selection: We only keep states that are in the code space. That means that when we measure the stabilizers, we get +1 for both XXXX and ZZZZ. that means that the effective error must commute with these stabilizers? Actually, if started with a state in the code space, after an error that is in the normalizer, the state will still be in the code space. So post-selection means that the effective error is in the normalizer of the code stabilizer. The normalizer of {XXXX, ZZZZ} consists of those Paulis that commute with both. As noted, that set has size 64. So then the probability that the state is kept after post-selection is P(normalizer) = probability that effective error is in that set of 64 Paulis out of 256.
Now, since effective error = F * E and this is a bijection between pairs (F,E) and Paulis, we need to compute the probability that a randomly chosen Pauli (with distribution induced by independent depolarizing on F and E) falls into the normalizer. That probability is that for the Pauli to be in the normalizer, it must satisfy conditions on the parities of Z/Y and X/Y counts. But wait, since F and E act on different pairs, maybe we can compute this probability by independence? because conditions for being in the normalizer might factor across the two pairs? Let&rsquo;s see. For effective error to be in the normalizer, it must commute with XXXX and ZZZZ. Consider XXXX. commute means that the number of qubits where effective error has Pauli that anticommutes with X is even. effective error factors as acting on (0,3) and (1,2). So that condition becomes: (number on (0,3) where Pauli is Z or Y) + (number on (1,2) where Pauli is Z or Y) is even.
 similarly for ZZZZ: (number on (0,3) where Pauli is X or Y) + (number on (1,2) where Pauli is X or Y) is even.
Now, if we want to compute the probability that effective error is in the normalizer, that is the probability that these two conditions hold. But careful: F and E are chosen independently with their own distributions. So we can compute the probability that for a given two-qubit Pauli acting on (0,3) that it has an even number of Z/Y sites. Let&rsquo;s compute that for depolarizing on two qubits. But wait, the distribution for F is not uniform over the 16 Paulis? It is: P(F) = 1-p for identity, and for each of the 15 non-identity, probability p/15.
So for F acting on two qubits, let&rsquo;s determine the probability that it has an even number of sites with Z or Y. But careful: The condition for normalizer is on the effective error itself, not on F alone because effective error = F * E. But since F and E act on different sets, the conditions become independent across the sets actually because they are separate sums. So actually, effective error is in the normalizer if and only if: 
[ ( parity of F regarding Z/Y ) + ( parity of E regarding Z/Y ) ] is even, and 
[ ( parity of F regarding X/Y ) + ( parity of E regarding X/Y ) ] is even.
So if I define for a two-qubit Pauli Q, let f_z(Q) = 0 if Q has an even number of sites with Z or Y, and 1 if odd.
 similarly, f_x(Q) = 0 if even number of sites with X or Y, and 1 if odd.
Then effective error is in normalizer if and only if: f_z(F) + f_z(E) = 0 mod2 and f_x(F) + f_x(E) = 0 mod2.
Now, since F and E are independent, the probability that effective error is in normalizer is = [ probability that f_z(F)=0 and f_x(F)=0 ] * [ probability that f_z(E)=0 and f_x(E)=0 ] + [ probability that f_z(F)=0 and f_x(F)=1 ] * [ probability that f_z(E)=0 and f_x(E)=1 ] wait careful actually because they must match in both regards. Actually, it is: P(normalizer) = P(f_z(F)=0)P(f_z(E)=0) * P(f_x(F)=0)P(f_x(E)=0) actually no because they are not independent within F itself necessarily. Let&rsquo;s do it properly:
We want: f_z(F) = f_z(E) and f_x(F) = f_x(E). So that means that the pair (f_z(F), f_x(F)) must equal (f_z(E), f_x(E)). So if I compute the distribution of these pairs for a random F according to its depolarizing distribution, then P(normalizer) = sum</em>{ pair } [P(F has that pair)]^2.
So let&rsquo;s compute for a two-qubit Pauli Q ( acting on two specific qubits) with distribution: P(Q=I) = 1-p, and for each of the 15 non-identity, probability p/15.
Now, let&rsquo;s list the 16 Paulis on two qubits. They are determined by Pauli on first and second qubit. I&rsquo;ll use notation where I will determine f_z and f_x for each.
 better: f_z(Q) is 0 if Q has an even number of sites where the Pauli is Z or Y. f_x(Q) is 0 if even number of sites with X or Y.
Now, identity: I⊗I: that has no sites with Z or Y -&gt; even so f_z=0. No sites with X or Y -&gt; even so f_x=0.
Now, Paulis that are products of I and something else? Actually, let&rsquo;s list by type based on whether both acts are identity or not. But maybe I can compute these probabilities directly.
Maybe it&rsquo;s easier to note that effective error is uniformly distributed over the 256 Paulis? Is it? Not exactly because the probabilities are not uniform because identity has higher probability. But wait, since F and E are independent and the map is bijective, the distribution on the 256 Paulis is such that each Pauli that comes from a pair where both are identity has probability (1-p)^2, each Pauli that comes from one identity and one non-identity has probability (1-p)*(p/15) times something actually careful: If a Pauli factors as Q_{03} ⊗ Q_{12}, then its probability is P(F=Q_{03}) * P(E=Q_{12}). So it&rsquo;s not uniform across all Paulis because different Q_{03} have different probabilities? Actually, wait: For depolarizing, every non-identity has the same probability p/15. So for Q_{03} that is identity, probability is (1-p). For Q_{03} that is any specific non-identity, probability is p/15. So indeed, different Paulis have different probabilities depending on whether they are identity on that pair or not.
So I need to compute the distribution of the pair (f_z, f_x) for depolarizing on two qubits.
Let&rsquo;s do that for general two-qubit Pauli space. There are 16 operators. They can be categorized by their weight? But careful: f_z and f_x are determined by the Pauli strings themselves. Let&rsquo;s list them explicitly for two qubits. Let the two qubits be called A and B.
The Paulis are determined by two Pauli matrices. I&rsquo;ll use notation where I will write the Pauli on each qubit. So outcomes:</p>
<ol>
<li>I,I -&gt; f_z=0, f_x=0.</li>
<li>I,X -&gt; then sites: first: I -&gt; not Z or Y so okay actually careful: f_z: need to count sites where Pauli is Z or Y. For I,X: first is I -&gt; not Z or Y so count=0; second is X -&gt; not Z or Y because X is not Z or Y? Actually, wait: f_z counts sites with Z or Y. X is not Z or Y, so count=0. So f_z=0. f_x: sites with X or Y. first: I -&gt; no; second: X -&gt; yes. So count=1 -&gt; odd so f_x=1.</li>
<li>I,Y -&gt; then: first: I -&gt;0; second: Y -&gt; Y counts for both actually careful: f_z: Y counts as Z or Y? Yes, because Y involves Z actually wait: f_z is defined as sites where the Pauli is either Z or Y. So yes, Y counts. So that gives count=1 -&gt; odd so f_z=1. f_x: sites with X or Y: Y counts as well because Y involves X? Actually, careful: f_x counts sites where Pauli is X or Y. So Y counts. So that gives count=1 -&gt; odd so f_x=1.</li>
<li>I,Z -&gt; then: first: I -&gt;0; second: Z -&gt; Z counts for f_z -&gt; count=1 so f_z=1; for f_x: Z does not count because Z is not X or Y, so count=0 -&gt; f_x=0.</li>
<li>X,I -&gt; by symmetry, this will be like I,X actually because order doesn&rsquo;t matter? But careful: f_z and f_x are determined by each qubit independently. So X,I: first: X -&gt; for f_z: X is not Z or Y so 0; second: I -&gt;0; so f_z=0. f_x: first: X -&gt; counts -&gt;1; second: I -&gt;0; so f_x=1.</li>
<li>X,X -&gt; then: first: X -&gt; for f_z:0; second: X -&gt;0; so f_z=0. f_x: first: X -&gt;1; second:1 -&gt; total 2 even so f_x=0.</li>
<li>X,Y -&gt; first: X -&gt; for f_z:0; second: Y -&gt; Y counts -&gt;1 so f_z=1; f_x: first: X -&gt;1; second: Y -&gt;1 -&gt; total2 even so f_x=0.</li>
<li>X,Z -&gt; first: X -&gt;0; second: Z -&gt; for f_z: Z counts -&gt;1 so f_z=1; f_x: first: X -&gt;1; second: Z -&gt;0 -&gt; total1 odd so f_x=1.</li>
<li>Y,I -&gt; similar to I,Y: f_z=1, f_x=1.</li>
<li>Y,X -&gt; already did? actually careful: Y,X is same as X,Y because order matters? But careful: Y,X means first qubit Y, second X. That gives: f_z: first: Y -&gt;1; second: X -&gt;0 -&gt; total1 odd so f_z=1; f_x: first: Y -&gt;1; second: X -&gt;1 -&gt; total2 even so f_x=0. So that is same as case 7 actually because case 7 was X,Y gave f_z=1, f_x=0. So yes.</li>
<li>Y,Y -&gt; first: Y -&gt;1; second: Y -&gt;1 -&gt; total2 even so f_z=0; f_x: first:1; second:1 -&gt;2 even so f_x=0.</li>
<li>Y,Z -&gt; first: Y -&gt;1; second: Z -&gt;1 -&gt; total2 even so f_z=0; f_x: first: Y -&gt;1; second: Z -&gt;0 -&gt; total1 odd so f_x=1.</li>
<li>Z,I -&gt; like I,Z: f_z=1, f_x=0.</li>
<li>Z,X -&gt; like X,Z: f_z=1, f_x=1.</li>
<li>Z,Y -&gt; like Y,Z: f_z=0, f_x=1.</li>
<li>Z,Z -&gt; first: Z -&gt;1; second: Z -&gt;1 -&gt;2 even so f_z=0; f_x: both not X or Y so f_x=0.</li>
</ol>
<p>So let&rsquo;s gather these outcomes for a two-qubit Pauli Q outcomes. I&rsquo;ll list them with their conditions for being identity or not identity because that affects probability.
 outcomes that are identity: only case 1: I,I. That has probability when chosen from depolarizing: actually careful: When we talk about depolarizing, identity has probability 1-p. So case 1: probability = 1-p.
 cases that are non-identity: cases 2 through 16. Each has probability p/15.
Now, let&rsquo;s count how many fall into each (f_z, f_x) category.
Category (0,0): f_z=0, f_x=0.
From above: </p>
<ol>
<li>I,I -&gt; (0,0)</li>
<li>X,X -&gt; (0,0)</li>
<li>Y,Y -&gt; (0,0)</li>
<li>Z,Z -&gt; (0,0)
Also any others? Check case? So there are 4 outcomes that give (0,0). Among these, 1 is identity, 3 are non-identity.
Category (0,1): f_z</li>
</ol>
                      </div>
                    </details>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>First, I need to find the logical state fidelity after post-selection on detectable errors. From the problem, we&rsquo;re using the [[4,2,2]] code, and we&rsquo;re post-selecting on all detectable errors. That means we only keep states where the error is in the normalizer of the code stabilizer, which allows us to detect errors that take the state outside the code space.</p>
<p>The code stabilizer is generated by XXXX and ZZZZ. The normalizer includes all Pauli operators that commute with these stabilizers. The size of the normalizer is 64 out of 256 possible Pauli operators on 4 qubits.</p>
<p>The logical fidelity is the probability that the state is correct given that it&rsquo;s in the code space. So, I need the conditional probability that the error is in the stabilizer of the logical state given that it&rsquo;s in the normalizer.</p>
<p>From my earlier derivation, the stabilizer of the logical GHZ state |ψ_ideal⟩ has 16 elements. These are the errors that leave the logical state unchanged.</p>
<p>The effective error comes from two depolarizing channels on the CNOT gates. Each CNOT gate has an error channel that applies a two-qubit Pauli error with probability p/15 for each non-identity Pauli, and identity with probability 1-p.</p>
<p>The effective error is the product of the errors from both gates, and since they act on different qubit pairs, I can consider them separately.</p>
<p>Let me define:</p>
<ul>
<li>
<p>Let F be the error on qubits 0 and 3. It can be any two-qubit Pauli with probability distribution: P(F=I) = 1-p, and for each of the 15 non-identity Paulis, P(F=P) = p/15.</p>
</li>
<li>
<p>Similarly, let E be the error on qubits 2 and 1. Same distribution.</p>
</li>
</ul>
<p>The effective error is F ⊗ E, which is a Pauli on all four qubits.</p>
<p>Now, for the effective error to be in the normalizer of the code stabilizer, it must commute with XXXX and ZZZZ. This imposes conditions on the parities of certain Pauli types.</p>
<p>I need to find the probability that the effective error is in the normalizer, and separately, the probability that it is in the stabilizer of |ψ_ideal⟩.</p>
<p>Then, the logical fidelity F_logical = P(stabilizer) / P(normalizer).</p>
<p>From my previous work, I recall that for a single two-qubit depolarizing channel, the probability that the error is in the stabilizer of a Bell state is 1 - 4p/5. But that might be for the physical fidelity without post-selection.</p>
<p>For the normalizer condition, I need to find when the effective error is in the normalizer.</p>
<p>Since the effective error factors as F and E on different pairs, the conditions for being in the normalizer can be separated into conditions on F and E independently, but they must match in terms of parities.</p>
<p>Let me define for a two-qubit Pauli Q:</p>
<ul>
<li>
<p>Let f_z(Q) be 0 if the number of qubits where Q is Z or Y is even, and 1 if odd.</p>
</li>
<li>
<p>Let f_x(Q) be 0 if the number of qubits where Q is X or Y is even, and 1 if odd.</p>
</li>
</ul>
<p>Then, for the effective error F ⊗ E to commute with XXXX, we need that the total number of qubits with Z or Y is even across all four qubits. Since F acts on two qubits and E on two qubits, this means that f_z(F) + f_z(E) must be even, i.e., f_z(F) = f_z(E).</p>
<p>Similarly, to commute with ZZZZ, we need f_x(F) + f_x(E) must be even, i.e., f_x(F) = f_x(E).</p>
<p>So, the effective error is in the normalizer if and only if f_z(F) = f_z(E) and f_x(F) = f_x(E).</p>
<p>Now, I need the probability that for a random F and E with the depolarizing distribution, this holds.</p>
<p>Similarly, for the stabilizer of |ψ_ideal⟩, which is the set of Paulis that leave the state unchanged. Since |ψ_ideal⟩ is a product of two Bell states between (0,3) and (1,2), the stabilizer consists of Paulis that are in the stabilizer of each Bell state independently.</p>
<p>For a Bell state, the stabilizer has 4 elements: I, XX, ZZ, and -YY. So for qubits 0 and 3, the stabilizer S_{03} = {I, X0X3, Z0Z3, -Y0Y3}. Similarly for qubits 2 and 1, S_{12} = {I, X2X1, Z2Z1, -Y2Y1}. Note that since the Pauli errors are applied directly, and we&rsquo;re dealing with the product, the effective error is in the stabilizer of |ψ_ideal⟩ if and only if F is in S_{03} and E is in S_{12}.</p>
<p>Is that correct? Yes, because if F stabilizes the Bell state on (0,3) and E stabilizes the Bell state on (1,2), then F ⊗ E stabilizes the product state |ψ_ideal⟩.</p>
<p>So, P(stabilizer) = P(F ∈ S_{03}) * P(E ∈ S_{12}) because F and E are independent.</p>
<p>Now, for a single two-qubit depolarizing channel, what is P(Q ∈ S) where S is the stabilizer of a Bell state? S has 4 elements: identity and three others. So, P(Q ∈ S) = P(Q=I) + 3 * P(Q= specific non-identity in S) = (1-p) + 3*(p/15) = 1-p + p/5 = 1 - 4p/5.</p>
<p>Therefore, P(stabilizer) = [1 - 4p/5]^2.</p>
<p>Now, for P(normalizer), I need P( f_z(F) = f_z(E) and f_x(F) = f_x(E) ).</p>
<p>Since F and E are independent, I need the distribution of (f_z(Q), f_x(Q)) for a two-qubit Pauli Q with the depolarizing distribution.</p>
<p>Let me compute that distribution.</p>
<p>For a two-qubit Pauli Q, there are 16 possibilities. I&rsquo;ll list them and determine (f_z, f_x).</p>
<p>I&rsquo;ll use the list I started earlier but complete it.</p>
<p>I&rsquo;ll consider the two qubits as a single entity. The Pauli operators are tensor products of I, X, Y, Z.</p>
<p>I need to find for each Pauli, what is f_z and f_x.</p>
<p>f_z(Q) is based on whether the number of sites with Z or Y is even or odd.</p>
<p>f_x(Q) is based on whether the number of sites with X or Y is even or odd.</p>
<p>Since Y counts for both, it might be better to compute for each Pauli string.</p>
<p>Let me list all two-qubit Pauli operators. I&rsquo;ll denote them by the Pauli on each qubit, like (P1, P2).</p>
<p>The possible pairs (P1, P2) where each P is I, X, Y, Z.</p>
<p>For each, I&rsquo;ll compute:</p>
<ul>
<li>
<p>count_z: number of qubits where Pauli is Z or Y</p>
</li>
<li>
<p>count_x: number of qubits where Pauli is X or Y</p>
</li>
</ul>
<p>Then f_z = count_z mod 2</p>
<p>f_x = count_x mod 2</p>
<p>And also, whether it is identity or not for probability.</p>
<p>I&rsquo;ll make a table.</p>
<p>List all 16 combinations:</p>
<ol>
<li>
<p>(I,I): count_z=0, count_x=0 → (0,0)</p>
</li>
<li>
<p>(I,X): count_z=0 (I not Z/Y, X not Z/Y), count_x=1 (X is X/Y) → (0,1)</p>
</li>
<li>
<p>(I,Y): count_z=1 (Y is Z/Y), count_x=1 (Y is X/Y) → (1,1)</p>
</li>
<li>
<p>(I,Z): count_z=1 (Z is Z/Y), count_x=0 (Z not X/Y) → (1,0)</p>
</li>
<li>
<p>(X,I): similar to (I,X), count_z=0, count_x=1 → (0,1)</p>
</li>
<li>
<p>(X,X): count_z=0, count_x=2 → even, so (0,0)</p>
</li>
<li>
<p>(X,Y): count_z=1 (Y is Z/Y), count_x=2 (X and Y both contribute to X/Y? wait, for count_x, we count sites with X or Y. So for (X,Y), first qubit: X counts for count_x, second qubit: Y counts for count_x, so count_x=2 → even, so f_x=0. count_z: first qubit: X not Z/Y, second qubit: Y is Z/Y, so count_z=1 → f_z=1. So (1,0)</p>
</li>
<li>
<p>(X,Z): count_z: first not Z/Y, second is Z/Y → count_z=1 → f_z=1. count_x: first is X/Y, second not X/Y → count_x=1 → f_x=1. So (1,1)</p>
</li>
<li>
<p>(Y,I): similar to (I,Y), count_z=1, count_x=1 → (1,1)</p>
</li>
<li>
<p>(Y,X): similar to (X,Y), count_z=1, count_x=2 → f_x=0, so (1,0)</p>
</li>
<li>
<p>(Y,Y): count_z=2 → even, f_z=0; count_x=2 → even, f_x=0 → (0,0)</p>
</li>
<li>
<p>(Y,Z): count_z: first is Z/Y, second is Z/Y → count_z=2 → f_z=0; count_x: first is X/Y, second not X/Y → count_x=1 → f_x=1 → (0,1)</p>
</li>
<li>
<p>(Z,I): similar to (I,Z), count_z=1, count_x=0 → (1,0)</p>
</li>
<li>
<p>(Z,X): similar to (X,Z), count_z=1, count_x=1 → (1,1)</p>
</li>
<li>
<p>(Z,Y): similar to (Y,Z), count_z=2 → f_z=0; count_x: first not X/Y, second is X/Y → count_x=1 → f_x=1 → (0,1)</p>
</li>
<li>
<p>(Z,Z): count_z=2 → f_z=0; count_x=0 → f_x=0 → (0,0)</p>
</li>
</ol>
<p>Now, I need to group these by the (f_z, f_x) values and also by whether they are identity or not.</p>
<p>Identity is only case 1: (I,I) which is (0,0)</p>
<p>Now, list all with (0,0): from above: cases 1,6,11,16 → that&rsquo;s 4 cases. Among them, 1 is identity, 3 are non-identity.</p>
<p>(0,1): cases where (f_z,f_x)=(0,1). From list: cases 2,5,12,15 → cases 2:(I,X), 5:(X,I), 12:(Y,Z), 15:(Z,Y) → that&rsquo;s 4 cases, all non-identity since identity is only (I,I).</p>
<p>(1,0): cases where (1,0). From list: cases 4,7,10,13 → cases 4:(I,Z), 7:(X,Y), 10:(Y,X), 13:(Z,I) → 4 cases, all non-identity.</p>
<p>(1,1): cases where (1,1). From list: cases 3,8,9,14 → cases 3:(I,Y), 8:(X,Z), 9:(Y,I), 14:(Z,X) → 4 cases, all non-identity.</p>
<p>So, for a random two-qubit Pauli Q with depolarizing distribution:</p>
<p>P(Q has (f_z,f_x) = (0,0)) = P(Q is identity) + P(Q is one of the other three in this group) = (1-p) + 3*(p/15) = 1-p + p/5 = 1 - 4p/5</p>
<p>P(Q has (0,1)) = there are 4 cases, each with probability p/15, so 4*(p/15) = 4p/15</p>
<p>Similarly, P(Q has (1,0)) = 4p/15</p>
<p>P(Q has (1,1)) = 4p/15</p>
<p>Now, for the normalizer condition, we need that for F and E, (f_z(F), f_x(F)) = (f_z(E), f_x(E))</p>
<p>Since F and E are independent, the probability that they have the same (f_z,f_x) is the sum over the four possible pairs of [P(F has that pair)] * [P(E has that pair)]</p>
<p>So, P(normalizer) = [P((0,0))]^2 + [P((0,1))]^2 + [P((1,0))]^2 + [P((1,1))]^2</p>
<p>Because if both have (0,0), or both have (0,1), etc.</p>
<p>Now, plug in the probabilities:</p>
<p>P((0,0)) = 1 - 4p/5</p>
<p>P((0,1)) = 4p/15</p>
<p>P((1,0)) = 4p/15</p>
<p>P((1,1)) = 4p/15</p>
<p>So, P(normalizer) = (1 - 4p/5)^2 + (4p/15)^2 + (4p/15)^2 + (4p/15)^2</p>
<p>Simplify: = (1 - 4p/5)^2 + 3 * (16 p^2 / 225) = (1 - 4p/5)^2 + 48 p^2 / 225</p>
<p>Now, (1 - 4p/5)^2 = 1 - 8p/5 + 16p^2/25</p>
<p>And 48/225 = 16/75 since 48/225 simplify divide by 3: 16/75.</p>
<p>16/25 = 48/75, so better to use denominator 75.</p>
<p>16p^2/25 = 48p^2/75</p>
<p>48p^2/225 = 16p^2/75? Let&rsquo;s see: 48/225 = 16/75 because 48/225 = 16/75 after dividing numerator and denominator by 3? 48÷3=16, 225÷3=75, yes.</p>
<p>So P(normalizer) = 1 - 8p/5 + 16p^2/25 + 3 * (16 p^2 / 225) </p>
<p>3 * 16 p^2 / 225 = 48 p^2 / 225 = 16 p^2 / 75</p>
<p>Now, 16p^2/25 = ? To combine, use common denominator. 25 and 75, so 16/25 = 48/75.</p>
<p>So 16p^2/25 = 48p^2/75</p>
<p>Thus P(normalizer) = 1 - 8p/5 + 48p^2/75 + 16p^2/75 = 1 - 8p/5 + 64p^2/75</p>
<p>Now, 8p/5 = 120p/75? 8/5 = 120/75? No, 8/5 = 120/75 would be 8/5 = 40/25 = 120/75, yes, 8/5 = 120/75? 8/5 = 1.6, 120/75=1.6, yes.</p>
<p>So P(normalizer) = 1 - 120p/75 + 64p^2/75 = (75 - 120p + 64p^2)/75</p>
<p>Now, we also have P(stabilizer) = [1 - 4p/5]^2 = 1 - 8p/5 + 16p^2/25 = (25 - 40p + 16p^2)/25? Let&rsquo;s keep it as is for now.</p>
<p>The logical fidelity is F_logical = P(stabilizer) / P(normalizer)</p>
<p>So F_logical = [1 - 4p/5]^2 / [ (75 - 120p + 64p^2)/75 ] = [1 - 4p/5]^2 * 75 / (75 - 120p + 64p^2)</p>
<p>Now, simplify [1 - 4p/5]^2 = (1 - 4p/5)^2 = (5/5 - 4p/5)^2 = (5-4p)^2 / 25</p>
<p>So F_logical = [ (5-4p)^2 / 25 ] * 75 / (75 - 120p + 64p^2) = (5-4p)^2 * 75 / (25 * (75 - 120p + 64p^2)) = (5-4p)^2 * 3 / (75 - 120p + 64p^2) since 75/25=3.</p>
<p>Now, notice that 75 - 120p + 64p^2 might be related to (5-4p)^2? (5-4p)^2 = 25 -40p +16p^2, not matching.</p>
<p>75 -120p +64p^2 = 25<em>3 -40p</em>3 +16p^2*4? Not sure.</p>
<p>Actually, 75 -120p +64p^2 = (5-4p)(15-16p)? Let&rsquo;s see: (5-4p)(15-16p) = 5<em>15 -5</em>16p -4p<em>15 +4p</em>16p =75 -80p -60p +64p^2=75-140p+64p^2, close but -140p instead of -120p.</p>
<p>Maybe it factors differently.</p>
<p>75 -120p +64p^2 = (15-8p)(5-8p)? 15<em>5=75, 15</em>(-8p)=-120p, -8p*5=-40p, total -160p, no.</p>
<p>Perhaps complete square or something.</p>
<p>Note that 75 -120p +64p^2 = 64p^2 -120p +75</p>
<p>Discriminant: 120^2 -4<em>64</em>75 =14400 -4<em>64</em>75=14400-19200= -4800, not a perfect square.</p>
<p>So better to leave it as is.</p>
<p>But I recall that for such codes, the logical fidelity might simplify.</p>
<p>Another way: since P(normalizer) = [P((0,0))]^2 + [P((0,1))]^2 + [P((1,0))]^2 + [P((1,1))]^2</p>
<p>And P((0,0)) = 1 - 4p/5</p>
<p>P((0,1)) = 4p/15, etc.</p>
<p>But for the logical fidelity, we have P(stabilizer) = [P((0,0))]^2 because for the stabilizer, we need F in S_{03} and E in S_{12}, and from above, S_{03} corresponds to the (0,0) group? Is that true?</p>
<p>From earlier, for a two-qubit Pauli, the stabilizer of the Bell state is exactly the set with (f_z,f_x)=(0,0). because from the list, the stabilizer elements are I, XX, ZZ, -YY, and from my table, I has (0,0), XX has (0,0) because (X,X) is (0,0), ZZ has (0,0), and -YY, since YY has (0,0) as in case 11, and with sign, but since we care about the Pauli itself, not the phase, for error purposes, the Pauli -YY is still the same as YY in terms of action on state? No, wait, in terms of error, when we apply a Pauli error, we consider the Pauli matrix itself, not including the phase. So for the depolarizing channel, when we say error Pauli, we mean the Pauli matrices without phase factors. So for example, is -Y considered? No, in the depolarizing channel, the errors are taken as the Pauli matrices I, X, Y, Z with positive sign because they are Hermitian. So for two qubits, the errors are tensor products of I,X,Y,Z without any overall phase. So in that case, for the stabilizer of the Bell state, the Paulis are I, X⊗X, Z⊗Z, and Y⊗Y? But wait, does Y⊗Y stabilize the Bell state? From earlier, Y⊗Y applied to |00⟩ gives i^2|11⟩ = -|11⟩, so it actually gives a phase of -1, so Y⊗Y does not stabilize because it gives -1 times the state. So to stabilize, we need -Y⊗Y. But in the error model, when we apply an error, we apply the Pauli matrix itself, so if we apply Y⊗Y, it will not stabilize because it introduces a phase. Therefore, for the depolarizing channel, the errors that actually leave the state unchanged are only those that are in the stabilizer set including the correct phase. But in terms of the Pauli matrices, since we apply the matrix itself, for Y⊗Y, it will change the state by a phase, so it should not be considered as stabilizing for the state fidelity. However, in quantum error correction, when we talk about errors, we often ignore the phase because the phase might not affect the outcome if we measure in the correct basis? But for state fidelity, the phase does matter because if the state is multiplied by -1, it is still the same state only if we consider global phase, but since it&rsquo;s a global phase, it doesn&rsquo;t matter. Is that right? Yes, in quantum mechanics, global phases are irrelevant. So actually, for state fidelity, if the error applies a global phase, it is still okay. So when we apply Y⊗Y to a state, if it gives -|ψ⟩, that is actually the same state up to global phase. So for the purpose of state fidelity, Y⊗Y does stabilize because it only changes the global phase. Therefore, in the depolarizing channel, when we apply Pauli errors, we should consider that any Pauli that is proportional to a stabilizer will leave the state invariant up to global phase. So for the Bell state, the stabilizer includes I, X⊗X, Z⊗Z, and Y⊗Y because Y⊗Y gives a global phase of -1, which is fine. So in terms of the Pauli matrices themselves, the set S_{03} should include I, X0X3, Z0Z3, and Y0Y3. But from my earlier list, Y0Y3 has (f_z,f_x)=(0,0) because from case 11, (Y,Y) has (0,0). So indeed, for the stabilizer, we need Paulis with (f_z,f_x)=(0,0). So P(Q ∈ S) = P((0,0)) = 1 - 4p/5, which matches what I have.</p>
<p>So that is correct.</p>
<p>Now back to F_logical = P(stabilizer) / P(normalizer) = [1 - 4p/5]^2 / [ (75 - 120p + 64p^2)/75 ] = [1 - 4p/5]^2 * 75 / (75 - 120p + 64p^2)</p>
<p>Now, let me simplify this expression.</p>
<p>First, [1 - 4p/5]^2 = (5-4p)^2 / 25</p>
<p>So F_logical = (5-4p)^2 / 25 * 75 / (75 - 120p + 64p^2) = (5-4p)^2 * 3 / (75 - 120p + 64p^2)</p>
<p>Now, 75 - 120p + 64p^2 = 64p^2 -120p +75</p>
<p>I can factor this? Let me see if it can be written as a square. (8p -7.5)^2 = 64p^2 -120p +56.25, not 75.</p>
<p>Maybe it factors as (8p-5)(8p-15) = 64p^2 -120p +75, yes! because 8p<em>8p=64p^2, 8p</em>(-15)= -120p, -5*8p=-40p, total -160p, no.</p>
<p>(8p-5)(8p-15) = 64p^2 -120p -40p +75? No, -5<em>8p=-40p, -15</em>8p=-120p, so -160p, not -120p.</p>
<p>Perhaps (4p-5)(16p-15) = 64p^2 -60p -80p +75 =64p^2 -140p+75, not.</p>
<p>Another combination: since 75=5<em>15, 64=8</em>8, so try (8p-5)(8p-15) already did.</p>
<p>75 -120p +64p^2 = (8p-5)(8p-15) would be 64p^2 -120p +75 only if -5<em>8p + -15</em>8p = -40p-120p=-160p, so no.</p>
<p>Maybe it doesn&rsquo;t factor nicely.</p>
<p>Note that 75 -120p +64p^2 = 25(3 - 4.8p +2.56p^2) not helpful.</p>
<p>I can leave it as is.</p>
<p>But let me write F_logical = 3(5-4p)^2 / (64p^2 -120p +75)</p>
<p>Now, for the output, I need to return this as a SymPy expression.</p>
<p>I should simplify the fraction if possible.</p>
<p>Notice that 64p^2 -120p +75 and (5-4p)^2 =25 -40p+16p^2, so not directly related.</p>
<p>I can compute the division for small p to see if it makes sense.</p>
<p>If p=0, F_logical = 3*25 /75 =75/75=1, good.</p>
<p>If p=1, F_logical = 3<em>(5-4)^2 / (64-120+75) =3</em>1/(19) =3/19, which is about 0.1579, while without post-selection, fidelity would be (1-4/5)^2=1/25=0.04, so better with post-selection, makes sense.</p>
<p>Now, for the code, I need to output this expression.</p>
<p>So in SymPy, I should define F_logical = 3<em>(5-4</em>p)<strong>2 / (64*p</strong>2 -120*p +75)</p>
<p>But let me write it properly.</p>
<p>Since I have to use the variable p, I should express it in terms of p.</p>
<p>I can also simplify by dividing numerator and denominator by&hellip; let me see if there is a common factor.</p>
<p>75 -120p +64p^2 = 64p^2 -120p +75</p>
<p>3<em>(5-4p)^2 = 3</em>(25 -40p +16p^2) =75 -120p +48p^2</p>
<p>So F_logical = (75 -120p +48p^2) / (64p^2 -120p +75)</p>
<p>So that is the expression.</p>
<p>I think this is fine.</p>
<p>So for the function, I will return this.</p>
<p>Now, to write in SymPy, I need to use sp symbols.</p>
<p>So in the function, I have input p, which is a symbol.</p>
<p>So I can compute:</p>
<p>numerator = 3 * (5 - 4<em>p)</em>*2</p>
<p>denominator = 64<em>p</em><em>2 - 120</em>p + 75</p>
<p>Then F_logical = numerator / denominator</p>
<p>But let me confirm the denominator: from earlier, P(normalizer) = (75 -120p +64p^2)/75, so when I have division, it corrects.</p>
<p>Yes.</p>
<p>So I think that&rsquo;s it.</p>
                      </div>
                    </details>
<div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Calculate the numerator: 3*(5 - 4p)^2</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># Calculate the denominator: 64p^2 - 120p + 75</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="mi">64</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">75</span>
    <span class="c1"># Logical fidelity is numerator divided by denominator</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.041554
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>