<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ğŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo;</p>
<p>Interpretation: We have a circuit: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). But careful: The equation is written in matrix multiplication order, while quantum operations occur in reverse order. So the actual circuit order from initial state to final state is: 
Start with initial state? Typically, we assume initial state is |0000&gt;? But problem doesn&rsquo;t explicitly say initial state? But we want to prepare a logical two-qubit GHZ state: (|00&gt;<em>AB + |11&gt;_AB)/âˆš2. So the circuit is supposed to produce that state. So initial state is presumably |0000&gt;? But wait: The circuit: (CNOT</em>{03}) (H_0) (CNOT_{21}) (H_2). In matrix multiplication order: That means if we write U = CNOT_{03} * H_0 * CNOT_{21} * H_2, then the actual circuit applies H_2 first, then CNOT_{21}, then H_0, then CNOT_{03}. So order: 
Step 1: Apply H on qubit 2.
Step 2: Apply CNOT with control qubit 2 and target qubit 1.
Step 3: Apply H on qubit 0.
Step 4: Apply CNOT with control qubit 0 and target qubit 3.
So initial state: |0000&gt;? But then check: 
After H_2: qubit2 becomes (|0&gt;+|1&gt;)/âˆš2, so state: |00&gt; (on qubits 0,1) and (|0&gt;+|1&gt;)/âˆš2 on qubit2, and qubit3: |0&gt; so state: |0000&gt; + |0010&gt;? Actually careful: Qubits: indices: 0,1,2,3. Initially: |0&gt;|0&gt;|0&gt;|0&gt;.
After H_2: becomes: (1/âˆš2)(|0&gt;|0&gt;|0&gt;|0&gt; + |0&gt;|0&gt;|1&gt;|0&gt;) = (|0000&gt; + |0010&gt;)/âˆš2.
Then CNOT_{21}: control qubit 2, target qubit 1. So if qubit2 is 1, flip qubit1.
So state becomes: (1/âˆš2)(|0000&gt; + |0110&gt;) because: For first term: qubit2=0 so no flip: remains |0000&gt;. For second: qubit2=1 so flip qubit1: from |0&gt; to |1&gt;: so becomes |0,1,1,0&gt; = |0110&gt;.
Then H_0: Apply Hadamard on qubit0. So state: (1/âˆš2)( H|0&gt;|0&gt;|0&gt;|0&gt; + H|0&gt;|1&gt;|1&gt;|0&gt; ) = (1/âˆš2)( (|0&gt;+|1&gt;)/âˆš2 |0&gt;|0&gt;|0&gt; + (|0&gt;+|1&gt;)/âˆš2 |1&gt;|1&gt;|0&gt; ) = 1/âˆš2 * 1/âˆš2 ( |0000&gt; + |1000&gt; + |0110&gt; + |1110&gt; ) = 1/2 ( |0000&gt; + |1000&gt; + |0110&gt; + |1110&gt; ).
Then CNOT_{03}: control qubit0, target qubit3. So if qubit0 is 1, flip qubit3.
So state: 
For |0000&gt;: qubit0=0 so remains: |0000&gt;
For |1000&gt;: qubit0=1 so flip qubit3: becomes |1001&gt;
For |0110&gt;: qubit0=0 so remains: |0110&gt;
For |1110&gt;: qubit0=1 so flip qubit3: becomes |1111&gt;
So final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
That state is: (|00&gt;_A? But wait: The logical qubits: A and B. Their logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI.
We want logical GHZ: (|00&gt;_AB + |11&gt;_AB)/âˆš2. Check: What is logical |00&gt;? The code [[4,2,2]] encodes two qubits. The stabilizers: XXXX and ZZZZ. The logical states? Possibly: 
|00&gt;_L = (|0000&gt; + |1111&gt;)/âˆš2? But then |11&gt;_L = (|0110&gt; + |1001&gt;)/âˆš2? Actually check: 
Given logical operators: 
X_A = XIXI. So acting on state |0000&gt;? But careful: The code space is 4-dimensional? Actually [[4,2,2]] means: n=4, k=2, d=2. So code space dimension 2^2=4. The stabilizers: XXXX and ZZZZ. They commute? Actually XXXX and ZZZZ commute? Check: XXXX * ZZZZ = (XZ)(XZ)(XZ)(XZ) = (-iY)(-iY)(-iY)(-iY) =? Actually easier: They commute because each pair: X and Z anticommute, but product over all qubits: XXXX and ZZZZ: Actually, X_i and Z_j commute if iâ‰ j, but here they are on same qubits? Actually, on each qubit, X and Z anticommute. So product: (X1 X2 X3 X4) and (Z1 Z2 Z3 Z4): For each qubit, X_i Z_i = -Z_i X_i. So overall, the commutator: XXXX ZZZZ = (X1Z1)(X2Z2)(X3Z3)(X4Z4) = (-Z1X1)(-Z2X2)(-Z3X3)(-Z4X4) = (-1)^4 (Z1X1 Z2X2 Z3X3 Z4X4) = (Z1Z2Z3Z4)(X1X2X3X4) = ZZZZ XXXX. So they commute. So stabilizers are valid.
The code space: states that are +1 eigenstates of both XXXX and ZZZZ.
Check our final state: 
|Ïˆ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
Compute XXXX|Ïˆ&gt; =? 
XXXX|0000&gt; = |1111&gt;
XXXX|1001&gt; = |0110&gt;? Because flip all: 1001 -&gt; 0110.
XXXX|0110&gt; = |1001&gt;
XXXX|1111&gt; = |0000&gt;
So XXXX|Ïˆ&gt; = 1/2 (|1111&gt; + |0110&gt; + |1001&gt; + |0000&gt;) = |Ïˆ&gt;. So it&rsquo;s +1.
ZZZZ|Ïˆ&gt; =? 
ZZZZ|0000&gt; = |0000&gt; because all phases: Z on |0&gt; gives +1.
ZZZZ|1001&gt; =? Z on qubit0: |1&gt; gives -1, qubit1: |0&gt; gives +1, qubit2: |0&gt; gives +1, qubit3: |1&gt; gives -1, so product = (-1)<em>(-1)=+1? Actually careful: ZZZZ means ZâŠ—ZâŠ—ZâŠ—Z. So on |1001&gt;, eigenvalue: for qubit0: -1, qubit1: +1, qubit2: +1, qubit3: -1, so product = (-1)</em>(+1)<em>(+1)</em>(-1)= +1. So |1001&gt; remains.
ZZZZ|0110&gt;: qubit0:0 -&gt; +1, qubit1:1 -&gt; -1, qubit2:1 -&gt; -1, qubit3:0 -&gt; +1, product = (+1)<em>(-1)</em>(-1)*(+1)= +1.
ZZZZ|1111&gt;: all ones: (-1)^4 = +1.
So indeed, |Ïˆ&gt; is in the code space. And it is a superposition of two basis states? Actually the code space is 4-dimensional. But our state is a specific state. And it is the logical GHZ state? Check: Logical operators: 
X_A = XIXI. Compute X_A on |Ïˆ&gt;:
X_A|0000&gt; = |0100&gt;? But wait: X_A = qubit0: X, qubit1: I, qubit2: X, qubit3: I. So on |0000&gt;, becomes |0? Actually careful: indices: 0,1,2,3. X_A acts on qubit0 and qubit2. So |0000&gt; becomes |1?0? Actually: qubit0: flip: 0-&gt;1, qubit2: flip: 0-&gt;1, so becomes |1,0,1,0&gt; = |1010&gt;. That is not in the superposition? So maybe our state is not an eigenstate of X_A? But we want GHZ: (|00&gt;+|11&gt;)/âˆš2. That state is not a code state? Actually, it is a state on two logical qubits. They are encoded. So we want to check: What are the logical basis states? They are usually defined such that they are eigenvectors of Z_A and Z_B. So we want Z_A and Z_B. 
Z_A = ZZII. So on our state: 
Z_A|Ïˆ&gt; =? 
For |0000&gt;: Z_A gives: qubit0: Z, qubit1: Z, so on |00&gt; gives +1, so remains.
|1001&gt;: qubit0:1 -&gt; -1, qubit1:0 -&gt; +1, so product -1.
|0110&gt;: qubit0:0 -&gt; +1, qubit1:1 -&gt; -1, so product -1.
|1111&gt;: qubit0:1 -&gt; -1, qubit1:1 -&gt; -1, product +1.
So Z_A|Ïˆ&gt; = 1/2 (|0000&gt; - |1001&gt; - |0110&gt; + |1111&gt;). That is not Â±|Ïˆ&gt; generally. So |Ïˆ&gt; is not an eigenstate of Z_A. But wait, the GHZ state is (|00&gt;+|11&gt;)/âˆš2. That state is not an eigenstate of ZâŠ—I? Actually, on two qubits, ZâŠ—I on (|00&gt;+|11&gt;)/âˆš2 gives (|00&gt; - |11&gt;)/âˆš2, so it&rsquo;s not an eigenstate. So that&rsquo;s fine.
Maybe we check: The logical state (|00&gt;+|11&gt;)/âˆš2 should have the property that if we measure Z_A and Z_B, we get correlated: either both +1 or both -1? Actually, for GHZ, if we measure Z on both, we get either (0,0) or (1,1) with equal probability. So our state: The probability to get Z_A=+1? That happens for |0000&gt; and |1111&gt; so amplitude 1/2 each, so probability 1/2. And Z_A=-1 for |1001&gt; and |0110&gt;, so probability 1/2. And similarly Z_B? Z_B = ZIZI. Compute on our state:
Z_B|0000&gt;: qubit0: Z gives +1, qubit2: Z gives +1, so +1.
|1001&gt;: qubit0: -1, qubit2: 0 -&gt; +1, so -1.
|0110&gt;: qubit0: 0 -&gt; +1, qubit2: 1 -&gt; -1, so -1.
|1111&gt;: qubit0: -1, qubit2: -1, so +1.
So indeed, Z_B gives +1 on |0000&gt; and |1111&gt; and -1 on the others. So indeed, our state is such that Z_A and Z_B are always equal. So it is the GHZ state: (|00&gt;_L + |11&gt;_L)/âˆš2, if we identify |00&gt;_L as the state with Z_A=+1, Z_B=+1, and |11&gt;_L as the state with Z_A=-1, Z_B=-1. But careful: The code space has 4 states. The logical basis can be chosen as: 
|00&gt;_L = (|0000&gt;+|1111&gt;)/âˆš2,
|01&gt;_L = (|0011&gt;+|1100&gt;)/âˆš2? Actually, need to check stabilizers? But anyway, our state is indeed: 
|Ïˆ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;) = 
= 1/âˆš2 [ (|0000&gt;+|1111&gt;)/âˆš2 + (|1001&gt;+|0110&gt;)/âˆš2 ].
And note that (|1001&gt;+|0110&gt;)/âˆš2 is actually the logical |11&gt;? Because then Z_A on that: gives -1 on each, and Z_B gives -1 on each. So yes.
So circuit produces the desired logical GHZ state.</p>
<p>Now, we introduce errors: Each CNOT gate is followed by a two-qubit depolarizing error channel. There are two CNOT gates: CNOT_{21} and CNOT_{03}. So after each CNOT, we apply an error channel on the two qubits involved. The error channel: With probability p, an error occurs. And if an error occurs, it is uniformly chosen among the 15 non-identity two-qubit Paulis. So probability of no error from a CNOT is (1-p). And if error occurs, each specific Pauli error (from the set of 15) has probability p/15.</p>
<p>We want: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of p?&rdquo; 
Interpretation: We want the fidelity between the ideal state (without errors) and the actual state (with errors) after the circuit. But careful: The circuit has gates: H_2, then CNOT_{21} (with error), then H_0, then CNOT_{03} (with error). But wait: The problem statement: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. So that means: After applying CNOT_{21}, we apply the error channel on qubits 2 and 1. And after applying CNOT_{03}, we apply the error channel on qubits 0 and 3.
Also, note: The Hadamard gates are assumed perfect? Probably yes. So only errors come from CNOT gates.</p>
<p>We want the fidelity F = &lt;Ïˆ_ideal| Ï_actual |Ïˆ_ideal&gt; where Ï_actual is the state after the circuit with errors.</p>
<p>We can compute this by tracing over the error processes. The circuit is: 
Start with |0000&gt;.
Apply H_2: perfect.
Then apply CNOT_{21} followed by error channel on qubits (2,1). 
Then apply H_0: perfect.
Then apply CNOT_{03} followed by error channel on qubits (0,3).</p>
<p>So we want to compute the final density matrix Ï. Since errors are independent on each CNOT, we can compute the effect of each error channel on the state evolution.</p>
<p>Let&rsquo;s denote:
U1 = CNOT_{21}
U2 = CNOT_{03}
And Hadamards: H2 and H0.
So circuit: U = U2 * H0 * U1 * H2. (But careful: Order: Actually, the circuit is: H2, then U1, then H0, then U2. So overall unitary: U = U2 * H0 * U1 * H2.)
Ideal state: |Ïˆ_ideal&gt; = U |0000&gt;.</p>
<p>Now, with errors: After U1, we apply error channel on qubits 2 and 1. That error channel: For each Pauli E from the set of two-qubit Paulis on qubits (2,1) (excluding identity), with probability p/15, we get error E. And with probability 1-p, we get identity.
So after step: state becomes: Ï1 = (1-p) U1 (H2|0000&gt;&lt;0000|H2â€ ) U1â€  + (p/15) âˆ‘<em>{E in Paulis on (2,1) non-identity} E U1 (H2|0000&gt;&lt;0000|H2â€ ) U1â€  Eâ€ .
But note: E are Pauli operators, so they are unitary and Hermitian. So Eâ€  = E.
So Ï1 = (1-p) |Ï†1&gt;&lt;Ï†1| + (p/15) âˆ‘</em>{E â‰  I} E |Ï†1&gt;&lt;Ï†1| E, where |Ï†1&gt; = U1 H2 |0000&gt;.
But careful: Actually, the error channel is applied after U1. So the state after U1 is |Ï†1&gt; = U1 H2 |0000&gt;. Then error channel: with probability 1-p, no error; with probability p, an error occurs, and then the state becomes E|Ï†1&gt; for some E. But then we average over E? Actually, the depolarizing channel: It is: Ï -&gt; (1-p) Ï + (p/15) âˆ‘_{E â‰  I} E Ï E. So yes.</p>
<p>Then after that, we apply H0 (perfect). So state becomes: Ï2 = H0 Ï1 H0â€ .
Then apply U2 (CNOT_{03}) perfect? Actually, careful: The circuit: after H0, we apply U2. But then after U2, we apply the error channel on qubits (0,3). So after U2, we get state: |Ï†2&gt; = U2 H0 |Ï†1&gt;? Actually, careful: The process: 
After step 1: Ï1 (on qubits 0,1,2,3).
Then apply H0 on qubit0. So Ï2 = (H0 âŠ— I_{1,2,3}) Ï1 (H0â€  âŠ— I).
Then apply U2 (CNOT_{03}). So then state becomes: Ï3 = U2 Ï2 U2â€ .
Then apply error channel on qubits (0,3): That gives: Ï_final = (1-p) Ï3 + (p/15) âˆ‘_{F in Paulis on (0,3) non-identity} F Ï3 F.</p>
<p>And we want fidelity: F = &lt;Ïˆ_ideal| Ï_final |Ïˆ_ideal&gt;, where |Ïˆ_ideal&gt; = U2 H0 U1 H2 |0000&gt; = U |0000&gt;.</p>
<p>Because the errors are independent and the circuit is linear, we can compute the fidelity as the product of the fidelities from each error step? But careful: The errors occur on different sets of qubits and they might not commute with subsequent gates? But we can compute exactly.</p>
<p>Alternatively, we can compute the effect of an error on the final state. The ideal final state is |Ïˆ_ideal&gt;. Now, if an error occurs at the first CNOT step (on qubits 2,1), that error E will be propagated through the subsequent gates H0 and U2. So effectively, if an error E occurs at the first step, then the final state becomes: U2 H0 E U1 H2 |0000&gt;? But careful: The error happens after U1. So the state becomes E U1 H2 |0000&gt;. Then we apply H0 on qubit0. That gives H0 E U1 H2 |0000&gt;. But note: H0 acts only on qubit0. And E acts on qubits 2 and 1. They commute because they act on different qubits? Actually, qubit0 is separate from qubits 1 and 2? Yes, qubits are 0,1,2,3. So H0 and E commute if E acts on qubits 1 and 2? But careful: H0 acts on qubit0. E acts on qubits 2 and 1. They act on disjoint sets, so they commute. So then state becomes: E H0 U1 H2 |0000&gt;. Then apply U2 (CNOT_{03}). That gives: U2 E H0 U1 H2 |0000&gt;. But does U2 commute with E? U2 acts on qubits 0 and 3. E acts on qubits 1 and 2. They act on disjoint sets, so they commute. So then state becomes: E U2 H0 U1 H2 |0000&gt; = E |Ïˆ_ideal&gt;. So indeed, an error E from the first CNOT step simply becomes a Pauli error on the final state: The final state becomes E |Ïˆ_ideal&gt;, where E is a Pauli on qubits 1 and 2? But wait: E originally acts on qubits 2 and 1. But after commuting through, it remains the same Pauli on those qubits. So any error from the first CNOT step becomes a Pauli error on the final state on qubits 1 and 2.
Similarly, an error from the second CNOT step: After U2, we apply error F on qubits (0,3). That error F directly acts on the ideal state? But careful: The ideal state after U2 is |Ïˆ_ideal&gt;? Actually, if there were no errors from first step, then after U2, the state is |Ïˆ_ideal&gt;. Then error F gives F |Ïˆ_ideal&gt;. So errors from the second step become Pauli errors on qubits 0 and 3 on the final state.
But wait: There is also the possibility of errors from both steps. But since errors are independent, the overall final state is a mixture: With probability (1-p)^2, no errors occur, so state is |Ïˆ_ideal&gt;.
With probability p(1-p) from first error only: then state becomes E |Ïˆ_ideal&gt; for some E (on qubits 1,2) with probability p/15 each.
With probability (1-p)p from second error only: then state becomes F |Ïˆ_ideal&gt; for some F (on qubits 0,3) with probability p/15 each.
With probability p^2 from both errors: then state becomes F E |Ïˆ_ideal&gt;? But careful: If both errors occur, then the first error gives E, and then after H0 and U2, we get E |Ïˆ_ideal&gt; as argued? But then the second error F acts on that: F E |Ïˆ_ideal&gt;. But note: F acts on qubits 0 and 3, and E acts on qubits 1 and 2. They commute. So indeed, the combined error is just the product F E. And since these are independent, the probability for a specific pair (E, F) is (p/15)^2.
So overall, the final density matrix is:
Ï_final = (1-p)^2 |Ïˆ_ideal&gt;&lt;Ïˆ_ideal| 
+ (p/15)(1-p) âˆ‘_{E in Paulis on {1,2} non-identity} |E Ïˆ_ideal&gt;<E Ïˆ_ideal|
+ (p/15)(1-p) âˆ‘_{F in Paulis on {0,3} non-identity} |F Ïˆ_ideal><F Ïˆ_ideal|
+ (p/15)^2 âˆ‘_{E,F} |F E Ïˆ_ideal>&lt;F E Ïˆ_ideal|.</p>
<p>But wait: Is that correct? Check: The error channels are applied independently. So yes.</p>
<p>Then the fidelity F = &lt;Ïˆ_ideal| Ï_final |Ïˆ_ideal&gt;.
That equals: 
(1-p)^2 * 1 
+ (p/15)(1-p) âˆ‘_{E} &lt;Ïˆ_ideal|E|Ïˆ_ideal&gt;&lt;Ïˆ_ideal|E|Ïˆ_ideal&gt;? Actually careful: The terms are projectors: |E Ïˆ&gt;&lt;E Ïˆ|. So &lt;Ïˆ| |E Ïˆ&gt;<E Ïˆ| |Ïˆ> = |&lt;Ïˆ|E|Ïˆ&gt;|^2.
Similarly, for F: |&lt;Ïˆ|F|Ïˆ&gt;|^2.
And for both: |&lt;Ïˆ|F E|Ïˆ&gt;|^2.</p>
<p>So fidelity = (1-p)^2 + (p/15)(1-p) [âˆ‘<em>{E on {1,2} non-identity} |&lt;Ïˆ|E|Ïˆ&gt;|^2] + (p/15)(1-p) [âˆ‘</em>{F on {0,3} non-identity} |&lt;Ïˆ|F|Ïˆ&gt;|^2] + (p/15)^2 [âˆ‘_{E on {1,2}, F on {0,3} non-identity} |&lt;Ïˆ|F E|Ïˆ&gt;|^2].</p>
<p>So we need to compute these overlaps: &lt;Ïˆ|P|Ïˆ&gt; for various Pauli operators P that act on subsets of qubits. But careful: Our state |Ïˆ&gt; is the ideal state: |Ïˆ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>We need to compute for each Pauli operator on the specified qubits, the expectation value &lt;Ïˆ|P|Ïˆ&gt;? Actually, we need |&lt;Ïˆ|P|Ïˆ&gt;|^2. But note: Since Pauli operators are Hermitian and unitary, they have eigenvalues Â±1. But our state might not be an eigenstate. But we can compute explicitly.</p>
<p>Let&rsquo;s denote the state: 
|Ïˆ&gt; = (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;)/2.
We want to compute &lt;Ïˆ|P|Ïˆ&gt; for a Pauli operator P. Since Pauli operators are tensor products of I, X, Y, Z on each qubit. But careful: The Paulis we consider: For first set: E acts on qubits 1 and 2. So E is of the form: P_{1} âŠ— P_{2} (on qubits 1 and 2) and identity on qubits 0 and 3.
For second set: F acts on qubits 0 and 3. So F is of the form: P_{0} âŠ— P_{3} and identity on qubits 1 and 2.
And for both: F E acts on all qubits? But careful: That product is on qubits 0,3 and on qubits 1,2. So it&rsquo;s a Pauli on all 4 qubits. But we sum over all non-identity on the respective sets. So we need to compute for each such Pauli, the overlap &lt;Ïˆ|P|Ïˆ&gt;.</p>
<p>Because the state |Ïˆ&gt; is symmetric in a certain pattern? Let&rsquo;s list the basis states: 
|a,b,c,d&gt; with a,b,c,d in {0,1}. And |Ïˆ&gt; has nonzero amplitudes only for states where: 
0000, 1001, 0110, 1111.
Notice pattern: The sum of the bits? For these, a+d? Actually, 0000: a=0,d=0; 1001: a=1,d=1; 0110: a=0,d=0? Actually, 0110: a=0,d=0; 1111: a=1,d=1. So it seems that a and d are always equal? Check: 0000: 0=0; 1001: 1=1; 0110: 0=0; 1111: 1=1. So indeed, qubit0 and qubit3 are always the same. Also, look at qubits 1 and 2: For 0000: b=0,c=0; 1001: b=0,c=0; 0110: b=1,c=1; 1111: b=1,c=1. So qubits 1 and 2 are also always the same. So |Ïˆ&gt; is actually: 
|Ïˆ&gt; = 1/2 (|0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt;) but careful: That ordering: qubits: 0,1,2,3. So indeed, condition: qubit0 = qubit3, and qubit1 = qubit2.
So we can write: |Ïˆ&gt; = 1/2 (|0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt;).</p>
<p>That might simplify computations.</p>
<p>Now, consider a Pauli operator on qubits 1 and 2. It is of the form: I âŠ— (P_{1} âŠ— P_{2}) âŠ— I? Actually careful: The qubits order: 0,1,2,3. So an operator on qubits 1 and 2 only: It acts as identity on qubit0 and qubit3. So let E = I_0 âŠ— A âŠ— B âŠ— I_3, where A and B are Pauli matrices (X, Y, Z) but not both I? Actually, we sum over non-identity on the pair. So A and B can be any Pauli from {X,Y,Z}? But wait: The set of two-qubit Paulis on qubits 1 and 2: There are 15 such operators: They are all products of Pauli matrices on qubit1 and qubit2, excluding the identity on both. But note: They include operators like XâŠ—I, IâŠ—X, etc. But careful: The error channel is on the two qubits together. So the errors are two-qubit Pauli operators on that pair. That set includes operators that act on only one qubit? Yes, because those are non-identity on the pair? For example, XâŠ—I is not the identity on the pair because identity on two qubits is IâŠ—I. So indeed, the set is: All Pauli operators on two qubits except IâŠ—I. So we have: 
On qubits 1 and 2, the Paulis are: 
XâŠ—I, YâŠ—I, ZâŠ—I,
IâŠ—X, IâŠ—Y, IâŠ—Z,
XâŠ—X, XâŠ—Y, XâŠ—Z,
YâŠ—X, YâŠ—Y, YâŠ—Z,
ZâŠ—X, ZâŠ—Y, ZâŠ—Z.
So 15 total.</p>
<p>We want to compute &lt;Ïˆ|E|Ïˆ&gt; for each such E. But note: Because of the symmetry of |Ïˆ&gt;? Actually, |Ïˆ&gt; has the property that qubits 1 and 2 are always equal. So if we apply an operator that does not preserve that symmetry, then E|Ïˆ&gt; might be orthogonal to |Ïˆ&gt;? Let&rsquo;s compute systematically.</p>
<p>Write |Ïˆ&gt; = 1/2 (|0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt;). 
For an operator E acting on qubits 1 and 2 only. So E = I_0 âŠ— O âŠ— I_3, where O is a 4x4 matrix on qubits 1 and 2. Then E|Ïˆ&gt; = 1/2 ( |0&gt; âŠ— (O|00&gt;) âŠ— |0&gt; + |1&gt; âŠ— (O|00&gt;) âŠ— |1&gt; + |0&gt; âŠ— (O|11&gt;) âŠ— |0&gt; + |1&gt; âŠ— (O|11&gt;) âŠ— |1&gt; ). Because on the terms: |0,0,0,0&gt; becomes: qubits1,2: |00&gt; so O|00&gt;; similarly, |1,0,0,1&gt;: qubits1,2: |00&gt; so O|00&gt;; |0,1,1,0&gt;: qubits1,2: |11&gt; so O|11&gt;; |1,1,1,1&gt;: qubits1,2: |11&gt; so O|11&gt;.
So then &lt;Ïˆ|E|Ïˆ&gt; = 1/4 [ &lt;00|O|00&gt; + &lt;00|O|00&gt; + &lt;11|O|11&gt; + &lt;11|O|11&gt;? Actually careful: 
&lt;Ïˆ|E|Ïˆ&gt; = (1/2)(1/2) sum? Let&rsquo;s do properly:
&lt;Ïˆ|E|Ïˆ&gt; = âˆ‘<em>{a,d in {0,1}}? Actually, we can compute:
&lt;Ïˆ|E|Ïˆ&gt; = 1/4 [ &lt;0000| + &lt;1001| + &lt;0110| + &lt;1111| ] E [ |0000&gt; + |1001&gt; + |0110&gt; + |1111&gt; ].
But since E acts only on qubits 1,2, the cross terms between different a,d? Actually, careful: The states are orthogonal if the qubit0 and qubit3 differ? Actually, |0000&gt; and |1001&gt; are orthogonal because qubit0 differs. So we can compute term by term:
Term from |0000&gt;: &lt;0000|E|0000&gt; = &lt;00|O|00&gt;.
|1001&gt;: &lt;1001|E|1001&gt; = &lt;00|O|00&gt;.
|0110&gt;: &lt;0110|E|0110&gt; = &lt;11|O|11&gt;.
|1111&gt;: &lt;1111|E|1111&gt; = &lt;11|O|11&gt;.
And cross terms like &lt;0000|E|1001&gt; = 0 because qubit0: 0 vs 1.
So indeed, &lt;Ïˆ|E|Ïˆ&gt; = 1/4 [ 2 &lt;00|O|00&gt; + 2 &lt;11|O|11&gt; ] = 1/2 [ &lt;00|O|00&gt; + &lt;11|O|11&gt; ].
So for any operator O on two qubits (qubits 1 and 2), we have:
&lt;Ïˆ|E|Ïˆ&gt; = 1/2 (Tr(O (|00&gt;&lt;00| + |11&gt;&lt;11|))? Actually, careful: &lt;00|O|00&gt; is the (00,00) matrix element, and &lt;11|O|11&gt; is the (11,11) matrix element.
So if O is a Pauli matrix, then these are either 0 or Â±1. Specifically, Pauli matrices: 
X: &lt;00|X|00&gt; = 0, &lt;11|X|11&gt; = 0? Actually, X flips bits: X|0&gt; = |1&gt;, so on two qubits, XâŠ—I: then &lt;00|XâŠ—I|00&gt; = &lt;0|X|0&gt;&lt;0|I|0&gt; = 0. Similarly, &lt;11|XâŠ—I|11&gt; = &lt;1|X|1&gt;&lt;1|I|1&gt; = 0. So that gives 0.
Y: similarly, 0.
Z: &lt;00|Z|00&gt; = 1? Actually, careful: Z|0&gt;=|0&gt;, so &lt;00|ZâŠ—I|00&gt; = 1. But wait: O is on two qubits. But we need to consider all Paulis on two qubits. They are products: For example, XâŠ—I, IâŠ—X, XâŠ—X, etc.
Let&rsquo;s list all 15 Paulis on qubits 1 and 2. They are of the form: P âŠ— Q, where P, Q âˆˆ {I, X, Y, Z} but not both I.
We want &lt;Ïˆ|E|Ïˆ&gt; = 1/2 ( &lt;00|PâŠ—Q|00&gt; + &lt;11|PâŠ—Q|11&gt; ).
Now, &lt;00|PâŠ—Q|00&gt; = &lt;0|P|0&gt;&lt;0|Q|0&gt;.
&lt;11|PâŠ—Q|11&gt; = &lt;1|P|1&gt;&lt;1|Q|1&gt;.
For Pauli matrices:
For I: &lt;0|I|0&gt;=1, &lt;1|I|1&gt;=1.
For X: &lt;0|X|0&gt;=0, &lt;1|X|1&gt;=0.
For Y: &lt;0|Y|0&gt;=0, &lt;1|Y|1&gt;=0.
For Z: &lt;0|Z|0&gt;=1, &lt;1|Z|1&gt; = -1.
So then:
If PâŠ—Q = IâŠ—I, then it&rsquo;s identity, but we exclude that.
So for non-identity:
Case: P = I, Q is non-identity: 
IâŠ—X: then &lt;00| = 1<em>0=0; &lt;11| = 1</em>0=0; so overlap = 0.
IâŠ—Y: 0.
IâŠ—Z: &lt;00| = 1<em>1=1; &lt;11| = 1</em>(-1) = -1; so sum = 1 + (-1)=0, so overlap = 0.
Similarly, P = X, Q = I: XâŠ—I: 0.
P = Y, Q = I: 0.
P = Z, Q = I: ZâŠ—I: &lt;00| = 1<em>1=1; &lt;11| = (-1)</em>1 = -1; so sum=0.
Now, if both P and Q are non-I:
XâŠ—X: &lt;00| = 0<em>0=0; &lt;11| = 0</em>0=0; so 0.
XâŠ—Y: 0.
XâŠ—Z: &lt;00| = 0<em>1=0; &lt;11| = 0</em>(-1)=0; so 0.
YâŠ—X: 0.
YâŠ—Y: 0? Actually, careful: Y|0&gt; = i|1&gt;, so &lt;0|Y|0&gt;=0, so yes 0.
YâŠ—Z: 0.
ZâŠ—X: &lt;00| = 1<em>0=0; &lt;11| = (-1)</em>0=0; so 0.
ZâŠ—Y: 0.
ZâŠ—Z: &lt;00| = 1<em>1=1; &lt;11| = (-1)</em>(-1)=1; so sum = 1+1=2, so overlap = 1/2 * 2 = 1.
So the only Pauli on qubits 1 and 2 that gives nonzero overlap is ZâŠ—Z. But wait: Check: What about Paulis that are products like? Actually, we&rsquo;ve covered all: The only one is ZâŠ—Z. But also, what about -ZâŠ—Z? That is not a separate Pauli because Paulis are defined up to phase? Actually, Pauli group: The Pauli matrices are usually taken as X, Y, Z. But note: Y = i? Actually, careful: The Pauli matrices are Hermitian? Actually, X and Z are Hermitian, but Y is Hermitian? Y = [[0,-i],[i,0]] is Hermitian. So they are all Hermitian. So indeed, the set is {I, X, Y, Z} on each qubit. So we&rsquo;ve covered.
So for errors on qubits 1 and 2, only the error E = ZâŠ—Z on qubits 1 and 2 (i.e., operator: I_0 âŠ— Z_1 âŠ— Z_2 âŠ— I_3) gives &lt;Ïˆ|E|Ïˆ&gt; = 1. But wait: Check: ZâŠ—Z on |Ïˆ&gt;: 
ZâŠ—Z on qubits 1 and 2: For |0000&gt;, qubits1,2: |00&gt; -&gt; Z|0&gt;=|0&gt;, so unchanged? Actually, ZâŠ—Z|00&gt; = |00&gt; because both get phase +1? Actually, careful: Z|0&gt;=|0&gt;, so ZâŠ—Z|00&gt; = |00&gt;. For |1001&gt;, similarly, |00&gt; -&gt; |00&gt;. For |0110&gt;, |11&gt; -&gt; ZâŠ—Z|11&gt; = (-1)*(-1)|11&gt; = |11&gt;. For |1111&gt;, |11&gt; -&gt; |11&gt;. So indeed, ZâŠ—Z leaves |Ïˆ&gt; unchanged. So &lt;Ïˆ|ZâŠ—Z|Ïˆ&gt; = 1.
But then we need |&lt;Ïˆ|E|Ïˆ&gt;|^2. For E = ZâŠ—Z, that is 1^2 = 1.
For all other E on qubits 1 and 2, the overlap is 0. So then the sum over E on qubits 1 and 2 (non-identity) of |&lt;Ïˆ|E|Ïˆ&gt;|^2 is: There is exactly 1 Pauli (ZâŠ—Z) that gives 1, and the other 14 give 0.
But wait: Check: What about -ZâŠ—Z? That is not a Pauli because Pauli matrices are defined as X, Y, Z. The Pauli group elements include phases Â±1, Â±i. But here the error channel: &ldquo;produces one of the 15 non-identity two-qubit Paulis&rdquo;. Usually, the two-qubit Pauli group has 15 elements if we consider them up to phase? Actually, careful: The depolarizing channel is usually defined as: With probability p, an error occurs, and the error is uniformly chosen from the set {I, X, Y, Z}âŠ—{I, X, Y, Z} minus the identity? But then that set has 15 elements. But note: That set includes, for example, -IâŠ—X? No, because we only take the matrices themselves: The set is {I, X, Y, Z} âŠ— {I, X, Y, Z} but excluding IâŠ—I. But then that set includes, for instance, XâŠ—I, YâŠ—I, ZâŠ—I, IâŠ—X, IâŠ—Y, IâŠ—Z, XâŠ—X, XâŠ—Y, XâŠ—Z, YâŠ—X, YâŠ—Y, YâŠ—Z, ZâŠ—X, ZâŠ—Y, ZâŠ—Z. So indeed, it&rsquo;s exactly 15. And none of these are negative? Because if we take -X, that is not in the set because we only take X, Y, Z. So it&rsquo;s fine.
So for errors on qubits 1 and 2, only ZâŠ—Z gives nonzero overlap. So sum</em>{E on {1,2} non-identity} |&lt;Ïˆ|E|Ïˆ&gt;|^2 = 1.</p>
<p>Now, similarly, consider errors on qubits 0 and 3. F is a Pauli on qubits 0 and 3. Write F = P âŠ— I_1 âŠ— I_2 âŠ— Q, where P, Q âˆˆ {X, Y, Z}? But careful: The set is all two-qubit Paulis on qubits 0 and 3 that are non-identity. So similar analysis: |Ïˆ&gt; has the property that qubit0 and qubit3 are always equal. So then by similar argument, if we act with an operator on qubits 0 and 3, then 
&lt;Ïˆ|F|Ïˆ&gt; = 1/2 ( &lt;0|P|0&gt;&lt;0|Q|0&gt; + &lt;1|P|1&gt;&lt;1|Q|1&gt; ) but careful: Actually, careful: F acts on qubits 0 and 3. Write |Ïˆ&gt; = 1/2 (|0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt;). Then F|Ïˆ&gt; = 1/2 ( (P|0&gt; âŠ— |00&gt; âŠ— (Q|0&gt;) + (P|1&gt; âŠ— |00&gt; âŠ— (Q|1&gt;) + (P|0&gt; âŠ— |11&gt; âŠ— (Q|0&gt;) + (P|1&gt; âŠ— |11&gt; âŠ— (Q|1&gt;) ). Then &lt;Ïˆ|F|Ïˆ&gt; = 1/4 [ &lt;0|P|0&gt;&lt;0|Q|0&gt; + &lt;1|P|1&gt;&lt;1|Q|1&gt; + &hellip; Actually, let&rsquo;s do similarly: 
&lt;Ïˆ|F|Ïˆ&gt; = 1/4 [ &lt;0000|F|0000&gt; + &lt;1001|F|1001&gt; + &lt;0110|F|0110&gt; + &lt;1111|F|1111&gt; ] because cross terms vanish.
Now, &lt;0000|F|0000&gt; = &lt;0|P|0&gt;&lt;0|Q|0&gt;.
&lt;1001|F|1001&gt; = &lt;1|P|1&gt;&lt;1|Q|1&gt;.
&lt;0110|F|0110&gt; = &lt;0|P|0&gt;&lt;0|Q|0&gt;? Actually careful: For |0110&gt;, qubit0=0, qubit3=0, so it gives &lt;0|P|0&gt;&lt;0|Q|0&gt;.
&lt;1111|F|1111&gt; = &lt;1|P|1&gt;&lt;1|Q|1&gt;.
So total = 1/4 [ 2(&lt;0|P|0&gt;&lt;0|Q|0&gt; + 2(&lt;1|P|1&gt;&lt;1|Q|1&gt;)] = 1/2 ( &lt;0|P|0&gt;&lt;0|Q|0&gt; + &lt;1|P|1&gt;&lt;1|Q|1&gt; ).
So again, if P and Q are such that one of them is X or Y, then these are 0. The only possibility is if both are Z? But careful: What if P = Z and Q = I? That is not allowed because then it&rsquo;s identity on the pair? Actually, wait: The set of Paulis on qubits 0 and 3: They are of the form: P âŠ— Q, where P, Q âˆˆ {I, X, Y, Z} but not both I. So we consider:
P = I, Q non-I: 
IâŠ—X: gives 0.
IâŠ—Y: 0.
IâŠ—Z: gives: &lt;0|I|0&gt;=1, &lt;0|Z|0&gt;=1; &lt;1|I|1&gt;=1, &lt;1|Z|1&gt; = -1; so sum = 1 + (-1)=0.
Similarly, P = X, Q = I: 0.
P = Y, Q = I: 0.
P = Z, Q = I: gives: &lt;0|Z|0&gt;=1, &lt;0|I|0&gt;=1; &lt;1|Z|1&gt;=-1, &lt;1|I|1&gt;=1; so sum = 1 + (-1)=0.
Now, both non-I:
XâŠ—X: 0.
XâŠ—Y: 0.
XâŠ—Z: 0.
YâŠ—X: 0.
YâŠ—Y: 0.
YâŠ—Z: 0.
ZâŠ—X: 0.
ZâŠ—Y: 0.
ZâŠ—Z: gives: &lt;0|Z|0&gt;=1, &lt;0|Z|0&gt;=1 so product=1; &lt;1|Z|1&gt;=-1, &lt;1|Z|1&gt;=-1 so product=1; sum=2, so overlap = 1.
So again, the only Pauli on qubits 0 and 3 that gives nonzero overlap is ZâŠ—Z. So sum_{F on {0,3} non-identity} |&lt;Ïˆ|F|Ïˆ&gt;|^2 = 1.</p>
<p>Now, what about errors from both steps? That is F E, where E is on qubits 1,2 (non-identity) and F is on qubits 0,3 (non-identity). Then we want |&lt;Ïˆ|F E|Ïˆ&gt;|^2. But note: F and E act on disjoint sets, so they commute. And we computed separately: For E, only E = ZâŠ—Z on {1,2} gives &lt;Ïˆ|E|Ïˆ&gt; = 1, and for F, only F = ZâŠ—Z on {0,3} gives &lt;Ïˆ|F|Ïˆ&gt; = 1. But careful: If we take E that is not ZâŠ—Z, then &lt;Ïˆ|E|Ïˆ&gt;=0, so then &lt;Ïˆ|F E|Ïˆ&gt; might be 0? But we need to sum over all E and F. But we can compute generally: 
&lt;Ïˆ|F E|Ïˆ&gt; = ? Since F and E act on different qubits, and |Ïˆ&gt; factorizes in a sense? Actually, |Ïˆ&gt; is not a product state but it has structure: qubits 0 and 3 are correlated, and qubits 1 and 2 are correlated. And F acts on 0,3 and E acts on 1,2. So then &lt;Ïˆ|F E|Ïˆ&gt; =? We can compute by writing |Ïˆ&gt; as: 
|Ïˆ&gt; = 1/2 (|0,0&gt;<em>{03} âŠ— |0,0&gt;</em>{12} + |1,1&gt;<em>{03} âŠ— |0,0&gt;</em>{12}? Actually careful: 
|Ïˆ&gt; = 1/2 (|0&gt;<em>0|0&gt;_1|0&gt;_2|0&gt;_3 + |1&gt;_0|0&gt;_1|0&gt;_2|1&gt;_3 + |0&gt;_0|1&gt;_1|1&gt;_2|0&gt;_3 + |1&gt;_0|1&gt;_1|1&gt;_2|1&gt;_3).
Group qubits: (0,3) and (1,2). Then we have: 
|Ïˆ&gt; = 1/2 ( |00&gt;</em>{03} âŠ— |00&gt;<em>{12} + |11&gt;</em>{03} âŠ— |00&gt;<em>{12} + |00&gt;</em>{03} âŠ— |11&gt;<em>{12} + |11&gt;</em>{03} âŠ— |11&gt;<em>{12} )? But careful: That would be if qubit0 and qubit3 are both 0 or both 1, and qubit1 and qubit2 are both 0 or both 1. So indeed, |Ïˆ&gt; = (|00&gt;+|11&gt;)</em>{03} âŠ— (|00&gt;+|11&gt;)<em>{12} / 2? Check: (|00&gt;+|11&gt;)</em>{03} âŠ— (|00&gt;+|11&gt;)<em>{12} = |0000&gt; + |0011&gt; + |1100&gt; + |1111&gt;. But our state is |0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;. That is not the same because |1001&gt; corresponds to |10&gt;</em>{03}? Actually, careful: Qubit0 and qubit3: For |1001&gt;, that is qubit0=1, qubit3=1? Actually, |1001&gt; means: qubit0=1, qubit1=0, qubit2=0, qubit3=1. So in the grouping (0,3) and (1,2), |1001&gt; becomes: (1,1) on (0,3) and (0,0) on (1,2). So it is |11&gt;<em>{03} âŠ— |00&gt;</em>{12}. And |0110&gt; becomes: (0,0) on (0,3) and (1,1) on (1,2). So indeed, |Ïˆ&gt; = |00&gt;<em>{03}âŠ—|00&gt;</em>{12} + |11&gt;<em>{03}âŠ—|00&gt;</em>{12} + |00&gt;<em>{03}âŠ—|11&gt;</em>{12} + |11&gt;<em>{03}âŠ—|11&gt;</em>{12} all divided by 2. That is actually = (|00&gt;<em>{03}+|11&gt;</em>{03}) âŠ— (|00&gt;<em>{12}+|11&gt;</em>{12}) / 2? But then that product gives cross terms: |00&gt;<em>{03}âŠ—|11&gt;</em>{12} and |11&gt;<em>{03}âŠ—|00&gt;</em>{12} are included, but also |00&gt;<em>{03}âŠ—|00&gt;</em>{12} and |11&gt;<em>{03}âŠ—|11&gt;</em>{12}. So yes, it is exactly: 
|Ïˆ&gt; = (|00&gt;<em>{03}+|11&gt;</em>{03})/âˆš2 âŠ— (|00&gt;<em>{12}+|11&gt;</em>{12})/âˆš2.
So indeed, |Ïˆ&gt; is a product of two Bell states on pairs (0,3) and (1,2). That is interesting.
So then, for an operator F that acts on qubits 0 and 3, and E that acts on qubits 1 and 2, we have:
&lt;Ïˆ|F E|Ïˆ&gt; = <Bell_{03}|F|Bell_{03}> * <Bell_{12}|E|Bell_{12}>, where Bell = (|00&gt;+|11&gt;)/âˆš2.
And we already computed for a two-qubit Pauli on a Bell state? Actually, for a Bell state |Î¦^+&gt; = (|00&gt;+|11&gt;)/âˆš2, what is &lt;Î¦^+|PâŠ—Q|Î¦^+&gt;? That is known: It is 1/2 (Tr(P Q^T)? Actually, simpler: For Bell state, &lt;Î¦^+|AâŠ—B|Î¦^+&gt; = 1/2 Tr(A^T B)? Alternatively, we can compute directly: 
For Bell state on two qubits: |Î¦&gt; = (|00&gt;+|11&gt;)/âˆš2.
Then &lt;Î¦| (PâŠ—Q) |Î¦&gt; = 1/2 ( &lt;00|PâŠ—Q|00&gt; + &lt;11|PâŠ—Q|11&gt; + &lt;00|PâŠ—Q|11&gt; + &lt;11|PâŠ—Q|00&gt; ). But note: &lt;00|PâŠ—Q|11&gt; = &lt;0|P|1&gt;&lt;0|Q|1&gt; and &lt;11|PâŠ—Q|00&gt; = &lt;1|P|0&gt;&lt;1|Q|0&gt;. But since P and Q are Paulis, they are either diagonal or off-diagonal. Actually, we already computed for operators that are diagonal in the computational basis? But careful: Our previous computation for operators on qubits 1 and2 gave: &lt;Ïˆ|E|Ïˆ&gt; = 1/2 (&lt;00|E|00&gt;+&lt;11|E|11&gt;) but that was because the state |Ïˆ&gt; here is actually a Bell state? Actually, wait: Our |Ïˆ&gt; is product of two Bell states. But then if we isolate one Bell state, say on qubits 1 and2, then that Bell state is (|00&gt;+|11&gt;)/âˆš2. And then <Bell|E|Bell> = 1/2 (&lt;00|E|00&gt;+&lt;11|E|11&gt; + &lt;00|E|11&gt;+&lt;11|E|00&gt;). But earlier, we computed for E acting on qubits 1 and2 from the full state, we got only the diagonal terms? That was because the full state |Ïˆ&gt; is product, and when we compute &lt;Ïˆ|E|Ïˆ&gt;, since E acts only on qubits 1 and2, it becomes <Bell_{03}|Bell_{03}> * <Bell_{12}|E|Bell_{12}> = <Bell_{12}|E|Bell_{12}>. So actually, <Bell_{12}|E|Bell_{12}> should be what we computed? But we computed &lt;Ïˆ|E|Ïˆ&gt; = 1/2 (&lt;00|E|00&gt;+&lt;11|E|11&gt;) from a direct computation. That suggests that for a Bell state, <Bell|E|Bell> is actually 1/2 (&lt;00|E|00&gt;+&lt;11|E|11&gt;) if E is diagonal? But wait, check: For E = XâŠ—I on qubits 1 and2. Then <Bell|XâŠ—I|Bell> = ? 
|Bell&gt; = (|00&gt;+|11&gt;)/âˆš2.
XâŠ—I|00&gt; = |10&gt;, XâŠ—I|11&gt; = |01&gt;. So <Bell|XâŠ—I|Bell> = 1/2 (&lt;00|10&gt;+&lt;00|01&gt;+&lt;11|10&gt;+&lt;11|01&gt;) = 0. So that matches: 1/2(0+0)=0.
For E = ZâŠ—Z, we got 1/2(1+1)=1. So indeed, for a Bell state, the off-diagonal terms &lt;00|E|11&gt; and &lt;11|E|00&gt; are actually 0 for Pauli operators? Check: For E = ZâŠ—Z, &lt;00|ZâŠ—Z|11&gt; = &lt;0|Z|1&gt;&lt;0|Z|1&gt; = 0<em>0=0. So indeed, for Pauli operators, the off-diagonal terms are always 0 because if E is a Pauli, then it either flips bits or doesn&rsquo;t. Actually, if E has any X or Y, then it will flip some bits, so the diagonal elements are 0. And if E is diagonal (only Z and I), then off-diagonals are 0. So indeed, <Bell|E|Bell> = 1/2 ( &lt;00|E|00&gt; + &lt;11|E|11&gt; ). So our previous computation is consistent.
So then, for errors on both sets: 
&lt;Ïˆ|F E|Ïˆ&gt; = <Bell_{03}|F|Bell_{03}> * <Bell_{12}|E|Bell_{12}>.
And we already computed that for a two-qubit Pauli on a Bell pair, the only nonzero is when it is ZâŠ—Z, giving value 1. So then, if both F and E are ZâŠ—Z on their respective pairs, then &lt;Ïˆ|F E|Ïˆ&gt; = 1</em>1 = 1. For any other combination, at least one factor is 0, so product is 0.
But wait: Could there be a case where, say, F is ZâŠ—Z and E is something that gives 0? That gives 0. Or F is something that gives 0 and E is ZâŠ—Z gives 0. So indeed, the only combination that gives nonzero is F = ZâŠ—Z on {0,3} and E = ZâŠ—Z on {1,2}. But note: That product is ZâŠ—Z on all qubits? Actually, ZâŠ—Z on {0,3} and ZâŠ—Z on {1,2} gives overall operator: Z_0 âŠ— Z_1 âŠ— Z_2 âŠ— Z_3. And what is &lt;Ïˆ| ZZZZ |Ïˆ&gt;? That is the stabilizer? Actually, ZZZZ is a stabilizer, so it gives +1. So indeed, that gives 1.
So then, sum over E on {1,2} and F on {0,3} non-identity of |&lt;Ïˆ|F E|Ïˆ&gt;|^2 = 1 (only the pair: E = ZâŠ—Z on {1,2} and F = ZâŠ—Z on {0,3}).</p>
<p>But wait: There is also possibility: What if the error from the first step is identity? That we already covered: (1-p)^2 term.
And errors from first step only: sum gives: (p/15)(1-p)<em>1.
Errors from second step only: (p/15)(1-p)</em>1.
Errors from both: (p/15)^2 * 1.</p>
<p>So then the fidelity F = (1-p)^2 + (p/15)(1-p) + (p/15)(1-p) + (p/15)^2 = (1-p)^2 + 2p(1-p)/15 + p^2/225.
Simplify: = 1 - 2p + p^2 + (2p/15 - 2p^2/15) + p^2/225 = 1 - 2p + p^2 + 2p/15 - 2p^2/15 + p^2/225 = 1 - (2p - 2p/15) + p^2<em>(1 - 2/15 + 1/225) = 1 - (30p/15 - 2p/15) + p^2</em>( (225/225) - (30/225) + (1/225) ) = 1 - (28p/15) + p^2*(196/225) = 1 - (28/15)p + (196/225)p^2.
So fidelity F = 1 - (28/15)p + (196/225)p^2.</p>
<p>But wait: Is that the physical state fidelity? That is the fidelity between the ideal state and the noisy state. But careful: The fidelity is defined as F = &lt;Ïˆ_ideal| Ï |Ïˆ_ideal&gt;. And we computed that as the sum of probabilities that the error pattern results in a state that is not orthogonal to |Ïˆ_ideal&gt;. And we found that if the error is either no error, or only the error that is ZâŠ—Z on the respective pairs, then the state is exactly |Ïˆ_ideal&gt; (since ZâŠ—Z on a Bell pair acts as identity on the Bell state? Actually, check: For the Bell state on qubits 1,2, ZâŠ—Z|Bell&gt; =? (|00&gt;+|11&gt;)/âˆš2, because ZâŠ—Z|00&gt; = |00&gt;, ZâŠ—Z|11&gt; = |11&gt;. So yes, it is invariant. Similarly, on qubits 0,3, ZâŠ—Z is invariant. So indeed, those errors do not change the state. So the fidelity is exactly the probability that the errors are either no error or exactly these specific errors. And that probability is: 
From first CNOT: probability of no error: (1-p) + probability of error that is ZâŠ—Z: that probability is p/15. So total from first CNOT: (1-p) + p/15 = 1 - p + p/15 = 1 - (14/15)p.
From second CNOT: similarly, (1-p) + p/15 = 1 - (14/15)p.
And since they are independent, the overall probability that the final state is exactly |Ïˆ_ideal&gt; is (1 - (14/15)p)^2 = 1 - (28/15)p + (196/225)p^2. That matches our fidelity. So indeed, the fidelity is exactly that.</p>
<p>But wait: Could there be other errors that leave the state unchanged? What about errors that are products of stabilizers? The stabilizers are XXXX and ZZZZ. But our errors are on specific pairs. For example, an error on qubits 1,2 that is XâŠ—X? That would give: XâŠ—X on Bell state? Actually, XâŠ—X on Bell state: (|00&gt;+|11&gt;)/âˆš2 becomes (|11&gt;+|00&gt;)/âˆš2, so that is invariant. But wait: Check: For qubits 1,2, if we apply XâŠ—X, then on |00&gt; it becomes |11&gt;, and on |11&gt; it becomes |00&gt;. So indeed, XâŠ—X also leaves the Bell state invariant? But then why did we get that <Bell|XâŠ—X|Bell> =? Let&rsquo;s compute: For Bell state on two qubits: |Î¦&gt; = (|00&gt;+|11&gt;)/âˆš2. Then XâŠ—X|Î¦&gt; = (XâŠ—X|00&gt; + XâŠ—X|11&gt;)/âˆš2 = (|11&gt;+|00&gt;)/âˆš2 = |Î¦&gt;. So actually, XâŠ—X also acts as identity on the Bell state. But then why did our computation earlier give that for an operator on qubits 1,2, we computed &lt;Ïˆ|E|Ïˆ&gt; = 1/2(&lt;00|E|00&gt;+&lt;11|E|11&gt;). For E = XâŠ—X, that gives 1/2(0+0)=0. That is a discrepancy. Let&rsquo;s recompute carefully: 
We want &lt;Ïˆ|E|Ïˆ&gt; for E acting on qubits 1 and 2. 
|Ïˆ&gt; = (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;)/2.
Consider E = XâŠ—X on qubits 1 and 2. That means: E = I_0 âŠ— (X on qubit1) âŠ— (X on qubit2) âŠ— I_3.
Then E|Ïˆ&gt; = 1/2 ( E|0000&gt; + E|1001&gt; + E|0110&gt; + E|1111&gt; ).
Now, |0000&gt;: qubits1,2 are |00&gt;. XâŠ—X|00&gt; = |11&gt;. So E|0000&gt; = |0,1,1,0&gt; = |0110&gt;.
|1001&gt;: qubits1,2: |00&gt; -&gt; becomes |1,1,1,1&gt;? Actually, careful: |1001&gt;: qubit0=1, qubit1=0, qubit2=0, qubit3=1. Under X on qubit1 and X on qubit2, we get: qubit1:0-&gt;1, qubit2:0-&gt;1, so state becomes: |1,1,1,1&gt; = |1111&gt;.
|0110&gt;: qubits1,2: |11&gt; -&gt; XâŠ—X|11&gt; = |00&gt;. So becomes |0,0,0,0&gt; = |0000&gt;.
|1111&gt;: qubits1,2: |11&gt; -&gt; becomes |1,0,0,1&gt; = |1001&gt;.
So E|Ïˆ&gt; = 1/2 (|0110&gt; + |1111&gt; + |0000&gt; + |1001&gt;) = |Ïˆ&gt;. So indeed, &lt;Ïˆ|E|Ïˆ&gt; = 1. But then our computation earlier gave: &lt;Ïˆ|E|Ïˆ&gt; = 1/2(&lt;00|E|00&gt;+&lt;11|E|11&gt;) = 1/2(0+0)=0. That suggests that our method of computing by only diagonal elements is not correct because we assumed that cross terms between different basis states vanish? But wait, why did we assume that? We computed: 
&lt;Ïˆ|E|Ïˆ&gt; = 1/4 [ &lt;0000|E|0000&gt; + &lt;1001|E|1001&gt; + &lt;0110|E|0110&gt; + &lt;1111|E|1111&gt; ] because we said cross terms like &lt;0000|E|1001&gt; are zero. But are they zero? Check: &lt;0000|E|1001&gt;. |0000&gt; and |1001&gt; differ in qubit0. But E acts only on qubits 1 and 2. So &lt;0000|E|1001&gt; = &lt;0|0&gt;? Actually, careful: 
&lt;0000|E|1001&gt; = &lt;0|1&gt; on qubit0? Actually, write: |0000&gt; = |0&gt;<em>0 |00&gt;</em>{12} |0&gt;<em>3.
|1001&gt; = |1&gt;_0 |00&gt;</em>{12} |1&gt;_3.
Then &lt;0000|E|1001&gt; = &lt;0|1&gt; * &lt;00|E|00&gt; * &lt;0|1&gt; = 0. So indeed, cross terms between states with different qubit0 and qubit3 are zero. But what about &lt;0000|E|0110&gt;? 
|0000&gt; and |0110&gt;: qubit0: 0 vs 0? Actually, |0000&gt;: qubit0=0, qubit3=0; |0110&gt;: qubit0=0, qubit3=0. So they have the same qubit0 and qubit3? Actually, |0000&gt; and |0110&gt; both have qubit0=0 and qubit3=0. So then &lt;0000|E|0110&gt; is not necessarily zero. Because: 
&lt;0000|E|0110&gt; = &lt;0|0&gt; * &lt;00|E|11&gt; * &lt;0|0&gt; = &lt;00|E|11&gt;. And for E = XâŠ—X, &lt;00|XâŠ—X|11&gt; = &lt;0|X|1&gt;&lt;0|X|1&gt; = (1)*(1)=1. So we missed cross terms between states that have the same qubit0 and qubit3 but different qubits 1 and 2. So our earlier computation that gave only diagonal terms was incorrect because we assumed that the only nonzero terms are when the state indices are the same. But actually, if qubit0 and qubit3 are the same, then states like |0000&gt; and |0110&gt; are both in the same &ldquo;sector&rdquo; (qubit0=0, qubit3=0). So we need to group by the values of qubit0 and qubit3. Let&rsquo;s do it properly:</p>
<p>We want &lt;Ïˆ|E|Ïˆ&gt; for E acting on qubits 1 and 2.
Write |Ïˆ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
Group by qubits 0 and 3:
Group 1: qubit0=0, qubit3=0: states: |0000&gt; and |0110&gt;.
Group 2: qubit0=1, qubit3=1: states: |1001&gt; and |1111&gt;.
And groups with qubit0=0, qubit3=1 and qubit0=1, qubit3=0 do not appear.
So then &lt;Ïˆ|E|Ïˆ&gt; = 1/4 [ (from group1: &lt;0000|E|0000&gt; + &lt;0000|E|0110&gt; + &lt;0110|E|0000&gt; + &lt;0110|E|0110&gt; ) + (group2: similar) ].
So for E = XâŠ—X, we computed:
&lt;0000|E|0000&gt; = &lt;00|XâŠ—X|00&gt; = 0.
&lt;0000|E|0110&gt; = &lt;00|XâŠ—X|11&gt; = 1.
&lt;0110|E|0000&gt; = &lt;11|XâŠ—X|00&gt; = 1.
&lt;0110|E|0110&gt; = &lt;11|XâŠ—X|11&gt; = 0.
So group1 contributes 0+1+1+0 = 2.
Group2: 
&lt;1001|E|1001&gt; = &lt;00|XâŠ—X|00&gt; = 0.
&lt;1001|E|1111&gt; = &lt;00|XâŠ—X|11&gt; = 1.
&lt;1111|E|1001&gt; = &lt;11|XâŠ—X|00&gt; = 1.
&lt;1111|E|1111&gt; = &lt;11|XâŠ—X|11&gt; = 0.
So group2 contributes 2.
Total = 1/4*(2+2)=1. So indeed, &lt;Ïˆ|E|Ïˆ&gt; = 1 for E = XâŠ—X.
So we need to recompute the overlaps for Paulis on qubits 1 and 2 carefully. And similarly for qubits 0 and 3.</p>
<p>Given that |Ïˆ&gt; is a product of two Bell states: |Ïˆ&gt; = |Î¦^+&gt;<em>{03} âŠ— |Î¦^+&gt;</em>{12}, where |Î¦^+&gt; = (|00&gt;+|11&gt;)/âˆš2.
Then for an operator E that acts on qubits 1 and 2 only, we have:
&lt;Ïˆ|E|Ïˆ&gt; = &lt;Î¦^+|<em>{12} | E |Î¦^+|</em>{12}&gt; because the part on 0,3 gives 1.
And we know that for a Bell state, the expectation value of a two-qubit Pauli operator is either 0 or Â±1. Specifically, for |Î¦^+&gt; = (|00&gt;+|11&gt;)/âˆš2, 
What are &lt;Î¦^+|PâŠ—Q|Î¦^+&gt;? 
We can compute: 
&lt;Î¦^+|PâŠ—Q|Î¦^+&gt; = 1/2 ( &lt;00|PâŠ—Q|00&gt; + &lt;00|PâŠ—Q|11&gt; + &lt;11|PâŠ—Q|00&gt; + &lt;11|PâŠ—Q|11&gt; ).
Now, if P and Q are Paulis. They are either I, X, Y, Z.
Let&rsquo;s compute systematically for all combinations? But maybe we only need the squared magnitude. And we are summing over all non-identity Paulis on two qubits. So we need to compute for each Pauli operator on two qubits (15 of them), the value of |&lt;Î¦^+|E|Î¦^+&gt;|^2.
Since |Î¦^+&gt; is a Bell state, it is known that the only Paulis that leave it invariant (up to a phase) are those that are in the stabilizer of the Bell state. The Bell state |Î¦^+&gt; is stabilized by XâŠ—X and ZâŠ—Z? Actually, check: XâŠ—X|Î¦^+&gt; = |Î¦^+&gt;, ZâŠ—Z|Î¦^+&gt; = |Î¦^+&gt;. Also, -YâŠ—Y|Î¦^+&gt; =? Actually, YâŠ—Y|Î¦^+&gt; = ? Let&rsquo;s compute: Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;. So YâŠ—Y|00&gt; = (i)(i)|11&gt; = -|11&gt;, and YâŠ—Y|11&gt; = (-i)(-i)|00&gt; = -|00&gt;. So YâŠ—Y|Î¦^+&gt; = -|Î¦^+&gt;. So actually, YâŠ—Y gives a phase of -1. But then |&lt;Î¦^+|YâŠ—Y|Î¦^+&gt;|^2 = 1. So also YâŠ—Y has magnitude 1.
What about other Paulis? For example, XâŠ—I: 
&lt;Î¦^+|XâŠ—I|Î¦^+&gt; = 1/2 ( &lt;00|XâŠ—I|00&gt; + &hellip; ) = 0 because it will flip one qubit and then orthogonal.
So generally, for a two-qubit Pauli operator on a Bell state, the expectation value is either 0 or Â±1. And it is Â±1 if and only if the Pauli is of the form AâŠ—A (up to a sign?) Actually, check: What about IâŠ—X? That gives 0. So indeed, the Paulis that have nonzero expectation on |Î¦^+&gt; are those that are symmetric: XâŠ—X, YâŠ—Y, ZâŠ—Z, and also IâŠ—I but that&rsquo;s identity. Also, what about -XâŠ—X? That is not in the set because we only take the Paulis themselves (X, Y, Z) and not their negatives. So the set of two-qubit Paulis on qubits 1 and 2 that are non-identity and have expectation value Â±1 are: XâŠ—X, YâŠ—Y, ZâŠ—Z. But wait, check: What about XâŠ—Y? 
XâŠ—Y|00&gt; = |1&gt; âŠ— (i|1&gt;) = i|11&gt;, 
XâŠ—Y|11&gt; = |0&gt; âŠ— (-i|0&gt;) = -i|00&gt;,
So &lt;Î¦^+|XâŠ—Y|Î¦^+&gt; = 1/2 (0 + &lt;00|? Actually, compute properly:
&lt;Î¦^+|XâŠ—Y|Î¦^+&gt; = 1/2 ( &lt;00|XâŠ—Y|00&gt; + &lt;00|XâŠ—Y|11&gt; + &lt;11|XâŠ—Y|00&gt; + &lt;11|XâŠ—Y|11&gt; )
&lt;00|XâŠ—Y|00&gt; = 0.
&lt;00|XâŠ—Y|11&gt; = &lt;0|X|1&gt;&lt;0|Y|1&gt; = (1)<em>( -i ) = -i? But careful: &lt;0|X|1&gt; = 1, &lt;0|Y|1&gt; = -i? Actually, Y|1&gt; = -i|0&gt;, so &lt;0|Y|1&gt; = -i. So that term is -i.
&lt;11|XâŠ—Y|00&gt; = &lt;1|X|0&gt;&lt;1|Y|0&gt; = (1)</em>(i) = i? Because Y|0&gt;= i|1&gt;, so &lt;1|Y|0&gt;= i.
&lt;11|XâŠ—Y|11&gt; = 0.
So total = 1/2 (0 + (-i) + (i) + 0) = 0.
So indeed, only symmetric ones (XâŠ—X, YâŠ—Y, ZâŠ—Z) give nonzero. But wait: What about IâŠ—Z? That is not symmetric. So yes.
So for errors on qubits 1 and 2, the Paulis that do not change the state (i.e., give expectation 1 in magnitude) are: E such that E = XâŠ—X, YâŠ—Y, ZâŠ—Z. But are all these actually leaving the Bell state invariant? 
We already computed: XâŠ—X gives +1.
ZâŠ—Z gives +1.
YâŠ—Y gives -1, so |&lt;Î¦^+|YâŠ—Y|Î¦^+&gt;|^2 = 1.
So there are 3 Paulis on qubits 1 and 2 that yield |&lt;Ïˆ|E|Ïˆ&gt;|^2 = 1.
But wait: Check: Could there be others? What about -IâŠ—? No.
So then, for errors on qubits 1 and 2, the sum over non-identity Paulis: âˆ‘_{E on {1,2} non-identity} |&lt;Ïˆ|E|Ïˆ&gt;|^2 = number of Paulis that are of the form AâŠ—A with A in {X,Y,Z}? That gives 3. But wait: What about Paulis like -XâŠ—X? Those are not in the set because the set is defined as the 15 Paulis: {I,X,Y,Z}âŠ—{I,X,Y,Z} minus IâŠ—I. So indeed, there are exactly 3: XâŠ—X, YâŠ—Y, ZâŠ—Z.
But wait: Check: Is YâŠ—Y actually in that set? Yes, Y is one of the Paulis.
So then, for the first error channel, the contribution is: (p/15)(1-p) * (sum over E: |&lt;Ïˆ|E|Ïˆ&gt;|^2) = (p/15)(1-p) * 3 = (3p/15)(1-p) = (p/5)(1-p).</p>
<p>Now, similarly, for errors on qubits 0 and 3, by the same argument, because the state on qubits 0 and 3 is also a Bell state, the Paulis that leave it invariant are those that are symmetric: XâŠ—X, YâŠ—Y, ZâŠ—Z. So sum over F on {0,3} non-identity: âˆ‘_{F} |&lt;Ïˆ|F|Ïˆ&gt;|^2 = 3.
So that contribution is also (p/15)(1-p)*3 = (p/5)(1-p).</p>
<p>Now, what about errors from both steps? That is F E, where E acts on {1,2} and F acts on {0,3}. Then &lt;Ïˆ|F E|Ïˆ&gt; = &lt;Î¦^+|<em>{03}|F|Î¦^+|</em>{03}&gt; * &lt;Î¦^+|<em>{12}|E|Î¦^+|</em>{12}&gt;. So |&lt;Ïˆ|F E|Ïˆ&gt;|^2 = |&lt;Î¦^+|<em>{03}|F|Î¦^+|</em>{03}&gt;|^2 * |&lt;Î¦^+|<em>{12}|E|Î¦^+|</em>{12}&gt;|^2.
So if both F and E are among the ones that give magnitude 1, then the product is 1. And if either is not, then it&rsquo;s 0. So the number of pairs (E, F) such that both are in {XâŠ—X, YâŠ—Y, ZâŠ—Z} is 3*3 = 9. But wait: Are there any cross terms where, say, F gives a phase and E gives a phase such that the product phase is 1? But we are taking the square modulus, so phases don&rsquo;t matter. So indeed, if both are in that set, then |&lt;Ïˆ|F E|Ïˆ&gt;|^2 = 1. So the sum over E (non-identity on {1,2}) and F (non-identity on {0,3}) of |&lt;Ïˆ|F E|Ïˆ&gt;|^2 is 9.
So then the contribution from both errors is: (p/15)^2 * 9 = 9p^2/225 = p^2/25.</p>
<p>And then the no-error term gives: (1-p)^2.</p>
<p>Also, there are terms from only first error and only second error we already computed: each gives 3<em>(p/15)(1-p) = (p/5)(1-p). So total from one error only: 2</em>(p/5)(1-p) = (2p/5)(1-p).</p>
<p>So then the fidelity F = (1-p)^2 + (2p/5)(1-p) + (p^2/25).
Simplify: (1-p)^2 = 1 - 2p + p^2.
So F = 1 - 2p + p^2 + (2p/5 - 2p^2/5) + p^2/25 = 1 - 2p + p^2 + 0.4p - 0.4p^2 + 0.04p^2 = 1 - (2p - 0.4p) + p^2<em>(1 - 0.4 + 0.04) = 1 - 1.6p + p^2</em>(0.64) = 1 - (8/5)p + (16/25)p^2? Because 1.6 = 8/5, and 0.64 = 16/25.
So F = 1 - (8/5)p + (16/25)p^2.
Or in fraction: = 1 - (8/5)p + (16/25)p^2 = (25/25) - (40/25)p + (16/25)p^2 = (25 - 40p + 16p^2)/25.</p>
<p>But wait, is that the physical state fidelity? That is the probability that the final state is exactly |Ïˆ_ideal&gt;. But careful: Could there be errors that are not exactly these Paulis but still yield a state that has overlap with |Ïˆ_ideal&gt;? Actually, fidelity is &lt;Ïˆ_ideal|Ï|Ïˆ_ideal&gt;. And Ï is a mixture of states that are of the form (some Pauli error applied to |Ïˆ_ideal&gt;). And if that Pauli error is not identity, then the state is orthogonal to |Ïˆ_ideal&gt;? Not necessarily: If the Pauli error commutes with the projector onto |Ïˆ_ideal&gt;, then it might have overlap. And we computed that overlap as &lt;Ïˆ_ideal|P|Ïˆ_ideal&gt;. And that is either 0 or 1 in magnitude? Actually, wait: For a Pauli operator P, since |Ïˆ_ideal&gt; is a stabilizer state of the code? Actually, |Ïˆ_ideal&gt; is not a code state? It is a logical state. But it is a specific state in the code space. And the code space is stabilized by XXXX and ZZZZ. So any Pauli operator that is a stabilizer will act as identity on the code space. But careful: The stabilizers are XXXX and ZZZZ. But our errors are on specific pairs. For example, an error on qubits 1,2 that is XâŠ—X. That is not necessarily a stabilizer because the stabilizer is XXXX, which is X on all qubits. But XâŠ—X on qubits 1,2 is a part of that? Actually, if we multiply XXXX by something? For instance, XXXX = (XâŠ—X) âŠ— (XâŠ—X). So indeed, XâŠ—X on qubits 1,2 is not exactly the stabilizer, but it is like half of it. But wait, check: The stabilizer is XXXX. That means that for any state in the code space, XXXX|Ïˆ&gt; = |Ïˆ&gt;. But that does not imply that XâŠ—X on qubits 1,2 acts as identity on the code space. Because if we take |Ïˆ&gt; = |0000&gt;+|1111&gt; (which is in the code space), then XâŠ—X on qubits 1,2 gives: on |0000&gt;, becomes |0110&gt; which is not necessarily the same state. So indeed, the only errors that leave |Ïˆ_ideal&gt; invariant are those that act as identity on |Ïˆ_ideal&gt;. And we determined that by using the fact that |Ïˆ_ideal&gt; is a product of two Bell states. And for a Bell state, the operators that leave it invariant are exactly those that are of the form AâŠ—A (with A being Pauli) because then AâŠ—A(|00&gt;+|11&gt;) = (A|0&gt;âŠ—A|0&gt; + A|1&gt;âŠ—A|1&gt;). For this to be proportional to |00&gt;+|11&gt;, we need A|0&gt; and A|1&gt; to be such that A|0&gt; is either |0&gt; or |1&gt;? Actually, let&rsquo;s derive: For a Bell state |Î¦^+&gt; = (|00&gt;+|11&gt;)/âˆš2, consider an operator UâŠ—V. We want UâŠ—V|Î¦^+&gt; = c|Î¦^+&gt;. This implies that U|0&gt;âŠ—V|0&gt; + U|1&gt;âŠ—V|1&gt; is proportional to |00&gt;+|11&gt;. This forces that U|0&gt; and V|0&gt; are related, and U|1&gt; and V|1&gt; are related. In fact, it is known that the only Pauli operators that preserve the Bell state are those with U=V up to a sign? Actually, check: If U=X and V=X, then it works. If U=X and V=Y, then X|0&gt;=|1&gt;, Y|0&gt;=-i|1&gt; so that gives -i|11&gt;, and X|1&gt;=|0&gt;, Y|1&gt;=i|0&gt; gives i|00&gt;, so total = i(|00&gt;-|11&gt;), which is not proportional to |00&gt;+|11&gt; generally. So indeed, the condition is that U and V must be the same Pauli (up to a global phase) for the Bell state to be an eigenvector. And then the eigenvalue is? For U=V=X, eigenvalue = 1. For U=V=Y, eigenvalue = -1. For U=V=Z, eigenvalue = 1. So indeed, the Paulis on two qubits that leave the Bell state invariant are exactly XâŠ—X, YâŠ—Y, ZâŠ—Z. So that is correct.</p>
<p>Therefore, the fidelity is the probability that the errors are such that on each CNOT, the error is either no error or one of these three Paulis that act as identity on the Bell state on that pair. But careful: The errors are applied after each CNOT. But we argued that these errors propagate to become Pauli errors on the final state. And that final state is |Ïˆ_ideal&gt; if and only if the combined error is one that acts as identity on |Ïˆ_ideal&gt;. And since |Ïˆ_ideal&gt; is a product of two Bell states, the condition is that on the pair (0,3), the error must be either I or one of {XâŠ—X, YâŠ—Y, ZâŠ—Z} and on the pair (1,2), the error must be either I or one of {XâŠ—X, YâŠ—Y, ZâŠ—Z}. But wait: Is that independent? Yes, because they act on different pairs. So the probability that the final state is exactly |Ïˆ_ideal&gt; is: 
Probability from first CNOT that the error is in {I, XâŠ—X, YâŠ—Y, ZâŠ—Z} = (1-p) + 3*(p/15) = 1-p + p/5 = 1 - (4/5)p.
Probability from second CNOT similarly: 1 - (4/5)p.
And since they are independent, overall probability = (1 - (4/5)p)^2 = 1 - (8/5)p + (16/25)p^2.
So that is the fidelity. So indeed, F = 1 - (8/5)p + (16/25)p^2.</p>
<p>But wait: Could there be errors that are not exactly these but still give some overlap? For example, if an error gives a phase of -1, then the state is -|Ïˆ_ideal&gt;, so the fidelity would still be 1 because |&lt;-Ïˆ_ideal|Ïˆ_ideal&gt;|^2 = 1. So actually, we want the fidelity, which is &lt;Ïˆ_ideal|Ï|Ïˆ_ideal&gt;. And if the state is -|Ïˆ_ideal&gt;, then that term contributes 1. So we should include errors that give a phase of -1 as well. And we already did: For the Bell state, YâŠ—Y gives -1, so that is included. So that&rsquo;s correct.</p>
<p>So then the fidelity is exactly the probability that the error on each CNOT is such that the resulting Pauli on that pair is in the set {I, XâŠ—X, YâŠ—Y, ZâŠ—Z}. And that probability is: For a single CNOT error channel, the probability of no error is (1-p) and the probability of each specific Pauli error is p/15. So the total probability for that CNOT to yield an error that is &ldquo;good&rdquo; (i.e., doesn&rsquo;t change the state) is: (1-p) + 3*(p/15) = 1-p + p/5 = 1 - (4/5)p.
And since the two CNOTs are independent, the overall probability that the final state is |Ïˆ_ideal&gt; (up to a phase) is (1 - (4/5)p)^2.
So the fidelity F = (1 - 4p/5)^2 = 1 - 8p/5 + 16p^2/25.</p>
<p>Thus the physical state fidelity as a function of p is: 
F = 1 - (8/5)p + (16/25)p^2.</p>
<p>That is the answer.</p>
<p>But wait: The problem asks: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; 
So answer: F = 1 - (8/5)p + (16/25)p^2.</p>
<p>I&rsquo;ll double-check: 
For p=0, F=1.
For small p, F â‰ˆ 1 - 1.6p.
That seems plausible.</p>
<p>So final answer for subproblem 1.</p>
<p>I&rsquo;ll now output in Markdown format.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-understand-the-circuit-and-the-ideal-state">Step 1. Understand the Circuit and the Ideal State</h3>
<p>The goal is to prepare the logical GHZ state  </p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the <span class="arithmatex">\([[4,2,2]]\)</span> code, using the circuit:  </p>
<div class="arithmatex">\[
(\text{CNOT}_{03}) (H_0) (\text{CNOT}_{21}) (H_2).
\]</div>
<p>In quantum circuit order (right-to-left), the operations are:</p>
<ol>
<li>Apply <span class="arithmatex">\(H\)</span> on qubit 2.</li>
<li>Apply <span class="arithmatex">\(\text{CNOT}_{21}\)</span> (control qubit 2, target qubit 1).</li>
<li>Apply <span class="arithmatex">\(H\)</span> on qubit 0.</li>
<li>Apply <span class="arithmatex">\(\text{CNOT}_{03}\)</span> (control qubit 0, target qubit 3).</li>
</ol>
<p>Starting from the initial state <span class="arithmatex">\(|0000\rangle\)</span>, the ideal final state is:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right).
\]</div>
<p>This state can be rewritten as a product of two Bell states:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}, \quad \text{where} \quad |\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}.
\]</div>
<hr />
<h3 id="step-2-model-the-errors">Step 2. Model the Errors</h3>
<p>Each <span class="arithmatex">\(\text{CNOT}\)</span> gate is followed by a two-qubit depolarizing error channel on its target qubits. The error channel acts as:</p>
<div class="arithmatex">\[
\rho \mapsto (1 - p) \rho + \frac{p}{15} \sum_{E \neq I} E \rho E^\dagger,
\]</div>
<p>where <span class="arithmatex">\(E\)</span> is a non-identity two-qubit Pauli operator on the qubits involved, and <span class="arithmatex">\(p\)</span> is the error probability per gate.</p>
<p>There are two <span class="arithmatex">\(\text{CNOT}\)</span> gates:</p>
<ul>
<li><span class="arithmatex">\(\text{CNOT}_{21}\)</span>: error acts on qubits 1 and 2.</li>
<li><span class="arithmatex">\(\text{CNOT}_{03}\)</span>: error acts on qubits 0 and 3.</li>
</ul>
<p>Since the Hadamard gates are perfect, the only errors come from these two channels.</p>
<hr />
<h3 id="step-3-propagate-errors-to-the-final-state">Step 3. Propagate Errors to the Final State</h3>
<p>An error <span class="arithmatex">\(E\)</span> on qubits 1 and 2 (after <span class="arithmatex">\(\text{CNOT}_{21}\)</span>) commutes with subsequent gates <span class="arithmatex">\(H_0\)</span> and <span class="arithmatex">\(\text{CNOT}_{03}\)</span>, so the final state becomes <span class="arithmatex">\(E |\psi_{\text{ideal}}\rangle\)</span>. Similarly, an error <span class="arithmatex">\(F\)</span> on qubits 0 and 3 (after <span class="arithmatex">\(\text{CNOT}_{03}\)</span>) gives <span class="arithmatex">\(F |\psi_{\text{ideal}}\rangle\)</span>. If both errors occur, the final state is <span class="arithmatex">\(FE |\psi_{\text{ideal}}\rangle\)</span>.</p>
<p>Thus, the final density matrix is a mixture:</p>
<div class="arithmatex">\[
\rho = (1 - p)^2 |\psi_{\text{ideal}}\rangle\langle\psi_{\text{ideal}}| 
+ \frac{p}{15}(1 - p) \sum_{E} |E \psi_{\text{ideal}}\rangle\langle E \psi_{\text{ideal}}|
+ \frac{p}{15}(1 - p) \sum_{F} |F \psi_{\text{ideal}}\rangle\langle F \psi_{\text{ideal}}|
+ \left( \frac{p}{15} \right)^2 \sum_{E,F} |FE \psi_{\text{ideal}}\rangle\langle FE \psi_{\text{ideal}}|,
\]</div>
<p>where <span class="arithmatex">\(E\)</span> and <span class="arithmatex">\(F\)</span> range over non-identity two-qubit Pauli operators on qubits <span class="arithmatex">\(\{1,2\}\)</span> and <span class="arithmatex">\(\{0,3\}\)</span>, respectively.</p>
<p>The fidelity is:</p>
<div class="arithmatex">\[
F = \langle \psi_{\text{ideal}} | \rho | \psi_{\text{ideal}} \rangle.
\]</div>
<p>This is the total probability that the final state is <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> (up to a global phase).</p>
<hr />
<h3 id="step-4-determine-which-errors-preserve-the-state">Step 4. Determine Which Errors Preserve the State</h3>
<p>Since <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}\)</span>, an error preserves the state if it acts as identity (up to a phase) on each Bell pair.</p>
<p>For a Bell state <span class="arithmatex">\(|\Phi^+\rangle = (|00\rangle + |11\rangle)/\sqrt{2}\)</span>, the two-qubit Pauli operators that leave it invariant (up to a phase) are:</p>
<div class="arithmatex">\[
X \otimes X, \quad Y \otimes Y, \quad Z \otimes Z.
\]</div>
<p>All other non-identity Pauli operators yield <span class="arithmatex">\(\langle \Phi^+ | P | \Phi^+ \rangle = 0\)</span>.</p>
<p>Therefore:</p>
<ul>
<li>On qubits 1 and 2, the â€œgoodâ€ errors are <span class="arithmatex">\(I\)</span>, <span class="arithmatex">\(X \otimes X\)</span>, <span class="arithmatex">\(Y \otimes Y\)</span>, and <span class="arithmatex">\(Z \otimes Z\)</span>.</li>
<li>On qubits 0 and 3, the â€œgoodâ€ errors are the same set.</li>
</ul>
<hr />
<h3 id="step-5-compute-the-fidelity">Step 5. Compute the Fidelity</h3>
<p>The probability that a single <span class="arithmatex">\(\text{CNOT}\)</span> error channel yields a â€œgoodâ€ error is:</p>
<div class="arithmatex">\[
P_{\text{good}} = (1 - p) + 3 \cdot \frac{p}{15} = 1 - p + \frac{p}{5} = 1 - \frac{4}{5}p.
\]</div>
<p>Since the two error channels are independent, the total probability that the final state is <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> is:</p>
<div class="arithmatex">\[
F = \left(1 - \frac{4}{5}p \right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2.
\]</div>
<hr />
<h3 id="final-answer">Final Answer:</h3>
<div class="arithmatex">\[
\boxed{1 - \frac{8}{5}p + \frac{16}{25}p^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given that the fidelity is F = 1 - (8/5)p + (16/25)p^2.
 We can write this as a SymPy expression.
 Note: We are to return a SymPy expression in terms of p.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p><strong>Final Answer:</strong><br />
The physical state fidelity of the final 4-qubit state is given by the expression:  </p>
<div class="arithmatex">\[
F = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="mi">16</span><span class="o">/</span><span class="mi">25</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.637957
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>