<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo;</p>
<p>Interpretation: We have a circuit: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). But careful: The equation is written in matrix multiplication order, while quantum operations occur in reverse order. So the actual circuit order from initial state to final state is: 
Start with initial state? Typically, we assume initial state is |0000&gt;? But problem doesn&rsquo;t explicitly say initial state? But we want to prepare a logical two-qubit GHZ state: (|00&gt;<em>AB + |11&gt;_AB)/√2. So the circuit is supposed to produce that state. So initial state is presumably |0000&gt;? But wait: The circuit: (CNOT</em>{03}) (H_0) (CNOT_{21}) (H_2). In matrix multiplication order: That means if we write U = CNOT_{03} * H_0 * CNOT_{21} * H_2, then the actual circuit applies H_2 first, then CNOT_{21}, then H_0, then CNOT_{03}. So order: 
Step 1: Apply H on qubit 2.
Step 2: Apply CNOT with control qubit 2 and target qubit 1.
Step 3: Apply H on qubit 0.
Step 4: Apply CNOT with control qubit 0 and target qubit 3.
So initial state: |0000&gt;? But then check: 
After H_2: qubit2 becomes (|0&gt;+|1&gt;)/√2, so state: |00&gt; (on qubits 0,1) and (|0&gt;+|1&gt;)/√2 on qubit2, and qubit3: |0&gt; so state: |0000&gt; + |0010&gt;? Actually careful: Qubits: indices: 0,1,2,3. Initially: |0&gt;|0&gt;|0&gt;|0&gt;.
After H_2: becomes: (1/√2)(|0&gt;|0&gt;|0&gt;|0&gt; + |0&gt;|0&gt;|1&gt;|0&gt;) = (|0000&gt; + |0010&gt;)/√2.
Then CNOT_{21}: control qubit 2, target qubit 1. So if qubit2 is 1, flip qubit1.
So state becomes: (1/√2)(|0000&gt; + |0110&gt;) because: For first term: qubit2=0 so no flip: remains |0000&gt;. For second: qubit2=1 so flip qubit1: from |0&gt; to |1&gt;: so becomes |0,1,1,0&gt; = |0110&gt;.
Then H_0: Apply Hadamard on qubit0. So state: (1/√2)( H|0&gt;|0&gt;|0&gt;|0&gt; + H|0&gt;|1&gt;|1&gt;|0&gt; ) = (1/√2)( (|0&gt;+|1&gt;)/√2 |0&gt;|0&gt;|0&gt; + (|0&gt;+|1&gt;)/√2 |1&gt;|1&gt;|0&gt; ) = 1/√2 * 1/√2 ( |0000&gt; + |1000&gt; + |0110&gt; + |1110&gt; ) = 1/2 ( |0000&gt; + |1000&gt; + |0110&gt; + |1110&gt; ).
Then CNOT_{03}: control qubit0, target qubit3. So if qubit0 is 1, flip qubit3.
So state: 
For |0000&gt;: qubit0=0 so remains: |0000&gt;
For |1000&gt;: qubit0=1 so flip qubit3: becomes |1001&gt;
For |0110&gt;: qubit0=0 so remains: |0110&gt;
For |1110&gt;: qubit0=1 so flip qubit3: becomes |1111&gt;
So final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
That state is: (|00&gt;_A? But wait: The logical qubits: A and B. Their logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI.
We want logical GHZ: (|00&gt;_AB + |11&gt;_AB)/√2. Check: What is logical |00&gt;? The code [[4,2,2]] encodes two qubits. The stabilizers: XXXX and ZZZZ. The logical states? Possibly: 
|00&gt;_L = (|0000&gt; + |1111&gt;)/√2? But then |11&gt;_L = (|0110&gt; + |1001&gt;)/√2? Actually check: 
Given logical operators: 
X_A = XIXI. So acting on state |0000&gt;? But careful: The code space is 4-dimensional? Actually [[4,2,2]] means: n=4, k=2, d=2. So code space dimension 2^2=4. The stabilizers: XXXX and ZZZZ. They commute? Actually XXXX and ZZZZ commute? Check: XXXX * ZZZZ = (XZ)(XZ)(XZ)(XZ) = (-iY)(-iY)(-iY)(-iY) =? Actually easier: They commute because each pair: X and Z anticommute, but product over all qubits: XXXX and ZZZZ: Actually, X_i and Z_j commute if i≠j, but here they are on same qubits? Actually, on each qubit, X and Z anticommute. So product: (X1 X2 X3 X4) and (Z1 Z2 Z3 Z4): For each qubit, X_i Z_i = -Z_i X_i. So overall, the commutator: XXXX ZZZZ = (X1Z1)(X2Z2)(X3Z3)(X4Z4) = (-Z1X1)(-Z2X2)(-Z3X3)(-Z4X4) = (-1)^4 (Z1X1 Z2X2 Z3X3 Z4X4) = (Z1Z2Z3Z4)(X1X2X3X4) = ZZZZ XXXX. So they commute. So stabilizers are valid.
The code space: states that are +1 eigenstates of both XXXX and ZZZZ.
Check our final state: 
|ψ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
Compute XXXX|ψ&gt; =? 
XXXX|0000&gt; = |1111&gt;
XXXX|1001&gt; = |0110&gt;? Because flip all: 1001 -&gt; 0110.
XXXX|0110&gt; = |1001&gt;
XXXX|1111&gt; = |0000&gt;
So XXXX|ψ&gt; = 1/2 (|1111&gt; + |0110&gt; + |1001&gt; + |0000&gt;) = |ψ&gt;. So it&rsquo;s +1.
ZZZZ|ψ&gt; =? 
ZZZZ|0000&gt; = |0000&gt; because all phases: Z on |0&gt; gives +1.
ZZZZ|1001&gt; =? Z on qubit0: |1&gt; gives -1, qubit1: |0&gt; gives +1, qubit2: |0&gt; gives +1, qubit3: |1&gt; gives -1, so product = (-1)<em>(-1)=+1? Actually careful: ZZZZ means Z⊗Z⊗Z⊗Z. So on |1001&gt;, eigenvalue: for qubit0: -1, qubit1: +1, qubit2: +1, qubit3: -1, so product = (-1)</em>(+1)<em>(+1)</em>(-1)= +1. So |1001&gt; remains.
ZZZZ|0110&gt;: qubit0:0 -&gt; +1, qubit1:1 -&gt; -1, qubit2:1 -&gt; -1, qubit3:0 -&gt; +1, product = (+1)<em>(-1)</em>(-1)*(+1)= +1.
ZZZZ|1111&gt;: all ones: (-1)^4 = +1.
So indeed, |ψ&gt; is in the code space. And it is a superposition of two basis states? Actually the code space is 4-dimensional. But our state is a specific state. And it is the logical GHZ state? Check: Logical operators: 
X_A = XIXI. Compute X_A on |ψ&gt;:
X_A|0000&gt; = |0100&gt;? But wait: X_A = qubit0: X, qubit1: I, qubit2: X, qubit3: I. So on |0000&gt;, becomes |0? Actually careful: indices: 0,1,2,3. X_A acts on qubit0 and qubit2. So |0000&gt; becomes |1?0? Actually: qubit0: flip: 0-&gt;1, qubit2: flip: 0-&gt;1, so becomes |1,0,1,0&gt; = |1010&gt;. That is not in the superposition? So maybe our state is not an eigenstate of X_A? But we want GHZ: (|00&gt;+|11&gt;)/√2. That state is not a code state? Actually, it is a state on two logical qubits. They are encoded. So we want to check: What are the logical basis states? They are usually defined such that they are eigenvectors of Z_A and Z_B. So we want Z_A and Z_B. 
Z_A = ZZII. So on our state: 
Z_A|ψ&gt; =? 
For |0000&gt;: Z_A gives: qubit0: Z, qubit1: Z, so on |00&gt; gives +1, so remains.
|1001&gt;: qubit0:1 -&gt; -1, qubit1:0 -&gt; +1, so product -1.
|0110&gt;: qubit0:0 -&gt; +1, qubit1:1 -&gt; -1, so product -1.
|1111&gt;: qubit0:1 -&gt; -1, qubit1:1 -&gt; -1, product +1.
So Z_A|ψ&gt; = 1/2 (|0000&gt; - |1001&gt; - |0110&gt; + |1111&gt;). That is not ±|ψ&gt; generally. So |ψ&gt; is not an eigenstate of Z_A. But wait, the GHZ state is (|00&gt;+|11&gt;)/√2. That state is not an eigenstate of Z⊗I? Actually, on two qubits, Z⊗I on (|00&gt;+|11&gt;)/√2 gives (|00&gt; - |11&gt;)/√2, so it&rsquo;s not an eigenstate. So that&rsquo;s fine.
Maybe we check: The logical state (|00&gt;+|11&gt;)/√2 should have the property that if we measure Z_A and Z_B, we get correlated: either both +1 or both -1? Actually, for GHZ, if we measure Z on both, we get either (0,0) or (1,1) with equal probability. So our state: The probability to get Z_A=+1? That happens for |0000&gt; and |1111&gt; so amplitude 1/2 each, so probability 1/2. And Z_A=-1 for |1001&gt; and |0110&gt;, so probability 1/2. And similarly Z_B? Z_B = ZIZI. Compute on our state:
Z_B|0000&gt;: qubit0: Z gives +1, qubit2: Z gives +1, so +1.
|1001&gt;: qubit0: -1, qubit2: 0 -&gt; +1, so -1.
|0110&gt;: qubit0: 0 -&gt; +1, qubit2: 1 -&gt; -1, so -1.
|1111&gt;: qubit0: -1, qubit2: -1, so +1.
So indeed, Z_B gives +1 on |0000&gt; and |1111&gt; and -1 on the others. So indeed, our state is such that Z_A and Z_B are always equal. So it is the GHZ state: (|00&gt;_L + |11&gt;_L)/√2, if we identify |00&gt;_L as the state with Z_A=+1, Z_B=+1, and |11&gt;_L as the state with Z_A=-1, Z_B=-1. But careful: The code space has 4 states. The logical basis can be chosen as: 
|00&gt;_L = (|0000&gt;+|1111&gt;)/√2,
|01&gt;_L = (|0011&gt;+|1100&gt;)/√2? Actually, need to check stabilizers? But anyway, our state is indeed: 
|ψ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;) = 
= 1/√2 [ (|0000&gt;+|1111&gt;)/√2 + (|1001&gt;+|0110&gt;)/√2 ].
And note that (|1001&gt;+|0110&gt;)/√2 is actually the logical |11&gt;? Because then Z_A on that: gives -1 on each, and Z_B gives -1 on each. So yes.
So circuit produces the desired logical GHZ state.</p>
<p>Now, we introduce errors: Each CNOT gate is followed by a two-qubit depolarizing error channel. There are two CNOT gates: CNOT_{21} and CNOT_{03}. So after each CNOT, we apply an error channel on the two qubits involved. The error channel: With probability p, an error occurs. And if an error occurs, it is uniformly chosen among the 15 non-identity two-qubit Paulis. So probability of no error from a CNOT is (1-p). And if error occurs, each specific Pauli error (from the set of 15) has probability p/15.</p>
<p>We want: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of p?&rdquo; 
Interpretation: We want the fidelity between the ideal state (without errors) and the actual state (with errors) after the circuit. But careful: The circuit has gates: H_2, then CNOT_{21} (with error), then H_0, then CNOT_{03} (with error). But wait: The problem statement: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it&rdquo;. So that means: After applying CNOT_{21}, we apply the error channel on qubits 2 and 1. And after applying CNOT_{03}, we apply the error channel on qubits 0 and 3.
Also, note: The Hadamard gates are assumed perfect? Probably yes. So only errors come from CNOT gates.</p>
<p>We want the fidelity F = &lt;ψ_ideal| ρ_actual |ψ_ideal&gt; where ρ_actual is the state after the circuit with errors.</p>
<p>We can compute this by tracing over the error processes. The circuit is: 
Start with |0000&gt;.
Apply H_2: perfect.
Then apply CNOT_{21} followed by error channel on qubits (2,1). 
Then apply H_0: perfect.
Then apply CNOT_{03} followed by error channel on qubits (0,3).</p>
<p>So we want to compute the final density matrix ρ. Since errors are independent on each CNOT, we can compute the effect of each error channel on the state evolution.</p>
<p>Let&rsquo;s denote:
U1 = CNOT_{21}
U2 = CNOT_{03}
And Hadamards: H2 and H0.
So circuit: U = U2 * H0 * U1 * H2. (But careful: Order: Actually, the circuit is: H2, then U1, then H0, then U2. So overall unitary: U = U2 * H0 * U1 * H2.)
Ideal state: |ψ_ideal&gt; = U |0000&gt;.</p>
<p>Now, with errors: After U1, we apply error channel on qubits 2 and 1. That error channel: For each Pauli E from the set of two-qubit Paulis on qubits (2,1) (excluding identity), with probability p/15, we get error E. And with probability 1-p, we get identity.
So after step: state becomes: ρ1 = (1-p) U1 (H2|0000&gt;&lt;0000|H2†) U1† + (p/15) ∑<em>{E in Paulis on (2,1) non-identity} E U1 (H2|0000&gt;&lt;0000|H2†) U1† E†.
But note: E are Pauli operators, so they are unitary and Hermitian. So E† = E.
So ρ1 = (1-p) |φ1&gt;&lt;φ1| + (p/15) ∑</em>{E ≠ I} E |φ1&gt;&lt;φ1| E, where |φ1&gt; = U1 H2 |0000&gt;.
But careful: Actually, the error channel is applied after U1. So the state after U1 is |φ1&gt; = U1 H2 |0000&gt;. Then error channel: with probability 1-p, no error; with probability p, an error occurs, and then the state becomes E|φ1&gt; for some E. But then we average over E? Actually, the depolarizing channel: It is: ρ -&gt; (1-p) ρ + (p/15) ∑_{E ≠ I} E ρ E. So yes.</p>
<p>Then after that, we apply H0 (perfect). So state becomes: ρ2 = H0 ρ1 H0†.
Then apply U2 (CNOT_{03}) perfect? Actually, careful: The circuit: after H0, we apply U2. But then after U2, we apply the error channel on qubits (0,3). So after U2, we get state: |φ2&gt; = U2 H0 |φ1&gt;? Actually, careful: The process: 
After step 1: ρ1 (on qubits 0,1,2,3).
Then apply H0 on qubit0. So ρ2 = (H0 ⊗ I_{1,2,3}) ρ1 (H0† ⊗ I).
Then apply U2 (CNOT_{03}). So then state becomes: ρ3 = U2 ρ2 U2†.
Then apply error channel on qubits (0,3): That gives: ρ_final = (1-p) ρ3 + (p/15) ∑_{F in Paulis on (0,3) non-identity} F ρ3 F.</p>
<p>And we want fidelity: F = &lt;ψ_ideal| ρ_final |ψ_ideal&gt;, where |ψ_ideal&gt; = U2 H0 U1 H2 |0000&gt; = U |0000&gt;.</p>
<p>Because the errors are independent and the circuit is linear, we can compute the fidelity as the product of the fidelities from each error step? But careful: The errors occur on different sets of qubits and they might not commute with subsequent gates? But we can compute exactly.</p>
<p>Alternatively, we can compute the effect of an error on the final state. The ideal final state is |ψ_ideal&gt;. Now, if an error occurs at the first CNOT step (on qubits 2,1), that error E will be propagated through the subsequent gates H0 and U2. So effectively, if an error E occurs at the first step, then the final state becomes: U2 H0 E U1 H2 |0000&gt;? But careful: The error happens after U1. So the state becomes E U1 H2 |0000&gt;. Then we apply H0 on qubit0. That gives H0 E U1 H2 |0000&gt;. But note: H0 acts only on qubit0. And E acts on qubits 2 and 1. They commute because they act on different qubits? Actually, qubit0 is separate from qubits 1 and 2? Yes, qubits are 0,1,2,3. So H0 and E commute if E acts on qubits 1 and 2? But careful: H0 acts on qubit0. E acts on qubits 2 and 1. They act on disjoint sets, so they commute. So then state becomes: E H0 U1 H2 |0000&gt;. Then apply U2 (CNOT_{03}). That gives: U2 E H0 U1 H2 |0000&gt;. But does U2 commute with E? U2 acts on qubits 0 and 3. E acts on qubits 1 and 2. They act on disjoint sets, so they commute. So then state becomes: E U2 H0 U1 H2 |0000&gt; = E |ψ_ideal&gt;. So indeed, an error E from the first CNOT step simply becomes a Pauli error on the final state: The final state becomes E |ψ_ideal&gt;, where E is a Pauli on qubits 1 and 2? But wait: E originally acts on qubits 2 and 1. But after commuting through, it remains the same Pauli on those qubits. So any error from the first CNOT step becomes a Pauli error on the final state on qubits 1 and 2.
Similarly, an error from the second CNOT step: After U2, we apply error F on qubits (0,3). That error F directly acts on the ideal state? But careful: The ideal state after U2 is |ψ_ideal&gt;? Actually, if there were no errors from first step, then after U2, the state is |ψ_ideal&gt;. Then error F gives F |ψ_ideal&gt;. So errors from the second step become Pauli errors on qubits 0 and 3 on the final state.
But wait: There is also the possibility of errors from both steps. But since errors are independent, the overall final state is a mixture: With probability (1-p)^2, no errors occur, so state is |ψ_ideal&gt;.
With probability p(1-p) from first error only: then state becomes E |ψ_ideal&gt; for some E (on qubits 1,2) with probability p/15 each.
With probability (1-p)p from second error only: then state becomes F |ψ_ideal&gt; for some F (on qubits 0,3) with probability p/15 each.
With probability p^2 from both errors: then state becomes F E |ψ_ideal&gt;? But careful: If both errors occur, then the first error gives E, and then after H0 and U2, we get E |ψ_ideal&gt; as argued? But then the second error F acts on that: F E |ψ_ideal&gt;. But note: F acts on qubits 0 and 3, and E acts on qubits 1 and 2. They commute. So indeed, the combined error is just the product F E. And since these are independent, the probability for a specific pair (E, F) is (p/15)^2.
So overall, the final density matrix is:
ρ_final = (1-p)^2 |ψ_ideal&gt;&lt;ψ_ideal| 
+ (p/15)(1-p) ∑_{E in Paulis on {1,2} non-identity} |E ψ_ideal&gt;<E ψ_ideal|
+ (p/15)(1-p) ∑_{F in Paulis on {0,3} non-identity} |F ψ_ideal><F ψ_ideal|
+ (p/15)^2 ∑_{E,F} |F E ψ_ideal>&lt;F E ψ_ideal|.</p>
<p>But wait: Is that correct? Check: The error channels are applied independently. So yes.</p>
<p>Then the fidelity F = &lt;ψ_ideal| ρ_final |ψ_ideal&gt;.
That equals: 
(1-p)^2 * 1 
+ (p/15)(1-p) ∑_{E} &lt;ψ_ideal|E|ψ_ideal&gt;&lt;ψ_ideal|E|ψ_ideal&gt;? Actually careful: The terms are projectors: |E ψ&gt;&lt;E ψ|. So &lt;ψ| |E ψ&gt;<E ψ| |ψ> = |&lt;ψ|E|ψ&gt;|^2.
Similarly, for F: |&lt;ψ|F|ψ&gt;|^2.
And for both: |&lt;ψ|F E|ψ&gt;|^2.</p>
<p>So fidelity = (1-p)^2 + (p/15)(1-p) [∑<em>{E on {1,2} non-identity} |&lt;ψ|E|ψ&gt;|^2] + (p/15)(1-p) [∑</em>{F on {0,3} non-identity} |&lt;ψ|F|ψ&gt;|^2] + (p/15)^2 [∑_{E on {1,2}, F on {0,3} non-identity} |&lt;ψ|F E|ψ&gt;|^2].</p>
<p>So we need to compute these overlaps: &lt;ψ|P|ψ&gt; for various Pauli operators P that act on subsets of qubits. But careful: Our state |ψ&gt; is the ideal state: |ψ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>We need to compute for each Pauli operator on the specified qubits, the expectation value &lt;ψ|P|ψ&gt;? Actually, we need |&lt;ψ|P|ψ&gt;|^2. But note: Since Pauli operators are Hermitian and unitary, they have eigenvalues ±1. But our state might not be an eigenstate. But we can compute explicitly.</p>
<p>Let&rsquo;s denote the state: 
|ψ&gt; = (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;)/2.
We want to compute &lt;ψ|P|ψ&gt; for a Pauli operator P. Since Pauli operators are tensor products of I, X, Y, Z on each qubit. But careful: The Paulis we consider: For first set: E acts on qubits 1 and 2. So E is of the form: P_{1} ⊗ P_{2} (on qubits 1 and 2) and identity on qubits 0 and 3.
For second set: F acts on qubits 0 and 3. So F is of the form: P_{0} ⊗ P_{3} and identity on qubits 1 and 2.
And for both: F E acts on all qubits? But careful: That product is on qubits 0,3 and on qubits 1,2. So it&rsquo;s a Pauli on all 4 qubits. But we sum over all non-identity on the respective sets. So we need to compute for each such Pauli, the overlap &lt;ψ|P|ψ&gt;.</p>
<p>Because the state |ψ&gt; is symmetric in a certain pattern? Let&rsquo;s list the basis states: 
|a,b,c,d&gt; with a,b,c,d in {0,1}. And |ψ&gt; has nonzero amplitudes only for states where: 
0000, 1001, 0110, 1111.
Notice pattern: The sum of the bits? For these, a+d? Actually, 0000: a=0,d=0; 1001: a=1,d=1; 0110: a=0,d=0? Actually, 0110: a=0,d=0; 1111: a=1,d=1. So it seems that a and d are always equal? Check: 0000: 0=0; 1001: 1=1; 0110: 0=0; 1111: 1=1. So indeed, qubit0 and qubit3 are always the same. Also, look at qubits 1 and 2: For 0000: b=0,c=0; 1001: b=0,c=0; 0110: b=1,c=1; 1111: b=1,c=1. So qubits 1 and 2 are also always the same. So |ψ&gt; is actually: 
|ψ&gt; = 1/2 (|0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt;) but careful: That ordering: qubits: 0,1,2,3. So indeed, condition: qubit0 = qubit3, and qubit1 = qubit2.
So we can write: |ψ&gt; = 1/2 (|0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt;).</p>
<p>That might simplify computations.</p>
<p>Now, consider a Pauli operator on qubits 1 and 2. It is of the form: I ⊗ (P_{1} ⊗ P_{2}) ⊗ I? Actually careful: The qubits order: 0,1,2,3. So an operator on qubits 1 and 2 only: It acts as identity on qubit0 and qubit3. So let E = I_0 ⊗ A ⊗ B ⊗ I_3, where A and B are Pauli matrices (X, Y, Z) but not both I? Actually, we sum over non-identity on the pair. So A and B can be any Pauli from {X,Y,Z}? But wait: The set of two-qubit Paulis on qubits 1 and 2: There are 15 such operators: They are all products of Pauli matrices on qubit1 and qubit2, excluding the identity on both. But note: They include operators like X⊗I, I⊗X, etc. But careful: The error channel is on the two qubits together. So the errors are two-qubit Pauli operators on that pair. That set includes operators that act on only one qubit? Yes, because those are non-identity on the pair? For example, X⊗I is not the identity on the pair because identity on two qubits is I⊗I. So indeed, the set is: All Pauli operators on two qubits except I⊗I. So we have: 
On qubits 1 and 2, the Paulis are: 
X⊗I, Y⊗I, Z⊗I,
I⊗X, I⊗Y, I⊗Z,
X⊗X, X⊗Y, X⊗Z,
Y⊗X, Y⊗Y, Y⊗Z,
Z⊗X, Z⊗Y, Z⊗Z.
So 15 total.</p>
<p>We want to compute &lt;ψ|E|ψ&gt; for each such E. But note: Because of the symmetry of |ψ&gt;? Actually, |ψ&gt; has the property that qubits 1 and 2 are always equal. So if we apply an operator that does not preserve that symmetry, then E|ψ&gt; might be orthogonal to |ψ&gt;? Let&rsquo;s compute systematically.</p>
<p>Write |ψ&gt; = 1/2 (|0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt;). 
For an operator E acting on qubits 1 and 2 only. So E = I_0 ⊗ O ⊗ I_3, where O is a 4x4 matrix on qubits 1 and 2. Then E|ψ&gt; = 1/2 ( |0&gt; ⊗ (O|00&gt;) ⊗ |0&gt; + |1&gt; ⊗ (O|00&gt;) ⊗ |1&gt; + |0&gt; ⊗ (O|11&gt;) ⊗ |0&gt; + |1&gt; ⊗ (O|11&gt;) ⊗ |1&gt; ). Because on the terms: |0,0,0,0&gt; becomes: qubits1,2: |00&gt; so O|00&gt;; similarly, |1,0,0,1&gt;: qubits1,2: |00&gt; so O|00&gt;; |0,1,1,0&gt;: qubits1,2: |11&gt; so O|11&gt;; |1,1,1,1&gt;: qubits1,2: |11&gt; so O|11&gt;.
So then &lt;ψ|E|ψ&gt; = 1/4 [ &lt;00|O|00&gt; + &lt;00|O|00&gt; + &lt;11|O|11&gt; + &lt;11|O|11&gt;? Actually careful: 
&lt;ψ|E|ψ&gt; = (1/2)(1/2) sum? Let&rsquo;s do properly:
&lt;ψ|E|ψ&gt; = ∑<em>{a,d in {0,1}}? Actually, we can compute:
&lt;ψ|E|ψ&gt; = 1/4 [ &lt;0000| + &lt;1001| + &lt;0110| + &lt;1111| ] E [ |0000&gt; + |1001&gt; + |0110&gt; + |1111&gt; ].
But since E acts only on qubits 1,2, the cross terms between different a,d? Actually, careful: The states are orthogonal if the qubit0 and qubit3 differ? Actually, |0000&gt; and |1001&gt; are orthogonal because qubit0 differs. So we can compute term by term:
Term from |0000&gt;: &lt;0000|E|0000&gt; = &lt;00|O|00&gt;.
|1001&gt;: &lt;1001|E|1001&gt; = &lt;00|O|00&gt;.
|0110&gt;: &lt;0110|E|0110&gt; = &lt;11|O|11&gt;.
|1111&gt;: &lt;1111|E|1111&gt; = &lt;11|O|11&gt;.
And cross terms like &lt;0000|E|1001&gt; = 0 because qubit0: 0 vs 1.
So indeed, &lt;ψ|E|ψ&gt; = 1/4 [ 2 &lt;00|O|00&gt; + 2 &lt;11|O|11&gt; ] = 1/2 [ &lt;00|O|00&gt; + &lt;11|O|11&gt; ].
So for any operator O on two qubits (qubits 1 and 2), we have:
&lt;ψ|E|ψ&gt; = 1/2 (Tr(O (|00&gt;&lt;00| + |11&gt;&lt;11|))? Actually, careful: &lt;00|O|00&gt; is the (00,00) matrix element, and &lt;11|O|11&gt; is the (11,11) matrix element.
So if O is a Pauli matrix, then these are either 0 or ±1. Specifically, Pauli matrices: 
X: &lt;00|X|00&gt; = 0, &lt;11|X|11&gt; = 0? Actually, X flips bits: X|0&gt; = |1&gt;, so on two qubits, X⊗I: then &lt;00|X⊗I|00&gt; = &lt;0|X|0&gt;&lt;0|I|0&gt; = 0. Similarly, &lt;11|X⊗I|11&gt; = &lt;1|X|1&gt;&lt;1|I|1&gt; = 0. So that gives 0.
Y: similarly, 0.
Z: &lt;00|Z|00&gt; = 1? Actually, careful: Z|0&gt;=|0&gt;, so &lt;00|Z⊗I|00&gt; = 1. But wait: O is on two qubits. But we need to consider all Paulis on two qubits. They are products: For example, X⊗I, I⊗X, X⊗X, etc.
Let&rsquo;s list all 15 Paulis on qubits 1 and 2. They are of the form: P ⊗ Q, where P, Q ∈ {I, X, Y, Z} but not both I.
We want &lt;ψ|E|ψ&gt; = 1/2 ( &lt;00|P⊗Q|00&gt; + &lt;11|P⊗Q|11&gt; ).
Now, &lt;00|P⊗Q|00&gt; = &lt;0|P|0&gt;&lt;0|Q|0&gt;.
&lt;11|P⊗Q|11&gt; = &lt;1|P|1&gt;&lt;1|Q|1&gt;.
For Pauli matrices:
For I: &lt;0|I|0&gt;=1, &lt;1|I|1&gt;=1.
For X: &lt;0|X|0&gt;=0, &lt;1|X|1&gt;=0.
For Y: &lt;0|Y|0&gt;=0, &lt;1|Y|1&gt;=0.
For Z: &lt;0|Z|0&gt;=1, &lt;1|Z|1&gt; = -1.
So then:
If P⊗Q = I⊗I, then it&rsquo;s identity, but we exclude that.
So for non-identity:
Case: P = I, Q is non-identity: 
I⊗X: then &lt;00| = 1<em>0=0; &lt;11| = 1</em>0=0; so overlap = 0.
I⊗Y: 0.
I⊗Z: &lt;00| = 1<em>1=1; &lt;11| = 1</em>(-1) = -1; so sum = 1 + (-1)=0, so overlap = 0.
Similarly, P = X, Q = I: X⊗I: 0.
P = Y, Q = I: 0.
P = Z, Q = I: Z⊗I: &lt;00| = 1<em>1=1; &lt;11| = (-1)</em>1 = -1; so sum=0.
Now, if both P and Q are non-I:
X⊗X: &lt;00| = 0<em>0=0; &lt;11| = 0</em>0=0; so 0.
X⊗Y: 0.
X⊗Z: &lt;00| = 0<em>1=0; &lt;11| = 0</em>(-1)=0; so 0.
Y⊗X: 0.
Y⊗Y: 0? Actually, careful: Y|0&gt; = i|1&gt;, so &lt;0|Y|0&gt;=0, so yes 0.
Y⊗Z: 0.
Z⊗X: &lt;00| = 1<em>0=0; &lt;11| = (-1)</em>0=0; so 0.
Z⊗Y: 0.
Z⊗Z: &lt;00| = 1<em>1=1; &lt;11| = (-1)</em>(-1)=1; so sum = 1+1=2, so overlap = 1/2 * 2 = 1.
So the only Pauli on qubits 1 and 2 that gives nonzero overlap is Z⊗Z. But wait: Check: What about Paulis that are products like? Actually, we&rsquo;ve covered all: The only one is Z⊗Z. But also, what about -Z⊗Z? That is not a separate Pauli because Paulis are defined up to phase? Actually, Pauli group: The Pauli matrices are usually taken as X, Y, Z. But note: Y = i? Actually, careful: The Pauli matrices are Hermitian? Actually, X and Z are Hermitian, but Y is Hermitian? Y = [[0,-i],[i,0]] is Hermitian. So they are all Hermitian. So indeed, the set is {I, X, Y, Z} on each qubit. So we&rsquo;ve covered.
So for errors on qubits 1 and 2, only the error E = Z⊗Z on qubits 1 and 2 (i.e., operator: I_0 ⊗ Z_1 ⊗ Z_2 ⊗ I_3) gives &lt;ψ|E|ψ&gt; = 1. But wait: Check: Z⊗Z on |ψ&gt;: 
Z⊗Z on qubits 1 and 2: For |0000&gt;, qubits1,2: |00&gt; -&gt; Z|0&gt;=|0&gt;, so unchanged? Actually, Z⊗Z|00&gt; = |00&gt; because both get phase +1? Actually, careful: Z|0&gt;=|0&gt;, so Z⊗Z|00&gt; = |00&gt;. For |1001&gt;, similarly, |00&gt; -&gt; |00&gt;. For |0110&gt;, |11&gt; -&gt; Z⊗Z|11&gt; = (-1)*(-1)|11&gt; = |11&gt;. For |1111&gt;, |11&gt; -&gt; |11&gt;. So indeed, Z⊗Z leaves |ψ&gt; unchanged. So &lt;ψ|Z⊗Z|ψ&gt; = 1.
But then we need |&lt;ψ|E|ψ&gt;|^2. For E = Z⊗Z, that is 1^2 = 1.
For all other E on qubits 1 and 2, the overlap is 0. So then the sum over E on qubits 1 and 2 (non-identity) of |&lt;ψ|E|ψ&gt;|^2 is: There is exactly 1 Pauli (Z⊗Z) that gives 1, and the other 14 give 0.
But wait: Check: What about -Z⊗Z? That is not a Pauli because Pauli matrices are defined as X, Y, Z. The Pauli group elements include phases ±1, ±i. But here the error channel: &ldquo;produces one of the 15 non-identity two-qubit Paulis&rdquo;. Usually, the two-qubit Pauli group has 15 elements if we consider them up to phase? Actually, careful: The depolarizing channel is usually defined as: With probability p, an error occurs, and the error is uniformly chosen from the set {I, X, Y, Z}⊗{I, X, Y, Z} minus the identity? But then that set has 15 elements. But note: That set includes, for example, -I⊗X? No, because we only take the matrices themselves: The set is {I, X, Y, Z} ⊗ {I, X, Y, Z} but excluding I⊗I. But then that set includes, for instance, X⊗I, Y⊗I, Z⊗I, I⊗X, I⊗Y, I⊗Z, X⊗X, X⊗Y, X⊗Z, Y⊗X, Y⊗Y, Y⊗Z, Z⊗X, Z⊗Y, Z⊗Z. So indeed, it&rsquo;s exactly 15. And none of these are negative? Because if we take -X, that is not in the set because we only take X, Y, Z. So it&rsquo;s fine.
So for errors on qubits 1 and 2, only Z⊗Z gives nonzero overlap. So sum</em>{E on {1,2} non-identity} |&lt;ψ|E|ψ&gt;|^2 = 1.</p>
<p>Now, similarly, consider errors on qubits 0 and 3. F is a Pauli on qubits 0 and 3. Write F = P ⊗ I_1 ⊗ I_2 ⊗ Q, where P, Q ∈ {X, Y, Z}? But careful: The set is all two-qubit Paulis on qubits 0 and 3 that are non-identity. So similar analysis: |ψ&gt; has the property that qubit0 and qubit3 are always equal. So then by similar argument, if we act with an operator on qubits 0 and 3, then 
&lt;ψ|F|ψ&gt; = 1/2 ( &lt;0|P|0&gt;&lt;0|Q|0&gt; + &lt;1|P|1&gt;&lt;1|Q|1&gt; ) but careful: Actually, careful: F acts on qubits 0 and 3. Write |ψ&gt; = 1/2 (|0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt;). Then F|ψ&gt; = 1/2 ( (P|0&gt; ⊗ |00&gt; ⊗ (Q|0&gt;) + (P|1&gt; ⊗ |00&gt; ⊗ (Q|1&gt;) + (P|0&gt; ⊗ |11&gt; ⊗ (Q|0&gt;) + (P|1&gt; ⊗ |11&gt; ⊗ (Q|1&gt;) ). Then &lt;ψ|F|ψ&gt; = 1/4 [ &lt;0|P|0&gt;&lt;0|Q|0&gt; + &lt;1|P|1&gt;&lt;1|Q|1&gt; + &hellip; Actually, let&rsquo;s do similarly: 
&lt;ψ|F|ψ&gt; = 1/4 [ &lt;0000|F|0000&gt; + &lt;1001|F|1001&gt; + &lt;0110|F|0110&gt; + &lt;1111|F|1111&gt; ] because cross terms vanish.
Now, &lt;0000|F|0000&gt; = &lt;0|P|0&gt;&lt;0|Q|0&gt;.
&lt;1001|F|1001&gt; = &lt;1|P|1&gt;&lt;1|Q|1&gt;.
&lt;0110|F|0110&gt; = &lt;0|P|0&gt;&lt;0|Q|0&gt;? Actually careful: For |0110&gt;, qubit0=0, qubit3=0, so it gives &lt;0|P|0&gt;&lt;0|Q|0&gt;.
&lt;1111|F|1111&gt; = &lt;1|P|1&gt;&lt;1|Q|1&gt;.
So total = 1/4 [ 2(&lt;0|P|0&gt;&lt;0|Q|0&gt; + 2(&lt;1|P|1&gt;&lt;1|Q|1&gt;)] = 1/2 ( &lt;0|P|0&gt;&lt;0|Q|0&gt; + &lt;1|P|1&gt;&lt;1|Q|1&gt; ).
So again, if P and Q are such that one of them is X or Y, then these are 0. The only possibility is if both are Z? But careful: What if P = Z and Q = I? That is not allowed because then it&rsquo;s identity on the pair? Actually, wait: The set of Paulis on qubits 0 and 3: They are of the form: P ⊗ Q, where P, Q ∈ {I, X, Y, Z} but not both I. So we consider:
P = I, Q non-I: 
I⊗X: gives 0.
I⊗Y: 0.
I⊗Z: gives: &lt;0|I|0&gt;=1, &lt;0|Z|0&gt;=1; &lt;1|I|1&gt;=1, &lt;1|Z|1&gt; = -1; so sum = 1 + (-1)=0.
Similarly, P = X, Q = I: 0.
P = Y, Q = I: 0.
P = Z, Q = I: gives: &lt;0|Z|0&gt;=1, &lt;0|I|0&gt;=1; &lt;1|Z|1&gt;=-1, &lt;1|I|1&gt;=1; so sum = 1 + (-1)=0.
Now, both non-I:
X⊗X: 0.
X⊗Y: 0.
X⊗Z: 0.
Y⊗X: 0.
Y⊗Y: 0.
Y⊗Z: 0.
Z⊗X: 0.
Z⊗Y: 0.
Z⊗Z: gives: &lt;0|Z|0&gt;=1, &lt;0|Z|0&gt;=1 so product=1; &lt;1|Z|1&gt;=-1, &lt;1|Z|1&gt;=-1 so product=1; sum=2, so overlap = 1.
So again, the only Pauli on qubits 0 and 3 that gives nonzero overlap is Z⊗Z. So sum_{F on {0,3} non-identity} |&lt;ψ|F|ψ&gt;|^2 = 1.</p>
<p>Now, what about errors from both steps? That is F E, where E is on qubits 1,2 (non-identity) and F is on qubits 0,3 (non-identity). Then we want |&lt;ψ|F E|ψ&gt;|^2. But note: F and E act on disjoint sets, so they commute. And we computed separately: For E, only E = Z⊗Z on {1,2} gives &lt;ψ|E|ψ&gt; = 1, and for F, only F = Z⊗Z on {0,3} gives &lt;ψ|F|ψ&gt; = 1. But careful: If we take E that is not Z⊗Z, then &lt;ψ|E|ψ&gt;=0, so then &lt;ψ|F E|ψ&gt; might be 0? But we need to sum over all E and F. But we can compute generally: 
&lt;ψ|F E|ψ&gt; = ? Since F and E act on different qubits, and |ψ&gt; factorizes in a sense? Actually, |ψ&gt; is not a product state but it has structure: qubits 0 and 3 are correlated, and qubits 1 and 2 are correlated. And F acts on 0,3 and E acts on 1,2. So then &lt;ψ|F E|ψ&gt; =? We can compute by writing |ψ&gt; as: 
|ψ&gt; = 1/2 (|0,0&gt;<em>{03} ⊗ |0,0&gt;</em>{12} + |1,1&gt;<em>{03} ⊗ |0,0&gt;</em>{12}? Actually careful: 
|ψ&gt; = 1/2 (|0&gt;<em>0|0&gt;_1|0&gt;_2|0&gt;_3 + |1&gt;_0|0&gt;_1|0&gt;_2|1&gt;_3 + |0&gt;_0|1&gt;_1|1&gt;_2|0&gt;_3 + |1&gt;_0|1&gt;_1|1&gt;_2|1&gt;_3).
Group qubits: (0,3) and (1,2). Then we have: 
|ψ&gt; = 1/2 ( |00&gt;</em>{03} ⊗ |00&gt;<em>{12} + |11&gt;</em>{03} ⊗ |00&gt;<em>{12} + |00&gt;</em>{03} ⊗ |11&gt;<em>{12} + |11&gt;</em>{03} ⊗ |11&gt;<em>{12} )? But careful: That would be if qubit0 and qubit3 are both 0 or both 1, and qubit1 and qubit2 are both 0 or both 1. So indeed, |ψ&gt; = (|00&gt;+|11&gt;)</em>{03} ⊗ (|00&gt;+|11&gt;)<em>{12} / 2? Check: (|00&gt;+|11&gt;)</em>{03} ⊗ (|00&gt;+|11&gt;)<em>{12} = |0000&gt; + |0011&gt; + |1100&gt; + |1111&gt;. But our state is |0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;. That is not the same because |1001&gt; corresponds to |10&gt;</em>{03}? Actually, careful: Qubit0 and qubit3: For |1001&gt;, that is qubit0=1, qubit3=1? Actually, |1001&gt; means: qubit0=1, qubit1=0, qubit2=0, qubit3=1. So in the grouping (0,3) and (1,2), |1001&gt; becomes: (1,1) on (0,3) and (0,0) on (1,2). So it is |11&gt;<em>{03} ⊗ |00&gt;</em>{12}. And |0110&gt; becomes: (0,0) on (0,3) and (1,1) on (1,2). So indeed, |ψ&gt; = |00&gt;<em>{03}⊗|00&gt;</em>{12} + |11&gt;<em>{03}⊗|00&gt;</em>{12} + |00&gt;<em>{03}⊗|11&gt;</em>{12} + |11&gt;<em>{03}⊗|11&gt;</em>{12} all divided by 2. That is actually = (|00&gt;<em>{03}+|11&gt;</em>{03}) ⊗ (|00&gt;<em>{12}+|11&gt;</em>{12}) / 2? But then that product gives cross terms: |00&gt;<em>{03}⊗|11&gt;</em>{12} and |11&gt;<em>{03}⊗|00&gt;</em>{12} are included, but also |00&gt;<em>{03}⊗|00&gt;</em>{12} and |11&gt;<em>{03}⊗|11&gt;</em>{12}. So yes, it is exactly: 
|ψ&gt; = (|00&gt;<em>{03}+|11&gt;</em>{03})/√2 ⊗ (|00&gt;<em>{12}+|11&gt;</em>{12})/√2.
So indeed, |ψ&gt; is a product of two Bell states on pairs (0,3) and (1,2). That is interesting.
So then, for an operator F that acts on qubits 0 and 3, and E that acts on qubits 1 and 2, we have:
&lt;ψ|F E|ψ&gt; = <Bell_{03}|F|Bell_{03}> * <Bell_{12}|E|Bell_{12}>, where Bell = (|00&gt;+|11&gt;)/√2.
And we already computed for a two-qubit Pauli on a Bell state? Actually, for a Bell state |Φ^+&gt; = (|00&gt;+|11&gt;)/√2, what is &lt;Φ^+|P⊗Q|Φ^+&gt;? That is known: It is 1/2 (Tr(P Q^T)? Actually, simpler: For Bell state, &lt;Φ^+|A⊗B|Φ^+&gt; = 1/2 Tr(A^T B)? Alternatively, we can compute directly: 
For Bell state on two qubits: |Φ&gt; = (|00&gt;+|11&gt;)/√2.
Then &lt;Φ| (P⊗Q) |Φ&gt; = 1/2 ( &lt;00|P⊗Q|00&gt; + &lt;11|P⊗Q|11&gt; + &lt;00|P⊗Q|11&gt; + &lt;11|P⊗Q|00&gt; ). But note: &lt;00|P⊗Q|11&gt; = &lt;0|P|1&gt;&lt;0|Q|1&gt; and &lt;11|P⊗Q|00&gt; = &lt;1|P|0&gt;&lt;1|Q|0&gt;. But since P and Q are Paulis, they are either diagonal or off-diagonal. Actually, we already computed for operators that are diagonal in the computational basis? But careful: Our previous computation for operators on qubits 1 and2 gave: &lt;ψ|E|ψ&gt; = 1/2 (&lt;00|E|00&gt;+&lt;11|E|11&gt;) but that was because the state |ψ&gt; here is actually a Bell state? Actually, wait: Our |ψ&gt; is product of two Bell states. But then if we isolate one Bell state, say on qubits 1 and2, then that Bell state is (|00&gt;+|11&gt;)/√2. And then <Bell|E|Bell> = 1/2 (&lt;00|E|00&gt;+&lt;11|E|11&gt; + &lt;00|E|11&gt;+&lt;11|E|00&gt;). But earlier, we computed for E acting on qubits 1 and2 from the full state, we got only the diagonal terms? That was because the full state |ψ&gt; is product, and when we compute &lt;ψ|E|ψ&gt;, since E acts only on qubits 1 and2, it becomes <Bell_{03}|Bell_{03}> * <Bell_{12}|E|Bell_{12}> = <Bell_{12}|E|Bell_{12}>. So actually, <Bell_{12}|E|Bell_{12}> should be what we computed? But we computed &lt;ψ|E|ψ&gt; = 1/2 (&lt;00|E|00&gt;+&lt;11|E|11&gt;) from a direct computation. That suggests that for a Bell state, <Bell|E|Bell> is actually 1/2 (&lt;00|E|00&gt;+&lt;11|E|11&gt;) if E is diagonal? But wait, check: For E = X⊗I on qubits 1 and2. Then <Bell|X⊗I|Bell> = ? 
|Bell&gt; = (|00&gt;+|11&gt;)/√2.
X⊗I|00&gt; = |10&gt;, X⊗I|11&gt; = |01&gt;. So <Bell|X⊗I|Bell> = 1/2 (&lt;00|10&gt;+&lt;00|01&gt;+&lt;11|10&gt;+&lt;11|01&gt;) = 0. So that matches: 1/2(0+0)=0.
For E = Z⊗Z, we got 1/2(1+1)=1. So indeed, for a Bell state, the off-diagonal terms &lt;00|E|11&gt; and &lt;11|E|00&gt; are actually 0 for Pauli operators? Check: For E = Z⊗Z, &lt;00|Z⊗Z|11&gt; = &lt;0|Z|1&gt;&lt;0|Z|1&gt; = 0<em>0=0. So indeed, for Pauli operators, the off-diagonal terms are always 0 because if E is a Pauli, then it either flips bits or doesn&rsquo;t. Actually, if E has any X or Y, then it will flip some bits, so the diagonal elements are 0. And if E is diagonal (only Z and I), then off-diagonals are 0. So indeed, <Bell|E|Bell> = 1/2 ( &lt;00|E|00&gt; + &lt;11|E|11&gt; ). So our previous computation is consistent.
So then, for errors on both sets: 
&lt;ψ|F E|ψ&gt; = <Bell_{03}|F|Bell_{03}> * <Bell_{12}|E|Bell_{12}>.
And we already computed that for a two-qubit Pauli on a Bell pair, the only nonzero is when it is Z⊗Z, giving value 1. So then, if both F and E are Z⊗Z on their respective pairs, then &lt;ψ|F E|ψ&gt; = 1</em>1 = 1. For any other combination, at least one factor is 0, so product is 0.
But wait: Could there be a case where, say, F is Z⊗Z and E is something that gives 0? That gives 0. Or F is something that gives 0 and E is Z⊗Z gives 0. So indeed, the only combination that gives nonzero is F = Z⊗Z on {0,3} and E = Z⊗Z on {1,2}. But note: That product is Z⊗Z on all qubits? Actually, Z⊗Z on {0,3} and Z⊗Z on {1,2} gives overall operator: Z_0 ⊗ Z_1 ⊗ Z_2 ⊗ Z_3. And what is &lt;ψ| ZZZZ |ψ&gt;? That is the stabilizer? Actually, ZZZZ is a stabilizer, so it gives +1. So indeed, that gives 1.
So then, sum over E on {1,2} and F on {0,3} non-identity of |&lt;ψ|F E|ψ&gt;|^2 = 1 (only the pair: E = Z⊗Z on {1,2} and F = Z⊗Z on {0,3}).</p>
<p>But wait: There is also possibility: What if the error from the first step is identity? That we already covered: (1-p)^2 term.
And errors from first step only: sum gives: (p/15)(1-p)<em>1.
Errors from second step only: (p/15)(1-p)</em>1.
Errors from both: (p/15)^2 * 1.</p>
<p>So then the fidelity F = (1-p)^2 + (p/15)(1-p) + (p/15)(1-p) + (p/15)^2 = (1-p)^2 + 2p(1-p)/15 + p^2/225.
Simplify: = 1 - 2p + p^2 + (2p/15 - 2p^2/15) + p^2/225 = 1 - 2p + p^2 + 2p/15 - 2p^2/15 + p^2/225 = 1 - (2p - 2p/15) + p^2<em>(1 - 2/15 + 1/225) = 1 - (30p/15 - 2p/15) + p^2</em>( (225/225) - (30/225) + (1/225) ) = 1 - (28p/15) + p^2*(196/225) = 1 - (28/15)p + (196/225)p^2.
So fidelity F = 1 - (28/15)p + (196/225)p^2.</p>
<p>But wait: Is that the physical state fidelity? That is the fidelity between the ideal state and the noisy state. But careful: The fidelity is defined as F = &lt;ψ_ideal| ρ |ψ_ideal&gt;. And we computed that as the sum of probabilities that the error pattern results in a state that is not orthogonal to |ψ_ideal&gt;. And we found that if the error is either no error, or only the error that is Z⊗Z on the respective pairs, then the state is exactly |ψ_ideal&gt; (since Z⊗Z on a Bell pair acts as identity on the Bell state? Actually, check: For the Bell state on qubits 1,2, Z⊗Z|Bell&gt; =? (|00&gt;+|11&gt;)/√2, because Z⊗Z|00&gt; = |00&gt;, Z⊗Z|11&gt; = |11&gt;. So yes, it is invariant. Similarly, on qubits 0,3, Z⊗Z is invariant. So indeed, those errors do not change the state. So the fidelity is exactly the probability that the errors are either no error or exactly these specific errors. And that probability is: 
From first CNOT: probability of no error: (1-p) + probability of error that is Z⊗Z: that probability is p/15. So total from first CNOT: (1-p) + p/15 = 1 - p + p/15 = 1 - (14/15)p.
From second CNOT: similarly, (1-p) + p/15 = 1 - (14/15)p.
And since they are independent, the overall probability that the final state is exactly |ψ_ideal&gt; is (1 - (14/15)p)^2 = 1 - (28/15)p + (196/225)p^2. That matches our fidelity. So indeed, the fidelity is exactly that.</p>
<p>But wait: Could there be other errors that leave the state unchanged? What about errors that are products of stabilizers? The stabilizers are XXXX and ZZZZ. But our errors are on specific pairs. For example, an error on qubits 1,2 that is X⊗X? That would give: X⊗X on Bell state? Actually, X⊗X on Bell state: (|00&gt;+|11&gt;)/√2 becomes (|11&gt;+|00&gt;)/√2, so that is invariant. But wait: Check: For qubits 1,2, if we apply X⊗X, then on |00&gt; it becomes |11&gt;, and on |11&gt; it becomes |00&gt;. So indeed, X⊗X also leaves the Bell state invariant? But then why did we get that <Bell|X⊗X|Bell> =? Let&rsquo;s compute: For Bell state on two qubits: |Φ&gt; = (|00&gt;+|11&gt;)/√2. Then X⊗X|Φ&gt; = (X⊗X|00&gt; + X⊗X|11&gt;)/√2 = (|11&gt;+|00&gt;)/√2 = |Φ&gt;. So actually, X⊗X also acts as identity on the Bell state. But then why did our computation earlier give that for an operator on qubits 1,2, we computed &lt;ψ|E|ψ&gt; = 1/2(&lt;00|E|00&gt;+&lt;11|E|11&gt;). For E = X⊗X, that gives 1/2(0+0)=0. That is a discrepancy. Let&rsquo;s recompute carefully: 
We want &lt;ψ|E|ψ&gt; for E acting on qubits 1 and 2. 
|ψ&gt; = (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;)/2.
Consider E = X⊗X on qubits 1 and 2. That means: E = I_0 ⊗ (X on qubit1) ⊗ (X on qubit2) ⊗ I_3.
Then E|ψ&gt; = 1/2 ( E|0000&gt; + E|1001&gt; + E|0110&gt; + E|1111&gt; ).
Now, |0000&gt;: qubits1,2 are |00&gt;. X⊗X|00&gt; = |11&gt;. So E|0000&gt; = |0,1,1,0&gt; = |0110&gt;.
|1001&gt;: qubits1,2: |00&gt; -&gt; becomes |1,1,1,1&gt;? Actually, careful: |1001&gt;: qubit0=1, qubit1=0, qubit2=0, qubit3=1. Under X on qubit1 and X on qubit2, we get: qubit1:0-&gt;1, qubit2:0-&gt;1, so state becomes: |1,1,1,1&gt; = |1111&gt;.
|0110&gt;: qubits1,2: |11&gt; -&gt; X⊗X|11&gt; = |00&gt;. So becomes |0,0,0,0&gt; = |0000&gt;.
|1111&gt;: qubits1,2: |11&gt; -&gt; becomes |1,0,0,1&gt; = |1001&gt;.
So E|ψ&gt; = 1/2 (|0110&gt; + |1111&gt; + |0000&gt; + |1001&gt;) = |ψ&gt;. So indeed, &lt;ψ|E|ψ&gt; = 1. But then our computation earlier gave: &lt;ψ|E|ψ&gt; = 1/2(&lt;00|E|00&gt;+&lt;11|E|11&gt;) = 1/2(0+0)=0. That suggests that our method of computing by only diagonal elements is not correct because we assumed that cross terms between different basis states vanish? But wait, why did we assume that? We computed: 
&lt;ψ|E|ψ&gt; = 1/4 [ &lt;0000|E|0000&gt; + &lt;1001|E|1001&gt; + &lt;0110|E|0110&gt; + &lt;1111|E|1111&gt; ] because we said cross terms like &lt;0000|E|1001&gt; are zero. But are they zero? Check: &lt;0000|E|1001&gt;. |0000&gt; and |1001&gt; differ in qubit0. But E acts only on qubits 1 and 2. So &lt;0000|E|1001&gt; = &lt;0|0&gt;? Actually, careful: 
&lt;0000|E|1001&gt; = &lt;0|1&gt; on qubit0? Actually, write: |0000&gt; = |0&gt;<em>0 |00&gt;</em>{12} |0&gt;<em>3.
|1001&gt; = |1&gt;_0 |00&gt;</em>{12} |1&gt;_3.
Then &lt;0000|E|1001&gt; = &lt;0|1&gt; * &lt;00|E|00&gt; * &lt;0|1&gt; = 0. So indeed, cross terms between states with different qubit0 and qubit3 are zero. But what about &lt;0000|E|0110&gt;? 
|0000&gt; and |0110&gt;: qubit0: 0 vs 0? Actually, |0000&gt;: qubit0=0, qubit3=0; |0110&gt;: qubit0=0, qubit3=0. So they have the same qubit0 and qubit3? Actually, |0000&gt; and |0110&gt; both have qubit0=0 and qubit3=0. So then &lt;0000|E|0110&gt; is not necessarily zero. Because: 
&lt;0000|E|0110&gt; = &lt;0|0&gt; * &lt;00|E|11&gt; * &lt;0|0&gt; = &lt;00|E|11&gt;. And for E = X⊗X, &lt;00|X⊗X|11&gt; = &lt;0|X|1&gt;&lt;0|X|1&gt; = (1)*(1)=1. So we missed cross terms between states that have the same qubit0 and qubit3 but different qubits 1 and 2. So our earlier computation that gave only diagonal terms was incorrect because we assumed that the only nonzero terms are when the state indices are the same. But actually, if qubit0 and qubit3 are the same, then states like |0000&gt; and |0110&gt; are both in the same &ldquo;sector&rdquo; (qubit0=0, qubit3=0). So we need to group by the values of qubit0 and qubit3. Let&rsquo;s do it properly:</p>
<p>We want &lt;ψ|E|ψ&gt; for E acting on qubits 1 and 2.
Write |ψ&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
Group by qubits 0 and 3:
Group 1: qubit0=0, qubit3=0: states: |0000&gt; and |0110&gt;.
Group 2: qubit0=1, qubit3=1: states: |1001&gt; and |1111&gt;.
And groups with qubit0=0, qubit3=1 and qubit0=1, qubit3=0 do not appear.
So then &lt;ψ|E|ψ&gt; = 1/4 [ (from group1: &lt;0000|E|0000&gt; + &lt;0000|E|0110&gt; + &lt;0110|E|0000&gt; + &lt;0110|E|0110&gt; ) + (group2: similar) ].
So for E = X⊗X, we computed:
&lt;0000|E|0000&gt; = &lt;00|X⊗X|00&gt; = 0.
&lt;0000|E|0110&gt; = &lt;00|X⊗X|11&gt; = 1.
&lt;0110|E|0000&gt; = &lt;11|X⊗X|00&gt; = 1.
&lt;0110|E|0110&gt; = &lt;11|X⊗X|11&gt; = 0.
So group1 contributes 0+1+1+0 = 2.
Group2: 
&lt;1001|E|1001&gt; = &lt;00|X⊗X|00&gt; = 0.
&lt;1001|E|1111&gt; = &lt;00|X⊗X|11&gt; = 1.
&lt;1111|E|1001&gt; = &lt;11|X⊗X|00&gt; = 1.
&lt;1111|E|1111&gt; = &lt;11|X⊗X|11&gt; = 0.
So group2 contributes 2.
Total = 1/4*(2+2)=1. So indeed, &lt;ψ|E|ψ&gt; = 1 for E = X⊗X.
So we need to recompute the overlaps for Paulis on qubits 1 and 2 carefully. And similarly for qubits 0 and 3.</p>
<p>Given that |ψ&gt; is a product of two Bell states: |ψ&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12}, where |Φ^+&gt; = (|00&gt;+|11&gt;)/√2.
Then for an operator E that acts on qubits 1 and 2 only, we have:
&lt;ψ|E|ψ&gt; = &lt;Φ^+|<em>{12} | E |Φ^+|</em>{12}&gt; because the part on 0,3 gives 1.
And we know that for a Bell state, the expectation value of a two-qubit Pauli operator is either 0 or ±1. Specifically, for |Φ^+&gt; = (|00&gt;+|11&gt;)/√2, 
What are &lt;Φ^+|P⊗Q|Φ^+&gt;? 
We can compute: 
&lt;Φ^+|P⊗Q|Φ^+&gt; = 1/2 ( &lt;00|P⊗Q|00&gt; + &lt;00|P⊗Q|11&gt; + &lt;11|P⊗Q|00&gt; + &lt;11|P⊗Q|11&gt; ).
Now, if P and Q are Paulis. They are either I, X, Y, Z.
Let&rsquo;s compute systematically for all combinations? But maybe we only need the squared magnitude. And we are summing over all non-identity Paulis on two qubits. So we need to compute for each Pauli operator on two qubits (15 of them), the value of |&lt;Φ^+|E|Φ^+&gt;|^2.
Since |Φ^+&gt; is a Bell state, it is known that the only Paulis that leave it invariant (up to a phase) are those that are in the stabilizer of the Bell state. The Bell state |Φ^+&gt; is stabilized by X⊗X and Z⊗Z? Actually, check: X⊗X|Φ^+&gt; = |Φ^+&gt;, Z⊗Z|Φ^+&gt; = |Φ^+&gt;. Also, -Y⊗Y|Φ^+&gt; =? Actually, Y⊗Y|Φ^+&gt; = ? Let&rsquo;s compute: Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;. So Y⊗Y|00&gt; = (i)(i)|11&gt; = -|11&gt;, and Y⊗Y|11&gt; = (-i)(-i)|00&gt; = -|00&gt;. So Y⊗Y|Φ^+&gt; = -|Φ^+&gt;. So actually, Y⊗Y gives a phase of -1. But then |&lt;Φ^+|Y⊗Y|Φ^+&gt;|^2 = 1. So also Y⊗Y has magnitude 1.
What about other Paulis? For example, X⊗I: 
&lt;Φ^+|X⊗I|Φ^+&gt; = 1/2 ( &lt;00|X⊗I|00&gt; + &hellip; ) = 0 because it will flip one qubit and then orthogonal.
So generally, for a two-qubit Pauli operator on a Bell state, the expectation value is either 0 or ±1. And it is ±1 if and only if the Pauli is of the form A⊗A (up to a sign?) Actually, check: What about I⊗X? That gives 0. So indeed, the Paulis that have nonzero expectation on |Φ^+&gt; are those that are symmetric: X⊗X, Y⊗Y, Z⊗Z, and also I⊗I but that&rsquo;s identity. Also, what about -X⊗X? That is not in the set because we only take the Paulis themselves (X, Y, Z) and not their negatives. So the set of two-qubit Paulis on qubits 1 and 2 that are non-identity and have expectation value ±1 are: X⊗X, Y⊗Y, Z⊗Z. But wait, check: What about X⊗Y? 
X⊗Y|00&gt; = |1&gt; ⊗ (i|1&gt;) = i|11&gt;, 
X⊗Y|11&gt; = |0&gt; ⊗ (-i|0&gt;) = -i|00&gt;,
So &lt;Φ^+|X⊗Y|Φ^+&gt; = 1/2 (0 + &lt;00|? Actually, compute properly:
&lt;Φ^+|X⊗Y|Φ^+&gt; = 1/2 ( &lt;00|X⊗Y|00&gt; + &lt;00|X⊗Y|11&gt; + &lt;11|X⊗Y|00&gt; + &lt;11|X⊗Y|11&gt; )
&lt;00|X⊗Y|00&gt; = 0.
&lt;00|X⊗Y|11&gt; = &lt;0|X|1&gt;&lt;0|Y|1&gt; = (1)<em>( -i ) = -i? But careful: &lt;0|X|1&gt; = 1, &lt;0|Y|1&gt; = -i? Actually, Y|1&gt; = -i|0&gt;, so &lt;0|Y|1&gt; = -i. So that term is -i.
&lt;11|X⊗Y|00&gt; = &lt;1|X|0&gt;&lt;1|Y|0&gt; = (1)</em>(i) = i? Because Y|0&gt;= i|1&gt;, so &lt;1|Y|0&gt;= i.
&lt;11|X⊗Y|11&gt; = 0.
So total = 1/2 (0 + (-i) + (i) + 0) = 0.
So indeed, only symmetric ones (X⊗X, Y⊗Y, Z⊗Z) give nonzero. But wait: What about I⊗Z? That is not symmetric. So yes.
So for errors on qubits 1 and 2, the Paulis that do not change the state (i.e., give expectation 1 in magnitude) are: E such that E = X⊗X, Y⊗Y, Z⊗Z. But are all these actually leaving the Bell state invariant? 
We already computed: X⊗X gives +1.
Z⊗Z gives +1.
Y⊗Y gives -1, so |&lt;Φ^+|Y⊗Y|Φ^+&gt;|^2 = 1.
So there are 3 Paulis on qubits 1 and 2 that yield |&lt;ψ|E|ψ&gt;|^2 = 1.
But wait: Check: Could there be others? What about -I⊗? No.
So then, for errors on qubits 1 and 2, the sum over non-identity Paulis: ∑_{E on {1,2} non-identity} |&lt;ψ|E|ψ&gt;|^2 = number of Paulis that are of the form A⊗A with A in {X,Y,Z}? That gives 3. But wait: What about Paulis like -X⊗X? Those are not in the set because the set is defined as the 15 Paulis: {I,X,Y,Z}⊗{I,X,Y,Z} minus I⊗I. So indeed, there are exactly 3: X⊗X, Y⊗Y, Z⊗Z.
But wait: Check: Is Y⊗Y actually in that set? Yes, Y is one of the Paulis.
So then, for the first error channel, the contribution is: (p/15)(1-p) * (sum over E: |&lt;ψ|E|ψ&gt;|^2) = (p/15)(1-p) * 3 = (3p/15)(1-p) = (p/5)(1-p).</p>
<p>Now, similarly, for errors on qubits 0 and 3, by the same argument, because the state on qubits 0 and 3 is also a Bell state, the Paulis that leave it invariant are those that are symmetric: X⊗X, Y⊗Y, Z⊗Z. So sum over F on {0,3} non-identity: ∑_{F} |&lt;ψ|F|ψ&gt;|^2 = 3.
So that contribution is also (p/15)(1-p)*3 = (p/5)(1-p).</p>
<p>Now, what about errors from both steps? That is F E, where E acts on {1,2} and F acts on {0,3}. Then &lt;ψ|F E|ψ&gt; = &lt;Φ^+|<em>{03}|F|Φ^+|</em>{03}&gt; * &lt;Φ^+|<em>{12}|E|Φ^+|</em>{12}&gt;. So |&lt;ψ|F E|ψ&gt;|^2 = |&lt;Φ^+|<em>{03}|F|Φ^+|</em>{03}&gt;|^2 * |&lt;Φ^+|<em>{12}|E|Φ^+|</em>{12}&gt;|^2.
So if both F and E are among the ones that give magnitude 1, then the product is 1. And if either is not, then it&rsquo;s 0. So the number of pairs (E, F) such that both are in {X⊗X, Y⊗Y, Z⊗Z} is 3*3 = 9. But wait: Are there any cross terms where, say, F gives a phase and E gives a phase such that the product phase is 1? But we are taking the square modulus, so phases don&rsquo;t matter. So indeed, if both are in that set, then |&lt;ψ|F E|ψ&gt;|^2 = 1. So the sum over E (non-identity on {1,2}) and F (non-identity on {0,3}) of |&lt;ψ|F E|ψ&gt;|^2 is 9.
So then the contribution from both errors is: (p/15)^2 * 9 = 9p^2/225 = p^2/25.</p>
<p>And then the no-error term gives: (1-p)^2.</p>
<p>Also, there are terms from only first error and only second error we already computed: each gives 3<em>(p/15)(1-p) = (p/5)(1-p). So total from one error only: 2</em>(p/5)(1-p) = (2p/5)(1-p).</p>
<p>So then the fidelity F = (1-p)^2 + (2p/5)(1-p) + (p^2/25).
Simplify: (1-p)^2 = 1 - 2p + p^2.
So F = 1 - 2p + p^2 + (2p/5 - 2p^2/5) + p^2/25 = 1 - 2p + p^2 + 0.4p - 0.4p^2 + 0.04p^2 = 1 - (2p - 0.4p) + p^2<em>(1 - 0.4 + 0.04) = 1 - 1.6p + p^2</em>(0.64) = 1 - (8/5)p + (16/25)p^2? Because 1.6 = 8/5, and 0.64 = 16/25.
So F = 1 - (8/5)p + (16/25)p^2.
Or in fraction: = 1 - (8/5)p + (16/25)p^2 = (25/25) - (40/25)p + (16/25)p^2 = (25 - 40p + 16p^2)/25.</p>
<p>But wait, is that the physical state fidelity? That is the probability that the final state is exactly |ψ_ideal&gt;. But careful: Could there be errors that are not exactly these Paulis but still yield a state that has overlap with |ψ_ideal&gt;? Actually, fidelity is &lt;ψ_ideal|ρ|ψ_ideal&gt;. And ρ is a mixture of states that are of the form (some Pauli error applied to |ψ_ideal&gt;). And if that Pauli error is not identity, then the state is orthogonal to |ψ_ideal&gt;? Not necessarily: If the Pauli error commutes with the projector onto |ψ_ideal&gt;, then it might have overlap. And we computed that overlap as &lt;ψ_ideal|P|ψ_ideal&gt;. And that is either 0 or 1 in magnitude? Actually, wait: For a Pauli operator P, since |ψ_ideal&gt; is a stabilizer state of the code? Actually, |ψ_ideal&gt; is not a code state? It is a logical state. But it is a specific state in the code space. And the code space is stabilized by XXXX and ZZZZ. So any Pauli operator that is a stabilizer will act as identity on the code space. But careful: The stabilizers are XXXX and ZZZZ. But our errors are on specific pairs. For example, an error on qubits 1,2 that is X⊗X. That is not necessarily a stabilizer because the stabilizer is XXXX, which is X on all qubits. But X⊗X on qubits 1,2 is a part of that? Actually, if we multiply XXXX by something? For instance, XXXX = (X⊗X) ⊗ (X⊗X). So indeed, X⊗X on qubits 1,2 is not exactly the stabilizer, but it is like half of it. But wait, check: The stabilizer is XXXX. That means that for any state in the code space, XXXX|ψ&gt; = |ψ&gt;. But that does not imply that X⊗X on qubits 1,2 acts as identity on the code space. Because if we take |ψ&gt; = |0000&gt;+|1111&gt; (which is in the code space), then X⊗X on qubits 1,2 gives: on |0000&gt;, becomes |0110&gt; which is not necessarily the same state. So indeed, the only errors that leave |ψ_ideal&gt; invariant are those that act as identity on |ψ_ideal&gt;. And we determined that by using the fact that |ψ_ideal&gt; is a product of two Bell states. And for a Bell state, the operators that leave it invariant are exactly those that are of the form A⊗A (with A being Pauli) because then A⊗A(|00&gt;+|11&gt;) = (A|0&gt;⊗A|0&gt; + A|1&gt;⊗A|1&gt;). For this to be proportional to |00&gt;+|11&gt;, we need A|0&gt; and A|1&gt; to be such that A|0&gt; is either |0&gt; or |1&gt;? Actually, let&rsquo;s derive: For a Bell state |Φ^+&gt; = (|00&gt;+|11&gt;)/√2, consider an operator U⊗V. We want U⊗V|Φ^+&gt; = c|Φ^+&gt;. This implies that U|0&gt;⊗V|0&gt; + U|1&gt;⊗V|1&gt; is proportional to |00&gt;+|11&gt;. This forces that U|0&gt; and V|0&gt; are related, and U|1&gt; and V|1&gt; are related. In fact, it is known that the only Pauli operators that preserve the Bell state are those with U=V up to a sign? Actually, check: If U=X and V=X, then it works. If U=X and V=Y, then X|0&gt;=|1&gt;, Y|0&gt;=-i|1&gt; so that gives -i|11&gt;, and X|1&gt;=|0&gt;, Y|1&gt;=i|0&gt; gives i|00&gt;, so total = i(|00&gt;-|11&gt;), which is not proportional to |00&gt;+|11&gt; generally. So indeed, the condition is that U and V must be the same Pauli (up to a global phase) for the Bell state to be an eigenvector. And then the eigenvalue is? For U=V=X, eigenvalue = 1. For U=V=Y, eigenvalue = -1. For U=V=Z, eigenvalue = 1. So indeed, the Paulis on two qubits that leave the Bell state invariant are exactly X⊗X, Y⊗Y, Z⊗Z. So that is correct.</p>
<p>Therefore, the fidelity is the probability that the errors are such that on each CNOT, the error is either no error or one of these three Paulis that act as identity on the Bell state on that pair. But careful: The errors are applied after each CNOT. But we argued that these errors propagate to become Pauli errors on the final state. And that final state is |ψ_ideal&gt; if and only if the combined error is one that acts as identity on |ψ_ideal&gt;. And since |ψ_ideal&gt; is a product of two Bell states, the condition is that on the pair (0,3), the error must be either I or one of {X⊗X, Y⊗Y, Z⊗Z} and on the pair (1,2), the error must be either I or one of {X⊗X, Y⊗Y, Z⊗Z}. But wait: Is that independent? Yes, because they act on different pairs. So the probability that the final state is exactly |ψ_ideal&gt; is: 
Probability from first CNOT that the error is in {I, X⊗X, Y⊗Y, Z⊗Z} = (1-p) + 3*(p/15) = 1-p + p/5 = 1 - (4/5)p.
Probability from second CNOT similarly: 1 - (4/5)p.
And since they are independent, overall probability = (1 - (4/5)p)^2 = 1 - (8/5)p + (16/25)p^2.
So that is the fidelity. So indeed, F = 1 - (8/5)p + (16/25)p^2.</p>
<p>But wait: Could there be errors that are not exactly these but still give some overlap? For example, if an error gives a phase of -1, then the state is -|ψ_ideal&gt;, so the fidelity would still be 1 because |&lt;-ψ_ideal|ψ_ideal&gt;|^2 = 1. So actually, we want the fidelity, which is &lt;ψ_ideal|ρ|ψ_ideal&gt;. And if the state is -|ψ_ideal&gt;, then that term contributes 1. So we should include errors that give a phase of -1 as well. And we already did: For the Bell state, Y⊗Y gives -1, so that is included. So that&rsquo;s correct.</p>
<p>So then the fidelity is exactly the probability that the error on each CNOT is such that the resulting Pauli on that pair is in the set {I, X⊗X, Y⊗Y, Z⊗Z}. And that probability is: For a single CNOT error channel, the probability of no error is (1-p) and the probability of each specific Pauli error is p/15. So the total probability for that CNOT to yield an error that is &ldquo;good&rdquo; (i.e., doesn&rsquo;t change the state) is: (1-p) + 3*(p/15) = 1-p + p/5 = 1 - (4/5)p.
And since the two CNOTs are independent, the overall probability that the final state is |ψ_ideal&gt; (up to a phase) is (1 - (4/5)p)^2.
So the fidelity F = (1 - 4p/5)^2 = 1 - 8p/5 + 16p^2/25.</p>
<p>Thus the physical state fidelity as a function of p is: 
F = 1 - (8/5)p + (16/25)p^2.</p>
<p>That is the answer.</p>
<p>But wait: The problem asks: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; 
So answer: F = 1 - (8/5)p + (16/25)p^2.</p>
<p>I&rsquo;ll double-check: 
For p=0, F=1.
For small p, F ≈ 1 - 1.6p.
That seems plausible.</p>
<p>So final answer for subproblem 1.</p>
<p>I&rsquo;ll now output in Markdown format.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-understand-the-circuit-and-the-ideal-state">Step 1. Understand the Circuit and the Ideal State</h3>
<p>The goal is to prepare the logical GHZ state  </p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the <span class="arithmatex">\([[4,2,2]]\)</span> code, using the circuit:  </p>
<div class="arithmatex">\[
(\text{CNOT}_{03}) (H_0) (\text{CNOT}_{21}) (H_2).
\]</div>
<p>In quantum circuit order (right-to-left), the operations are:</p>
<ol>
<li>Apply <span class="arithmatex">\(H\)</span> on qubit 2.</li>
<li>Apply <span class="arithmatex">\(\text{CNOT}_{21}\)</span> (control qubit 2, target qubit 1).</li>
<li>Apply <span class="arithmatex">\(H\)</span> on qubit 0.</li>
<li>Apply <span class="arithmatex">\(\text{CNOT}_{03}\)</span> (control qubit 0, target qubit 3).</li>
</ol>
<p>Starting from the initial state <span class="arithmatex">\(|0000\rangle\)</span>, the ideal final state is:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right).
\]</div>
<p>This state can be rewritten as a product of two Bell states:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}, \quad \text{where} \quad |\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}.
\]</div>
<hr />
<h3 id="step-2-model-the-errors">Step 2. Model the Errors</h3>
<p>Each <span class="arithmatex">\(\text{CNOT}\)</span> gate is followed by a two-qubit depolarizing error channel on its target qubits. The error channel acts as:</p>
<div class="arithmatex">\[
\rho \mapsto (1 - p) \rho + \frac{p}{15} \sum_{E \neq I} E \rho E^\dagger,
\]</div>
<p>where <span class="arithmatex">\(E\)</span> is a non-identity two-qubit Pauli operator on the qubits involved, and <span class="arithmatex">\(p\)</span> is the error probability per gate.</p>
<p>There are two <span class="arithmatex">\(\text{CNOT}\)</span> gates:</p>
<ul>
<li><span class="arithmatex">\(\text{CNOT}_{21}\)</span>: error acts on qubits 1 and 2.</li>
<li><span class="arithmatex">\(\text{CNOT}_{03}\)</span>: error acts on qubits 0 and 3.</li>
</ul>
<p>Since the Hadamard gates are perfect, the only errors come from these two channels.</p>
<hr />
<h3 id="step-3-propagate-errors-to-the-final-state">Step 3. Propagate Errors to the Final State</h3>
<p>An error <span class="arithmatex">\(E\)</span> on qubits 1 and 2 (after <span class="arithmatex">\(\text{CNOT}_{21}\)</span>) commutes with subsequent gates <span class="arithmatex">\(H_0\)</span> and <span class="arithmatex">\(\text{CNOT}_{03}\)</span>, so the final state becomes <span class="arithmatex">\(E |\psi_{\text{ideal}}\rangle\)</span>. Similarly, an error <span class="arithmatex">\(F\)</span> on qubits 0 and 3 (after <span class="arithmatex">\(\text{CNOT}_{03}\)</span>) gives <span class="arithmatex">\(F |\psi_{\text{ideal}}\rangle\)</span>. If both errors occur, the final state is <span class="arithmatex">\(FE |\psi_{\text{ideal}}\rangle\)</span>.</p>
<p>Thus, the final density matrix is a mixture:</p>
<div class="arithmatex">\[
\rho = (1 - p)^2 |\psi_{\text{ideal}}\rangle\langle\psi_{\text{ideal}}| 
+ \frac{p}{15}(1 - p) \sum_{E} |E \psi_{\text{ideal}}\rangle\langle E \psi_{\text{ideal}}|
+ \frac{p}{15}(1 - p) \sum_{F} |F \psi_{\text{ideal}}\rangle\langle F \psi_{\text{ideal}}|
+ \left( \frac{p}{15} \right)^2 \sum_{E,F} |FE \psi_{\text{ideal}}\rangle\langle FE \psi_{\text{ideal}}|,
\]</div>
<p>where <span class="arithmatex">\(E\)</span> and <span class="arithmatex">\(F\)</span> range over non-identity two-qubit Pauli operators on qubits <span class="arithmatex">\(\{1,2\}\)</span> and <span class="arithmatex">\(\{0,3\}\)</span>, respectively.</p>
<p>The fidelity is:</p>
<div class="arithmatex">\[
F = \langle \psi_{\text{ideal}} | \rho | \psi_{\text{ideal}} \rangle.
\]</div>
<p>This is the total probability that the final state is <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> (up to a global phase).</p>
<hr />
<h3 id="step-4-determine-which-errors-preserve-the-state">Step 4. Determine Which Errors Preserve the State</h3>
<p>Since <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}\)</span>, an error preserves the state if it acts as identity (up to a phase) on each Bell pair.</p>
<p>For a Bell state <span class="arithmatex">\(|\Phi^+\rangle = (|00\rangle + |11\rangle)/\sqrt{2}\)</span>, the two-qubit Pauli operators that leave it invariant (up to a phase) are:</p>
<div class="arithmatex">\[
X \otimes X, \quad Y \otimes Y, \quad Z \otimes Z.
\]</div>
<p>All other non-identity Pauli operators yield <span class="arithmatex">\(\langle \Phi^+ | P | \Phi^+ \rangle = 0\)</span>.</p>
<p>Therefore:</p>
<ul>
<li>On qubits 1 and 2, the “good” errors are <span class="arithmatex">\(I\)</span>, <span class="arithmatex">\(X \otimes X\)</span>, <span class="arithmatex">\(Y \otimes Y\)</span>, and <span class="arithmatex">\(Z \otimes Z\)</span>.</li>
<li>On qubits 0 and 3, the “good” errors are the same set.</li>
</ul>
<hr />
<h3 id="step-5-compute-the-fidelity">Step 5. Compute the Fidelity</h3>
<p>The probability that a single <span class="arithmatex">\(\text{CNOT}\)</span> error channel yields a “good” error is:</p>
<div class="arithmatex">\[
P_{\text{good}} = (1 - p) + 3 \cdot \frac{p}{15} = 1 - p + \frac{p}{5} = 1 - \frac{4}{5}p.
\]</div>
<p>Since the two error channels are independent, the total probability that the final state is <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> is:</p>
<div class="arithmatex">\[
F = \left(1 - \frac{4}{5}p \right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2.
\]</div>
<hr />
<h3 id="final-answer">Final Answer:</h3>
<div class="arithmatex">\[
\boxed{1 - \frac{8}{5}p + \frac{16}{25}p^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are asked: &ldquo;What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate p, assuming the state is post-selected on all detectable errors in the code?&rdquo;</p>
<p>Interpretation: We have the same circuit as before. But now we post-select on detectable errors. That means we measure the stabilizers (XXXX and ZZZZ) and only keep outcomes that are +1? But careful: &ldquo;post-selected on all detectable errors&rdquo; means that if an error is detected (i.e., if the syndrome is non-trivial), we discard the state. So we only keep states that have no detectable error. But note: The code [[4,2,2]] has distance 2, so it can detect any single-qubit error? Actually, [[4,2,2]] code: stabilizers: XXXX and ZZZZ. The weight of these stabilizers is 4. They can detect errors of weight 1? Check: A single-qubit Pauli error: say X on qubit 0. Then it will anti-commute with ZZZZ? Actually, ZZZZ commutes with X? Actually, X and Z anticommute. So X on qubit 0 will anti-commute with Z on qubit 0, so with ZZZZ, so it will flip the sign. So yes, it is detectable. So any single-qubit error is detectable. But wait: The errors we have are two-qubit errors from depolarizing channels on CNOT gates. But these errors are on specific pairs: first CNOT gives errors on qubits 1 and 2; second gives errors on qubits 0 and 3. So these errors can be weight 1 or weight 2. They are detectable if they anti-commute with at least one stabilizer. But note: Some errors might be undetectable? For example, an error that is a stabilizer itself? But stabilizers are XXXX and ZZZZ. But our errors are on two qubits only. Could a two-qubit error be undetectable? For instance, if the error is X⊗X on qubits 1 and 2, then does it commute with XXXX? XXXX acts on all qubits. X⊗X on qubits 1,2 will commute with XXXX if the product on qubits 1,2 gives? Actually, check: X⊗X on qubits 1,2 and XXXX: On qubits 1 and 2, we have X and X, so they commute. On qubits 0 and 3, identity commutes. So X⊗X on qubits 1,2 commutes with XXXX. With ZZZZ: ZZZZ on qubits 1,2: Z and Z, so commute. So X⊗X on qubits 1,2 is actually a logical operator? Actually, wait: The logical operators are given: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI. So X⊗X on qubits 1,2 is not exactly a logical operator? But it might be equivalent to a stabilizer times a logical operator? Let&rsquo;s check: X⊗X on qubits 1,2 means: qubit1: X, qubit2: X, qubit0: I, qubit3: I. That operator commutes with both stabilizers? Check with XXXX: product over qubits: I, X, X, I -&gt; overall, it commutes because it&rsquo;s just product of two X&rsquo;s. With ZZZZ: I, Z, Z, I -&gt; commutes. So this error is undetectable. But wait, is it harmful? It might change the logical state. But we are post-selecting on detectable errors. So if an error is undetectable, it will not be detected by the stabilizer measurements. So then such states are not discarded? But the problem says: &ldquo;post-selected on all detectable errors&rdquo;. That means we only keep states that yield trivial syndrome. So if an error is undetectable (i.e., it commutes with both stabilizers), then it will not trigger a detection. So those states are kept. But then the logical fidelity might be affected because those errors might change the logical state.</p>
<p>So we need to compute the logical fidelity after post-selection. That is: We want the fidelity of the logical state (on qubits A and B) given that the syndrome measurement结果 is trivial (i.e., no error detected). So we condition on the event that the stabilizers measure +1.</p>
<p>Let&rsquo;s denote the ideal logical state as |Ψ⟩_L = (|00⟩_L + |11⟩_L)/√2.
We have errors from the two CNOT gates. As before, these errors become Pauli errors on the final state. So the final state (before post-selection) is a mixture of states of the form P |ψ_ideal⟩, where P is a Pauli operator on the 4 qubits that comes from the product of errors from the two CNOT steps. But careful: The errors are applied after each CNOT. But as argued, they propagate to become Pauli errors on the final state. And they act on disjoint sets: first error acts on qubits 1,2; second on qubits 0,3. So overall, the error is of the form E ⊗ F, where E is a Pauli on qubits 1,2 and F is a Pauli on qubits 0,3. And the probability distribution: 
With probability (1-p)^2, no error.
With probability p(1-p)/15 for each non-identity E on {1,2} (15 possibilities)
With probability p(1-p)/15 for each non-identity F on {0,3}
With probability p^2/225 for each pair (E,F) with both non-identity.</p>
<p>So total: The final state is: 
ρ = ∑_{E,F} Pr(E,F) ( (E⊗F) |ψ_ideal⟩⟨ψ_ideal| (E⊗F)^† )
where Pr(I,I) = (1-p)^2,
Pr(E,I) = p(1-p)/15 for E ≠ I,
Pr(I,F) = p(1-p)/15 for F ≠ I,
Pr(E,F) = p^2/225 for E,F ≠ I.</p>
<p>Now, we post-select on the syndrome being trivial. That means we measure the stabilizers S1 = XXXX and S2 = ZZZZ. We only keep if both measure +1. So we want the conditional state given that the error operator commutes with both stabilizers? Actually, careful: The syndrome is trivial if the error operator is in the normalizer of the stabilizer group? Actually, for a stabilizer code, an error E is detectable if it anti-commutes with at least one stabilizer. So if E commutes with all stabilizers, then it is not detected. So post-selection keeps states where the error operator is in the centralizer of the stabilizer group. But note: The centralizer includes the stabilizer group itself and the logical operators. So we only keep errors that are in the set of Paulis that commute with XXXX and ZZZZ.</p>
<p>So we need to determine, for each error operator P = E⊗F (where E acts on qubits 1,2 and F acts on qubits 0,3), whether it is detectable or not. And then the post-selected state is proportional to the sum over those P that are in the centralizer.</p>
<p>But wait: There is also the possibility that the error might be a stabilizer itself? But stabilizers act trivially on the code space. So if the error is a stabilizer, then it does not change the logical state. So such errors are &ldquo;good&rdquo; in terms of fidelity because they yield the same logical state. But they are undetectable? Actually, stabilizers are undetectable because they commute with all stabilizers. So they are kept.</p>
<p>So we want the logical fidelity after post-selection. That is: Given that the syndrome is trivial, what is the probability that the logical state is correct? That is: F_logical = ⟨Ψ_L| ρ_logical |Ψ_L⟩, where ρ_logical is the reduced state on the logical qubits after post-selection.</p>
<p>Since the code is a stabilizer code, the effect of an error P on the logical state is given by the logical operator associated with P (if any). Specifically, if P is in the normalizer of the stabilizer group, then it acts as a logical operator on the code space. So we need to determine, for each error pattern P that is undetectable (i.e., commutes with both stabilizers), what logical operator does it correspond to? And then the fidelity will be the probability that the logical operator is the identity (up to stabilizers) relative to the total probability of undetectable errors.</p>
<p>So steps:</p>
<ol>
<li>List all error operators P = E ⊗ F, where E is a Pauli on qubits 1,2 and F is a Pauli on qubits 0,3. But note: They come from independent distributions on the two CNOTs. But careful: The distribution is not uniform over all Paulis on 4 qubits? Actually, it is: The probability for a given P = (E,F) is: 
If E=I and F=I: (1-p)^2.
If E≠I, F=I: p(1-p)/15.
If E=I, F≠I: p(1-p)/15.
If E≠I, F≠I: p^2/225.</li>
</ol>
<p>But note: There are 15 possibilities for E≠I and 15 for F≠I, so total 1 + 15 + 15 + 225 = 256, which is all Paulis on 4 qubits? Actually, Paulis on 4 qubits have 4^4 = 256 elements. But here our distribution is not uniform over all Paulis because the errors on the two pairs are independent? Actually, it is: The probability of a Pauli P that factors as P = P_{0,3} ⊗ P_{1,2} is as given. But not every Pauli on 4 qubits factors that way? Actually, any Pauli on 4 qubits can be written as a product of Paulis on qubits 0,3 and qubits 1,2 if they act on disjoint sets? Yes, because the Pauli group on 4 qubits is the tensor product of the Pauli groups on qubits 0,3 and on qubits 1,2. So indeed, every Pauli on 4 qubits can be written as F ⊗ E, where F acts on qubits 0 and 3, and E acts on qubits 1 and 2. So our distribution covers all Paulis. But careful: The distribution is not uniform over all Paulis because the probabilities depend on whether the Pauli is identity on each pair. So it&rsquo;s: 
Pr(P) = (1-p)^2 if P = I⊗I.
Pr(P) = p(1-p)/15 if P is non-identity on one pair and identity on the other.
Pr(P) = p^2/225 if P is non-identity on both pairs.</p>
<p>So that is the distribution.</p>
<ol start="2">
<li>Determine which Paulis are undetectable. A Pauli P is undetectable if it commutes with both stabilizers S1 = XXXX and S2 = ZZZZ.
Since P factors as P = F ⊗ E, where F acts on qubits 0,3 and E acts on qubits 1,2, we can compute commutation with S1 and S2.
S1 = XXXX = (X⊗X)<em>{0,3} ⊗ (X⊗X)</em>{1,2}. So P commutes with S1 if and only if F commutes with X⊗X on qubits 0,3 and E commutes with X⊗X on qubits 1,2? Actually, careful: P and S1 commute if the number of anticommuting pairs is even? But since they act on disjoint sets, actually P commutes with S1 if and only if F commutes with X⊗X and E commutes with X⊗X? Actually, because S1 = (X⊗X)<em>{03} ⊗ (X⊗X)</em>{12}. And P = F ⊗ E. Then P S1 = (F (X⊗X)) ⊗ (E (X⊗X)). And S1 P = ((X⊗X) F) ⊗ ((X⊗X) E). So for these to be equal, we need F and X⊗X to commute, and E and X⊗X to commute. So condition: [F, X⊗X] = 0 and [E, X⊗X] = 0.
Similarly, S2 = ZZZZ = (Z⊗Z)<em>{03} ⊗ (Z⊗Z)</em>{12}. So we need [F, Z⊗Z] = 0 and [E, Z⊗Z] = 0.</li>
</ol>
<p>So what are the Paulis on two qubits that commute with both X⊗X and Z⊗Z? Let&rsquo;s consider a Pauli on two qubits. It can be written as ± i^? But we ignore phases because commutation is determined by the Pauli matrices themselves. So we want: A two-qubit Pauli operator (on two specific qubits) that commutes with X⊗X and Z⊗Z.
Let&rsquo;s denote a Pauli on two qubits as A ⊗ B, where A,B ∈ {I, X, Y, Z} but not both I? Actually, we include identity as well.
We want: [A⊗B, X⊗X] = 0. This means that A and X commute? Actually, careful: (A⊗B)(X⊗X) = (A X) ⊗ (B X). And (X⊗X)(A⊗B) = (X A) ⊗ (X B). So we need A X = ± X A? Actually, for them to commute, we need that A and X commute and B and X commute? But wait: If A and X anticommute, then A X = - X A. Then (A⊗B)(X⊗X) = (-X A) ⊗ (B X). And (X⊗X)(A⊗B) = (X A) ⊗ (X B). For these to be equal, we would need -1 * (X A) ⊗ (B X) = (X A) ⊗ (X B) for all states? That would require B X = - X B as well, so that the minus signs multiply to give +1? Actually, let&rsquo;s do it properly:
We want (A⊗B)(X⊗X) = (X⊗X)(A⊗B). 
Left: (A X) ⊗ (B X).
Right: (X A) ⊗ (X B).
So we need A X = ε X A and B X = δ X B such that (ε)(δ) = 1. Since ε, δ are ±1. So condition: ε δ = 1, i.e., ε = δ.
So [A⊗B, X⊗X] = 0 if and only if A and X either both commute or both anticommute? Actually, if A anticommutes with X, then ε = -1. So we need B also anticommutes with X to get δ = -1, then product = 1. So condition: The number of anticommutations mod 2? Actually, simpler: A⊗B commutes with X⊗X if and only if the parity of anticommutation of A with X is the same as the parity of anticommutation of B with X? But wait, check: I and X: I commutes with X, so parity 0. So if A=I, then we need B to commute with X. So that means if A=I, then B must be I or Z? Because Z commutes with X? Actually, X and Z anticommute. So Z anticommutes with X. So if A=I (commutes), then B must commute with X. Which Paulis commute with X? I and X commute with X? Actually, X commutes with X. Y anticommutes with X. Z anticommutes with X. So for A=I, we need B such that B commutes with X: that is I and X. But wait, check: I⊗X: I commutes with X, X commutes with X? Actually, X commutes with X, so I⊗X commutes with X⊗X? Let&rsquo;s check: (I⊗X)(X⊗X) = X ⊗ (X X) = X⊗I? Actually, do properly: 
I⊗X and X⊗X. 
(I⊗X)(X⊗X) = (I X) ⊗ (X X) = X ⊗ (X^2) = X ⊗ I.
(X⊗X)(I⊗X) = (X I) ⊗ (X X) = X ⊗ (X^2) = X ⊗ I.
So yes, I⊗X commutes.
What about I⊗Z? 
(I⊗Z)(X⊗X) = X ⊗ (Z X) = X ⊗ ( - X Z) = - X ⊗ (X Z).
(X⊗X)(I⊗Z) = X ⊗ (X Z) = X ⊗ (X Z).
So they anticommute. So condition: For A⊗B to commute with X⊗X, we need that the number of Paulis that anticommute with X is even. That is: Let f(A) = 0 if A commutes with X, and 1 if A anticommutes with X. Then we need f(A) + f(B) even.
Similarly, for commutation with Z⊗Z: We need that the number of Paulis that anticommute with Z is even. For Z: Which Paulis anticommute with Z? X and Y anticommute with Z; I and Z commute with Z.
So conditions for a two-qubit Pauli (on a pair) to be in the centralizer of the stabilizers on that pair? Actually, careful: Our stabilizers are XXXX and ZZZZ. But we are breaking it into two pairs: qubits 0,3 and qubits 1,2. But note: The condition for the full Pauli P = F⊗E to commute with S1 is that F commutes with X⊗X and E commutes with X⊗X? Actually, as derived: P commutes with S1 if and only if F and X⊗X commute and E and X⊗X commute? Is that correct? Let&rsquo;s check: P = F⊗E, S1 = (X⊗X)⊗(X⊗X). Then P S1 = (F (X⊗X)) ⊗ (E (X⊗X)). S1 P = ((X⊗X) F) ⊗ ((X⊗X) E). For these to be equal for all states, we need F (X⊗X) = (X⊗X) F and E (X⊗X) = (X⊗X) E. So yes, independently, F must commute with X⊗X and E must commute with X⊗X. Similarly, for S2: F must commute with Z⊗Z and E must commute with Z⊗Z.
So we need to determine, for a two-qubit Pauli operator on a pair (say on qubits 0,3), what are the operators that commute with both X⊗X and Z⊗Z?
Let&rsquo;s denote a Pauli on two qubits as A⊗B. Conditions:
Commutes with X⊗X: f_X(A) + f_X(B) is even.
Commutes with Z⊗Z: f_Z(A) + f_Z(B) is even.
Where:
f_X(I)=0, f_X(X)=0? Actually, check: I commutes with X, so f_X(I)=0.
X commutes with X? Actually, X and X: they commute? Yes, because X X = X X. So f_X(X)=0.
Y: Y anticommutes with X? Actually, X Y = - Y X, so f_X(Y)=1.
Z: Z anticommutes with X? Actually, X Z = - Z X, so f_X(Z)=1.
So f_X: I-&gt;0, X-&gt;0, Y-&gt;1, Z-&gt;1.
f_Z: I-&gt;0, Z-&gt;0, X-&gt;1, Y-&gt;1.
So conditions:
For A⊗B to commute with X⊗X: f_X(A)+f_X(B) even.
For A⊗B to commute with Z⊗Z: f_Z(A)+f_Z(B) even.</p>
<p>Now, list all two-qubit Paulis (16 of them) and check which ones commute with both X⊗X and Z⊗Z.
The Paulis on two qubits are: </p>
<ol>
<li>I⊗I: f_X(0+0)=0 even, f_Z(0+0)=0 even. So yes.</li>
<li>I⊗X: f_X(0+0)=0 even; f_Z(0+1)=1 odd. So no.</li>
<li>I⊗Y: f_X(0+1)=1 odd; so no.</li>
<li>I⊗Z: f_X(0+1)=1 odd; so no.</li>
<li>X⊗I: f_X(0+0)=0; f_Z(1+0)=1 odd; so no.</li>
<li>X⊗X: f_X(0+0)=0; f_Z(1+1)=2 even; so yes.</li>
<li>X⊗Y: f_X(0+1)=1 odd; so no.</li>
<li>X⊗Z: f_X(0+1)=1 odd; so no.</li>
<li>Y⊗I: f_X(1+0)=1 odd; so no.</li>
<li>Y⊗X: f_X(1+0)=1 odd; so no.</li>
<li>Y⊗Y: f_X(1+1)=2 even; f_Z(1+1)=2 even; so yes.</li>
<li>Y⊗Z: f_X(1+1)=2 even; f_Z(1+0)=1 odd; so no.</li>
<li>Z⊗I: f_X(1+0)=1 odd; so no.</li>
<li>Z⊗X: f_X(1+0)=1 odd; so no.</li>
<li>Z⊗Y: f_X(1+1)=2 even; f_Z(0+1)=1 odd; so no.</li>
<li>Z⊗Z: f_X(1+1)=2 even; f_Z(0+0)=0 even; so yes.</li>
</ol>
<p>So on each pair, the Paulis that commute with both X⊗X and Z⊗Z are: I⊗I, X⊗X, Y⊗Y, Z⊗Z. That is 4 operators. But wait, what about -I⊗I? That is not considered separately because we consider Paulis up to phase? Actually, our Pauli set is exactly these 16? But careful: The Pauli group on two qubits has 16 elements if we include signs? But usually, when we say &ldquo;Pauli error&rdquo;, we mean one of the operators from the set {I, X, Y, Z} for each qubit, and we don&rsquo;t include overall phases? Actually, the depolarizing channel is defined as: with probability p/15, apply a non-identity Pauli from the set of 15. That set does not include negative signs? Actually, it does include? Typically, the depolarizing channel is: ρ -&gt; (1-p)ρ + (p/3)(XρX + YρY + ZρZ) for single qubit. For two qubits, it is: ρ -&gt; (1-p)ρ + (p/15) ∑_{P in {I,X,Y,Z}⊗2 \ {I⊗I}} P ρ P. So indeed, the set is exactly these 15 non-identity operators. And they are exactly the ones listed from 2 to 16 above. And then plus identity. So on each pair, the operators that are undetectable (commute with both stabilizers) are: I, X⊗X, Y⊗Y, Z⊗Z. But wait: Check: I is identity. So that&rsquo;s 1. And then there are 3 non-identity ones: X⊗X, Y⊗Y, Z⊗Z. So that matches our earlier finding from the Bell state perspective. So indeed, on each pair, the probability that an error is undetectable is: Probability that the error on that CNOT is in {I, X⊗X, Y⊗Y, Z⊗Z} = (1-p) + 3*(p/15) = 1 - p + p/5 = 1 - 4p/5.
And the probability that it is detectable is the complement: 4p/5? Actually, total probability is 1, so detectable probability = 1 - (1 - 4p/5) = 4p/5. That makes sense.</p>
<p>But careful: That is for one CNOT error channel. But note: The errors on the two CNOTs are independent. So the overall probability that the total error P = F⊗E is undetectable is: It is undetectable if and only if F is undetectable on its pair and E is undetectable on its pair. Because as we derived, P commutes with S1 and S2 if and only if F commutes with X⊗X and Z⊗Z, and E commutes with X⊗X and Z⊗Z. So the set of undetectable errors is exactly: {F undetectable} ⊗ {E undetectable}. And that set has size: 4 * 4 = 16 Paulis. But wait: Are all these 16 actually undetectable? Check: For example, F = I, E = I gives identity.
F = I, E = X⊗X gives overall: I⊗(X⊗X) on qubits 0,3 and 1,2. That commutes? Yes.
So indeed, the undetectable set U is: U = { I, X⊗X, Y⊗Y, Z⊗Z } on qubits 0,3} × { I, X⊗X, Y⊗Y, Z⊗Z } on qubits 1,2}.
So there are 16 undetectable errors.</p>
<p>Now, among these undetectable errors, some will act trivially on the logical state (i.e., they are stabilizers or identity) and some will act as non-identity logical operators. We want the logical fidelity after post-selection. That is: Given that the error is undetectable, what is the probability that the logical state is still the ideal state? That probability is: (Probability that the error is in the set that acts as identity on the logical space) / (Total probability of undetectable errors).</p>
<p>So we need to determine, for each undetectable error P = F ⊗ E (with F in {I, X⊗X, Y⊗Y, Z⊗Z} on qubits 0,3 and E in the same set on qubits 1,2), what is its action on the logical state? The logical state we want is |Ψ⟩<em>L = (|00⟩_L + |11⟩_L)/√2. But careful: The logical operators are given: 
X_A = XIXI, 
X_B = XXII,
Z_A = ZZII,
Z_B = ZIZI.
We need to see how these undetectable errors act on the code space. Alternatively, we can use the fact that the ideal state is a product of two Bell states. And we already computed that on a Bell state, the operators that act as identity (up to phase) are exactly I, X⊗X, Y⊗Y, Z⊗Z? But wait: That was for the Bell state itself. But careful: The logical state is not just the Bell state on each pair? Actually, it is: |ψ_ideal⟩ = |Φ^+⟩</em>{03} ⊗ |Φ^+⟩<em>{12}. So if an error P = F ⊗ E acts on it, then the resulting state is (F|Φ^+⟩</em>{03}) ⊗ (E|Φ^+⟩<em>{12}). And we want this state to be the same as |Φ^+⟩</em>{03} ⊗ |Φ^+⟩<em>{12} up to a global phase. That happens if and only if F|Φ^+⟩ = c_F |Φ^+⟩ and E|Φ^+⟩ = c_E |Φ^+⟩ with c_F * c_E = 1? Actually, we want the product to be exactly |ψ_ideal⟩. But since |ψ_ideal⟩ is a product state, it will be preserved if each factor is preserved up to a phase, and the phases multiply to 1. But wait: The logical state is defined on the code space. But here, if we get a phase, that is still the same logical state because global phase doesn&rsquo;t matter. However, if one factor gets a phase of -1 and the other gets -1, then product phase is 1. So actually, we want that the error does not change the logical state if and only if F|Φ^+⟩ is proportional to |Φ^+⟩ and E|Φ^+⟩ is proportional to |Φ^+⟩. But we already computed: For a Bell state, the operators that leave it invariant (up to a phase) are exactly I, X⊗X, Y⊗Y, Z⊗Z. But careful: They give phases: 
I gives phase 1.
X⊗X gives phase 1.
Y⊗Y gives phase -1.
Z⊗Z gives phase 1.
So, if F is I or X⊗X or Z⊗Z, then F|Φ^+⟩ = |Φ^+⟩.
If F is Y⊗Y, then F|Φ^+⟩ = -|Φ^+⟩.
Similarly for E.
So then, the product state will be unchanged if and only if (phase from F) * (phase from E) = 1. That is, if both are either from {I, X⊗X, Z⊗Z} or if both are Y⊗Y? Because Y⊗Y gives -1, so if both are Y⊗Y, then product phase = (-1)<em>(-1)=1. So actually, the errors that act trivially on the logical state are those for which F and E are either both in the set {I, X⊗X, Z⊗Z} OR both are Y⊗Y. But wait: Check: If F = Y⊗Y and E = I, then product phase = -1, so the state becomes -|ψ_ideal⟩. That is actually the same logical state because global phase -1 is irrelevant. Actually, careful: The logical state is a vector in the Hilbert space. If we multiply by -1, it is the same state. So actually, any global phase is acceptable. So we want the state to be exactly |ψ_ideal⟩ up to a global phase. That means that if F|Φ^+⟩ = c|Φ^+⟩ and E|Φ^+⟩ = d|Φ^+⟩, then the product is c</em>d|ψ_ideal⟩. And that is the same as |ψ_ideal⟩ if c<em>d is a complex number of modulus 1. But since these are ±1, we require that c</em>d = 1? Actually, if c<em>d = -1, then the state is -|ψ_ideal⟩, which is physically the same state. Because states are defined up to a global phase. So actually, any phase is fine. So wait: Then actually, any error that is of the form F⊗E where F and E are in {I, X⊗X, Y⊗Y, Z⊗Z} will give F|Φ^+⟩ = ±|Φ^+⟩ and E|Φ^+⟩ = ±|Φ^+⟩, so the product is ±|ψ_ideal⟩. That is the same logical state. So then it seems that all undetectable errors actually preserve the logical state? Is that true? Let&rsquo;s check: Consider an error that is, say, F = X⊗X on qubits 0,3 and E = I on qubits 1,2. Then as computed, X⊗X on |Φ^+⟩ gives |Φ^+⟩. So that gives |ψ_ideal⟩. 
What about F = Y⊗Y on qubits 0,3 and E = I on qubits 1,2? Then Y⊗Y gives -|Φ^+⟩, so product = -|ψ_ideal⟩, which is the same state.
What about F = Z⊗Z on qubits 0,3 and E = I? That gives |ψ_ideal⟩.
So it appears that any error that is undetectable (i.e., F and E are in {I, X⊗X, Y⊗Y, Z⊗Z}) will actually leave the logical state invariant? But wait, is that always true? Consider an error that is a logical operator. For example, what is the logical X operator on qubit A? X_A = XIXI. That acts on qubits: qubit0: X, qubit1: I, qubit2: X? Actually, careful: X_A = XIXI means: on qubit0: X, qubit1: I, qubit2: X, qubit3: I. That is not of the form F⊗E with F on qubits 0,3 and E on qubits 1,2? Because F on qubits 0,3 would be X⊗I, but that is not in our set because X⊗I is detectable? Actually, check: X⊗I on qubits 0,3: Does it commute with X⊗X? X⊗I and X⊗X: f_X(X)=0, f_X(I)=0, so that commutes with X⊗X? But wait, we computed earlier: X⊗I on two qubits: That is item 5? Actually, we computed: X⊗I: f_X(0+0)=0, but f_Z(1+0)=1, so it does not commute with Z⊗Z. So X⊗I is detectable. So indeed, logical operators are not in the undetectable set? But wait, the logical operators should be undetectable because they commute with the stabilizers. Let&rsquo;s check: X_A = X ⊗ I ⊗ X ⊗ I. Write it as on qubits 0,3: X⊗I, and on qubits 1,2: I⊗X? Actually, careful: X_A = on qubit0: X, qubit1: I, qubit2: X, qubit3: I. So if we group as (0,3) and (1,2), then X_A = (X⊗I)<em>{03} ⊗ (I⊗X)</em>{12}. But (I⊗X) on qubits 1,2: f_X(I)=0, f_X(X)=0 so okay for X⊗X? But f_Z(I)=0, f_Z(X)=1 so that gives odd, so it does not commute with Z⊗Z. So indeed, X_A is detectable? That is interesting: The logical operators given are: X_A = XIXI, X_B = XXII, Z_A = ZZII, Z_B = ZIZI. Let&rsquo;s check if they commute with the stabilizers. 
S1 = XXXX. X_A and S1: They act on each qubit: qubit0: X and X commute, qubit1: I and X commute, qubit2: X and X commute, qubit3: I and X commute. So X_A commutes with S1. 
S2 = ZZZZ. X_A: qubit0: X and Z anticommute, qubit1: I and Z commute, qubit2: X and Z anticommute, qubit3: I and Z commute. So overall, number of anticommutations: 2, which is even? Actually, careful: For two operators that are products of Paulis, they commute if the number of qubits where they anticommute is even. Here, on qubit0: X and Z anticommute, so that gives a factor of -1. On qubit2: another -1. So total factor = (-1)</em>(-1)=1. So X_A commutes with S2. So X_A is undetectable. But then our condition using the pair decomposition: X_A = (X⊗I)</em>{03} ⊗ (I⊗X)<em>{12}. For the (03) part: X⊗I. We determined that X⊗I does not commute with Z⊗Z? But wait, check: Z⊗Z on qubits 0,3 and X⊗I: On qubit0: X and Z anticommute, on qubit3: I and Z commute. So that gives a minus sign. So (X⊗I) anticommutes with (Z⊗Z). But then for the (12) part: I⊗X. On qubit1: I and Z commute, on qubit2: X and Z anticommute, so that also gives a minus sign. So overall, the product of these two minus signs gives plus. So indeed, when we break into pairs, the condition is not that each pair individually commutes with the stabilizers on that pair, but rather that the product of the commutation factors from each pair gives +1. Because S2 = (Z⊗Z)</em>{03} ⊗ (Z⊗Z)_{12}. And we have P = F ⊗ E. Then P S2 = (F (Z⊗Z)) ⊗ (E (Z⊗Z)). And S2 P = ((Z⊗Z) F) ⊗ ((Z⊗Z) E). For these to be equal, we need that F (Z⊗Z) = ε (Z⊗Z) F and E (Z⊗Z) = δ (Z⊗Z) E, and then we require that ε δ = 1. So the condition for commutation with S2 is that the signs from F and E multiply to 1. Similarly, for S1: we need that the signs from F and E with respect to X⊗X multiply to 1.
So let&rsquo;s redefine: For a two-qubit Pauli on a pair, define:
For F on qubits 0,3, let α(F) be such that F (X⊗X) = α(F) (X⊗X) F, and β(F) such that F (Z⊗Z) = β(F) (Z⊗Z) F.
Similarly, for E on qubits 1,2, define α(E) and β(E).
Then P = F⊗E commutes with S1 if α(F) α(E) = 1, and with S2 if β(F) β(E) = 1.
Now, what are α and β for the Paulis on two qubits? We computed earlier for each Pauli whether it commutes or anticommutes with X⊗X and Z⊗Z individually. But careful: That was when we considered the condition that the Pauli commutes with X⊗X. But actually, we want the sign. Let&rsquo;s compute for each Pauli on two qubits (on any pair) the signs α and β.
We&rsquo;ll list the 16 Paulis on two qubits. But note: We only care about the set of Paulis that can appear from the error channels? Actually, our errors on each pair come from the depolarizing channel: they are any Pauli from {I, X, Y, Z}⊗{I, X, Y, Z} with the probability distribution as given. But then when considering undetectable errors, we need to consider all Paulis that satisfy α(F)α(E)=1 and β(F)β(E)=1. That set is larger than the product of the sets that individually commute with X⊗X and Z⊗Z? Because it allows one to anticommute and the other to anticommute, so that the product gives commute.
So let&rsquo;s compute for each two-qubit Pauli, the signs α and β.
We&rsquo;ll use the following: For a single Pauli: 
I: commutes with X and Z so: α(I)=1, β(I)=1.
X: commutes with X? Actually, careful: For a single qubit, if we have operator A and we want A X = ? But here we are dealing with two-qubit operators and the operator is X⊗X. So we need to compute for a two-qubit Pauli F = A⊗B.
We want: (A⊗B)(X⊗X) = (A X)⊗(B X). And (X⊗X)(A⊗B) = (X A)⊗(X B). So the sign α is such that (A X)⊗(B X) = α (X A)⊗(X B). This will hold if A X = α_A (X A) and B X = α_B (X B) with α_A α_B = α. So actually, α(F) = (sign from A with X) * (sign from B with X). But careful: That is if we can separate? Actually, it&rsquo;s exactly: (A⊗B)(X⊗X) = (A X)⊗(B X) and (X⊗X)(A⊗B) = (X A)⊗(X B). For these to be equal, we need that for each term, A X = ε (X A) and B X = δ (X B) such that ε δ = 1? Actually, they don&rsquo;t have to be separately scalar because the tensor product: if A X = ε (X A) and B X = δ (X B), then (A⊗B)(X⊗X) = ε δ (X A)⊗(X B) = ε δ (X⊗X)(A⊗B). So indeed, α(F) = (commutation sign of A with X) * (commutation sign of B with X). But note: The commutation sign of a Pauli with X: 
I: +1
X: +1 (since X X = X X)
Y: -1 (X Y = -Y X)
Z: -1 (X Z = -Z X)
So α(F) = f(A)<em>f(B) where f(I)=1, f(X)=1, f(Y)=-1, f(Z)=-1.
Similarly, for β(F) with Z⊗Z: 
We need: (A⊗B)(Z⊗Z) = (A Z)⊗(B Z) and (Z⊗Z)(A⊗B) = (Z A)⊗(Z B). The commutation sign of a Pauli with Z:
I: +1
X: -1 (X Z = -Z X)
Y: -1 (Y Z = -Z Y)
Z: +1 (Z Z = Z Z)
So β(F) = g(A)</em>g(B) where g(I)=1, g(X)=-1, g(Y)=-1, g(Z)=1.</p>
<p>So now, let&rsquo;s list all two-qubit Paulis F (on any pair) and compute α(F) and β(F). I&rsquo;ll make a table for F = A⊗B:</p>
<ol>
<li>I⊗I: α=1<em>1=1, β=1</em>1=1.</li>
<li>I⊗X: α=1<em>1=1, β=1</em>(-1)=-1.</li>
<li>I⊗Y: α=1<em>(-1)=-1, β=1</em>(-1)=-1.</li>
<li>I⊗Z: α=1<em>(-1)=-1, β=1</em>1=1.</li>
<li>X⊗I: α=1<em>1=1, β=(-1)</em>1=-1.</li>
<li>X⊗X: α=1<em>1=1, β=(-1)</em>(-1)=1.</li>
<li>X⊗Y: α=1<em>(-1)=-1, β=(-1)</em>(-1)=1.</li>
<li>X⊗Z: α=1<em>(-1)=-1, β=(-1)</em>1=-1.</li>
<li>Y⊗I: α=(-1)<em>1=-1, β=(-1)</em>1=-1.</li>
<li>Y⊗X: α=(-1)<em>1=-1, β=(-1)</em>(-1)=1.</li>
<li>Y⊗Y: α=(-1)<em>(-1)=1, β=(-1)</em>(-1)=1.</li>
<li>Y⊗Z: α=(-1)<em>(-1)=1, β=(-1)</em>1=-1.</li>
<li>Z⊗I: α=(-1)<em>1=-1, β=1</em>1=1.</li>
<li>Z⊗X: α=(-1)<em>1=-1, β=1</em>(-1)=-1.</li>
<li>Z⊗Y: α=(-1)<em>(-1)=1, β=1</em>(-1)=-1.</li>
<li>Z⊗Z: α=(-1)<em>(-1)=1, β=1</em>1=1.</li>
</ol>
<p>So that is the table for any two-qubit Pauli on a pair.</p>
<p>Now, an error P = F⊗E is undetectable if:
α(F)α(E) = 1 and β(F)β(E) = 1.
So that means that α(F) and α(E) must be the same? Actually, they must multiply to 1, so they are both 1 or both -1.
And β(F) and β(E) must multiply to 1, so they are both 1 or both -1.</p>
<p>So the set of undetectable errors is: All pairs (F, E) such that α(F)=α(E) and β(F)=β(E). 
From the table, we can group the two-qubit Paulis by their (α, β) values:
(α, β) can be: 
(1,1): These are: I⊗I, X⊗X, Y⊗Y, Z⊗Z. (4 Paulis)
(1,-1): These are: I⊗Z? Check: I⊗Z: α=-1? Actually, I⊗Z: α = -1 from above? Wait, check I⊗Z: α = 1*? Let&rsquo;s recalc: I⊗Z: For I, f(I)=1; for Z, f(Z) = -1? Actually, careful: f(Z) for commutation with X: Z anticommutes with X, so f(Z) should be -1. So I⊗Z: α = 1 * (-1) = -1. So I⊗Z is not (1,-1). Let&rsquo;s do systematically:
We want (α, β) values:
From table:</p>
<ol>
<li>I⊗I: (1,1)</li>
<li>I⊗X: (1, -1)</li>
<li>I⊗Y: (-1, -1)</li>
<li>I⊗Z: (-1, 1)</li>
<li>X⊗I: (1, -1)</li>
<li>X⊗X: (1, 1)</li>
<li>X⊗Y: (-1, 1)</li>
<li>X⊗Z: (-1, -1)</li>
<li>Y⊗I: (-1, -1)</li>
<li>Y⊗X: (-1, 1)</li>
<li>Y⊗Y: (1, 1)</li>
<li>Y⊗Z: (1, -1)</li>
<li>Z⊗I: (-1, 1)</li>
<li>Z⊗X: (-1, -1)</li>
<li>Z⊗Y: (1, -1)</li>
<li>Z⊗Z: (1, 1)</li>
</ol>
<p>So grouping by (α, β):
(1,1): Items: 1, 6, 11, 16. So that&rsquo;s 4: I⊗I, X⊗X, Y⊗Y, Z⊗Z.
(1,-1): Items: 2, 5, 12, 15. So that&rsquo;s 4: I⊗X, X⊗I, Y⊗Z, Z⊗Y.
(-1,1): Items: 4, 7, 10, 13. So that&rsquo;s 4: I⊗Z, X⊗Y, Y⊗X, Z⊗I.
(-1,-1): Items: 3, 8, 9, 14. So that&rsquo;s 4: I⊗Y, X⊗Z, Y⊗I, Z⊗X.</p>
<p>So on each pair, there are 4 Paulis in each category.
Now, for P = F⊗E to be undetectable, we need:
α(F)α(E)=1 =&gt; α(F) = α(E).
β(F)β(E)=1 =&gt; β(F) = β(E).
So F and E must be in the same category. So the undetectable errors are those where F and E have the same (α,β) pair. There are 4 categories. For each category, there are 4 choices for F and 4 choices for E, so total 16 per category, so total undetectable errors = 4*16 = 64. But wait, that would be 64 out of 256 total Paulis. That makes sense because the code has distance 2, so it can detect any error of weight 1. Actually, the number of undetectable errors for a stabilizer code is |C(S)|/|S|? Actually, the normalizer of the stabilizer group has size 2^(2n-k) = 2^(8-2)=2^6=64. Yes, so there are 64 undetectable Pauli errors (ignoring phases). So that checks out: The undetectable set U has size 64. And they are exactly those for which F and E are in the same category.</p>
<p>Now, we need to determine, for each undetectable error P, what is its action on the logical state? The logical state is |ψ_ideal⟩ = |Φ^+⟩<em>{03} ⊗ |Φ^+⟩</em>{12}. And P = F⊗E. So the resulting state is (F|Φ^+⟩) ⊗ (E|Φ^+⟩). We want to know when this state is the same as |ψ_ideal⟩ up to a global phase. That is, when is (F|Φ^+⟩) ⊗ (E|Φ^+⟩) = γ |Φ^+⟩ ⊗ |Φ^+⟩ for some phase γ? Since |Φ^+⟩ is a Bell state, we know that for any two-qubit Pauli, acting on |Φ^+⟩ gives either ±|Φ^+⟩ or something else? Actually, not every Pauli will leave |Φ^+⟩ invariant. Let&rsquo;s compute: For a Bell state |Φ^+⟩ = (|00⟩+|11⟩)/√2. What is the action of a two-qubit Pauli on it? We can compute: 
For any Pauli F, F|Φ^+⟩ is either proportional to |Φ^+⟩ or to another Bell state? Actually, the Bell states are eigenstates of certain Paulis. Specifically, |Φ^+⟩ is an eigenvector of X⊗X and Z⊗Z with eigenvalue +1, and of Y⊗Y with eigenvalue -1. What about other Paulis? For example, take F = I⊗X. Then I⊗X|Φ^+⟩ = (|00⟩? Actually, compute: I⊗X|00⟩ = |01⟩, I⊗X|11⟩ = |10⟩. So that gives (|01⟩+|10⟩)/√2 which is |Ψ^+⟩. So that is a different Bell state. So indeed, only Paulis that are in the set that commute with both X⊗X and Z⊗Z? Actually, wait: The condition for F to leave |Φ^+⟩ invariant (up to a phase) is that F must be in the stabilizer of |Φ^+⟩? The stabilizer of |Φ^+⟩ is generated by X⊗X and Z⊗Z. So the Paulis that leave |Φ^+⟩ invariant are exactly those that are in the group generated by X⊗X and Z⊗Z. That group has elements: I, X⊗X, Y⊗Y, Z⊗Z. So indeed, if F is in {I, X⊗X, Y⊗Y, Z⊗Z}, then F|Φ^+⟩ = ±|Φ^+⟩. What are the signs? 
I: +1
X⊗X: +1 (since X⊗X|Φ^+⟩ = |Φ^+⟩)
Y⊗Y: -1 (Y⊗Y|Φ^+⟩ = -|Φ^+⟩)
Z⊗Z: +1 (Z⊗Z|Φ^+⟩ = |Φ^+⟩)
So if F is in that set, then F|Φ^+⟩ = either |Φ^+⟩ or -|Φ^+⟩.
Now, what if F is not in that set? Then F|Φ^+⟩ will be a different Bell state. For example, I⊗X gives |Ψ^+⟩. So then the resulting state would be |Ψ^+⟩<em>{03} ⊗ (E|Φ^+⟩</em>{12}). For this to be proportional to |Φ^+⟩<em>{03}⊗|Φ^+⟩</em>{12}, we would need that |Ψ^+⟩ is proportional to |Φ^+⟩, which is not true. So for the logical state to remain unchanged, we need that both F and E are in the set {I, X⊗X, Y⊗Y, Z⊗Z}. But wait, is that sufficient? If F and E are both in that set, then F|Φ^+⟩ = c_F|Φ^+⟩ with c_F = ±1, and E|Φ^+⟩ = c_E|Φ^+⟩ with c_E = ±1. Then the product is c_F c_E |ψ_ideal⟩. So that is the same state. So the condition for the error to not change the logical state is that F and E are in the set U0 = {I, X⊗X, Y⊗Y, Z⊗Z} on their respective pairs. But note: This set U0 corresponds to the category (1,1) from our table? Actually, from our table, the Paulis with (α,β)=(1,1) are exactly I, X⊗X, Y⊗Y, Z⊗Z. So that is 4 Paulis per pair.
But wait: What about errors that are undetectable but not in U0? For example, take F = I⊗X which is in category (1,-1) and E = I⊗X which is also in category (1,-1). Then α(F)=1, α(E)=1 so product=1; β(F)=-1, β(E)=-1 so product=1. So that error is undetectable. But what is its action on |ψ_ideal⟩? F = I⊗X on qubits 0,3: I⊗X|Φ^+⟩ =? As computed, I⊗X|Φ^+⟩ = (|01⟩+|10⟩)/√2 = |Ψ^+⟩. So then the state becomes |Ψ^+⟩<em>{03} ⊗ (I⊗X|Φ^+⟩</em>{12}) but careful: E is also I⊗X, so similarly, E|Φ^+⟩ = |Ψ^+⟩. So the resulting state is |Ψ^+⟩<em>{03} ⊗ |Ψ^+⟩</em>{12}. Is that the same logical state as |Φ^+⟩<em>{03}⊗|Φ^+⟩</em>{12}? Not necessarily. The logical state we want is (|00⟩<em>L+|11⟩_L)/√2. How is that encoded? Our encoding: |ψ_ideal⟩ = |Φ^+⟩</em>{03}⊗|Φ^+⟩<em>{12}. That is one specific state. If we act with a logical operator, we might get a different logical state. For instance, what is the logical X operator on qubit A? X_A = XIXI. In terms of pairs, that is: on qubits 0,3: X⊗I, and on qubits 1,2: I⊗X. That is not in the same category because X⊗I has (α,β) = (1,-1) and I⊗X has (1,-1) as well? Actually, check: X⊗I: from table, item 5: (1,-1). I⊗X: item 2: (1,-1). So indeed, X_A is undetectable. And it will change the logical state. So errors that are undetectable but not in U0 will act as non-identity logical operators. So then, for post-selection, we only keep errors that are undetectable. Among these, some will preserve the logical state (those with F and E in U0) and some will change it (those with F and E in the other categories). But wait: Could it be that an error from a different category still gives the same logical state? For example, if the error is a stabilizer? But stabilizers are in U0 because stabilizers are XXXX and ZZZZ. XXXX = (X⊗X)</em>{03} (X⊗X)<em>{12} which is in U0 because both factors are in U0. So that&rsquo;s fine.
What about errors that are logical operators? For example, X_A = (X⊗I)</em>{03} (I⊗X)_{12}. That is from category: (X⊗I) is (1,-1) and (I⊗X) is (1,-1). So that will map |ψ_ideal⟩ to X_A|ψ_ideal⟩. And that is a different logical state if |ψ_ideal⟩ is not an eigenstate of X_A. And indeed, |ψ_ideal⟩ is a GHZ state: (|00⟩+|11⟩)/√2. X_A flips the first logical qubit, so it becomes (|10⟩+|01⟩)/√2, which is different. So yes, that changes the logical state.
So, we want the logical fidelity after post-selection. That is: 
F_logical = (Probability that error is undetectable AND it acts as identity on the logical state) / (Probability that error is undetectable).</p>
<p>Now, let&rsquo;s compute these probabilities.
We have two independent error channels: one on pair (1,2) and one on pair (0,3). Their distributions are: 
For each pair, the probability distribution over the 16 Paulis is:
Pr(I) = 1-p.
For each non-identity Pauli, Pr(P) = p/15.
So, for a given pair, the probability that the error is in a particular set S (of Paulis) is: 
If S contains I, then contribution from I: (1-p).
And for each non-identity Pauli in S, contribution: p/15.
So if |S| = n (including I), then total probability = (1-p) + (n-1)*(p/15).</p>
<p>Now, for the error to be undetectable, we need that the errors on the two pairs belong to the same category. There are 4 categories. Let&rsquo;s denote the categories as:
Category 1: U0 = {I, X⊗X, Y⊗Y, Z⊗Z}. Size 4.
Category 2: U1 = {I⊗X, X⊗I, Y⊗Z, Z⊗Y}. Size 4.
Category 3: U2 = {I⊗Z, X⊗Y, Y⊗X, Z⊗I}. Size 4.
Category 4: U3 = {I⊗Y, X⊗Z, Y⊗I, Z⊗X}. Size 4.</p>
<p>And undetectable condition: The error on pair (0,3) is in some category i and the error on pair (1,2) is in the same category i.
So the total probability of undetectable error is:
P_undetect = Sum_{i=0}^{3} [Prob(F in U_i) * Prob(E in U_i)].
For each category, Prob(in U_i) = (1-p) + 3<em>(p/15) = 1-p + p/5 = 1 - 4p/5.
So P_undetect = 4 * (1 - 4p/5)^2? But wait, that would be if the categories were disjoint and cover all Paulis? But careful: The categories are disjoint and their union is all 16 Paulis? Actually, there are 4 categories each of size 4, so yes, they partition the set of Paulis on a pair. So indeed, for any pair, the probability that it falls into a particular category is exactly: (1-p) + 3</em>(p/15) = 1 - 4p/5. So then the probability that both pairs fall into the same category is: Sum_{i} (1 - 4p/5)^2 = 4<em>(1 - 4p/5)^2.
But wait, is that correct? That would be if the events for different categories were independent? But careful: The probability that a pair is in category i is indeed 1 - 4p/5 for each i? But then sum over i gives 4</em>(1-4p/5) = 4 - 16p/5, but that is not 1 generally. Actually, the total probability for a pair is 1. And indeed, 4<em>(1-4p/5) = 4 - 16p/5. For p=0, that is 4, which is not 1. So I&rsquo;m making a mistake: The probability that a pair is in a specific category is not 1 - 4p/5 because that number is greater than 1 when p=0? Actually, when p=0, the only possibility is I, which belongs to category? I belongs to U0? Actually, I is in U0? But wait, I is in all categories? No, each category is a set of 4 Paulis. I appears only in one category? Actually, I is only in U0? Because U0 = {I, X⊗X, Y⊗Y, Z⊗Z}. So I is in U0. So for p=0, the probability that the error is in U0 is 1. And the probability that it is in any other category is 0. So then Prob(in U0) = 1-p + 3</em>(p/15) but that gives 1 when p=0. And Prob(in U1) = 0 + 4<em>(p/15) = 4p/15. So indeed, for a given pair, the probability to be in category i is:
For i=0 (U0): = (1-p) + 3</em>(p/15) = 1 - p + p/5 = 1 - 4p/5.
For i=1,2,3: = 0 + 4<em>(p/15) = 4p/15.
And these sum to: (1 - 4p/5) + 3</em>(4p/15) = 1 - 4p/5 + 12p/15 = 1 - 4p/5 + 4p/5 = 1. Good.
So, for a pair, 
P(category 0) = 1 - 4p/5.
P(category 1) = 4p/15.
P(category 2) = 4p/15.
P(category 3) = 4p/15.</p>
<p>Now, undetectable errors require that both pairs are in the same category. So:
P_undetect = P(both in category 0) + P(both in category 1) + P(both in category 2) + P(both in category 3)
= (1 - 4p/5)^2 + 3<em>(4p/15)^2 = (1 - 4p/5)^2 + 3</em>(16p^2/225) = (1 - 4p/5)^2 + (48p^2/225).</p>
<p>Now, among undetectable errors, those that preserve the logical state are those where both errors are in category 0 (U0). Because as argued, if F and E are in U0, then F|Φ^+⟩ = ±|Φ^+⟩ and E|Φ^+⟩ = ±|Φ^+⟩, so the product is ±|ψ_ideal⟩. So that is good.
What about if they are in another category? Then the resulting state will be a different logical state. So the probability of correct logical state after post-selection is:
P(correct | undetectable) = P(both in category 0) / P_undetect = (1 - 4p/5)^2 / [ (1 - 4p/5)^2 + 48p^2/225 ].</p>
<p>But wait: Is that the logical fidelity? That would be the probability that the logical state is exactly the ideal state given that no error was detected. So the logical fidelity F_logical = (1 - 4p/5)^2 / [ (1 - 4p/5)^2 + 48p^2/225 ].</p>
<p>We can simplify that:
(1 - 4p/5)^2 = 1 - 8p/5 + 16p^2/25 = (25/25) - (40p/25) + (16p^2/25) = (25 - 40p + 16p^2)/25.
And 48p^2/225 remains.
So denominator = (25 - 40p + 16p^2)/25 + 48p^2/225 = (9<em>(25 - 40p + 16p^2) + 48p^2) /225 = (225 - 360p + 144p^2 + 48p^2) /225 = (225 - 360p + 192p^2)/225.
So F_logical = [ (25 - 40p + 16p^2)/25 ] / [ (225 - 360p + 192p^2)/225 ] = (25 - 40p + 16p^2)/25 * 225/(225 - 360p + 192p^2) = (25 - 40p + 16p^2)</em>9/(225 - 360p + 192p^2) = (225 - 360p + 144p^2) / (225 - 360p + 192p^2) = 1 - (48p^2)/(225 - 360p + 192p^2)? Actually, it simplifies to:
F_logical = (225 - 360p + 144p^2) / (225 - 360p + 192p^2) = 1 - (48p^2)/(225 - 360p + 192p^2). 
We can also factor 9? 225=9<em>25, 360=9</em>40, 144=9<em>16, 192=9</em>21.33? Not sure.
Maybe factor 3? 225/3=75, 360/3=120, 144/3=48, 192/3=64. So 
F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2). 
That is a nice form: F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2).</p>
<p>We can also factor 3? 75=3<em>25, 120=3</em>40, 48=3*16, 64 is not divisible by 3. So that&rsquo;s it.</p>
<p>So the logical fidelity after post-selection is: 
F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2).</p>
<p>But wait, is that the final answer? It might be. But let me double-check with a sanity check: When p=0, F_logical=1. When p is small, F_logical ≈ 1 - (16p^2)/(75)?? Actually, expand: Denominator = 75 - 120p + 64p^2, Numerator = 75 - 120p + 48p^2, so F_logical = 1 - (16p^2)/(75 - 120p + 64p^2) ≈ 1 - (16/75)p^2 for small p. So the infidelity scales as p^2, which is good because post-selection removes first-order errors.
Also, if p is such that? That seems plausible.</p>
<p>I will check one example: Consider an error on one CNOT that is in category 1. That probability is 4p/15. For both to be in category 1, probability = (4p/15)^2 = 16p^2/225. And there are 3 such categories, so total probability of undetectable but logical error = 3*(16p^2/225)=48p^2/225. And probability of undetectable and correct = (1-4p/5)^2 = 1 - 8p/5 + 16p^2/25 = (25 - 40p + 16p^2)/25 = convert to denominator 225: = (225 - 360p + 144p^2)/225. So indeed, F_logical = (225 - 360p + 144p^2) / (225 - 360p + 144p^2 + 48p^2) = (225 - 360p + 144p^2) / (225 - 360p + 192p^2). That matches.</p>
<p>So answer for subproblem 2 is: 
F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2).</p>
<p>I&rsquo;ll put that in a box.</p>
<p>Thus final answers:
Subproblem 1: F_physical = 1 - (8/5)p + (16/25)p^2.
Subproblem 2: F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2).</p>
<p>I&rsquo;ll now output in markdown.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-circuit-and-ideal-state">🧮 Step 1: Circuit and Ideal State</h3>
<p>The goal is to prepare the logical GHZ state  </p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the <span class="arithmatex">\([[4,2,2]]\)</span> code using the circuit:  </p>
<div class="arithmatex">\[
(\text{CNOT}_{03}) (H_0) (\text{CNOT}_{21}) (H_2).
\]</div>
<p>In quantum circuit order (right-to-left), the operations are:</p>
<ol>
<li>Apply <span class="arithmatex">\(H\)</span> on qubit 2.</li>
<li>Apply <span class="arithmatex">\(\text{CNOT}_{21}\)</span> (control qubit 2, target qubit 1).</li>
<li>Apply <span class="arithmatex">\(H\)</span> on qubit 0.</li>
<li>Apply <span class="arithmatex">\(\text{CNOT}_{03}\)</span> (control qubit 0, target qubit 3).</li>
</ol>
<p>Starting from <span class="arithmatex">\(|0000\rangle\)</span>, the ideal final state is:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right).
\]</div>
<p>This state factors into two Bell pairs:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}, \quad \text{where} \quad |\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}.
\]</div>
<hr />
<h3 id="step-2-error-model">⚡ Step 2: Error Model</h3>
<p>Each <span class="arithmatex">\(\text{CNOT}\)</span> gate is followed by a two-qubit depolarizing error channel on its target qubits. The error channel acts as:</p>
<div class="arithmatex">\[
\rho \mapsto (1 - p) \rho + \frac{p}{15} \sum_{E \neq I} E \rho E^\dagger,
\]</div>
<p>where <span class="arithmatex">\(E\)</span> is a non-identity two-qubit Pauli operator on the involved qubits, and <span class="arithmatex">\(p\)</span> is the error probability per gate.</p>
<p>There are two <span class="arithmatex">\(\text{CNOT}\)</span> gates:</p>
<ul>
<li><span class="arithmatex">\(\text{CNOT}_{21}\)</span>: error acts on qubits 1 and 2.</li>
<li><span class="arithmatex">\(\text{CNOT}_{03}\)</span>: error acts on qubits 0 and 3.</li>
</ul>
<p>The Hadamard gates are perfect. Errors propagate to the final state as Pauli operators <span class="arithmatex">\(P = F \otimes E\)</span>, where <span class="arithmatex">\(F\)</span> acts on qubits 0 and 3, and <span class="arithmatex">\(E\)</span> acts on qubits 1 and 2. The probability distribution is:</p>
<ul>
<li><span class="arithmatex">\(\Pr(I, I) = (1 - p)^2\)</span></li>
<li><span class="arithmatex">\(\Pr(E, I) = \frac{p(1 - p)}{15}\)</span> for <span class="arithmatex">\(E \neq I\)</span></li>
<li><span class="arithmatex">\(\Pr(I, F) = \frac{p(1 - p)}{15}\)</span> for <span class="arithmatex">\(F \neq I\)</span></li>
<li><span class="arithmatex">\(\Pr(E, F) = \frac{p^2}{225}\)</span> for <span class="arithmatex">\(E, F \neq I\)</span></li>
</ul>
<hr />
<h3 id="step-3-physical-state-fidelity-subproblem-1">📊 Step 3: Physical State Fidelity (Subproblem 1)</h3>
<p>The physical state fidelity is the probability that the final state is <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> (up to global phase). This occurs if the error on each pair leaves its Bell state invariant.</p>
<p>On a Bell state <span class="arithmatex">\(|\Phi^+\rangle\)</span>, the Pauli operators that preserve it (up to phase) are:</p>
<div class="arithmatex">\[
\{I, X \otimes X, Y \otimes Y, Z \otimes Z\}.
\]</div>
<p>The probability that a single error channel yields such an operator is:</p>
<div class="arithmatex">\[
1 - p + 3 \cdot \frac{p}{15} = 1 - \frac{4}{5}p.
\]</div>
<p>Since the error channels are independent, the total probability is:</p>
<div class="arithmatex">\[
F_{\text{physical}} = \left(1 - \frac{4}{5}p\right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2.
\]</div>
<hr />
<h3 id="step-4-logical-state-fidelity-with-post-selection-subproblem-2">🔍 Step 4: Logical State Fidelity with Post-Selection (Subproblem 2)</h3>
<p>We now post-select on undetectable errors—those that commute with both stabilizers <span class="arithmatex">\(S_1 = XXXX\)</span> and <span class="arithmatex">\(S_2 = ZZZZ\)</span>.</p>
<p>The 16 Pauli operators on a pair can be grouped into 4 categories based on their commutation signs with <span class="arithmatex">\(X \otimes X\)</span> and <span class="arithmatex">\(Z \otimes Z\)</span>:</p>
<ul>
<li><strong>Category 0</strong>: <span class="arithmatex">\(\{I, X \otimes X, Y \otimes Y, Z \otimes Z\}\)</span> → preserve <span class="arithmatex">\(|\Phi^+\rangle\)</span></li>
<li><strong>Categories 1–3</strong>: Other Pauli operators → do not preserve <span class="arithmatex">\(|\Phi^+\rangle\)</span></li>
</ul>
<p>The probabilities for a pair are:</p>
<ul>
<li><span class="arithmatex">\(\Pr(\text{Category 0}) = 1 - \frac{4}{5}p\)</span></li>
<li><span class="arithmatex">\(\Pr(\text{Category } i) = \frac{4p}{15}\)</span> for <span class="arithmatex">\(i = 1, 2, 3\)</span></li>
</ul>
<p>An error <span class="arithmatex">\(P = F \otimes E\)</span> is undetectable if <span class="arithmatex">\(F\)</span> and <span class="arithmatex">\(E\)</span> belong to the same category. The probability of this is:</p>
<div class="arithmatex">\[
P_{\text{undetect}} = \left(1 - \frac{4}{5}p\right)^2 + 3 \left(\frac{4p}{15}\right)^2 = \left(1 - \frac{4}{5}p\right)^2 + \frac{48p^2}{225}.
\]</div>
<p>The logical state is preserved only if both errors are in Category 0:</p>
<div class="arithmatex">\[
P_{\text{correct}} = \left(1 - \frac{4}{5}p\right)^2.
\]</div>
<p>Thus, the logical fidelity is:</p>
<div class="arithmatex">\[
F_{\text{logical}} = \frac{P_{\text{correct}}}{P_{\text{undetect}}} = \frac{(1 - \frac{4}{5}p)^2}{(1 - \frac{4}{5}p)^2 + \frac{48p^2}{225}}.
\]</div>
<p>Simplifying:</p>
<div class="arithmatex">\[
F_{\text{logical}} = \frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}.
\]</div>
<hr />
<h3 id="final-answers">✅ Final Answers</h3>
<p><strong>Subproblem 1:</strong>  </p>
<div class="arithmatex">\[
\boxed{1 - \frac{8}{5}p + \frac{16}{25}p^2}
\]</div>
<p><strong>Subproblem 2:</strong>  </p>
<div class="arithmatex">\[
\boxed{\frac{75 - 120p + 48p^2}{75 - 120p + 64p^2}}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given the problem: 
 We want the logical state fidelity after post-selection on detectable errors.</p>
<p>From our derivation, the logical fidelity is:
   F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2)</p>
<p>However, note that the expression we derived is:
   F_logical = (75 - 120p + 48p^2) / (75 - 120p + 64p^2)</p>
<p>We can simplify this expression by factoring out common factors? 
 Alternatively, we can write it in a simplified form.</p>
<p>But note: the problem asks for the logical state fidelity as a function of p.</p>
<p>We&rsquo;ll return this expression in SymPy.</p>
<p>Let&rsquo;s write:
   numerator = 75 - 120<em>p + 48</em>p<strong>2
   denominator = 75 - 120<em>p + 64</em>p</strong>2</p>
<p>However, we can also simplify by dividing numerator and denominator by 1? 
 Alternatively, we can leave it as is.</p>
<p>But note: the expression we have is already in its simplest form.</p>
<p>Let&rsquo;s code it accordingly.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p><strong>Final Answer:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">75</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">48</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">75</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">64</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.551426
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>