<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?&rdquo;</p>
<p>Interpretation: We have a circuit that prepares a logical GHZ state. The circuit is given as: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). But careful: The equation is written in matrix multiplication order, but the quantum operations occur in reverse order. That means the actual circuit order from initial state to final state is: first apply H_2, then CNOT_{21}, then H_0, then CNOT_{03}. So the circuit steps:
Step 1: Apply H on qubit 2.
Step 2: Apply CNOT with control qubit 2 and target qubit 1.
Step 3: Apply H on qubit 0.
Step 4: Apply CNOT with control qubit 0 and target qubit 3.</p>
<p>We assume initial state? Typically, we start from |0000&gt;? But careful: The problem says: &ldquo;prepare a logical two-qubit GHZ state (|00&gt;<em>{AB}+|11&gt;</em>{AB})/√2&rdquo;. So the intended final state is that logical state. So we want to compute the fidelity of the actual state produced by the circuit when each CNOT gate is followed by a depolarizing error channel. But note: There are two CNOT gates: CNOT_{21} and CNOT_{03}. And there are Hadamard gates: H_2 and H_0. The problem says: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; So the errors occur on the two-qubit gates. The Hadamard gates are single-qubit gates. They are assumed perfect? Probably yes. So only errors on CNOT gates.</p>
<p>So we have two CNOT gates. Each CNOT gate is followed by an error channel that with probability (1-p) does nothing, and with probability p, applies a random two-qubit Pauli error from the set of 15 non-identity Paulis on the two qubits involved. And these errors are applied after the CNOT gate. So the circuit becomes:
Start: |0000&gt;.
Apply H_2: becomes: |0&gt;<em>0, |0&gt;_1, (|0&gt;+|1&gt;)/√2 on qubit 2, |0&gt;_3. So state: 1/√2 (|0000&gt; + |0010&gt;) but careful: qubits: 0,1,2,3. So state: |0&gt;_0|0&gt;_1 (|0&gt;_2+|1&gt;_2)/√2 |0&gt;_3 = 1/√2 (|0000&gt; + |0010&gt;).
Then apply CNOT</em>{21}. This gate: control qubit 2, target qubit 1. So it flips qubit 1 if qubit 2 is 1.
So after CNOT_{21}: state becomes: 1/√2 (|0000&gt; + |0110&gt;) because: if state is |0010&gt;, then qubit2=1 so flip qubit1: from 0 to 1, so becomes |0110&gt;.
But wait: Actually, careful: The qubits order: 0,1,2,3. So state: |q0,q1,q2,q3&gt;. So initial: |0,0,0,0&gt; and |0,0,1,0&gt;. After CNOT_{21}: 
For |0,0,0,0&gt;: qubit2=0 so no flip: remains |0,0,0,0&gt;.
For |0,0,1,0&gt;: qubit2=1 so flip qubit1: becomes |0,1,1,0&gt;.
So state: 1/√2 (|0000&gt; + |0110&gt;).</p>
<p>Then after CNOT_{21}, we have an error channel. But careful: The error channel acts on the two qubits involved: qubits 2 and 1. So it applies a Pauli error from the set of 15 non-identity Paulis on qubits (2,1) with probability p/15 each, and with probability 1-p, identity.
So after this step, the state becomes a mixture. But we want the fidelity of the final physical state. The fidelity is defined as the overlap between the ideal state (which is the state without errors) and the actual state. But the actual state is a mixed state due to errors. So we want F = &lt;ψ_ideal| ρ_actual |ψ_ideal&gt;. And we want it as a function of p.</p>
<p>Then next: Apply H_0. That is a perfect gate. So after H_0: 
Ideal: H_0 on qubit 0. So state becomes: 1/√2 ( (H|0&gt;)_0 |0&gt;_1 |0&gt;_2 |0&gt;_3 + (H|0&gt;)_0 |1&gt;_1 |1&gt;_2 |0&gt;_3 ) = 1/√2 ( (|0&gt;+|1&gt;)/√2 |000&gt; + (|0&gt;+|1&gt;)/√2 |110&gt; ) = 1/2 ( |0000&gt; + |1000&gt; + |0110&gt; + |1110&gt; )? Wait careful: 
Actually: 
First term: |0000&gt; becomes: H on qubit0: (|0&gt;+|1&gt;)/√2 on qubit0, so becomes: 1/√2 (|0000&gt; + |1000&gt;).
Second term: |0110&gt; becomes: H on qubit0: (|0&gt;+|1&gt;)/√2 on qubit0, so becomes: 1/√2 (|0110&gt; + |1110&gt;).
So overall: 1/√2 * 1/√2 (|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;) = 1/2 (|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;).</p>
<p>But wait: That is the state after H_0 if no errors occurred. But we have errors from previous step. But we will compute the overall effect later.</p>
<p>Then after H_0, we apply CNOT_{03}. This gate: control qubit 0, target qubit 3. So ideal: 
State: 1/2 (|0000&gt;+|1000&gt;+|0110&gt;+|1110&gt;). After CNOT_{03}: 
For terms with qubit0=0: no flip on qubit3: so |0000&gt; remains |0000&gt;, |0110&gt; remains |0110&gt;.
For terms with qubit0=1: flip qubit3: so |1000&gt; becomes |1001&gt;, |1110&gt; becomes |1111&gt;.
So ideal final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;). 
But is that the logical GHZ state? The logical GHZ state is (|00&gt;<em>{AB}+|11&gt;</em>{AB})/√2. And we have encoding: The logical operators: X_A = XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI. So what are the logical basis states? 
For the [[4,2,2]] code, the code space is 4-dimensional. The logical states are typically: 
|00&gt;_L, |01&gt;_L, |10&gt;_L, |11&gt;_L. 
But here we want GHZ: (|00&gt;+|11&gt;)/√2. 
Our final state: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;). Check: Is that in the code space? The stabilizers are XXXX and ZZZZ. Check: XXXX applied to this state: 
XXXX|0000&gt; = |1111&gt; so that gives coefficient? Actually, the state is a superposition. For it to be in the code space, it must be an eigenvector of XXXX with eigenvalue +1. Check: XXXX on state: 
XXXX (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;) = |1111&gt; + |0110&gt; + |1001&gt; + |0000&gt; = same state. So it is +1 eigenvector.
ZZZZ: ZZZZ on state: 
ZZZZ|0000&gt; = |0000&gt; (since all zeros, phase +1)
ZZZZ|1001&gt; = (-1)^(1+0+0+1?) Actually careful: Z on each qubit: qubit0: if 1 then -1, so |1001&gt;: qubit0=1 -&gt; factor -1, qubit1=0 -&gt; +1, qubit2=0 -&gt; +1, qubit3=1 -&gt; -1, so product = (-1)<em>(-1)=+1? Actually: (-1)^(1+1)= (-1)^2=1. So |1001&gt; gives +1.
|0110&gt;: qubit0=0, qubit1=1 -&gt; -1, qubit2=1 -&gt; -1, qubit3=0 -&gt; +1, so product = (-1)</em>(-1)=+1.
|1111&gt;: all ones: product = (-1)^4=1.
So indeed it is +1 eigenvector of ZZZZ. So it is in the code space.
Now, what are the logical states? We have logical operators: 
X_A = XIXI. Apply X_A to this state: 
X_A: flip qubit0 and qubit2? Actually: X_A = X on qubit0? Actually: X_A = XIXI. That means: on qubit0: X, qubit1: I, qubit2: X, qubit3: I.
So X_A |0000&gt; = |1010&gt; which is not in our state. But wait, the logical operators are defined up to stabilizers. So we might represent logical states differently. Actually, the state we got: 1/2(|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;) might be the logical GHZ state. Check: The logical GHZ state is (|00&gt;_L + |11&gt;_L)/√2. So if we identify |00&gt;_L and |11&gt;_L appropriately. For instance, maybe |00&gt;_L = (|0000&gt;+|1111&gt;)/√2 and |11&gt;_L = (|1001&gt;+|0110&gt;)/√2? Then our state becomes: 1/2(|0000&gt;+|1111&gt;+|1001&gt;+|0110&gt;) = 1/√2 ( (|0000&gt;+|1111&gt;)/√2 + (|1001&gt;+|0110&gt;)/√2 ) = 1/√2 (|00&gt;_L + |11&gt;_L). So that works. So indeed the circuit prepares the logical GHZ state.</p>
<p>Now, we want the physical state fidelity. That is: F = &lt;ψ_ideal| ρ_actual |ψ_ideal&gt;, where ρ_actual is the state after the circuit including errors on CNOT gates.</p>
<p>We have two CNOT gates: CNOT_{21} and CNOT_{03}. Each CNOT gate is followed by an error channel. The error channel: After the CNOT gate, with probability 1-p, no error; with probability p, an error from the set of 15 two-qubit Paulis on the two qubits involved. And these errors are applied after the gate. So the overall evolution: 
We start with |0000&gt;. Then apply H_2 (perfect). Then apply CNOT_{21} followed by error channel E1 on qubits (2,1). Then apply H_0 (perfect). Then apply CNOT_{03} followed by error channel E2 on qubits (0,3).</p>
<p>So the actual state is a mixture over error patterns. We want the fidelity relative to the ideal state (which is the state if no errors occur).</p>
<p>Let&rsquo;s denote:
Step 0: |ψ0&gt; = |0000&gt;.
Step 1: Apply H_2: |ψ1&gt; = (|0000&gt; + |0010&gt;)/√2.
Step 2: Apply CNOT_{21} ideally: |ψ2&gt; = (|0000&gt; + |0110&gt;)/√2.
But then error channel on qubits (2,1): It applies a Pauli operator from the set {I, and 15 errors} with probabilities: P(I) = 1-p, and for each non-identity Pauli E (on two qubits), probability p/15.
So after step 2, the state becomes: ρ_2 = (1-p) |ψ2&gt;&lt;ψ2| + (p/15) * sum_{E in Paulis on qubits (2,1), E ≠ I} E |ψ2&gt;&lt;ψ2| E†. But careful: The error is applied after the CNOT gate. But note: The CNOT gate itself is unitary. But the error channel acts on the state after the CNOT. So indeed, if we denote U = CNOT_{21}, then the operation is: U, then error channel on qubits (2,1). So the state after step 2 is: ρ = sum_{E} p_E (E U) |ψ1&gt;&lt;ψ1| (U† E†) where p_I = 1-p, and p_E = p/15 for E ≠ I.
But we can compute the effect on the fidelity later. Alternatively, we can compute the overall transformation as: The final ideal state is: |ψ_ideal&gt; = U_total |0000&gt;, where U_total = CNOT_{03} * H_0 * CNOT_{21} * H_2.
And with errors: Actually, careful: The errors occur after each CNOT. So the actual operation is: 
Actual = (E2 * CNOT_{03}) * H_0 * (E1 * CNOT_{21}) * H_2, where E1 is a random Pauli on qubits (2,1) and E2 is a random Pauli on qubits (0,3). And these are independent. So the final state is: ρ = average_{E1, E2} (U_E1,E2) |0000&gt;&lt;0000| (U_E1,E2)†, where U_E1,E2 = (E2 * CNOT_{03}) * H_0 * (E1 * CNOT_{21}) * H_2.
And we want F = &lt;ψ_ideal| ρ |ψ_ideal&gt; = average_{E1,E2} |&lt;ψ_ideal| U_E1,E2 |0000&gt;|^2.</p>
<p>So we need to compute for each error pattern (E1 on qubits (2,1) and E2 on qubits (0,3)), the overlap squared between the ideal state and the state produced by that error pattern. Then average over the probabilities: For E1: probability: if E1 = I, probability = 1-p; if E1 is any of the 15 non-identity, probability = p/15 each. Similarly for E2.</p>
<p>So F = (1-p)^2 * (overlap for both no errors) + (1-p)<em>(p/15)</em> (sum over E2 errors? Actually careful: There are two independent error channels. So overall:
F = Σ_{E1 in Paulis on {1,2}} Σ_{E2 in Paulis on {0,3}} (Prob(E1)* (Prob(E2)) * |&lt;ψ_ideal| U(E1,E2) |0000&gt;|^2, where U(E1,E2) = CNOT_{03} * E2? Actually careful: The order: U(E1,E2) = (CNOT_{03} * (error E2 on (0,3))? But wait: The error E2 is applied after CNOT_{03}. But then it is: U(E1,E2) = (E2 * CNOT_{03}) * H_0 * (E1 * CNOT_{21}) * H_2. But note that CNOT_{03} and H_0 commute? Not necessarily. But we can compute step by step.</p>
<p>Maybe it&rsquo;s easier to compute the effect of errors on the state step by step. But since the errors are Pauli errors, and the ideal state is a specific state, we can compute how each Pauli error affects the overlap.</p>
<p>Alternate approach: The fidelity F is the probability that no error occurs that takes the state out of the code space? But careful: Even if an error occurs, it might still leave the state in the ideal state if the error is a stabilizer? But wait: The ideal state is a specific state. If an error E is such that E|ψ_ideal&gt; is proportional to |ψ_ideal&gt;, then the overlap is 1. But if it is orthogonal, then overlap 0. But also there might be cases where the overlap is something else? But since the errors are Pauli operators, and the ideal state is a specific state in the code space, then for a Pauli error E (which acts on the physical qubits), either E|ψ_ideal&gt; is either exactly |ψ_ideal&gt; (if E is a stabilizer or logical operator that leaves that state invariant?) Actually, careful: The ideal state is not necessarily an eigenstate of all logical operators. For example, the GHZ state: (|00&gt;_L+|11&gt;_L)/√2. That state is not an eigenstate of logical X on one qubit? Actually, it might be. But anyway, we can compute the overlap explicitly.</p>
<p>Maybe we can compute the transformation step by step and then compute the effect of errors.</p>
<p>Let&rsquo;s denote the ideal transformation without errors:
U_ideal = CNOT_{03} * H_0 * CNOT_{21} * H_2.
We want to compute for a given error pattern (E1 on qubits (2,1) and E2 on qubits (0,3)), what is U(E1,E2) |0000&gt;? And then compute its overlap with |ψ_ideal&gt; = U_ideal|0000&gt;.</p>
<p>Maybe we can compute the state after each step in terms of basis states. But since errors are Pauli, they just flip bits and phases. Perhaps we can compute the effect on the final state.</p>
<p>Alternatively, note that the circuit is relatively small. We can compute the state after each step explicitly.</p>
<p>Let&rsquo;s denote the qubits as: q0, q1, q2, q3.
Initial: |0000&gt;.</p>
<p>Step 1: H_2: becomes: 1/√2 (|0000&gt; + |0010&gt;).</p>
<p>Step 2: CNOT_{21} (control 2, target 1): 
|0000&gt; -&gt; |0000&gt;
|0010&gt; -&gt; |0110&gt;
So state: 1/√2 (|0000&gt; + |0110&gt;).</p>
<p>Now, error E1 on qubits (2,1). E1 is a Pauli operator on qubits 2 and 1. It can be written as: E1 = σ_a ⊗ σ_b, where σ_a, σ_b are from {I, X, Y, Z} but not both I? Actually, includes I? But error channel: with probability 1-p, we take I. And with probability p/15 each, we take any of the 15 non-identity Paulis. So we consider E1 as any Pauli on two qubits. But we&rsquo;ll compute the effect on the state. The state after step 2 (before error) is: |ψ2&gt; = 1/√2 (|0000&gt; + |0110&gt;). 
Now, apply a Pauli operator on qubits 1 and 2. Let&rsquo;s denote the Pauli as: P = P_1 ⊗ P_2, acting on qubit1 and qubit2. But careful: The order: qubits: 0,1,2,3. So error on qubits (2,1) means: it acts on qubit2 and qubit1. But note: The order in the tensor product: usually we list qubits in order: 0,1,2,3. So if we have an operator on qubits 1 and 2, it is I_0 ⊗ (operator on qubit1) ⊗ (operator on qubit2) ⊗ I_3. But careful: The error E1 is applied after CNOT_{21}. So the state becomes: E1 |ψ2&gt;. 
So let&rsquo;s compute: For each Pauli on two qubits, what is E1 |ψ2&gt;? But note: The state |ψ2&gt; is a superposition of two basis states: |0,0,0,0&gt; and |0,1,1,0&gt;. So we can compute the effect of a Pauli on qubits 1 and 2 on these states.
Let&rsquo;s denote the basis states as |q0, q1, q2, q3&gt;. For the two states:
State A: |0,0,0,0&gt;
State B: |0,1,1,0&gt;</p>
<p>A Pauli on qubits 1 and 2: It will map these to some states with possible phases.
For example, if E1 = I ⊗ I, then it&rsquo;s identity.
If E1 = I ⊗ X (on qubit2 only? But careful: The Pauli on two qubits: They are products of Paulis on each qubit. So we list all 16 Paulis? But we only need the overlap with the ideal final state later. Perhaps we can compute the final state after the entire circuit with an error E1. That might be easier: The circuit after step 2 error is: Then apply H_0 (on qubit0) and then CNOT_{03} with error E2. So the final state (for a given error pattern) is: 
|ψ_final(E1,E2)&gt; = (CNOT_{03} * E2) * H_0 * (E1 * CNOT_{21} * H_2) |0000&gt;? But careful: The order: Actually, the operations are: 
H_2, then CNOT_{21}, then E1, then H_0, then CNOT_{03}, then E2.
So if we denote U1 = CNOT_{21} * H_2, then state after step2 (before error) is U1|0000&gt;. Then after E1, it&rsquo;s E1 U1|0000&gt;. Then H_0 gives H_0 E1 U1|0000&gt;. Then CNOT_{03} gives CNOT_{03} H_0 E1 U1|0000&gt;. Then E2 gives E2 CNOT_{03} H_0 E1 U1|0000&gt;.
So final state: |ψ_final&gt; = E2 * CNOT_{03} * H_0 * E1 * CNOT_{21} * H_2 |0000&gt;.
And the ideal is: |ψ_ideal&gt; = CNOT_{03} * H_0 * CNOT_{21} * H_2 |0000&gt;.
So if we define V = CNOT_{03} * H_0 * CNOT_{21} * H_2, then ideal = V|0000&gt;.
And with errors: |ψ_final&gt; = E2 * CNOT_{03} * H_0 * E1 * (CNOT_{21} * H_2) |0000&gt;. But note that CNOT_{21} * H_2 is not necessarily commuting with E1? But we can try to move E1 through H_0 and CNOT_{03}? Because E1 acts on qubits 1 and 2. And H_0 acts on qubit0, so it commutes with E1. And CNOT_{03} acts on qubits 0 and 3, so it commutes with E1 as well because they act on disjoint sets? Actually, careful: E1 acts on qubits 1 and 2. CNOT_{03} acts on qubits 0 and 3. So they commute. So we have:
|ψ_final&gt; = E2 * CNOT_{03} * H_0 * E1 * CNOT_{21} * H_2 |0000&gt; = E2 * E1 * CNOT_{03} * H_0 * CNOT_{21} * H_2 |0000&gt;? Check: E1 commutes with H_0 and CNOT_{03} because they act on different qubits. But careful: E1 commutes with CNOT_{21}? Actually, E1 is applied after CNOT_{21} so it&rsquo;s not that we can move E1 before CNOT_{21} because they don&rsquo;t necessarily commute? But wait: The order is: &hellip; * H_0 * E1 * CNOT_{21} * H_2. But E1 and CNOT_{21} act on the same qubits? Actually, E1 acts on qubits 1 and 2. CNOT_{21} acts on qubits 2 and 1. So they do not commute in general. So we cannot simply move E1 past CNOT_{21} because that would change the order. But we can move E1 past H_0 and CNOT_{03} because those act on qubits 0 and 3, so they commute with E1. So we get:
|ψ_final&gt; = E2 * CNOT_{03} * H_0 * E1 * CNOT_{21} * H_2 |0000&gt; = E2 * E1 * CNOT_{03} * H_0 * CNOT_{21} * H_2 |0000&gt;? That would be if E1 commutes with CNOT_{21}? But they don&rsquo;t necessarily commute. Actually, check: The operations: We have: H_0 * E1 * CNOT_{21}. Since H_0 commutes with E1 (different qubits), we can write H_0 * E1 = E1 * H_0. So then it becomes: E2 * CNOT_{03} * E1 * H_0 * CNOT_{21} * H_2. And then, does E1 commute with CNOT_{03}? Yes, because CNOT_{03} acts on qubits 0 and 3, and E1 on qubits 1 and 2, so they commute. So then we get: E2 * E1 * CNOT_{03} * H_0 * CNOT_{21} * H_2 = E2 * E1 * V. So actually, it seems that E1 does commute with CNOT_{21}? Wait, careful: The order is: &hellip; * H_0 * E1 * CNOT_{21} * H_2. We want to move E1 to the left. But E1 and CNOT_{21} do not necessarily commute because they act on the same qubits. However, note that H_0 is to the left of E1. But H_0 commutes with E1, so we can swap H_0 and E1: That gives: &hellip; * E1 * H_0 * CNOT_{21} * H_2. So then we have E1 and then H_0 * CNOT_{21} * H_2. But then can we move E1 past CNOT_{03}? CNOT_{03} is to the left of that whole block? Actually, the full expression is: E2 * CNOT_{03} * (H_0 * E1 * CNOT_{21} * H_2). And we already swapped H_0 and E1: = E2 * CNOT_{03} * (E1 * H_0 * CNOT_{21} * H_2) = E2 * CNOT_{03} * E1 * (H_0 * CNOT_{21} * H_2). And since CNOT_{03} and E1 commute (disjoint sets), we get: E2 * E1 * CNOT_{03} * (H_0 * CNOT_{21} * H_2) = E2 * E1 * CNOT_{03} * H_0 * CNOT_{21} * H_2 = E2 * E1 * V. So indeed, it seems that we can move E1 all the way to the left? But wait: Check: The original order: &hellip; * H_0 * E1 * CNOT_{21} * H_2. Is it valid to swap E1 and CNOT_{21}? We did not swap E1 and CNOT_{21}. We only swapped H_0 and E1. That is valid because H_0 acts on qubit0 and E1 on qubits 1,2. Then we have CNOT_{03} * E1. Those commute because CNOT_{03} acts on qubits 0,3 and E1 on 1,2. So then we get E1 * CNOT_{03} * H_0 * CNOT_{21} * H_2. But then we have E1 and then CNOT_{03} * H_0 * CNOT_{21} * H_2. But note: CNOT_{03} * H_0 * CNOT_{21} * H_2 is V. But wait, is it? V = CNOT_{03} * H_0 * CNOT_{21} * H_2. So then we get: |ψ_final&gt; = E2 * E1 * V |0000&gt;? That would imply that the error E1 effectively acts on the final state? But careful: That manipulation would be valid if E1 commuted with CNOT_{21}? But we never swapped E1 and CNOT_{21}. Let&rsquo;s do it step by step carefully:</p>
<p>We have: U_total with errors = E2 * CNOT_{03} * H_0 * E1 * CNOT_{21} * H_2.
Write this as: U = E2 * CNOT_{03} * H_0 * E1 * CNOT_{21} * H_2.
Consider the product: H_0 * E1. Since H_0 acts on qubit0 and E1 on qubits 1,2, they commute. So H_0 * E1 = E1 * H_0. So then:
U = E2 * CNOT_{03} * (E1 * H_0) * CNOT_{21} * H_2 = E2 * CNOT_{03} * E1 * H_0 * CNOT_{21} * H_2.
Now, CNOT_{03} and E1: They act on disjoint sets (CNOT_{03} on qubits 0,3; E1 on qubits 1,2), so they commute. So CNOT_{03} * E1 = E1 * CNOT_{03}. So then:
U = E2 * (E1 * CNOT_{03}) * H_0 * CNOT_{21} * H_2 = E2 * E1 * CNOT_{03} * H_0 * CNOT_{21} * H_2 = E2 * E1 * V.
So indeed, U = E2 * E1 * V. That is surprising because it suggests that the error E1, which is applied after CNOT_{21}, actually becomes like an error on the final state? But wait, is that valid? Check with a simple example: Suppose we have a circuit: CNOT followed by an error E on the same qubits. That is: E * CNOT. And if we had instead applied the error before the CNOT, it would be CNOT * E&rsquo; where E&rsquo; is something else. They are not necessarily the same. But here, we are not moving E1 before CNOT_{21}; we are moving it past H_0 and CNOT_{03}. And indeed, H_0 and CNOT_{03} act on different qubits, so they commute with E1. So it is valid: 
U = E2 * CNOT_{03} * H_0 * E1 * CNOT_{21} * H_2.
= E2 * CNOT_{03} * (H_0 * E1) * CNOT_{21} * H_2 = E2 * CNOT_{03} * (E1 * H_0) * CNOT_{21} * H_2 = E2 * (CNOT_{03} * E1) * H_0 * CNOT_{21} * H_2 = E2 * (E1 * CNOT_{03}) * H_0 * CNOT_{21} * H_2 = E2 * E1 * CNOT_{03} * H_0 * CNOT_{21} * H_2 = E2 * E1 * V.
So indeed, the effect of the error E1 (on qubits 1,2) applied after CNOT_{21} is equivalent to applying E1 at the very end? But careful: That would be if the operations after E1 commute with E1. And they do because H_0 acts on qubit0 and CNOT_{03} acts on qubits 0,3. So yes, that is valid. So then the final state with errors is: |ψ_final&gt; = (E2 * E1) V |0000&gt; = (E2 * E1) |ψ_ideal&gt;.
But wait: Is that always true? Check with a specific error: Say E1 = X on qubit1 (so Pauli X on qubit1, and I on qubit2). Then originally: After CNOT_{21}, state is 1/√2 (|0000&gt; + |0110&gt;). Then E1 (X on qubit1) gives: 1/√2 (|0100&gt; + |0010&gt;). Then H_0: H on qubit0: becomes: 1/√2 ( (|0&gt;+|1&gt;)/√2 on qubit0 for first term? Actually, careful: 
State after E1: |0100&gt; and |0010&gt;. 
Apply H_0: 
|0100&gt; -&gt; (|0100&gt; + |1100&gt;)/√2.
|0010&gt; -&gt; (|0010&gt; + |1010&gt;)/√2.
So state = 1/√2 * 1/√2 (|0100&gt;+|1100&gt;+|0010&gt;+|1010&gt;) = 1/2 (|0100&gt;+|1100&gt;+|0010&gt;+|1010&gt;).
Then CNOT_{03}: 
|0100&gt;: qubit0=0 -&gt; no flip: remains |0100&gt;
|1100&gt;: qubit0=1 -&gt; flip qubit3: becomes |1101&gt;
|0010&gt;: qubit0=0 -&gt; remains |0010&gt;
|1010&gt;: qubit0=1 -&gt; becomes |1011&gt;
So state = 1/2 (|0100&gt;+|1101&gt;+|0010&gt;+|1011&gt;).
Now, if we instead apply E1 at the end on the ideal state? The ideal state is: |ψ_ideal&gt; = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;). Applying E1 (X on qubit1) to that: 
X on qubit1: 
|0000&gt; -&gt; |0100&gt;
|1001&gt; -&gt; |1101&gt;
|0110&gt; -&gt; |0010&gt; (because qubit1: 1-&gt;0)
|1111&gt; -&gt; |1011&gt;
So indeed we get the same state. So it works.</p>
<p>Similarly, E2 is applied after CNOT_{03} but since there is nothing after, it&rsquo;s just E2 at the end. So indeed, the overall effect is that the final state is: (E2 * E1) |ψ_ideal&gt;, where E1 is the error on qubits (2,1) and E2 is the error on qubits (0,3). But wait: Is that always true? Check: What if E1 acts on qubit2? For example, E1 = X on qubit2. Then after CNOT_{21}, state: 1/√2 (|0000&gt;+|0110&gt;). Apply E1: X on qubit2: becomes: 1/√2 (|0010&gt;+|0100&gt;). Then H_0: 
|0010&gt; -&gt; (|0010&gt;+|1010&gt;)/√2
|0100&gt; -&gt; (|0100&gt;+|1100&gt;)/√2
So state = 1/√2 * 1/√2 (|0010&gt;+|1010&gt;+|0100&gt;+|1100&gt;) = 1/2 (|0010&gt;+|1010&gt;+|0100&gt;+|1100&gt;)
Then CNOT_{03}:
|0010&gt;: qubit0=0 -&gt; remains |0010&gt;
|1010&gt;: qubit0=1 -&gt; becomes |1011&gt;
|0100&gt;: qubit0=0 -&gt; remains |0100&gt;
|1100&gt;: qubit0=1 -&gt; becomes |1101&gt;
So state = 1/2 (|0010&gt;+|1011&gt;+|0100&gt;+|1101&gt;).
Now, if we apply E1 at the end to ideal state: E1 = X on qubit2. 
Ideal: 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;)
Apply X on qubit2:
|0000&gt; -&gt; |0010&gt;
|1001&gt; -&gt; |1011&gt;
|0110&gt; -&gt; |0100&gt; (qubit2: 1-&gt;0)
|1111&gt; -&gt; |1101&gt;
So indeed same. So it works.</p>
<p>Thus, the final state with errors is: |ψ_final(E1,E2)&gt; = (E2 E1) |ψ_ideal&gt;, where E1 is a Pauli on qubits {1,2} and E2 is a Pauli on qubits {0,3}. And these errors occur with probabilities: For E1: P(I) = 1-p, and for each of the 15 non-identity, p/15. Similarly for E2.</p>
<p>Then the fidelity is: F = average_{E1,E2} |&lt;ψ_ideal| (E2 E1) |ψ_ideal&gt;|^2.
But careful: The errors E1 and E2 are independent. So:
F = Σ_{E1} Σ_{E2} P(E1) P(E2) |&lt;ψ_ideal| E2 E1 |ψ_ideal&gt;|^2.
And note that E2 and E1 act on disjoint sets, so they commute. So E2 E1 is a Pauli operator on all 4 qubits. But it&rsquo;s not arbitrary: It is of the form: (Pauli on qubits 0,3) times (Pauli on qubits 1,2). So there are 16*16 = 256 such operators. But many will give the same overlap.</p>
<p>So we need to compute: For a given Pauli operator P (on 4 qubits) that factors as P = P_{03} ⊗ P_{12} (with the order: qubit0,3 and qubit1,2 separately), what is |&lt;ψ_ideal| P |ψ_ideal&gt;|^2? And then average over the distribution of P. But careful: The distribution: E1 is on qubits 1,2: probability: For each Pauli on two qubits, probability: if it is identity, then probability = 1-p; if non-identity, then probability = p/15. Similarly, E2 on qubits 0,3: same. And then the overall Pauli is P = E2 * E1. But note: This product is not independent over all 256 because the probabilities factor: P(P) = (probability for E2) * (probability for E1). So we can compute:
F = (Σ_{E2 on {0,3}} P(E2) ) * (Σ_{E1 on {1,2}} P(E1) |&lt;ψ_ideal| E2 E1 |ψ_ideal&gt;|^2 )? But careful: The overlap |&lt;ψ_ideal| E2 E1 |ψ_ideal&gt;|^2 depends on both E2 and E1. So we need to sum over both.</p>
<p>Maybe we can compute: For a given Pauli operator P on all 4 qubits that is of the form: P = P_0 ⊗ P_1 ⊗ P_2 ⊗ P_3, but with the constraint that P_0 and P_3 come from E2 (so they are correlated? Actually, E2 is a Pauli on qubits 0 and 3. That means it is of the form: σ_a ⊗ σ_b on qubits 0 and 3. But note: There is no constraint that the Pauli on qubit0 and qubit3 are the same type? They can be independent. So E2 can be, for example, X on qubit0 and Z on qubit3. So indeed, E2 is any element of the Pauli group on two qubits. Similarly, E1 is any element on qubits 1 and 2.
So then the overall Pauli is: P = (E2) ⊗ (E1) but careful: The order: qubits: 0,1,2,3. So if E2 = σ_{a} on qubit0 and σ_{b} on qubit3, and E1 = σ_{c} on qubit1 and σ_{d} on qubit2, then P = σ_a ⊗ σ_c ⊗ σ_d ⊗ σ_b. So it&rsquo;s a Pauli on 4 qubits. So we want to compute the overlap squared: |&lt;ψ_ideal| P |ψ_ideal&gt;|^2.</p>
<p>Now, what is |ψ_ideal&gt;? 
|ψ_ideal&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;). 
Let&rsquo;s write it explicitly: 
|ψ_ideal&gt; = 1/2 ( |0,0,0,0&gt; + |1,0,0,1&gt; + |0,1,1,0&gt; + |1,1,1,1&gt; ).</p>
<p>We want to compute &lt;ψ_ideal| P |ψ_ideal&gt; for a Pauli P. Since P is a Pauli, it will map basis states to other basis states up to a phase. So we can compute:
&lt;ψ_ideal| P |ψ_ideal&gt; = 1/4 sum_{x,y in {the four basis states}} <x| P |y>.
But maybe we can determine conditions for P to leave |ψ_ideal&gt; invariant (up to a phase). Because then the overlap squared is 1. Otherwise, it might be 0? But careful: Could it be something like 1/2? Let&rsquo;s check: Suppose P = I on all qubits, then overlap = 1.
What if P is a stabilizer? The stabilizers are XXXX and ZZZZ. Check: XXXX|ψ_ideal&gt; = ? We computed: XXXX|ψ_ideal&gt; = |ψ_ideal&gt; so that gives overlap = 1.
What about ZZZZ? ZZZZ|ψ_ideal&gt; = |ψ_ideal&gt; as computed, so overlap = 1.
What about something like: P = X on qubit0 only? That is not of the form we consider? But wait, our errors are only on the pairs: E2 on (0,3) and E1 on (1,2). So P will always have the property that the Pauli on qubit0 and qubit3 are from the same two-qubit Pauli? Actually, careful: E2 is a Pauli on qubits 0 and 3. So if E2 = X ⊗ I, then that means on qubit0: X, on qubit3: I. And E1 could be I ⊗ I. Then overall P = X on qubit0, I on others. So such an operator is possible. So let&rsquo;s compute: P = X_0 (i.e., Pauli X on qubit0 only). Then P|ψ_ideal&gt; = 1/2 (X|0000&gt; + X|1001&gt; + X|0110&gt; + X|1111&gt;) = 1/2 (|1000&gt; + |0001&gt; + |1110&gt; + |0111&gt;). The overlap with |ψ_ideal&gt; is: &lt;ψ_ideal| = 1/2 (&lt;0000|+&lt;1001|+&lt;0110|+&lt;1111|). Dot product: 
&lt;0000|1000&gt; = 0,
&lt;0000|0001&gt; = 0,
&lt;0000|1110&gt; = 0,
&lt;0000|0111&gt; = 0.
&lt;1001|1000&gt; = 0,
&lt;1001|0001&gt; = 0? Actually, &lt;1001|0001&gt; = 0 because first qubit: 1 vs 0,
&lt;1001|1110&gt; = 0,
&lt;1001|0111&gt; = 0.
&lt;0110|1000&gt; = 0,
&lt;0110|0001&gt; = 0,
&lt;0110|1110&gt; = 0,
&lt;0110|0111&gt; = 0,
&lt;1111|1000&gt; = 0,
&lt;1111|0001&gt; = 0,
&lt;1111|1110&gt; = 0,
&lt;1111|0111&gt; = 0.
So overlap = 0. So |&lt;ψ_ideal| X_0 |ψ_ideal&gt;|^2 = 0.
What about P = Z on qubit0? Then P|ψ_ideal&gt; = 1/2 (Z|0000&gt; + Z|1001&gt; + Z|0110&gt; + Z|1111&gt;) = 1/2 (|0000&gt; - |1001&gt; + |0110&gt; - |1111&gt;). Overlap with |ψ_ideal&gt; = 1/2 (1 -1 +1 -1)/2? Actually, compute: &lt;ψ_ideal| P|ψ_ideal&gt; = 1/4 ( &lt;0000|0000&gt; + &lt;1001|1001&gt;<em>(-1) + &lt;0110|0110&gt; + &lt;1111|1111&gt;</em>(-1) )? But careful: 
&lt;ψ_ideal| = 1/2 (&lt;0000|+&lt;1001|+&lt;0110|+&lt;1111|)
So &lt;ψ_ideal| P|ψ_ideal&gt; = 1/4 [ &lt;0000|0000&gt; + &lt;1001|(-|1001&gt;) + &lt;0110|0110&gt; + &lt;1111|(-|1111&gt;) ] = 1/4 (1 -1+1-1)=0.
So that gives 0.
What about P = X on qubit0 and X on qubit3? That is E2 = X ⊗ X. And E1 = I. Then P = X_0 X_3. Then P|ψ_ideal&gt; = 1/2 (X_0X_3|0000&gt; + X_0X_3|1001&gt; + X_0X_3|0110&gt; + X_0X_3|1111&gt;) = 
|0000&gt; -&gt; X_0X_3|0000&gt; = |1001&gt;? Actually, careful: X on qubit0 and X on qubit3: 
|0000&gt; -&gt; |1001&gt;
|1001&gt; -&gt; |0000&gt;
|0110&gt; -&gt; |1110&gt;? Wait: |0110&gt;: qubit0=0 -&gt; becomes 1, qubit3=0 -&gt; becomes 1, so becomes |1110&gt;? But then qubit1 and qubit2 remain: 1 and 1, so actually |1110&gt;.
|1111&gt; -&gt; |0111&gt;? Actually, |1111&gt;: qubit0=1 -&gt; becomes 0, qubit3=1 -&gt; becomes 0, so becomes |0111&gt;.
So P|ψ_ideal&gt; = 1/2 (|1001&gt; + |0000&gt; + |1110&gt; + |0111&gt;). That is not exactly |ψ_ideal&gt; because |ψ_ideal&gt; has |0110&gt; and |1111&gt; instead of |1110&gt; and |0111&gt;. So overlap? 
&lt;ψ_ideal| = 1/2 (&lt;0000|+&lt;1001|+&lt;0110|+&lt;1111|). Dot product: 
&lt;0000| from P: coefficient 1/2 from second term gives 1/2 * 1/2? Actually, careful: 
&lt;ψ_ideal| P|ψ_ideal&gt; = (1/2)(1/2) sum_{i,j} <basis_i| P |basis_j> but maybe compute directly:
&lt;ψ_ideal| P|ψ_ideal&gt; = 1/4 [ &lt;0000|P|0000&gt; + &lt;0000|P|1001&gt; + &hellip; Actually, easier: The states in |ψ_ideal&gt; are: 
A = |0000&gt;, B = |1001&gt;, C = |0110&gt;, D = |1111&gt;.
P maps: A -&gt; |1001&gt; = B, B -&gt; |0000&gt; = A, C -&gt; |1110&gt; (call this E, not in set), D -&gt; |0111&gt; (F, not in set).
So then &lt;ψ_ideal| P|ψ_ideal&gt; = 1/4 ( <A|B> + <A|A>? Actually, careful: 
P|ψ_ideal&gt; = 1/2 (B + A + E + F). Then &lt;ψ_ideal| = 1/2 (A†+B†+C†+D†). So inner product = 1/4 (A†(B+A+E+F) + &hellip; = 1/4 (0+1+0+0 + from B: 1+0+0+0 + from C: 0+0+0+0 + from D: 0+0+0+0) = 1/4*(1+1)=1/2.
So then |&lt;ψ_ideal| P|ψ_ideal&gt;|^2 = 1/4.
So that is not 0 or 1. So we need to compute the overlap squared for each Pauli P that is of the form: P = (Pauli on qubits 0,3) ⊗ (Pauli on qubits 1,2). And then average over the probabilities.</p>
<p>So let&rsquo;s denote: P = P_{03} ⊗ P_{12}, where P_{03} is a Pauli on qubits 0 and 3, and P_{12} is a Pauli on qubits 1 and 2.
We want: O(P) = |&lt;ψ_ideal| P |ψ_ideal&gt;|^2.
And |ψ_ideal&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).</p>
<p>Let&rsquo;s denote basis states as: 
A = |0,0,0,0&gt;
B = |1,0,0,1&gt;
C = |0,1,1,0&gt;
D = |1,1,1,1&gt;</p>
<p>So |ψ_ideal&gt; = (A+B+C+D)/2.</p>
<p>Now, P acts on these qubits. Write P = P_0 ⊗ P_1 ⊗ P_2 ⊗ P_3. But note that our P is not arbitrary: It factors as (P_0 ⊗ P_3) and (P_1 ⊗ P_2) independently. But that is actually all Paulis? Actually, any Pauli on 4 qubits can be written as a product of Paulis on each qubit. But here the probability distribution is such that the Pauli on qubits 0 and 3 comes from the set of 16 with a specific distribution (1-p for identity, p/15 for each non-identity) and similarly for qubits 1 and 2. So we need to compute O(P) for each such P.</p>
<p>Since P is a Pauli, it will map each computational basis state to another computational basis state, multiplied by a phase ±1 or ±i. But Paulis are Hermitian and square to identity, so they have eigenvalues ±1. Actually, careful: Pauli matrices are Hermitian, so they have real eigenvalues. But Y gives i? Actually, Y = iσ_y? Actually, Pauli matrices are usually defined as X, Y, Z where Y = iσ_y? Actually, in quantum computing, Pauli matrices are often taken as X, Y, Z with Y = [[0, -i], [i, 0]] so that they are Hermitian. So indeed, X, Y, Z are Hermitian. So phases are ±1. But wait: Y = iσ_y? Actually, standard Pauli matrices: σ_x, σ_y, σ_z. σ_y is [[0, -i], [i, 0]]. That is Hermitian? Check: (σ_y)† = transpose conjugate = [[0, -i], [i, 0]]^T = [[0, i], [-i, 0]] which is not the same. Actually, σ_y is not Hermitian? Wait, Hermitian means A = A†. For σ_y, we have σ_y = [[0, -i], [i, 0]]. Its conjugate transpose is: take conjugate: [[0, i], [-i, 0]], then transpose: [[0, -i], [i, 0]] which is actually the same? Let&rsquo;s do carefully: 
σ_y = [ [0, -i],
         [i,  0] ].
Conjugate: [ [0, i],
            [-i, 0] ].
Transpose: [ [0, -i],
            [i,  0] ].
So indeed, σ_y is Hermitian. So all Paulis are Hermitian and have eigenvalues ±1. So the phase factors are ±1. So when P acts on a basis state, it gives ± another basis state.</p>
<p>So we want: &lt;ψ_ideal| P |ψ_ideal&gt; = 1/4 sum_{s,t in {A,B,C,D}} <s| P |t>. But since P is a Pauli, it will map each basis state to a specific basis state (maybe not necessarily one of A,B,C,D? But note: A,B,C,D have specific patterns: 
A: 0,0,0,0
B: 1,0,0,1
C: 0,1,1,0
D: 1,1,1,1
So these states are characterized by: qubit0 and qubit3 are the same? Actually, A: 0 and 0; B: 1 and 1; C: 0 and 0? Actually, C: qubit0=0, qubit3=0; D: qubit0=1, qubit3=1. And qubit1 and qubit2: A: 0,0; B: 0,0; C: 1,1; D: 1,1.
So the states in the support of |ψ_ideal&gt; are those where qubit0 = qubit3 and qubit1 = qubit2. So if P maps one of these states to another state, it will be in the support if the image also satisfies that condition. So we need to determine for a given Pauli P (which is a product of Paulis on each qubit), what is the action on the set {A,B,C,D}? And then compute the matrix element.</p>
<p>Alternatively, we can compute: 
&lt;ψ_ideal| P |ψ_ideal&gt; = 1/4 ( <A|P|A> + <A|P|B> + &hellip; + <D|P|D> ) but note that P will map each basis state to a basis state. So many terms are zero unless P maps exactly one of these to another. So it&rsquo;s easier: Let f(P) = &lt;ψ_ideal| P |ψ_ideal&gt;. This is the expectation value of P in the state |ψ_ideal&gt;. And since |ψ_ideal&gt; is a pure state, f(P) is a number. And then we want |f(P)|^2.</p>
<p>Maybe we can compute f(P) by noting that |ψ_ideal&gt; is an eigenstate of the stabilizers XXXX and ZZZZ. Also, it is a GHZ state in the logical basis. Perhaps we can express P in terms of logical operators? But careful: P is a physical Pauli. And the code is [[4,2,2]]. The logical operators are: X_A = XIXI, X_B = XXII, Z_A = ZZII, Z_B = ZIZI. But our state is not a logical basis state but a GHZ state. Alternatively, we can compute f(P) by direct computation. Since P factors as (P on qubits 0,3) and (P on qubits 1,2), and the state |ψ_ideal&gt; is a product state between the pair (0,3) and (1,2)? Actually, check: |ψ_ideal&gt; = 1/2 (|00&gt;<em>{03}|00&gt;</em>{12} + |11&gt;<em>{03}|00&gt;</em>{12}? That doesn&rsquo;t work because: A: |00&gt;<em>{03}|00&gt;</em>{12}; B: |11&gt;<em>{03}|00&gt;</em>{12}; C: |00&gt;<em>{03}|11&gt;</em>{12}; D: |11&gt;<em>{03}|11&gt;</em>{12}. So indeed, |ψ_ideal&gt; = (|00&gt;<em>{03} + |11&gt;</em>{03})/√2 ⊗ (|00&gt;<em>{12} + |11&gt;</em>{12})/√2? But careful: That would be 1/2 (|00&gt;|00&gt; + |00&gt;|11&gt; + |11&gt;|00&gt; + |11&gt;|11&gt;) but our state is only the terms where the two pairs are either both 00 or both 11. So actually, |ψ_ideal&gt; is not a product state between the two pairs; it is entangled across them? Actually, it is: |ψ_ideal&gt; = 1/2 (|00&gt;<em>{03}|00&gt;</em>{12} + |11&gt;<em>{03}|00&gt;</em>{12} + |00&gt;<em>{03}|11&gt;</em>{12} + |11&gt;<em>{03}|11&gt;</em>{12}). That is actually a product state? Because (|00&gt;+|11&gt;)/√2 on first pair and (|00&gt;+|11&gt;)/√2 on second pair would give: 1/2 (|00&gt;|00&gt; + |00&gt;|11&gt; + |11&gt;|00&gt; + |11&gt;|11&gt;). So indeed, |ψ_ideal&gt; = (|00&gt;<em>{03}+|11&gt;</em>{03})/√2 ⊗ (|00&gt;<em>{12}+|11&gt;</em>{12})/√2. Wait, check: (|00&gt;+|11&gt;)/√2 on qubits 0,3 gives: 1/√2 (|00&gt; + |11&gt;). And on qubits 1,2: 1/√2 (|00&gt; + |11&gt;). Their tensor product is 1/2 (|0000&gt; + |0011&gt; + |1100&gt; + |1111&gt;). But our |ψ_ideal&gt; is: 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;). These are different: Our state has |1001&gt; and |0110&gt; instead of |0011&gt; and |1100&gt;. So it&rsquo;s not a product across the partition (0,3) and (1,2). Actually, note: In our state, qubit0 and qubit3 are correlated: they are the same. And qubit1 and qubit2 are correlated: they are the same. But if we take the pair (0,3) and (1,2), then the state is: 1/2 (|00,00&gt; + |11,00&gt; + |00,11&gt; + |11,11&gt;) but careful: |11,00&gt; means qubits 0,3 = 11 and qubits 1,2 = 00, that is |1,0,0,1&gt; which is B. And |00,11&gt; means qubits 0,3 = 00 and qubits 1,2 = 11, that is |0,1,1,0&gt; which is C. So indeed, if we label the pair (0,3) as one system and (1,2) as the other, then the state is: 1/2 (|00,00&gt; + |11,00&gt; + |00,11&gt; + |11,11&gt;). That is actually a product state? Because a product state would be (a|00&gt;+b|11&gt;) ⊗ (c|00&gt;+d|11&gt;) = ac|00,00&gt; + ad|00,11&gt; + bc|11,00&gt; + bd|11,11&gt;. For this to equal 1/2 (|00,00&gt;+|11,00&gt;+|00,11&gt;+|11,11&gt;), we need ac=1/2, ad=1/2, bc=1/2, bd=1/2. That implies a, b, c, d are all nonzero and a/b =? Actually, from ad=1/2 and bc=1/2, we get a/b = (1/(2d))/(1/(2c)) = c/d. And from ac=1/2 and bd=1/2, we get a/b = (1/(2c))/(1/(2d)) = d/c. So we need c/d = d/c, so c^2 = d^2, so d = ± c. And then ac=1/2 gives a=1/(2c), and ad=1/2 gives a=1/(2d) so that forces c=d. So then a=1/(2c), and bc=1/2 gives b=1/(2c), so a=b. Then the product state is (a|00&gt;+a|11&gt;) ⊗ (c|00&gt;+c|11&gt;) = a c (|00&gt;+|11&gt;)⊗(|00&gt;+|11&gt;) = ac (|00,00&gt;+|00,11&gt;+|11,00&gt;+|11,11&gt;). For this to be 1/2, we need ac=1/2. So indeed, if we take a = 1/√2 and c = 1/√2, then we get the state. So actually, |ψ_ideal&gt; is a product state between the two pairs? But careful: The pairs are (0,3) and (1,2). But then the state would be: (|00&gt;<em>{03}+|11&gt;</em>{03})/√2 ⊗ (|00&gt;<em>{12}+|11&gt;</em>{12})/√2 = 1/2 (|00,00&gt;+|00,11&gt;+|11,00&gt;+|11,11&gt;). But that gives: |00,00&gt; = |0,0,0,0&gt; = A, good.
|00,11&gt; = |0,1,1,0&gt; = C, good.
|11,00&gt; = |1,0,0,1&gt; = B, good.
|11,11&gt; = |1,1,1,1&gt; = D, good.
So indeed, |ψ_ideal&gt; = (|00&gt;<em>{03}+|11&gt;</em>{03})/√2 ⊗ (|00&gt;<em>{12}+|11&gt;</em>{12})/√2.
That is a product state! But wait, then the logical GHZ state is actually a product of two Bell states? That is interesting. So we have:
|ψ_ideal&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12}, where |Φ^+&gt; = (|00&gt;+|11&gt;)/√2.
That is a very nice factorization. So then the expectation value of a Pauli operator P that factors as P = P_{03} ⊗ P_{12} is:
&lt;ψ_ideal| P |ψ_ideal&gt; = (&lt;Φ^+|<em>{03} ⊗ &lt;Φ^+|</em>{12}|) (P_{03} ⊗ P_{12}) (|Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12}) = (&lt;Φ^+|<em>{03}| P</em>{03} |Φ^+&gt;<em>{03}) * (&lt;Φ^+|</em>{12}| P_{12} |Φ^+&gt;<em>{12}).
So then |&lt;ψ_ideal| P |ψ_ideal&gt;|^2 = |&lt;Φ^+| P</em>{03} |Φ^+&gt;|^2 * |&lt;Φ^+| P_{12} |Φ^+&gt;|^2.</p>
<p>And we know the expectation values for two-qubit Paulis on a Bell state |Φ^+&gt; = (|00&gt;+|11&gt;)/√2.
For a two-qubit Pauli operator Q on two qubits, what is &lt;Φ^+| Q |Φ^+&gt;? 
Recall: |Φ^+&gt; = (|00&gt;+|11&gt;)/√2.
For Pauli operators:
I ⊗ I: &lt;Φ^+| I|Φ^+&gt; = 1.
X ⊗ I: &lt;Φ^+| (X⊗I) |Φ^+&gt; = ? 
(X⊗I)|Φ^+&gt; = (|10&gt;+|01&gt;)/√2 = |Ψ^+&gt; actually. And &lt;Φ^+|Ψ^+&gt; = 0. So = 0.
Similarly, I ⊗ X: 0.
Z ⊗ I: (Z⊗I)|Φ^+&gt; = (|00&gt; - |11&gt;)/√2 = |Φ^-⟩, so overlap 0.
I ⊗ Z: similarly 0.
X ⊗ X: (X⊗X)|Φ^+&gt; = (|11&gt;+|00&gt;)/√2 = |Φ^+&gt;, so &lt;Φ^+| = 1.
Y ⊗ Y: (Y⊗Y)|Φ^+&gt; = ? Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;, so (Y⊗Y)|00&gt; = (i)(-i)|11&gt; = |11&gt;, and (Y⊗Y)|11&gt; = (-i)(i)|00&gt; = |00&gt;, so actually (Y⊗Y)|Φ^+&gt; = |Φ^+&gt;, so &lt;Φ^+| = 1? But careful: There might be a phase? Actually, Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;, so (Y⊗Y)|00&gt; = i * (-i) |11&gt; = 1|11&gt;, and (Y⊗Y)|11&gt; = (-i)<em>(i)|00&gt; = 1|00&gt;. So indeed, Y⊗Y gives 1.
Z ⊗ Z: (Z⊗Z)|Φ^+&gt; = (|00&gt;+(-1)(-1)|11&gt;)/√2? Actually, Z⊗Z|00&gt; = |00&gt;, Z⊗Z|11&gt; = (-1)</em>(-1)|11&gt; = |11&gt;, so = |Φ^+&gt;, so &lt;Φ^+| = 1.
What about cross terms like X⊗Z? 
(X⊗Z)|Φ^+&gt; = (|10&gt; + (-1)|01&gt;)/√2 = (|10&gt; - |01&gt;)/√2 = -|Ψ^-&gt;, so overlap with |Φ^+&gt; is 0.
Similarly, any Pauli that is not of the form where the two Paulis are the same? Actually, more generally: For |Φ^+&gt;, we have: &lt;Φ^+| (σ ⊗ τ) |Φ^+&gt; = Tr(σ^T τ)/2? Actually, there is a formula: &lt;Φ^+| (A⊗B) |Φ^+&gt; = Tr(A^T B)/2. So then if A and B are Paulis, then A^T is just A (since Paulis are symmetric except Y? Actually, X and Z are symmetric, Y is antisymmetric? Y^T = -Y. So careful: For Paulis, X^T = X, Z^T = Z, Y^T = -Y. So then &lt;Φ^+| (X⊗X) |Φ^+&gt; = Tr(X X)/2 = Tr(I)/2 = 1.
For (Y⊗Y): Tr(Y^T Y)/2 = Tr((-Y)Y)/2 = -Tr(Y^2)/2 = -Tr(I)/2 = -1? But we computed earlier that (Y⊗Y)|Φ^+&gt; seemed to give |Φ^+&gt;? Let&rsquo;s recompute (Y⊗Y) carefully:
Y = [[0, -i], [i, 0]]. So Y|0&gt; = i|1&gt;, Y|1&gt; = -i|0&gt;.
So (Y⊗Y)|00&gt; = Y|0&gt; ⊗ Y|0&gt; = (i|1&gt;)⊗(i|1&gt;) = i^2 |11&gt; = -|11&gt;.
(Y⊗Y)|11&gt; = Y|1&gt;⊗Y|1&gt; = (-i|0&gt;)⊗(-i|0&gt;) = i^2 |00&gt; = -|00&gt;.
So (Y⊗Y)|Φ^+&gt; = (Y⊗Y)(|00&gt;+|11&gt;)/√2 = (-|11&gt; - |00&gt;)/√2 = -|Φ^+&gt;.
So &lt;Φ^+| (Y⊗Y)|Φ^+&gt; = -1.
But then |&lt;Φ^+| (Y⊗Y)|Φ^+&gt;|^2 = 1. So for the squared overlap, the sign doesn&rsquo;t matter. But careful: Our quantity is |&lt;ψ_ideal| P |ψ_ideal&gt;|^2. And that is the square of the expectation value. So we only care about the magnitude squared. So for a two-qubit Pauli Q on the Bell state, we have:
If Q = I⊗I, then expectation = 1, so squared = 1.
If Q is such that it is a product of two Paulis that are the same? Actually, from the formula: &lt;Φ^+| (σ ⊗ τ) |Φ^+&gt; = Tr(σ^T τ)/2. For Paulis, if σ and τ are both I, then 1.
If σ = X, τ = X, then Tr(X^T X)=Tr(X^2)=Tr(I)=2, so expectation = 1.
If σ = Y, τ = Y, then Y^T = -Y, so Tr((-Y)Y)= -Tr(Y^2)= -2, so expectation = -1, squared = 1.
If σ = Z, τ = Z, then Tr(Z^T Z)=Tr(Z^2)=2, so expectation = 1.
What if σ and τ are different? For example, X⊗Z: Tr(X^T Z)=Tr(X Z)=Tr( -iY ) = 0. So indeed, the expectation is nonzero only if the Pauli on the two qubits is either I⊗I, or X⊗X, Y⊗Y, Z⊗Z. But wait: What about Paulis like X⊗Y? Then Tr(X^T Y)=Tr(X Y)= Tr(iZ)=0. So yes.
Also, what about Paulis that are not tensor products? Actually, any two-qubit Pauli is a tensor product up to a phase? Actually, all Paulis are of the form ± σ_a ⊗ σ_b, and since we care about the operator itself (and not the phase? But careful: Our errors are Pauli operators. They are exactly these: They are from the set {I,X,Y,Z} on each qubit, but with a possible overall phase? But Pauli group elements can have factors of i. But typically, we take the Pauli matrices to be Hermitian, so they are X, Y, Z. And then products are Hermitian if an even number of Y&rsquo;s? Actually, X, Y, Z are Hermitian. The product of two Hermitian matrices is Hermitian if they commute. But X and Y anticommute, so X⊗Y is not Hermitian? Actually, check: (X⊗Y)† = X†⊗Y† = X⊗Y, so it is Hermitian. Because (X⊗Y)† = X†⊗Y† = X⊗Y since X and Y are Hermitian. So indeed, all products of Paulis are Hermitian. But they might have eigenvalues ±1. So it&rsquo;s fine.
So, for a two-qubit Pauli Q on the pair, we have:
&lt;Φ^+| Q |Φ^+&gt; is nonzero only if Q is one of: I⊗I, X⊗X, Y⊗Y, Z⊗Z. And in those cases, the expectation is ±1. So then |&lt;Φ^+| Q |Φ^+&gt;|^2 = 1.
For any other two-qubit Pauli, the expectation is 0.
But wait: There is also the possibility: What about Q = -I⊗I? That is not considered because Pauli errors are usually taken as the matrices themselves, not with a minus sign? But actually, the Pauli group includes ±1, ±i. But in the error model, we said &ldquo;one of the 15 non-identity two-qubit Paulis&rdquo;. Typically, the depolarizing channel is defined as: with probability p, apply an error from the set {P} where P are all Pauli operators on two qubits except identity, and they are equally likely. And these Pauli operators are usually taken as the matrices themselves (like X, Y, Z on each qubit, and their products). But note: Could there be a minus sign? For example, -I⊗I is identity up to a phase? Actually, -I is not considered because it&rsquo;s just a global phase. So we consider the Pauli operators as the set {I, X, Y, Z} on each qubit, and then the two-qubit Paulis are of the form σ_a ⊗ σ_b, where σ_a, σ_b ∈ {I, X, Y, Z}. And there are 16 such operators. And the error channel: with probability 1-p, no error (which is I⊗I). With probability p/15 each, we take any of the other 15. So that is our distribution.</p>
<p>So then, for a given error pattern: E2 is a two-qubit Pauli on qubits (0,3). And E1 is a two-qubit Pauli on qubits (1,2). Then the overall effect is P = E2 ⊗ E1 (but careful: The order: qubits: 0,1,2,3, so actually it is: On qubit0: from E2, on qubit3: from E2, on qubit1: from E1, on qubit2: from E1). So then:
&lt;ψ_ideal| P |ψ_ideal&gt; = (&lt;Φ^+|<em>{03}| E2 |Φ^+&gt;</em>{03}) * (&lt;Φ^+|<em>{12}| E1 |Φ^+&gt;</em>{12}).
So then |&lt;ψ_ideal| P |ψ_ideal&gt;|^2 = |&lt;Φ^+| E2 |Φ^+&gt;|^2 * |&lt;Φ^+| E1 |Φ^+&gt;|^2.</p>
<p>Now, for a two-qubit Pauli Q (on a pair), we have:
If Q = I⊗I, then |&lt;Φ^+| Q |Φ^+&gt;|^2 = 1.
If Q is such that it is of the form: X⊗X, Y⊗Y, Z⊗Z, then also |&lt;Φ^+| Q |Φ^+&gt;|^2 = 1.
For any other Q (like I⊗X, X⊗I, etc.), |&lt;Φ^+| Q |Φ^+&gt;|^2 = 0.</p>
<p>So, for E2 (on qubits 0,3), the overlap squared is 1 if E2 is either the identity or if E2 is a Pauli that is the same on both qubits (i.e., X⊗X, Y⊗Y, Z⊗Z). How many such Paulis are there? Identity: 1, and then X⊗X, Y⊗Y, Z⊗Z: that&rsquo;s 3. So total 4 Paulis out of 16 give nonzero overlap (and actually give overlap squared = 1). For any other Pauli (there are 12 of them), the overlap is 0.
Similarly for E1 on qubits (1,2): exactly 4 Paulis give overlap squared = 1, and 12 give 0.</p>
<p>And note that these errors are independent. So then the fidelity F is:
F = Σ_{E2} Σ_{E1} P(E2) P(E1) * (1 if E2 is in S and E1 is in S, else 0), where S is the set of two-qubit Paulis that are either identity or of the form σ⊗σ (with σ ∈ {X,Y,Z}).
So then F = (Probability that E2 is in S) * (Probability that E1 is in S).</p>
<p>Now, what is the probability that a given two-qubit Pauli error (from the depolarizing channel on that gate) is in S? 
For a given CNOT gate, the error channel: With probability 1-p, we have no error (which is identity, and identity is in S). With probability p, an error occurs, and then it is uniformly distributed among the 15 non-identity Paulis. Among these 15, how many are in S? The ones in S besides identity are: X⊗X, Y⊗Y, Z⊗Z. So that&rsquo;s 3. So the probability that the error is in S (i.e., the Pauli is such that it doesn&rsquo;t ruin the overlap) is: (1-p) + (p/15)<em>3 = 1-p + p/5 = 1 - (4/5)p.
Wait: Check: If p is the error probability, then probability of identity = 1-p. Probability of each non-identity = p/15. So total probability for being in S = (1-p) + 3</em>(p/15) = 1-p + p/5 = 1 - (4/5)p.
So for each CNOT gate, the probability that the error is &ldquo;good&rdquo; (i.e., it gives overlap 1) is 1 - (4/5)p.
And these are independent for the two CNOT gates. So then the fidelity F = [1 - (4/5)p] * [1 - (4/5)p] = (1 - 4p/5)^2.
But wait: Is that the physical state fidelity? That would be the probability that the final state is exactly |ψ_ideal&gt;? But careful: The fidelity is the overlap squared between the actual state and the ideal state. And if the error is such that E2 and E1 are both in S, then (E2 E1)|ψ_ideal&gt; will have overlap 1 with |ψ_ideal&gt;? But is it exactly |ψ_ideal&gt;? Not necessarily: For example, if E2 = X⊗X and E1 = I, then we computed earlier that &lt;ψ_ideal| P|ψ_ideal&gt; was 1/2, but then squared is 1/4? Wait, we computed for P = X_0 X_3 (and E1=I) earlier and got overlap = 1/2, so squared = 1/4. But then according to our factorization, for E2 = X⊗X, we would have &lt;Φ^+| X⊗X |Φ^+&gt; = 1, so that gives 1. There is a discrepancy. Let&rsquo;s recheck that example: E2 = X⊗X on qubits (0,3) and E1 = I on qubits (1,2). Then our computed final state from that error was: |ψ_final&gt; = (X_0 X_3) |ψ_ideal&gt;. And we computed earlier: 
|ψ_ideal&gt; = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;).
Apply X_0 X_3: 
X_0 X_3|0000&gt; = |1001&gt;
X_0 X_3|1001&gt; = |0000&gt;
X_0 X_3|0110&gt; = |1110&gt;? Because: |0110&gt;: qubit0=0 -&gt; becomes 1, qubit3=0 -&gt; becomes 1, so becomes |1110&gt;.
X_0 X_3|1111&gt; = |0111&gt;.
So |ψ_final&gt; = 1/2 (|1001&gt;+|0000&gt;+|1110&gt;+|0111&gt;) = 1/2 (|0000&gt;+|1001&gt;+|0111&gt;+|1110&gt;).
Then &lt;ψ_ideal|ψ_final&gt; = 1/4 (1+1+0+0) = 1/2. So the overlap squared is 1/4.
But according to our factorization, we said that |ψ_ideal&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12}. And then if E2 = X⊗X, then &lt;Φ^+|<em>{03}| X⊗X |Φ^+&gt;</em>{03} = 1 (as computed: (X⊗X)|Φ^+&gt; = |Φ^+&gt;, so expectation = 1). And E1 = I gives expectation 1. So then the product is 1. So there is a discrepancy. Why? Because careful: When we factor, we have to be careful with the ordering of qubits. Our factorization: |ψ_ideal&gt; = (|00&gt;<em>{03}+|11&gt;</em>{03})/√2 ⊗ (|00&gt;<em>{12}+|11&gt;</em>{12})/√2. But is that true? Let&rsquo;s check: 
(|00&gt;<em>{03}+|11&gt;</em>{03})/√2 ⊗ (|00&gt;<em>{12}+|11&gt;</em>{12})/√2 = 1/2 (|00,00&gt; + |00,11&gt; + |11,00&gt; + |11,11&gt;) but careful: |00,00&gt; means qubit0=0, qubit3=0, qubit1=0, qubit2=0 -&gt; that is |0000&gt; = A. Good.
|00,11&gt; means qubit0=0, qubit3=0, qubit1=1, qubit2=1 -&gt; that is |0110&gt; = C. Good.
|11,00&gt; means qubit0=1, qubit3=1, qubit1=0, qubit2=0 -&gt; that is |1001&gt; = B. Good.
|11,11&gt; means qubit0=1, qubit3=1, qubit1=1, qubit2=1 -&gt; that is |1111&gt; = D. Good.
So indeed, |ψ_ideal&gt; = |Φ^+&gt;<em>{03} ⊗ |Φ^+&gt;</em>{12} if we define |Φ^+&gt; on qubits (0,3) as (|00&gt;+|11&gt;)/√2 and on qubits (1,2) as (|00&gt;+|11&gt;)/√2. So that is correct.
Now, if we apply E2 = X⊗X on qubits (0,3), then what is (X⊗X) on the pair (0,3)? But careful: Our E2 is defined as acting on qubits 0 and 3. But in the tensor product ordering, qubit0 is the first qubit of that pair and qubit3 is the second. So if we write |Φ^+&gt;<em>{03} = (|0_0,0_3&gt; + |1_0,1_3&gt;)/√2, then applying X⊗X means applying X on qubit0 and X on qubit3. Then (X⊗X)|Φ^+&gt;</em>{03} = (|1_0,1_3&gt; + |0_0,0_3&gt;)/√2 = |Φ^+&gt;<em>{03}. So indeed, the expectation is 1. So then why did our direct computation give a different result? Because in our direct computation, we applied X_0 X_3 to |ψ_ideal&gt;. But note: X_0 X_3 is exactly the operator that acts as X on qubit0 and X on qubit3. So it should give the same. Let&rsquo;s recompute carefully with the factored form:
|ψ_ideal&gt; = |Φ^+&gt;</em>{03} ⊗ |Φ^+&gt;<em>{12}, where 
|Φ^+&gt;</em>{03} = (|0_0,0_3&gt; + |1_0,1_3&gt;)/√2,
|Φ^+&gt;<em>{12} = (|0_1,0_2&gt; + |1_1,1_2&gt;)/√2.
Now, apply X_0 X_3 to |ψ_ideal&gt;. That acts only on the first factor. So we get: (X_0 X_3|Φ^+&gt;</em>{03}) ⊗ |Φ^+&gt;<em>{12} = |Φ^+&gt;</em>{03} ⊗ |Φ^+&gt;<em>{12} = |ψ_ideal&gt;. So it should leave the state invariant. But our earlier computation gave: 
X_0 X_3|0000&gt; = |1001&gt; (that is correct: |0000&gt; -&gt; X on qubit0: 0-&gt;1, X on qubit3: 0-&gt;1, so becomes |1001&gt;)
X_0 X_3|1001&gt; = |0000&gt; (since qubit0:1-&gt;0, qubit3:1-&gt;0)
X_0 X_3|0110&gt; = ? For |0110&gt;: qubit0=0 -&gt; becomes 1, qubit3=0 -&gt; becomes 1, so becomes |1110&gt;? But wait: |0110&gt; means: qubit0=0, qubit1=1, qubit2=1, qubit3=0. Applying X_0: qubit0 becomes 1. Applying X_3: qubit3 becomes 1. So the result is: |1,1,1,1&gt;? That is |1111&gt; actually. Because qubit1 and qubit2 remain 1. So |0110&gt; should become |1111&gt;? But then what about |1111&gt;? 
X_0 X_3|1111&gt; = qubit0:1-&gt;0, qubit3:1-&gt;0, so becomes |0111&gt;? 
So then if I compute: 
|ψ_ideal&gt; = 1/2 (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;).
Apply X_0 X_3:
|0000&gt; -&gt; |1001&gt;
|1001&gt; -&gt; |0000&gt;
|0110&gt; -&gt; |1111&gt;? (Because: 0-&gt;1, so qubit0 becomes 1; qubit3:0-&gt;1, so qubit3 becomes 1; so indeed, |0110&gt; -&gt; |1,1,1,1&gt; = |1111&gt;)
|1111&gt; -&gt; |0111&gt;? (qubit0:1-&gt;0, qubit3:1-&gt;0, so becomes |0,1,1,1&gt; = |0111&gt;)
So then the resulting state is: 1/2 (|1001&gt; + |0000&gt; + |1111&gt; + |0111&gt;) = 1/2 (|0000&gt;+|1001&gt;+|1111&gt;+|0111&gt;). 
That is different from |ψ_ideal&gt; because |ψ_ideal&gt; has |0110&gt; and |1111&gt;? Actually, |ψ_ideal&gt; has |0110&gt; and |1111&gt;. Here we have |1111&gt; and |0111&gt;. So there is a discrepancy: According to the factored form, X_0 X_3 should leave |Φ^+&gt;</em>{03} invariant. But wait: What is |Φ^+&gt;<em>{03}? It is (|00&gt;</em>{03} + |11&gt;_{03})/√2. That means states where qubit0 and qubit3 are the same. In |0110&gt;, qubit0=0 and qubit3=0, so that is actually |00&gt; in the (0,3) pair? But careful: When we factor, we consider the pair (0,3) as a system. The basis states for that system are: |00&gt;, |01&gt;, |10&gt;, |11&gt;. In |ψ_ideal&gt;, the (0,3) part is either |00&gt; or |11&gt;. So |0000&gt; gives (0,3)=00, (1,2)=00.
|1001&gt; gives (0,3)=11, (1,2)=00.
|0110&gt; gives (0,3)=00? Because qubit0=0, qubit3=0, so that is |00&gt; actually. But wait: |0110&gt;: qubit0=0, qubit3=0, so that is |00&gt; in the (0,3) pair. And (1,2) part: qubit1=1, qubit2=1, so that is |11&gt;.
|1111&gt; gives (0,3)=11, (1,2)=11.
So indeed, |ψ_ideal&gt; = 1/2 (|00,00&gt; + |11,00&gt; + |00,11&gt; + |11,11&gt;) in the factored notation where the first tensor factor is (0,3) and the second is (1,2). Now, what is the action of X_0 X_3 on the (0,3) factor? On the (0,3) factor, the operator X_0 X_3 means: apply X to the first qubit of that factor and X to the second qubit of that factor. So if the state of the (0,3) factor is |00&gt;, then X_0 X_3|00&gt; = |11&gt;. If it is |11&gt;, then X_0 X_3|11&gt; = |00&gt;. So actually, X_0 X_3 swaps |00&gt; and |11&gt;. So then applied to |ψ_ideal&gt;, we get:
X_0 X_3|ψ_ideal&gt; = 1/2 (|11,00&gt; + |00,00&gt; + |11,11&gt; + |00,11&gt;) = 1/2 (|00,00&gt; + |11,00&gt; + |00,11&gt; + |11,11&gt;) = |ψ_ideal&gt;. So it is invariant. 
Now, let&rsquo;s check with the detailed computation using the 4-qubit basis:
We have |ψ_ideal&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;).
Now, apply X_0 X_3. 
For |0000&gt;: qubit0=0 -&gt; becomes 1, qubit3=0 -&gt; becomes 1, so becomes |1001&gt;? But careful: |0000&gt; becomes: qubit0: 0-&gt;1, so becomes 1; qubit3: 0-&gt;1, so becomes 1; so the result is |1,0,0,1&gt; which is |1001&gt;. 
For |1001&gt;: qubit0=1 -&gt; becomes 0, qubit3=1 -&gt; becomes 0, so becomes |0000&gt;.
For |0110&gt;: qubit0=0 -&gt; becomes 1, qubit3=0 -&gt; becomes 1, so becomes |1,1,1,1&gt;? That would be |1111&gt; if qubit1 and qubit2 remain 1. But wait: |0110&gt; has qubit1=1, qubit2=1, so yes, it becomes |1111&gt;.
For |1111&gt;: qubit0=1 -&gt; becomes 0, qubit3=1 -&gt; becomes 0, so becomes |0,1,1,1&gt; which is |0111&gt;? That is not |0110&gt;. There&rsquo;s the error: For |1111&gt;, applying X_0: qubit0: 1-&gt;0, so becomes 0; applying X_3: qubit3: 1-&gt;0, so becomes 0; so the result is |0,1,1,0&gt; which is |0110&gt; actually. Because |1111&gt; is: qubit0=1, qubit1=1, qubit2=1, qubit3=1. After X_0: becomes 0; after X_3: becomes 0; so we get |0,1,1,0&gt; = |0110&gt;. I earlier mistakenly wrote |0111&gt; but it should be |0110&gt; because qubit2 is 1, so it&rsquo;s 0,1,1,0. So then:
|0000&gt; -&gt; |1001&gt;
|1001&gt; -&gt; |0000&gt;
|0110&gt; -&gt; |1111&gt;
|1111&gt; -&gt; |0110&gt;
So indeed, the state becomes: 1/2 (|1001&gt; + |0000&gt; + |1111&gt; + |0110&gt;) which is the same as |ψ_ideal&gt;. So the overlap is 1. My earlier computation for X_0 X_3 had a mistake: I computed |0110&gt; -&gt; |1110&gt; incorrectly. Because |0110&gt;: qubit0=0 -&gt; becomes 1, so qubit0 becomes 1; qubit3=0 -&gt; becomes 1, so qubit3 becomes 1; so the result is |1,1,1,1&gt; = |1111&gt;, not |1110&gt;. And |1111&gt; -&gt; |0,1,1,0&gt; = |0110&gt;. So it&rsquo;s consistent. So then indeed, for E2 = X⊗X, we get overlap = 1. And similarly, for any E2 that is of the form σ⊗σ (with σ being X, Y, or Z), we get that it actually leaves |Φ^+&gt; invariant up to a sign? But careful: For Y⊗Y, we computed that (Y⊗Y)|Φ^+&gt; = -|Φ^+&gt;, so the expectation is -1, but squared gives 1. So that&rsquo;s fine.
So then our factorization is correct: 
|&lt;ψ_ideal| P |ψ_ideal&gt;|^2 = 1 if and only if E2 is in S (the set of Paulis on two qubits that are either identity or of the form σ⊗σ) and E1 is in S. And otherwise, it is 0.
So then the fidelity F = (Probability that E2 is in S) * (Probability that E1 is in S) = [1 - (4/5)p]^2.</p>
<p>But wait: Is that the physical state fidelity? That would be the probability that the final state is exactly the ideal state. But careful: The actual state is a mixture: ρ = Σ_{E2,E1} p(E2)p(E1) |ψ_{E2,E1}&gt;&lt;ψ_{E2,E1}|, where |ψ_{E2,E1}&gt; = (E2 E1) |ψ_ideal&gt;. And then the fidelity is &lt;ψ_ideal| ρ |ψ_ideal&gt; = Σ_{E2,E1} p(E2)p(E1) |&lt;ψ_ideal| E2 E1 |ψ_ideal&gt;|^2. And we&rsquo;ve computed that this is 1 if both errors are in S, and 0 otherwise. So indeed, F = (1 - 4p/5)^2.</p>
<p>But wait: There is also the possibility that the errors could cancel each other? But they are independent, so no.</p>
<p>So then the answer for Subproblem 1 is: F = (1 - 4p/5)^2.</p>
<p>But is that the physical state fidelity? The problem asks: &ldquo;What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate p?&rdquo; That would be F = (1 - 4p/5)^2.</p>
<p>However, let&rsquo;s double-check with a couple of examples:
- If p=0, then F=1.
- If p is small, then F ≈ 1 - (8/5)p? Actually, (1 - 4p/5)^2 = 1 - 8p/5 + &hellip; So the infidelity is 8p/5 to first order. That seems plausible.</p>
<p>I will check one more: Consider an error on the first CNOT: E1 = X on qubit1 only (so that is I⊗X on qubits (1,2)? Actually, careful: E1 acts on qubits (2,1) but order: qubit2 and qubit1. But we can consider it as a Pauli on qubits (1,2) as well, but careful with order? Actually, the pair is (2,1) but since the Pauli group is the same regardless of order, it&rsquo;s fine. So take E1 = X on qubit1 only, which is I⊗X on qubits (1,2) if we order as (1,2). That is not in S because for it to be in S, it would need to be something like X⊗X or I⊗I, etc. So then the overlap should be 0. We computed earlier with E1 = X on qubit1 (and E2=I) and got that the final state was orthogonal to |ψ_ideal&gt;. So that gives 0. So that fits.</p>
<p>Thus, the fidelity is indeed the product of the probabilities that each CNOT&rsquo;s error is in the set that doesn&rsquo;t disturb the Bell state on that pair. And that probability is: For a given CNOT, the error channel: With probability 1-p, no error (identity). With probability p, an error occurs, and among the 15, only 3 yield a Pauli that is of the form σ⊗σ. So probability that the error is &ldquo;good&rdquo; = 1-p + (3/15)p = 1 - p + p/5 = 1 - 4p/5.
So then F = (1 - 4p/5)^2.</p>
<p>Therefore, the answer for Subproblem 1 is: 
Physical state fidelity F = (1 - 4p/5)^2.</p>
<p>I&rsquo;ll put that in a box.</p>
<p>But wait: The problem might expect an expression in terms of p. So final answer: \boxed{(1 - \frac{4}{5}p)^2}.</p>
<p>I&rsquo;ll now produce the step-by-step derivation.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-circuit-and-ideal-state-preparation">Step 1. Circuit and Ideal State Preparation</h3>
<p>The goal is to prepare the logical GHZ state:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the [[4,2,2]] code. The physical qubits are labeled 0, 1, 2, 3. The circuit (written in matrix multiplication order, but applied right-to-left) is:</p>
<div class="arithmatex">\[
\text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2
\]</div>
<p>The actual order of operations is:</p>
<ol>
<li>Apply <span class="arithmatex">\( H_2 \)</span>  </li>
<li>Apply <span class="arithmatex">\( \text{CNOT}_{21} \)</span>  </li>
<li>Apply <span class="arithmatex">\( H_0 \)</span>  </li>
<li>Apply <span class="arithmatex">\( \text{CNOT}_{03} \)</span></li>
</ol>
<p>Starting from the initial state <span class="arithmatex">\( |0000\rangle \)</span>, the ideal final state is:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right)
\]</div>
<p>This state lies in the code space and corresponds to the logical GHZ state.</p>
<hr />
<h3 id="step-2-error-model">Step 2. Error Model</h3>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel:</p>
<ul>
<li>With probability <span class="arithmatex">\( 1 - p \)</span>, no error occurs.</li>
<li>With probability <span class="arithmatex">\( p \)</span>, an error occurs, and one of the 15 non-identity two-qubit Pauli operators is applied with equal probability <span class="arithmatex">\( p/15 \)</span>.</li>
</ul>
<p>The errors are independent for each CNOT gate. The Hadamard gates are assumed perfect.</p>
<p>Let:</p>
<ul>
<li><span class="arithmatex">\( E_1 \)</span>: error on qubits (2,1) after <span class="arithmatex">\( \text{CNOT}_{21} \)</span></li>
<li><span class="arithmatex">\( E_2 \)</span>: error on qubits (0,3) after <span class="arithmatex">\( \text{CNOT}_{03} \)</span></li>
</ul>
<p>The actual final state (including errors) is:</p>
<div class="arithmatex">\[
|\psi_{\text{final}}\rangle = E_2 \cdot \text{CNOT}_{03} \cdot H_0 \cdot E_1 \cdot \text{CNOT}_{21} \cdot H_2 |0000\rangle
\]</div>
<p>Using commutativity of operators on disjoint qubit sets, this simplifies to:</p>
<div class="arithmatex">\[
|\psi_{\text{final}}\rangle = (E_2 E_1) |\psi_{\text{ideal}}\rangle
\]</div>
<hr />
<h3 id="step-3-fidelity-calculation">Step 3. Fidelity Calculation</h3>
<p>The fidelity is defined as:</p>
<div class="arithmatex">\[
F = \langle \psi_{\text{ideal}} | \rho | \psi_{\text{ideal}} \rangle
\]</div>
<p>where <span class="arithmatex">\( \rho \)</span> is the density matrix of the actual state. Since the errors are independent, we average over all possible error patterns:</p>
<div class="arithmatex">\[
F = \sum_{E_1, E_2} P(E_1) P(E_2) \left| \langle \psi_{\text{ideal}} | E_2 E_1 | \psi_{\text{ideal}} \rangle \right|^2
\]</div>
<p>Let <span class="arithmatex">\( P = E_2 E_1 \)</span>. Since <span class="arithmatex">\( E_1 \)</span> and <span class="arithmatex">\( E_2 \)</span> act on disjoint sets of qubits, <span class="arithmatex">\( P \)</span> is a Pauli operator on all four qubits.</p>
<p>The ideal state factors as:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}, \quad \text{where} \quad |\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}
\]</div>
<p>Thus,</p>
<div class="arithmatex">\[
\langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle = \left( \langle \Phi^+|_{03} | E_2 | \Phi^+\rangle_{03} \right) \left( \langle \Phi^+|_{12} | E_1 | \Phi^+\rangle_{12} \right)
\]</div>
<p>and</p>
<div class="arithmatex">\[
\left| \langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle \right|^2 = \left| \langle \Phi^+ | E_2 | \Phi^+ \rangle \right|^2 \cdot \left| \langle \Phi^+ | E_1 | \Phi^+ \rangle \right|^2
\]</div>
<p>For a two-qubit Pauli operator <span class="arithmatex">\( Q \)</span>, the expectation value <span class="arithmatex">\( \langle \Phi^+ | Q | \Phi^+ \rangle \)</span> is nonzero only if <span class="arithmatex">\( Q \)</span> is either:</p>
<ul>
<li><span class="arithmatex">\( I \otimes I \)</span></li>
<li><span class="arithmatex">\( X \otimes X \)</span></li>
<li><span class="arithmatex">\( Y \otimes Y \)</span></li>
<li><span class="arithmatex">\( Z \otimes Z \)</span></li>
</ul>
<p>In these cases, <span class="arithmatex">\( \left| \langle \Phi^+ | Q | \Phi^+ \rangle \right|^2 = 1 \)</span>. For all other Pauli operators, the expectation value is 0.</p>
<p>Let <span class="arithmatex">\( S \)</span> be the set of such “good” Pauli operators:</p>
<div class="arithmatex">\[
S = \{ I \otimes I, X \otimes X, Y \otimes Y, Z \otimes Z \}
\]</div>
<p>Then:</p>
<div class="arithmatex">\[
\left| \langle \psi_{\text{ideal}} | P | \psi_{\text{ideal}} \rangle \right|^2 = 
\begin{cases}
1 &amp; \text{if } E_1, E_2 \in S \\
0 &amp; \text{otherwise}
\end{cases}
\]</div>
<hr />
<h3 id="step-4-probability-of-good-errors">Step 4. Probability of “Good” Errors</h3>
<p>For each CNOT gate:</p>
<ul>
<li>Probability of no error (i.e., <span class="arithmatex">\( I \otimes I \)</span>): <span class="arithmatex">\( 1 - p \)</span></li>
<li>Probability of a specific non-identity error: <span class="arithmatex">\( p/15 \)</span></li>
</ul>
<p>There are 3 non-identity operators in <span class="arithmatex">\( S \)</span>: <span class="arithmatex">\( X \otimes X, Y \otimes Y, Z \otimes Z \)</span></p>
<p>So, the total probability that an error is in <span class="arithmatex">\( S \)</span> is:</p>
<div class="arithmatex">\[
P(\text{good}) = (1 - p) + 3 \cdot \frac{p}{15} = 1 - p + \frac{p}{5} = 1 - \frac{4}{5}p
\]</div>
<p>Since the errors on the two CNOT gates are independent:</p>
<div class="arithmatex">\[
F = \left(1 - \frac{4}{5}p \right)^2
\]</div>
<hr />
<h3 id="final-answer">Final Answer:</h3>
<div class="arithmatex">\[
\boxed{(1 - \frac{4}{5}p)^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given that the fidelity is (1 - 4p/5)^2.
 We&rsquo;ll express this using SymPy.
 Note: We must use rational numbers carefully. 4/5 is 0.8, but we can use fractions.
 Alternatively, we can write it as (1 - 4<em>p/5)</em>*2.</p>
<p>However, note that the problem says: &ldquo;Return the expression of the physical state fidelity&rdquo;</p>
<p>Let&rsquo;s write: F_physical = (1 - 4<em>p/5)</em>*2</p>
<p>But note: We are using SymPy, so we should use rationals if needed. However, since p is a symbol, we can do:</p>
<p>F_physical = (1 - (4<em>sp.Rational(1,5))</em>p)<strong>2   OR simply (1 - 4*p/5)</strong>2</p>
<p>But note: In SymPy, 4/5 would be a float unless we use sp.Rational. However, since we are using symbols, 
 and we want an exact symbolic expression, we can use:</p>
<p>Option 1: (1 - 4<em>p/5)</em>*2   -&gt; but 4/5 in Python is 0.8, which is a float. We want an exact fraction.</p>
<p>Better: Use sp.Rational(4,5) or sp.S(4)/5.</p>
<p>Alternatively, we can write: (1 - 4*p/5) and then square, but to keep it exact, we do:</p>
<p>Let&rsquo;s use: (1 - (4<em>p)/5)</em>*2</p>
<p>However, note that if we write 4/5, Python will evaluate it to 0.8, which is a float. 
 We want to keep it symbolic. So we can use:</p>
<p>F_physical = (1 - sp.Rational(&lsquo;4/5&rsquo;)<em>p)</em>*2</p>
<p>But the problem says: &ldquo;Do not import any modules or packages beyond what is provided in the template.&rdquo;</p>
<p>The template already imports sympy as sp. So we can use sp.Rational.</p>
<p>Alternatively, we can write: (1 - 4*p/5) and then square, but to avoid float we can do:</p>
<p>Since p is a symbol, 4*p/5 is a symbolic expression. However, 4/5 is represented as 0.8 in floating point, which we don&rsquo;t want.</p>
<p>Let&rsquo;s use:</p>
<p>F_physical = (1 - (4<em>sp.S(1)/5)</em>p)**2</p>
<p>But a simpler way is to use:</p>
<p>F_physical = (1 - 4<em>p/5)</em>*2</p>
<p>But wait: if we write 4/5, it becomes 0.8, which is a float. We want an exact fraction.</p>
<p>We can use:</p>
<p>F_physical = (1 - sp.Rational(4,5)<em>p)</em>*2</p>
<p>This will give (1 - 4<em>p/5)</em>*2 as an exact symbolic expression.</p>
<p>Let&rsquo;s do that.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p><strong>Step-by-Step Derivation:</strong></p>
<ol>
<li><strong>Ideal State Preparation:</strong>
   The circuit prepares the logical GHZ state:</li>
</ol>
<div class="arithmatex">\[
   |\psi_{\text{ideal}}\rangle = \frac{1}{2} \left( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle \right)
\]</div>
<p>This state factors as:</p>
<div class="arithmatex">\[
   |\psi_{\text{ideal}}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}, \quad \text{where} \quad |\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}
\]</div>
<ol start="2">
<li>
<p><strong>Error Model:</strong>
   Each CNOT gate is followed by a depolarizing error channel:
   - With probability <span class="arithmatex">\(1 - p\)</span>, no error occurs (identity operator).
   - With probability <span class="arithmatex">\(p\)</span>, one of the 15 non-identity two-qubit Pauli errors occurs, each with probability <span class="arithmatex">\(p/15\)</span>.</p>
</li>
<li>
<p><strong>Fidelity Calculation:</strong>
   The fidelity <span class="arithmatex">\(F\)</span> is the overlap between the ideal and actual states:</p>
</li>
</ol>
<div class="arithmatex">\[
   F = \left| \langle \psi_{\text{ideal}} | \psi_{\text{final}} \rangle \right|^2
\]</div>
<p>The errors <span class="arithmatex">\(E_1\)</span> (on qubits 2,1) and <span class="arithmatex">\(E_2\)</span> (on qubits 0,3) act independently. The overlap is nonzero only if both <span class="arithmatex">\(E_1\)</span> and <span class="arithmatex">\(E_2\)</span> are in the set:</p>
<div class="arithmatex">\[
   S = \{ I \otimes I, X \otimes X, Y \otimes Y, Z \otimes Z \}
\]</div>
<p>The probability that a given error is in <span class="arithmatex">\(S\)</span> is:</p>
<div class="arithmatex">\[
   P(\text{good}) = (1 - p) + 3 \cdot \frac{p}{15} = 1 - \frac{4}{5}p
\]</div>
<p>Since the errors are independent:</p>
<div class="arithmatex">\[
   F = \left(1 - \frac{4}{5}p \right)^2
\]</div>
<p><strong>Final Answer:</strong>
The physical state fidelity is <span class="arithmatex">\(\left(1 - \frac{4}{5}p\right)^2\)</span>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.550561
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>