<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">üåì</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>First, I need to find the physical state fidelity of the final state after the circuit, considering errors from the CNOT gates. The circuit is given as: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). But since quantum operations are applied from right to left, the actual order of operations is:</p>
<ol>
<li>
<p>Apply H_2</p>
</li>
<li>
<p>Apply CNOT_{21}</p>
</li>
<li>
<p>Apply H_0</p>
</li>
<li>
<p>Apply CNOT_{03}</p>
</li>
</ol>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel with error probability p. That means after each CNOT, with probability p, one of the 15 non-identity two-qubit Paulis is applied, each with probability p/15. But since the error channel is applied after the gate, I need to model the errors separately for each CNOT.</p>
<p>The fidelity is between the ideal state and the actual state with errors. So I need to find the ideal state first, then find the actual state with errors, and then compute the fidelity.</p>
<p>The ideal state is what we get without any errors. Let&rsquo;s compute that step by step.</p>
<p>Start with all qubits in |0‚ü© state, I assume? The problem doesn&rsquo;t specify the initial state, but typically for state preparation, we start with all qubits in |0‚ü©. So let&rsquo;s assume initial state is |0000‚ü©.</p>
<p>Now, apply the operations in order:</p>
<p>First, apply H_2. H_2 is Hadamard on qubit 2. So after H_2: |0‚ü©_2 becomes (|0‚ü© + |1‚ü©)/‚àö2, so state is |00‚ü© (qubits 0,1) ‚äó (|0‚ü© + |1‚ü©)/‚àö2 ‚äó |0‚ü©_3? Let&rsquo;s label qubits: qubit 0,1,2,3.</p>
<p>After H_2: qubit 2 is now in |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2, so state is |0‚ü©_0 |0‚ü©_1 (|0‚ü© + |1‚ü©)/‚àö2 |0‚ü©_3 = (|0000‚ü© + |0010‚ü©)/‚àö2? No: qubit 2 is the third qubit? Qubits are labelled 0,1,2,3, so after H_2, state is |0‚ü©_0 |0‚ü©_1 |+‚ü©_2 |0‚ü©_3 = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle ) but |0010‚ü© means qubit 0=0,1=0,2=1,3=0, so yes.</p>
<p>But better to write as \frac{1}{\sqrt{2}} ( |00\rangle_{01} |0\rangle_2 |0\rangle_3 + |00\rangle_{01} |1\rangle_2 |0\rangle_3 ) = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )</p>
<p>Now, next operation: CNOT_{21}. CNOT with control qubit 2 and target qubit 1.</p>
<p>So apply CNOT_{21} to the state. CNOT_{21} flips qubit 1 if qubit 2 is |1‚ü©.</p>
<p>So on the state \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )</p>
<p>After CNOT_{21}:</p>
<ul>
<li>
<p>For |0000‚ü©: control qubit 2 is |0‚ü©, so no flip, remains |0000‚ü©</p>
</li>
<li>
<p>For |0010‚ü©: control qubit 2 is |1‚ü©, so flip qubit 1, which is |0‚ü© to |1‚ü©, so becomes |0110‚ü©? Qubit 1 was |0‚ü©, so after flip, |1‚ü©, so state is |0‚ü©_0 |1‚ü©_1 |1‚ü©_2 |0‚ü©_3, so |0110‚ü©.</p>
</li>
</ul>
<p>So state becomes \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>Now, next operation: H_0. Hadamard on qubit 0.</p>
<p>Apply H_0 to each term.</p>
<p>H_0 |0‚ü©_0 = (|0‚ü© + |1‚ü©)/‚àö2</p>
<p>H_0 |1‚ü©_0 = (|0‚ü© - |1‚ü©)/‚àö2</p>
<p>But in our state, qubit 0 is always |0‚ü© in both terms? |0000‚ü© has qubit 0=0, |0110‚ü© has qubit 0=0, so both have qubit 0 in |0‚ü©.</p>
<p>So after H_0:</p>
<p>For |0000‚ü©: H_0 applied, so becomes (|0‚ü©<em>0 + |1‚ü©_0)/‚àö2 ‚äó |000‚ü©</em>{123}? No, the state is |0000‚ü©, so after H_0 on qubit 0, it becomes \frac{1}{\sqrt{2}} ( |0000\rangle + |1000\rangle ) but since we have a global factor, let&rsquo;s see.</p>
<p>The state before H_0 is \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>After H_0 on qubit 0:</p>
<p>|0000‚ü© ‚Üí \frac{1}{\sqrt{2}} ( |0000\rangle + |1000\rangle )</p>
<p>|0110‚ü© ‚Üí \frac{1}{\sqrt{2}} ( |0110\rangle + |1110\rangle )? No: H_0 |0‚ü©_0 = (|0‚ü© + |1‚ü©)/‚àö2, so |0110‚ü© becomes \frac{1}{\sqrt{2}} ( |0110\rangle + |1110\rangle )</p>
<p>But since we have a global 1/‚àö2, the state becomes:</p>
<p>\frac{1}{\sqrt{2}} \left[ \frac{1}{\sqrt{2}} ( |0000\rangle + |1000\rangle ) + \frac{1}{\sqrt{2}} ( |0110\rangle + |1110\rangle ) \right] = \frac{1}{2} ( |0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle )</p>
<p>Now, finally, apply CNOT_{03}. CNOT with control qubit 0 and target qubit 3.</p>
<p>So apply CNOT_{03} to this state.</p>
<p>CNOT_{03} flips qubit 3 if qubit 0 is |1‚ü©.</p>
<p>So let&rsquo;s apply to each term:</p>
<ul>
<li>
<p>|0000‚ü©: control qubit 0 is |0‚ü©, so no flip, remains |0000‚ü©</p>
</li>
<li>
<p>|1000‚ü©: control qubit 0 is |1‚ü©, so flip qubit 3 from |0‚ü© to |1‚ü©, so becomes |1001‚ü©</p>
</li>
<li>
<p>|0110‚ü©: control qubit 0 is |0‚ü©, so no flip, remains |0110‚ü©</p>
</li>
<li>
<p>|1110‚ü©: control qubit 0 is |1‚ü©, so flip qubit 3 from |0‚ü© to |1‚ü©, so becomes |1111‚ü©</p>
</li>
</ul>
<p>So the ideal final state is:</p>
<p>\frac{1}{2} ( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle )</p>
<p>Now, is this the logical GHZ state? The logical GHZ state for qubits A and B should be (|00‚ü©_AB + |11‚ü©_AB)/‚àö2.</p>
<p>But what are the logical states? From the problem, the logical operators are given, but I need to know the code states.</p>
<p>The [[4,2,2]] code has stabilizers XXXX and ZZZZ. The logical states are defined with respect to these.</p>
<p>For example, the logical |00‚ü©_AB might be a state that is +1 eigenstate of stabilizers and logical Z operators.</p>
<p>But in this state, we have |0000‚ü©, |1001‚ü©, etc. I need to see if this is indeed the logical GHZ state.</p>
<p>Perhaps for fidelity calculation, I don&rsquo;t need to know the logical part, since fidelity is about the physical state.</p>
<p>The question is to find the physical state fidelity, which is the fidelity between the ideal physical state and the actual physical state with errors.</p>
<p>So for the ideal state, we have it as above.</p>
<p>Now, for the actual state, we have errors after each CNOT gate.</p>
<p>There are two CNOT gates: CNOT_{21} and CNOT_{03}.</p>
<p>Each CNOT is followed by a depolarizing error channel on the two qubits involved.</p>
<p>So, after CNOT_{21}, with probability 1-p, no error, and with probability p, an error occurs, which is one of the 15 Pauli errors on qubits 2 and 1, each with probability p/15.</p>
<p>Similarly, after CNOT_{03}, with probability 1-p, no error, and with probability p, an error occurs on qubits 0 and 3.</p>
<p>The Hadamard gates are assumed to be perfect, I think? The problem only mentions errors for CNOT gates, so H gates are noiseless.</p>
<p>So, the actual state is affected by errors after CNOT gates.</p>
<p>I need to find the output state after the circuit with errors, and then find the fidelity with the ideal state.</p>
<p>Fidelity F = |‚ü®œà_ideal | œà_actual ‚ü©|^2, but since there might be multiple error possibilities, œà_actual is a mixed state, so fidelity is for pure state and mixed state? The ideal state is pure, but actual state is mixed due to errors.</p>
<p>The fidelity between a pure state |œà‚ü© and a mixed state œÅ is ‚ü®œà| œÅ |œà‚ü©.</p>
<p>So I need to find the density matrix of the actual output state, and then compute ‚ü®œà_ideal| œÅ |œà_ideal‚ü©.</p>
<p>Since the errors are stochastic, I need to average over all possible error patterns.</p>
<p>There are two error locations: after CNOT_{21} and after CNOT_{03}.</p>
<p>For each CNOT, the error channel is: after the gate, with prob 1-p, identity, with prob p, a Pauli error E chosen uniformly from the 15 non-identity two-qubit Paulis on the pair.</p>
<p>The Pauli errors are applied after the gate, so they affect the state.</p>
<p>I need to find the state after each step, considering errors.</p>
<p>Start with initial state œÅ_0 = |0000‚ü©‚ü®0000|</p>
<p>First, apply H_2. No error, so after H_2, state is |œà1‚ü©‚ü®œà1| where |œà1‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )  as before.</p>
<p>Now, apply CNOT_{21}. First, apply the ideal CNOT_{21} to |œà1‚ü©, which gives |œà2‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )  as before.</p>
<p>But after applying CNOT_{21}, we have the error channel. So after CNOT_{21}, we have a state, then we apply the error channel.</p>
<p>Let me denote the state after ideal CNOT_{21} as |œà2‚ü©.</p>
<p>Then, after error channel, the state becomes:</p>
<p>With probability 1-p, no error, so state remains |œà2‚ü©</p>
<p>With probability p, an error E is applied, where E is a Pauli on qubits 2 and 1. Since |œà2‚ü© is a state, after error, it becomes E |œà2‚ü©, but since E is Pauli, it changes the state.</p>
<p>But for the density matrix, after error channel, the state is a mixture: (1-p) |œà2‚ü©‚ü®œà2| + (p/15) sum_{E in Paulis on {1,2}, E‚â†I} E |œà2‚ü©‚ü®œà2| E^\dagger</p>
<p>Since Paulis are unitary, E^\dagger E = I, so it&rsquo;s (1-p) |œà2‚ü©‚ü®œà2| + (p/15) sum_{E} E |œà2‚ü©‚ü®œà2| E^\dagger</p>
<p>But since the sum is over all non-identity Paulis on two qubits, and there are 15 of them.</p>
<p>Now, after this, we apply H_0, which is perfect, so we apply H_0 to this density matrix.</p>
<p>Then, after H_0, we apply CNOT_{03} ideally, and then after that, we apply the error channel for CNOT_{03}.</p>
<p>So, let&rsquo;s do this step by step.</p>
<p>First, after CNOT_{21} and error channel, the density matrix œÅ_2 is:</p>
<p>œÅ_2 = (1-p) |œà2‚ü©‚ü®œà2| + \frac{p}{15} \sum_{E \in \mathcal{P}_{21} \setminus {I}} E |œà2‚ü©‚ü®œà2| E^\dagger</p>
<p>where \mathcal{P}_{21} is the set of Pauli operators on qubits 2 and 1.</p>
<p>Now, |œà2‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>Now, we apply H_0 to œÅ_2. Since H_0 is unitary, the new density matrix is H_0 œÅ_2 H_0^\dagger</p>
<p>H_0 acts only on qubit 0, so it commutes with operators on other qubits, but since œÅ_2 involves qubits 0,1,2,3, we apply H_0 to it.</p>
<p>After H_0, we have œÅ_3 = H_0 œÅ_2 H_0^\dagger</p>
<p>Now, we apply ideal CNOT_{03} to œÅ_3. Let U_{03} be the unitary for CNOT_{03}, so after CNOT_{03}, we have œÅ_4 = U_{03} œÅ_3 U_{03}^\dagger</p>
<p>Then, after CNOT_{03}, we apply the error channel for CNOT_{03}, which is on qubits 0 and 3. So the final density matrix œÅ_final is:</p>
<p>œÅ_final = (1-p) œÅ_4 + \frac{p}{15} \sum_{F \in \mathcal{P}_{03} \setminus {I}} F œÅ_4 F^\dagger</p>
<p>where \mathcal{P}_{03} is Paulis on qubits 0 and 3.</p>
<p>Now, we need to find the fidelity F = ‚ü®œà_ideal| œÅ_final |œà_ideal‚ü©</p>
<p>where |œà_ideal‚ü© = \frac{1}{2} ( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle ) as derived earlier.</p>
<p>Since the error channels are Pauli errors, and the initial state and operations are Clifford, perhaps I can compute the effect of errors on the ideal state.</p>
<p>Notice that the ideal state is a stabilizer state, and errors are Pauli errors, so the fidelity might be computed by finding the probability that no error occurs or errors that cancel, but since errors happen during the circuit, it might be messy.</p>
<p>I recall that for depolarizing noise, the fidelity can be related to the probability that the state is not affected by errors.</p>
<p>But here errors are after specific gates, so I need to see how errors propagate through the circuit.</p>
<p>Since the circuit consists of Clifford gates, and errors are Pauli, I can track how Pauli errors affect the state.</p>
<p>But for fidelity, I need ‚ü®œà| œÅ |œà‚ü©, which is the probability that the actual state is the ideal state.</p>
<p>Since œÅ_final is a mixture of states obtained by applying Pauli errors at different points, and then the gates, I can think of all possible error sequences and find the final state for each error pattern, and then average the fidelity.</p>
<p>There are two error locations: after CNOT21 and after CNOT03.</p>
<p>For each error location, there are 16 possibilities: no error or one of 15 Pauli errors.</p>
<p>But since the errors are applied after the gate, and then subsequent gates are applied, I need to see what happens when errors occur.</p>
<p>Let me define the ideal circuit without errors as U_circuit = CNOT03 H0 CNOT21 H2</p>
<p>And the ideal output |œà_ideal‚ü© = U_circuit |0000‚ü©</p>
<p>With errors, after each CNOT, an error may occur.</p>
<p>So, let me denote the actual operation.</p>
<p>Start with |0000‚ü©</p>
<p>Apply H2: no error, so |œà1‚ü© = H2 |0000‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )</p>
<p>Now apply CNOT21: first apply CNOT21 ideally, so |œà2‚ü© = CNOT21 |œà1‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>Then after CNOT21, with prob 1-p, no error, state remains |œà2‚ü©</p>
<p>With prob p, an error E on {2,1} is applied, so state becomes E |œà2‚ü©</p>
<p>Then after this, apply H0: so if no error, H0 |œà2‚ü© = |œà3‚ü© where |œà3‚ü© = H0 |œà2‚ü© = \frac{1}{2} ( |0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle ) as before? Earlier we had after H0, the state was \frac{1}{2} ( |0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle ) but that was after H0 on |œà2‚ü©, which is correct.</p>
<p>But after error, if error E occurred, then we apply H0 to E |œà2‚ü©.</p>
<p>Then after H0, we apply CNOT03 ideally: so first apply CNOT03 to the state after H0.</p>
<p>Then after CNOT03, with prob 1-p, no error, or with prob p, error F on {0,3} applied.</p>
<p>So for each error pattern, we have a final state, and then we average over the error probabilities.</p>
<p>Then fidelity is |‚ü®œà_ideal| œà_actual ‚ü©|^2 for each pure state œà_actual, but since we have mixture, we need the average of |‚ü®œà_ideal| œà_final ‚ü©|^2 over error patterns, but for fidelity between pure and mixed, it is the average of |‚ü®œà_ideal| œà‚ü©|^2 for each |œà‚ü© in the mixture, which is exactly what we have since œÅ_final is a mixture of pure states.</p>
<p>So let&rsquo;s find for each error pattern, what is the final state, and then what is |‚ü®œà_ideal| œà_final ‚ü©|^2, and then average over error probabilities.</p>
<p>First, define the states after each step without errors.</p>
<p>After H2: |œà1‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )</p>
<p>After CNOT21: |œà2‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>After H0: |œà3‚ü© = H0 |œà2‚ü© = \frac{1}{2} ( |0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle )</p>
<p>After CNOT03: |œà_ideal‚ü© = CNOT03 |œà3‚ü© = \frac{1}{2} ( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle )</p>
<p>Now, with errors.</p>
<p>Case 1: no error after CNOT21.</p>
<p>Then after CNOT21, state is |œà2‚ü©.</p>
<p>Then apply H0: state becomes |œà3‚ü©.</p>
<p>Then apply CNOT03 ideally: state becomes |œà_ideal‚ü©.</p>
<p>Then after CNOT03, we have error channel.</p>
<p>So after CNOT03, state is |œà_ideal‚ü©.</p>
<p>Then with probability 1-p, no error, so final state |œà_ideal‚ü©</p>
<p>With probability p, error F on {0,3} is applied, so final state F |œà_ideal‚ü©</p>
<p>So for no error after CNOT21, the final state is:</p>
<ul>
<li>
<p>With prob (1-p) from error after CNOT03: |œà_ideal‚ü©</p>
</li>
<li>
<p>With prob p from error after CNOT03: F |œà_ideal‚ü© for each F, with prob p/15 each F.</p>
</li>
</ul>
<p>But since we have multiple F, we need to average.</p>
<p>Now, case 2: error E after CNOT21.</p>
<p>With probability p/15 for each E, after CNOT21, state is E |œà2‚ü©</p>
<p>Then apply H0: state becomes H0 E |œà2‚ü©</p>
<p>Then apply CNOT03 ideally: state becomes CNOT03 H0 E |œà2‚ü©</p>
<p>Then after CNOT03, with probability 1-p, no error, so final state CNOT03 H0 E |œà2‚ü©</p>
<p>With probability p, error F on {0,3} applied, so final state F CNOT03 H0 E |œà2‚ü©</p>
<p>Now, we need to find for each such final state, what is |‚ü®œà_ideal| œà_final ‚ü©|^2</p>
<p>Since |œà_ideal‚ü© is a state, and œà_final is some state, we need the overlap.</p>
<p>Notice that |œà_ideal‚ü© = CNOT03 H0 |œà2‚ü©, because |œà2‚ü© = CNOT21 H2 |0000‚ü©, and U_circuit = CNOT03 H0 CNOT21 H2, so |œà_ideal‚ü© = CNOT03 H0 CNOT21 H2 |0000‚ü© = CNOT03 H0 |œà2‚ü©</p>
<p>So |œà_ideal‚ü© = CNOT03 H0 |œà2‚ü©</p>
<p>Therefore, for any operator O, ‚ü®œà_ideal| O |œà_ideal‚ü© = ‚ü®œà2| H0^\dagger CNOT03^\dagger O CNOT03 H0 |œà2‚ü©</p>
<p>But for our case, we need ‚ü®œà_ideal| œà_final ‚ü© for various œà_final.</p>
<p>First, for case 1: no error after CNOT21.</p>
<p>Then after CNOT03, if no error, œà_final = |œà_ideal‚ü©, so ‚ü®œà_ideal| œà_final ‚ü© =1, so |‚ü®|^2=1</p>
<p>If error F after CNOT03, œà_final = F |œà_ideal‚ü©, so ‚ü®œà_ideal| F |œà_ideal‚ü©</p>
<p>So |‚ü®œà_ideal| F |œà_ideal‚ü©|^2</p>
<p>Since F is Pauli on {0,3}, and |œà_ideal‚ü© is a state, we need to see how F acts on |œà_ideal‚ü©.</p>
<p>Similarly for other cases.</p>
<p>Now, |œà_ideal‚ü© = \frac{1}{2} ( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle )</p>
<p>This state might have some symmetry or stabilizers.</p>
<p>Notice that the circuit is designed to create the logical GHZ state, but for physical fidelity, we care about the physical state.</p>
<p>Let me write |œà_ideal‚ü© explicitly.</p>
<p>|œà_ideal‚ü© = \frac{1}{2} ( |0\rangle_0 |0\rangle_1 |0\rangle_2 |0\rangle_3 + |1\rangle_0 |0\rangle_1 |0\rangle_2 |1\rangle_3 + |0\rangle_0 |1\rangle_1 |1\rangle_2 |0\rangle_3 + |1\rangle_0 |1\rangle_1 |1\rangle_2 |1\rangle_3 )</p>
<p>Now, let&rsquo;s find the stabilizers of this state. Since it&rsquo;s a GHZ-like state, it might be stabilized by some Paulis.</p>
<p>For example, XXXX applied to |œà_ideal‚ü©: XXXX |œà_ideal‚ü© = \frac{1}{2} ( |1111\rangle + |0110\rangle + |1001\rangle + |0000\rangle ) = |œà_ideal‚ü©, so it is stabilized by XXXX.</p>
<p>Similarly, ZZZZ |œà_ideal‚ü© = \frac{1}{2} ( |0000\rangle + (-1) |1001\rangle + (-1) |0110\rangle + (1) |1111\rangle )? Let&rsquo;s see: ZZZZ means Z on each qubit, so for each term, phase based on number of |1‚ü©.</p>
<p>|0000‚ü©: all |0‚ü©, so phase +1</p>
<p>|1001‚ü©: qubit 0=1,1=0,2=0,3=1, so three |1‚ü©? qubit 0=1,1=0,2=0,3=1, so two |1‚ü©? |1‚ü© on qubit 0 and 3, so two |1‚ü©, so ZZZZ gives phase (-1)^2 = +1? Z applied to |1‚ü© gives -|1‚ü©, but for basis state, Z_i |x_i‚ü© = (-1)^{x_i} |x_i‚ü©, so for state, ZZZZ |ket&gt; = product of (-1)^{x_i} for each qubit.</p>
<p>For |1001‚ü©, x0=1, x1=0, x2=0, x3=1, so (-1)^{1+0+0+1} = (-1)^2 =1, so phase +1.</p>
<p>Similarly, |0110‚ü©: x0=0,x1=1,x2=1,x3=0, so (-1)^{0+1+1+0} = (-1)^2=1</p>
<p>|1111‚ü©: all 1, (-1)^4=1</p>
<p>So ZZZZ |œà_ideal‚ü© = |œà_ideal‚ü©, so it is also stabilized by ZZZZ.</p>
<p>So |œà_ideal‚ü© is indeed a stabilizer state of the [[4,2,2]] code? But the code has multiple logical states, so this is one of them.</p>
<p>Now, back to fidelity.</p>
<p>First, for case 1: no error after CNOT21.</p>
<p>Then after CNOT03, with prob 1-p, no error, final state |œà_ideal‚ü©, fidelity |‚ü®œà_ideal|œà_ideal‚ü©|^2 =1</p>
<p>With prob p, error F on {0,3}, final state F |œà_ideal‚ü©, so fidelity |‚ü®œà_ideal| F |œà_ideal‚ü©|^2</p>
<p>Now, since F is Pauli on qubits 0 and 3, and |œà_ideal‚ü© is stabilized by XXXX and ZZZZ, but F acts only on 0 and 3, so we need to see if F commutes with the stabilizers or not, but for the overlap, ‚ü®œà_ideal| F |œà_ideal‚ü© is the expectation value of F in state |œà_ideal‚ü©.</p>
<p>Since |œà_ideal‚ü© is a stabilizer state, for any Pauli operator P, ‚ü®œà| P |œà‚ü© is either 0 or ¬±1, depending on whether P is in the stabilizer or not.</p>
<p>Specifically, for a stabilizer state |œà‚ü© with stabilizer group S, ‚ü®œà| P |œà‚ü© = 1 if P ‚àà S, -1 if P ‚àà -S, and 0 otherwise.</p>
<p>But here, F is on qubits 0 and 3, so we need to see if F is in the stabilizer of |œà_ideal‚ü© or not.</p>
<p>The stabilizer of |œà_ideal‚ü© includes XXXX and ZZZZ, but also other operators? Since it&rsquo;s a stabilizer state, the full stabilizer group has 4 generators for 4 qubits, but here we have two generators mentioned, but for this state, it might have more.</p>
<p>From the state, let&rsquo;s find what stabilizes it.</p>
<p>For example, consider operator Z I Z I? Let&rsquo;s see.</p>
<p>First, list the basis states: |0000‚ü©, |1001‚ü©, |0110‚ü©, |1111‚ü©</p>
<p>Notice that the parity of qubits 0 and 3 is the same: in |0000‚ü©, both 0, |1001‚ü© both 1, |0110‚ü© both 0? |0110‚ü© has qubit 0=0, qubit 3=0, so both 0, |1111‚ü© both 1. So qubit 0 and qubit 3 are always equal. So the operator that measures if they are equal? For example, the operator that is I if both same, -I if different, but for stabilizer, we need operators that fix the state.</p>
<p>Since always same, the operator X0 X3 should have expectation, but X0 X3 |œà_ideal‚ü© = ?</p>
<p>X0 X3 |0000‚ü© = |1001‚ü©</p>
<p>X0 X3 |1001‚ü© = |0000‚ü©</p>
<p>X0 X3 |0110‚ü© = |1111‚ü©? X0 on |0&gt; = |1&gt;, X3 on |0&gt; = |1&gt;, so |1111‚ü©? |0110‚ü© with X0 X3: X0 on qubit 0: |0&gt; to |1&gt;, so |1110‚ü©? No: |0110‚ü© means qubit 0=0,1=1,2=1,3=0. After X0, qubit 0=1, so |1110‚ü©? Then X3 on qubit 3=0 to 1, so |1111‚ü©. Similarly X0 X3 |1111‚ü© = |0110‚ü©? X0 on |1&gt; = |0&gt;, X3 on |1&gt; = |0&gt;, so |0110‚ü©. So X0 X3 |œà_ideal‚ü© = |œà_ideal‚ü©, so it is stabilized by X0 X3.</p>
<p>Similarly, since XXXX stabilizes, and X0 X3 stabilizes, then X1 X2 must also stabilize? XXXX = X0 X1 X2 X3, so if X0 X3 stabilizes, then X1 X2 must stabilize because XXXX (X0 X3) = X1 X2, so yes, X1 X2 also stabilizes |œà_ideal‚ü©.</p>
<p>Similarly for Z operators. From ZZZZ, and since qubit 0 and 3 are always same, but let&rsquo;s see Z0 Z3.</p>
<p>Z0 Z3 |0000‚ü© = |0000‚ü©</p>
<p>Z0 Z3 |1001‚ü© = (-1) * (-1) |1001‚ü© = |1001‚ü©? Z0 on |1&gt; = -|1&gt;, Z3 on |1&gt; = -|1&gt;, so product phase (-1)(-1)=1, so yes.</p>
<p>Z0 Z3 |0110‚ü© = Z0 on |0&gt; =1, Z3 on |0&gt; =1, so |0110‚ü©</p>
<p>Z0 Z3 |1111‚ü© = (-1)(-1)|1111‚ü© = |1111‚ü©</p>
<p>So Z0 Z3 |œà_ideal‚ü© = |œà_ideal‚ü©, so stabilized by Z0 Z3.</p>
<p>Similarly, from ZZZZ, and Z0 Z3, then Z1 Z2 must stabilize.</p>
<p>So the stabilizer group of |œà_ideal‚ü© is generated by XXXX, ZZZZ, X0 X3, Z0 Z3, etc., but since XXXX and X0 X3 imply X1 X2, similarly for Z.</p>
<p>But for our purpose, we need to find for Pauli F on {0,3}, what is ‚ü®œà_ideal| F |œà_ideal‚ü©.</p>
<p>F is a Pauli on qubits 0 and 3, so it can be I, X0, X3, X0 X3, Z0, Z3, Z0 Z3, Y0, Y3, Y0 Y3, etc., but since it&rsquo;s Pauli, it&rsquo;s products of X and Z.</p>
<p>But since |œà_ideal‚ü© is stabilized by X0 X3 and Z0 Z3, then for any Pauli P on {0,3}, if P commutes with X0 X3 and Z0 Z3, then it might be in the stabilizer, but not necessarily.</p>
<p>Actually, for a stabilizer state, the expectation value of Pauli P is non-zero only if P commutes with all stabilizers, but since the stabilizers include operators on other qubits, P on {0,3} may not commute with, say, X1 X2, but X1 X2 acts on other qubits, so it commutes with P since acting on different qubits, so yes, P commutes with all stabilizers that act on other qubits.</p>
<p>The stabilizer group of |œà_ideal‚ü© includes operators on all qubits, but since P acts only on 0 and 3, it commutes with any operator that doesn&rsquo;t act on 0 or 3, but for operators that act on 0 or 3, we need to see.</p>
<p>The key point is that for |œà_ideal‚ü©, since it is a stabilizer state, and the subgroup acting on qubits 0 and 3 can be characterized.</p>
<p>From the state, we see that qubit 0 and qubit 3 are always equal in the basis state, so for any Pauli P on {0,3}, it will have non-zero expectation only if it doesn&rsquo;t change the correlation between 0 and 3.</p>
<p>But let&rsquo;s calculate ‚ü®œà_ideal| F |œà_ideal‚ü© for each type of F.</p>
<p>F is a two-qubit Pauli on qubits 0 and 3. There are 16 Paulis, but we need only non-identity for error, but for expectation, we can compute.</p>
<p>Since |œà_ideal‚ü© is normalized, ‚ü®œà_ideal| F |œà_ideal‚ü© is the expectation value.</p>
<p>From the state, let&rsquo;s compute for each possible F.</p>
<p>First, if F = I, then ‚ü®I‚ü© =1</p>
<p>If F = X0, then X0 |œà_ideal‚ü© = \frac{1}{2} ( X0 |0000‚ü© + X0 |1001‚ü© + X0 |0110‚ü© + X0 |1111‚ü© ) = \frac{1}{2} ( |1000‚ü© + |0001‚ü© + |1110‚ü© + |0111‚ü© )</p>
<p>Now ‚ü®œà_ideal| X0 |œà_ideal‚ü© = \frac{1}{4} \langle 0000| + \langle 1001| + \langle 0110| + \langle 1111| ) ( |1000‚ü© + |0001‚ü© + |1110‚ü© + |0111‚ü© )</p>
<p>Now, dot product: ‚ü®0000|1000‚ü©=0, ‚ü®0000|0001‚ü©=0, etc., all terms are orthogonal, so each inner product is zero unless same state. But here, |0000‚ü© vs |1000‚ü©, different, so all inner products are zero. So ‚ü®œà_ideal| X0 |œà_ideal‚ü© =0</p>
<p>Similarly, if F = X3, similarly, X3 |œà_ideal‚ü© = \frac{1}{2} ( |0001‚ü© + |1000‚ü© + |0111‚ü© + |1110‚ü© ) , same as above, so ‚ü®œà_ideal| X3 |œà_ideal‚ü© =0</p>
<p>If F = X0 X3, then X0 X3 |œà_ideal‚ü© = |œà_ideal‚ü© as we saw earlier, so ‚ü®œà_ideal| X0 X3 |œà_ideal‚ü© =1</p>
<p>Similarly, if F = Z0, then Z0 |œà_ideal‚ü© = \frac{1}{2} ( Z0 |0000‚ü© + Z0 |1001‚ü© + Z0 |0110‚ü© + Z0 |1111‚ü© ) = \frac{1}{2} ( |0000‚ü© + (-1)|1001‚ü© + |0110‚ü© + (-1)|1111‚ü© )</p>
<p>Now ‚ü®œà_ideal| Z0 |œà_ideal‚ü© = \frac{1}{4} ( ‚ü®0000| + ‚ü®1001| + ‚ü®0110| + ‚ü®1111| ) ( |0000‚ü© - |1001‚ü© + |0110‚ü© - |1111‚ü© ) = \frac{1}{4} (1 -1 +1 -1) =0</p>
<p>Similarly for Z3, same thing, because from state, qubit 0 and 3 have same value, so Z0 and Z3 have same effect? Z3 |œà_ideal‚ü© = \frac{1}{2} ( |0000‚ü© + (-1)|1001‚ü© + |0110‚ü© + (-1)|1111‚ü© ) same as above, so ‚ü®Z3‚ü©=0</p>
<p>If F = Z0 Z3, then Z0 Z3 |œà_ideal‚ü© = |œà_ideal‚ü© as above, so ‚ü®Z0 Z3‚ü©=1</p>
<p>Now for Y operators. Y = i X Z, so for example F = Y0 = i X0 Z0</p>
<p>But since expectation is linear, and we have ‚ü®X0‚ü©=0, ‚ü®Z0‚ü©=0, so ‚ü®Y0‚ü© = i ‚ü®X0 Z0‚ü© but X0 Z0 is another Pauli, so we can compute directly.</p>
<p>Y0 |œà_ideal‚ü© = i X0 Z0 |œà_ideal‚ü© = i X0 [ \frac{1}{2} ( |0000‚ü© - |1001‚ü© + |0110‚ü© - |1111‚ü© ) ] from earlier? Z0 |œà_ideal‚ü© = \frac{1}{2} ( |0000‚ü© - |1001‚ü© + |0110‚ü© - |1111‚ü© )</p>
<p>Then X0 on that: X0 Z0 |œà_ideal‚ü© = \frac{1}{2} ( X0 |0000‚ü© - X0 |1001‚ü© + X0 |0110‚ü© - X0 |1111‚ü© ) = \frac{1}{2} ( |1000‚ü© - |0001‚ü© + |1110‚ü© - |0111‚ü© )</p>
<p>So Y0 |œà_ideal‚ü© = i \frac{1}{2} ( |1000‚ü© - |0001‚ü© + |1110‚ü© - |0111‚ü© )</p>
<p>Now ‚ü®œà_ideal| Y0 |œà_ideal‚ü© = i \frac{1}{4} \langle 0000| + \langle 1001| + \langle 0110| + \langle 1111| ) ( |1000‚ü© - |0001‚ü© + |1110‚ü© - |0111‚ü© ) =0 since all inner products zero.</p>
<p>Similarly for Y3, same thing.</p>
<p>For F = Y0 Y3, etc., but similarly, since X0 X3 has expectation 1, Z0 Z3 has expectation 1, but Y0 Y3 = i^2 X0 Z0 X3 Z3 = - X0 X3 Z0 Z3, and since X0 X3 and Z0 Z3 both stabilize, so Y0 Y3 |œà_ideal‚ü© = - |œà_ideal‚ü©? Let&rsquo;s see.</p>
<p>Y0 Y3 = (i X0 Z0) (i X3 Z3) = i^2 X0 X3 Z0 Z3 = - X0 X3 Z0 Z3</p>
<p>Now X0 X3 Z0 Z3 |œà_ideal‚ü© = since X0 X3 |œà_ideal‚ü© = |œà_ideal‚ü©, and Z0 Z3 |œà_ideal‚ü© = |œà_ideal‚ü©, but careful: X0 X3 and Z0 Z3 commute? X0 X3 and Z0 Z3 act on different qubits? No, both act on qubit 0 and 3, so they commute? X0 and Z0 anti-commute, but X0 X3 and Z0 Z3: [X0 X3, Z0 Z3] = X0 X3 Z0 Z3 - Z0 Z3 X0 X3 = X0 Z0 X3 Z3 - Z0 X0 Z3 X3 = (-Z0 X0) (-Z3 X3) - Z0 X0 Z3 X3? Let&rsquo;s compute the commutator.</p>
<p>Since X0 and Z0 anti-commute, {X0,Z0}=0, so X0 Z0 = - Z0 X0</p>
<p>Similarly for X3 and Z3.</p>
<p>So X0 X3 Z0 Z3 = X0 Z0 X3 Z3 = (-Z0 X0) (-Z3 X3) = Z0 X0 Z3 X3</p>
<p>And Z0 Z3 X0 X3 = Z0 X0 Z3 X3</p>
<p>So they are equal, so [X0 X3, Z0 Z3] =0, so they commute.</p>
<p>Therefore X0 X3 Z0 Z3 |œà_ideal‚ü© = X0 X3 (Z0 Z3 |œà_ideal‚ü©) = X0 X3 |œà_ideal‚ü© = |œà_ideal‚ü©</p>
<p>So Y0 Y3 |œà_ideal‚ü© = - X0 X3 Z0 Z3 |œà_ideal‚ü© = - |œà_ideal‚ü©</p>
<p>Thus ‚ü®œà_ideal| Y0 Y3 |œà_ideal‚ü© = -1</p>
<p>Similarly, for other products like X0 Z3, etc.</p>
<p>But for fidelity, we need |‚ü®œà_ideal| F |œà_ideal‚ü©|^2, so for F that gives expectation ¬±1, | |^2 =1, for expectation 0, | |^2=0.</p>
<p>So for Pauli F on {0,3}, ‚ü®œà_ideal| F |œà_ideal‚ü© is non-zero only if F is a product of X0 X3 and Z0 Z3, i.e., if F is in the group generated by X0 X3 and Z0 Z3.</p>
<p>The group generated by X0 X3 and Z0 Z3 has elements: I, X0 X3, Z0 Z3, X0 X3 Z0 Z3 = - Y0 Y3? X0 X3 Z0 Z3 = (X0 Z0) (X3 Z3) but since X0 Z0 = i Y0, etc., but anyway, the expectation is ¬±1.</p>
<p>Specifically, from above:</p>
<ul>
<li>
<p>If F = I, ‚ü®F‚ü©=1</p>
</li>
<li>
<p>F = X0 X3, ‚ü®F‚ü©=1</p>
</li>
<li>
<p>F = Z0 Z3, ‚ü®F‚ü©=1</p>
</li>
<li>
<p>F = X0 X3 Z0 Z3, which is same as (X0 Z0) (X3 Z3) but since X0 Z0 = i Y0, so i Y0 i Y3 = i^2 Y0 Y3 = - Y0 Y3, and we have ‚ü® - Y0 Y3 ‚ü© = -1, so for F = X0 X3 Z0 Z3, ‚ü®F‚ü©= -1? From above, Y0 Y3 |œà_ideal‚ü© = - |œà_ideal‚ü©, so ‚ü®Y0 Y3‚ü© = -1, so for F = Y0 Y3, ‚ü®F‚ü©= -1</p>
</li>
</ul>
<p>But Y0 Y3 = i X0 Z0 i X3 Z3 = i^2 X0 X3 Z0 Z3 = - X0 X3 Z0 Z3, so X0 X3 Z0 Z3 = - Y0 Y3, so ‚ü® X0 X3 Z0 Z3 ‚ü© = - ‚ü® Y0 Y3 ‚ü© = - (-1) =1</p>
<p>Similarly, other combinations.</p>
<p>The group generated by X0 X3 and Z0 Z3 has four elements: I, X0 X3, Z0 Z3, and (X0 X3)(Z0 Z3) = X0 X3 Z0 Z3.</p>
<p>And from above, all have expectation 1? From calculation: X0 X3 Z0 Z3 |œà_ideal‚ü© = |œà_ideal‚ü©, so yes, ‚ü®X0 X3 Z0 Z3‚ü©=1.</p>
<p>And for Y0 Y3, which is not in the group, but Y0 Y3 = - X0 X3 Z0 Z3, so ‚ü®Y0 Y3‚ü©= -1.</p>
<p>But for Pauli F, if F is proportional to one of these, but since Pauli operators are defined with phase ¬±1,¬±i, but in the error channel, the Paulis are applied with phase 1, I think? The depolarizing channel applies Pauli operators without phase, so for example, it applies X0, not i Y0, etc.</p>
<p>In the error model, it says &ldquo;produces one of the 15 non-identity two-qubit Paulis&rdquo;, and Paulis are usually taken as the matrices with eigenvalues ¬±1, so for two qubits, the Pauli group has elements like X I, X Z, etc., with phase ¬±1,¬±i, but typically in error models, we consider the operators with phase 1, so the non-identity Paulis are those like X0, X3, X0 X3, Z0, Z3, Z0 Z3, X0 Z3, Z0 X3, Y0, Y3, Y0 Y3, Y0 X3, etc., all with coefficient 1.</p>
<p>So for F on {0,3}, we need to list all 16 Paulis, but for expectation, we can see which ones have non-zero expectation.</p>
<p>From the state |œà_ideal‚ü©, since qubit 0 and 3 are always equal, the reduced density matrix for qubits 0 and 3 is proportional to |00‚ü©‚ü®00| + |11‚ü©‚ü®11|, so it is classical correlated.</p>
<p>For any Pauli P on {0,3}, ‚ü®P‚ü© is non-zero only if P does not change the parity or something.</p>
<p>Specifically, from earlier calculation:</p>
<ul>
<li>
<p>If P has X0 or X3 alone, ‚ü®P‚ü©=0</p>
</li>
<li>
<p>If P has Z0 or Z3 alone, ‚ü®P‚ü©=0</p>
</li>
<li>
<p>If P has Y0 or Y3 alone, ‚ü®P‚ü©=0</p>
</li>
<li>
<p>If P is X0 X3, ‚ü®P‚ü©=1</p>
</li>
<li>
<p>If P is Z0 Z3, ‚ü®P‚ü©=1</p>
</li>
<li>
<p>If P is X0 Z3, let&rsquo;s compute: X0 Z3 |œà_ideal‚ü© = X0 Z3 \frac{1}{2} ( |0000‚ü© + |1001‚ü© + |0110‚ü© + |1111‚ü© ) = \frac{1}{2} ( X0 Z3 |0000‚ü© + X0 Z3 |1001‚ü© + X0 Z3 |0110‚ü© + X0 Z3 |1111‚ü© )</p>
</li>
</ul>
<p>Z3 |0000‚ü© = |0000‚ü©, then X0 |0000‚ü© = |1000‚ü©</p>
<p>Z3 |1001‚ü© = (-1) |1001‚ü© because qubit 3=1, so - |1001‚ü©, then X0 |1001‚ü© = |0001‚ü©? X0 on |1&gt; = |0&gt;, so |0001‚ü©</p>
<p>Similarly, Z3 |0110‚ü© = |0110‚ü© since qubit 3=0, then X0 |0110‚ü© = |1110‚ü©</p>
<p>Z3 |1111‚ü© = (-1) |1111‚ü©, then X0 |1111‚ü© = |0111‚ü©</p>
<p>So X0 Z3 |œà_ideal‚ü© = \frac{1}{2} ( |1000‚ü© + |0001‚ü© + |1110‚ü© + |0111‚ü© )</p>
<p>Now ‚ü®œà_ideal| this state =0, so ‚ü®X0 Z3‚ü©=0</p>
<p>Similarly for Z0 X3, same thing.</p>
<p>Now for P = Y0 X3 etc., but similarly, will be zero.</p>
<p>Now for P = Y0 Y3, we have ‚ü®Y0 Y3‚ü©= -1 as above.</p>
<p>Y0 Y3 = i X0 Z0 i X3 Z3 = - X0 X3 Z0 Z3, but since X0 X3 Z0 Z3 has expectation 1, so Y0 Y3 has expectation -1.</p>
<p>Similarly, for P = X0 X3 Z0 Z3, which is the same as above, expectation 1.</p>
<p>But note that X0 X3 Z0 Z3 is not a basic Pauli; it is a product.</p>
<p>In the Pauli list, for two qubits, the Pauli operators are tensor products of I,X,Y,Z on each qubit, so for example, X0 I3, I0 X3, X0 X3, Z0 I3, I0 Z3, Z0 Z3, X0 Z3, Z0 X3, Y0 I3, I0 Y3, Y0 Y3, X0 Y3, Y0 X3, Z0 Y3, Y0 Z3.</p>
<p>And each can have phase ¬±1, but in application, we apply the operator with phase 1.</p>
<p>So for expectation, we need to compute for each.</p>
<p>But from symmetry, since the state has qubit 0 and 3 correlated, only Paulis that preserve the correlation will have non-zero expectation.</p>
<p>Specifically, Paulis that commute with X0 X3 and Z0 Z3 will have non-zero expectation.</p>
<p>The Paulis on {0,3} that commute with X0 X3 are those that have the same Pauli type on both qubits or something.</p>
<p>From group theory, the centralizer of {X0 X3, Z0 Z3} in the Pauli group on {0,3} is the group generated by X0 X3 and Z0 Z3, which has four elements: I, X0 X3, Z0 Z3, X0 X3 Z0 Z3.</p>
<p>And for these, expectation is 1 for I, X0 X3, Z0 Z3, and for X0 X3 Z0 Z3, which is equivalent to Y0 Y3 up to phase, but since we apply with phase 1, X0 X3 Z0 Z3 has expectation 1, as calculated.</p>
<p>But Y0 Y3 has expectation -1, so when we apply the error operator, if we apply Y0 Y3, it has phase -1, but the operator itself is applied, so for fidelity, |‚ü®œà| Y0 Y3 |œà‚ü©|^2 = | -1 |^2 =1.</p>
<p>Similarly, for any Pauli in the group generated by X0 X3 and Z0 Z3, but with phase, but since we apply the Pauli operator with coefficient 1, for example, if we apply the operator Y0 Y3, which is not in the group, but it has expectation -1, so |‚ü®|^2=1.</p>
<p>From calculation, for any Pauli P on {0,3}, ‚ü®œà_ideal| P |œà_ideal‚ü© is either 0 or ¬±1, and it is ¬±1 only if P is in the set where P is a product of X0 X3 and Z0 Z3, but since X0 X3 and Z0 Z3 generate a group, and any P that is proportional to I, X0 X3, Z0 Z3, or X0 X3 Z0 Z3 will have expectation ¬±1.</p>
<p>But let&rsquo;s list all possible P on {0,3} with coefficient 1.</p>
<p>The Pauli operators are:</p>
<ol>
<li>
<p>I I</p>
</li>
<li>
<p>X I</p>
</li>
<li>
<p>I X</p>
</li>
<li>
<p>X X</p>
</li>
<li>
<p>Z I</p>
</li>
<li>
<p>I Z</p>
</li>
<li>
<p>Z Z</p>
</li>
<li>
<p>X Z</p>
</li>
<li>
<p>Z X</p>
</li>
<li>
<p>Y I</p>
</li>
<li>
<p>I Y</p>
</li>
<li>
<p>Y Y</p>
</li>
<li>
<p>X Y</p>
</li>
<li>
<p>Y X</p>
</li>
<li>
<p>Z Y</p>
</li>
<li>
<p>Y Z</p>
</li>
</ol>
<p>Now, from earlier:</p>
<ul>
<li>
<p>I I: expectation 1</p>
</li>
<li>
<p>X I: expectation 0</p>
</li>
<li>
<p>I X: expectation 0</p>
</li>
<li>
<p>X X: expectation 1</p>
</li>
<li>
<p>Z I: expectation 0</p>
</li>
<li>
<p>I Z: expectation 0</p>
</li>
<li>
<p>Z Z: expectation 1</p>
</li>
<li>
<p>X Z: expectation 0 (as computed)</p>
</li>
<li>
<p>Z X: expectation 0</p>
</li>
<li>
<p>Y I: expectation 0</p>
</li>
<li>
<p>I Y: expectation 0</p>
</li>
<li>
<p>Y Y: expectation -1</p>
</li>
<li>
<p>X Y: let&rsquo;s compute quickly? X Y |œà_ideal‚ü© = X0 Y3 |œà_ideal‚ü©, likely 0</p>
</li>
<li>
<p>Similarly others, all have expectation 0 except the ones above.</p>
</li>
</ul>
<p>So for P on {0,3}, ‚ü®œà_ideal| P |œà_ideal‚ü© ‚â† 0 only for P = I, X X, Z Z, and Y Y.</p>
<p>And for these, |‚ü®œà_ideal| P |œà_ideal‚ü©|^2 =1 since expectation magnitude 1.</p>
<p>So for error F on {0,3}, if F is one of I, X0 X3, Z0 Z3, Y0 Y3, then |‚ü®œà_ideal| F |œà_ideal‚ü©|^2 =1, otherwise 0.</p>
<p>But I is identity, so for non-identity, the Paulis that have non-zero expectation are X0 X3, Z0 Z3, and Y0 Y3.</p>
<p>There are three such Paulis.</p>
<p>In the depolarizing channel, there are 15 non-identity Paulis, so for most, fidelity is 0.</p>
<p>Now back to case 1: no error after CNOT21.</p>
<p>Then after CNOT03, with prob 1-p, no error, fidelity 1</p>
<p>With prob p, error F, and for each F, with prob p/15, fidelity |‚ü®œà_ideal| F |œà_ideal‚ü©|^2</p>
<p>So the average fidelity for case 1 is: (1-p) * 1 + p * [ fraction of F that give fidelity 1 ]</p>
<p>There are 15 possible F, and for 3 of them, fidelity 1, for other 12, fidelity 0.</p>
<p>So average from error after CNOT03: (1-p) <em>1 + p * (3/15) </em>1 + p * (12/15) *0 = (1-p) + p * 3/15 = 1-p + p/5 = 1 - (4/5)p</p>
<p>But this is for after CNOT03 error, but this is when there was no error after CNOT21.</p>
<p>So for case 1, which has probability (1-p) for no error after CNOT21, the fidelity is 1 - (4/5)p</p>
<p>Now, case 2: error E after CNOT21.</p>
<p>This happens with probability p for error after CNOT21, and for each E, prob p/15.</p>
<p>After error E, state is E |œà2‚ü©</p>
<p>Then apply H0: state becomes H0 E |œà2‚ü©</p>
<p>Then apply CNOT03 ideally: state becomes CNOT03 H0 E |œà2‚ü©</p>
<p>Then after CNOT03, with prob 1-p, no error, so final state CNOT03 H0 E |œà2‚ü©</p>
<p>With prob p, error F, so final state F CNOT03 H0 E |œà2‚ü©</p>
<p>Now, we need |‚ü®œà_ideal| final state ‚ü©|^2</p>
<p>But |œà_ideal‚ü© = CNOT03 H0 |œà2‚ü©</p>
<p>So for final state without F error, i.e., CNOT03 H0 E |œà2‚ü©</p>
<p>Then ‚ü®œà_ideal| CNOT03 H0 E |œà2‚ü© = ‚ü®œà2| H0^\dagger CNOT03^\dagger CNOT03 H0 E |œà2‚ü© = ‚ü®œà2| H0^\dagger H0 E |œà2‚ü© = ‚ü®œà2| E |œà2‚ü©</p>
<p>Since H0 and CNOT03 are unitary.</p>
<p>Similarly, if with F error, final state F CNOT03 H0 E |œà2‚ü©</p>
<p>Then ‚ü®œà_ideal| F CNOT03 H0 E |œà2‚ü© = ‚ü®œà2| H0^\dagger CNOT03^\dagger F CNOT03 H0 E |œà2‚ü©</p>
<p>Now, CNOT03^\dagger F CNOT03 is some operator on qubits 0 and 3, since F acts on 0 and 3, and CNOT03 acts on 0 and 3, so CNOT03^\dagger F CNOT03 is also a Pauli on 0 and 3, because CNOT conjugates Pauli to Pauli.</p>
<p>Similarly, H0 acts on qubit 0, so H0^\dagger (CNOT03^\dagger F CNOT03) H0 may change it, but let&rsquo;s see.</p>
<p>First, for simplicity, let&rsquo;s define |œÜ‚ü© = |œà2‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>And we need ‚ü®œÜ| E |œÜ‚ü© for the case without F error.</p>
<p>And for with F error, we need ‚ü®œÜ| H0^\dagger CNOT03^\dagger F CNOT03 H0 E |œÜ‚ü©</p>
<p>But since E is a Pauli on {2,1}, and |œÜ‚ü© is a state on all qubits, we need to compute these overlaps.</p>
<p>Notice that |œÜ‚ü© = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle ) = \frac{1}{\sqrt{2}} |0\rangle_0 |0\rangle_1 |0\rangle_2 |0\rangle_3 + \frac{1}{\sqrt{2}} |0\rangle_0 |1\rangle_1 |1\rangle_2 |0\rangle_3</p>
<p>So |œÜ‚ü© is a state where qubit 0 is always |0‚ü©, qubit 3 is always |0‚ü©, and qubits 1 and 2 are either both |0‚ü© or both |1‚ü©.</p>
<p>So |œÜ‚ü© is stabilized by some operators? For example, Z0, Z3, and X1 X2, etc.</p>
<p>Now, E is a Pauli on qubits 2 and 1.</p>
<p>So for ‚ü®œÜ| E |œÜ‚ü©, since E acts on qubits 1 and 2, and |œÜ‚ü© involves only states where qubits 1 and 2 are correlated.</p>
<p>Let&rsquo;s compute ‚ü®œÜ| E |œÜ‚ü© for general E on {1,2}.</p>
<p>|œÜ‚ü© = \frac{1}{\sqrt{2}} ( |a\rangle + |b\rangle ) where |a‚ü© = |0000‚ü©, |b‚ü© = |0110‚ü©</p>
<p>So ‚ü®œÜ| E |œÜ‚ü© = \frac{1}{2} ( \langle a| E |a\rangle + \langle a| E |b\rangle + \langle b| E |a\rangle + \langle b| E |b\rangle )</p>
<p>Now, |a‚ü© and |b‚ü© are orthogonal, and E is Pauli, so unless E changes the state, but let&rsquo;s see.</p>
<p>For example, if E = I, then ‚ü®œÜ| I |œÜ‚ü© =1</p>
<p>If E = X1, then X1 |a‚ü© = X1 |0000‚ü© = |0100‚ü©, not |a‚ü© or |b‚ü©, so ‚ü®a| X1 |a‚ü©=0, similarly ‚ü®a| X1 |b‚ü© = ‚ü®0000| X1 |0110‚ü© = ‚ü®0000| |0110‚ü©? X1 |0110‚ü© = |0010‚ü©? X1 on qubit 1: |1&gt; to |0&gt;, so |0010‚ü©, so ‚ü®0000|0010‚ü©=0, similarly all terms zero, so ‚ü®œÜ| X1 |œÜ‚ü©=0</p>
<p>Similarly, if E = X2, X2 |a‚ü© = |0010‚ü©, not in {|a‚ü©,|b‚ü©}, so overlap 0</p>
<p>If E = X1 X2, then X1 X2 |a‚ü© = X1 X2 |0000‚ü© = |0110‚ü© = |b‚ü©</p>
<p>X1 X2 |b‚ü© = X1 X2 |0110‚ü© = |0000‚ü© = |a‚ü©</p>
<p>So ‚ü®a| X1 X2 |a‚ü© = ‚ü®a|b‚ü©=0</p>
<p>‚ü®a| X1 X2 |b‚ü© = ‚ü®a|a‚ü©=1</p>
<p>‚ü®b| X1 X2 |a‚ü© = ‚ü®b|b‚ü©=1</p>
<p>‚ü®b| X1 X2 |b‚ü© = ‚ü®b|a‚ü©=0</p>
<p>So ‚ü®œÜ| X1 X2 |œÜ‚ü© = \frac{1}{2} (0 +1 +1 +0) =1</p>
<p>Similarly, if E = Z1, then Z1 |a‚ü© = |0000‚ü©, Z1 |b‚ü© = - |0110‚ü© = - |b‚ü©</p>
<p>So ‚ü®a| Z1 |a‚ü©=1, ‚ü®a| Z1 |b‚ü©= ‚ü®a| -|b‚ü©=0, ‚ü®b| Z1 |a‚ü©=0, ‚ü®b| Z1 |b‚ü©= -1</p>
<p>So ‚ü®œÜ| Z1 |œÜ‚ü© = \frac{1}{2} (1 +0 +0 -1) =0</p>
<p>Similarly for Z2, Z2 |a‚ü© = |0000‚ü©, Z2 |b‚ü© = - |0110‚ü© = - |b‚ü©? Z2 on |b‚ü© = |0110‚ü©, since qubit2=1, Z2 |1&gt; = -|1&gt;, so - |0110‚ü©, so similarly ‚ü®œÜ| Z2 |œÜ‚ü©=0</p>
<p>If E = Z1 Z2, then Z1 Z2 |a‚ü© = |0000‚ü©, Z1 Z2 |b‚ü© = (-1)(-1) |0110‚ü© = |0110‚ü©? Z1 Z2 |0110‚ü© = Z1 |0&gt;1&gt;1&gt;0&gt; but qubit1=1, qubit2=1, so Z1 gives -1, Z2 gives -1, so product phase (-1)(-1)=1, so |0110‚ü©</p>
<p>So Z1 Z2 |a‚ü© = |a‚ü©, Z1 Z2 |b‚ü© = |b‚ü©, so ‚ü®œÜ| Z1 Z2 |œÜ‚ü© =1</p>
<p>Now for Y operators, e.g., E = Y1 = i X1 Z1</p>
<p>But from above, since ‚ü®X1‚ü©=0, ‚ü®Z1‚ü©=0, but let&rsquo;s compute directly.</p>
<p>Y1 |a‚ü© = i X1 Z1 |0000‚ü© = i X1 |0000‚ü© = i |0100‚ü©</p>
<p>Y1 |b‚ü© = i X1 Z1 |0110‚ü© = i X1 ( - |0110‚ü© ) since Z1 |1&gt; = -|1&gt;, so - i X1 |0110‚ü© = - i |0010‚ü©? X1 |0110‚ü© = |0010‚ü©, so -i |0010‚ü©</p>
<p>Now ‚ü®a| Y1 |a‚ü© = ‚ü®0000| i |0100‚ü© =0</p>
<p>‚ü®a| Y1 |b‚ü© = ‚ü®0000| -i |0010‚ü© =0</p>
<p>Similarly all zero, so ‚ü®œÜ| Y1 |œÜ‚ü©=0</p>
<p>Similarly for Y2, etc.</p>
<p>Now for products like X1 Z2, etc.</p>
<p>But from the pattern, ‚ü®œÜ| E |œÜ‚ü© is non-zero only if E preserves the correlation between qubit 1 and 2, i.e., if E is in the group generated by X1 X2 and Z1 Z2.</p>
<p>Similarly to before, for E on {1,2}, ‚ü®œÜ| E |œÜ‚ü© ‚â†0 only if E is I, X1 X2, Z1 Z2, or Y1 Y2? Let&rsquo;s check Y1 Y2.</p>
<p>Y1 Y2 |a‚ü© = Y1 Y2 |0000‚ü© = i X1 Z1 i X2 Z2 |0000‚ü© = i^2 X1 X2 Z1 Z2 |0000‚ü© = - X1 X2 |0000‚ü© since Z1 Z2 |0000‚ü©=|0000‚ü©, so - |0110‚ü© = - |b‚ü©</p>
<p>Y1 Y2 |b‚ü© = Y1 Y2 |0110‚ü© = i X1 Z1 i X2 Z2 |0110‚ü© = - X1 X2 Z1 Z2 |0110‚ü© = - X1 X2 |0110‚ü© since Z1 Z2 |0110‚ü©=|0110‚ü©, so - |0000‚ü© = - |a‚ü©</p>
<p>So ‚ü®a| Y1 Y2 |a‚ü© = ‚ü®a| -|b‚ü©=0</p>
<p>‚ü®a| Y1 Y2 |b‚ü© = ‚ü®a| -|a‚ü©= -1</p>
<p>‚ü®b| Y1 Y2 |a‚ü© = ‚ü®b| -|b‚ü©= -1</p>
<p>‚ü®b| Y1 Y2 |b‚ü© = ‚ü®b| -|a‚ü©=0</p>
<p>So ‚ü®œÜ| Y1 Y2 |œÜ‚ü© = \frac{1}{2} (0 -1 -1 +0) = -1</p>
<p>So |‚ü®œÜ| Y1 Y2 |œÜ‚ü©|^2 =1</p>
<p>Similarly, for other Paulis, only when E is proportional to I, X1 X2, Z1 Z2, or X1 X2 Z1 Z2, but X1 X2 Z1 Z2 |œÜ‚ü© = since X1 X2 Z1 Z2 |a‚ü© = X1 X2 |a‚ü© = |b‚ü©, and X1 X2 Z1 Z2 |b‚ü© = X1 X2 |b‚ü© = |a‚ü©, so ‚ü®œÜ| X1 X2 Z1 Z2 |œÜ‚ü© = \frac{1}{2} (‚ü®a|b‚ü© + ‚ü®a|a‚ü© + ‚ü®b|b‚ü© + ‚ü®b|a‚ü©) wait no.</p>
<p>‚ü®œÜ| X1 X2 Z1 Z2 |œÜ‚ü© = \frac{1}{2} ( \langle a| X1 X2 Z1 Z2 |a\rangle + \langle a| X1 X2 Z1 Z2 |b\rangle + \langle b| X1 X2 Z1 Z2 |a\rangle + \langle b| X1 X2 Z1 Z2 |b\rangle ) = \frac{1}{2} ( \langle a|b\rangle + \langle a|a\rangle + \langle b|b\rangle + \langle b|a\rangle ) = \frac{1}{2} (0+1+1+0) =1</p>
<p>So indeed, for E on {1,2}, ‚ü®œÜ| E |œÜ‚ü© is non-zero only for E in the set where E is I, X1 X2, Z1 Z2, or X1 X2 Z1 Z2.</p>
<p>But X1 X2 Z1 Z2 is the same as Y1 Y2 up to phase? Y1 Y2 = i X1 Z1 i X2 Z2 = - X1 X2 Z1 Z2, so X1 X2 Z1 Z2 = - Y1 Y2, so when we apply the operator, if we apply X1 X2 Z1 Z2, it has expectation 1, if we apply Y1 Y2, it has expectation -1.</p>
<p>But in terms of the operator applied, for the error channel, we apply the Pauli operators with coefficient 1, so for example, we apply X1, I2, etc., or X1 X2, etc.</p>
<p>So from above, the Paulis E on {1,2} that have non-zero expectation are those that are products of X1 X2 and Z1 Z2, i.e., the group generated by X1 X2 and Z1 Z2.</p>
<p>The group has four elements: I, X1 X2, Z1 Z2, and X1 X2 Z1 Z2.</p>
<p>But X1 X2 Z1 Z2 is not a basic Pauli; it is a product. In the list of Pauli operators on two qubits, the operators are things like X1 I2, X1 X2, etc., so for example, X1 X2 is one operator, Z1 Z2 is another, and X1 X2 Z1 Z2 is another operator, which is the same as - Y1 Y2 but with coefficient 1, so when we apply the operator X1 X2 Z1 Z2, it is applied as is.</p>
<p>In the depolarizing channel, the Paulis are all possible tensor products, so including X1 X2, Z1 Z2, and also X1 Z2, etc., and also products like X1 X2 Z1 Z2, which is a valid Pauli operator.</p>
<p>Similarly for others.</p>
<p>So for E on {1,2}, there are 16 Paulis, but only 4 of them have |‚ü®œÜ| E |œÜ‚ü©|^2 =1, and the other 12 have |‚ü®œÜ| E |œÜ‚ü©|^2 =0.</p>
<p>From above, when E is I, X1 X2, Z1 Z2, or X1 X2 Z1 Z2, then ‚ü®œÜ| E |œÜ‚ü© =1,1,1,1 respectively? From calculation:</p>
<ul>
<li>
<p>I: ‚ü®œÜ| I |œÜ‚ü© =1</p>
</li>
<li>
<p>X1 X2: ‚ü®œÜ| X1 X2 |œÜ‚ü© =1</p>
</li>
<li>
<p>Z1 Z2: ‚ü®œÜ| Z1 Z2 |œÜ‚ü© =1</p>
</li>
<li>
<p>X1 X2 Z1 Z2: ‚ü®œÜ| X1 X2 Z1 Z2 |œÜ‚ü© =1</p>
</li>
</ul>
<p>And for Y1 Y2, which is another Pauli, ‚ü®œÜ| Y1 Y2 |œÜ‚ü© = -1, so |‚ü®|^2=1</p>
<p>But Y1 Y2 is not the same as X1 X2 Z1 Z2; they are different operators.</p>
<p>In the list, Y1 Y2 is a Pauli operator, and it has |‚ü®œÜ| Y1 Y2 |œÜ‚ü©|^2 =1.</p>
<p>Similarly, are there others?</p>
<p>Let&rsquo;s list all Paulis on {1,2} that have non-zero expectation.</p>
<p>From the state |œÜ‚ü©, since qubits 1 and 2 are always equal in the sense that in |a‚ü© they are both 0, in |b‚ü© they are both 1, so the reduced density matrix is |00‚ü©‚ü®00| + |11‚ü©‚ü®11| for qubits 1 and2.</p>
<p>So for Pauli P on {1,2}, ‚ü®P‚ü© is non-zero only if P does not change the basis or something.</p>
<p>Specifically, P must commute with X1 X2 and Z1 Z2.</p>
<p>The Paulis that commute with X1 X2 are those that have the same Pauli on both qubits or something.</p>
<p>From earlier calculation, only Paulis that are products of X1 X2 and Z1 Z2 have non-zero expectation, but that includes I, X1 X2, Z1 Z2, and X1 X2 Z1 Z2.</p>
<p>But X1 X2 Z1 Z2 = (X1 Z1) (X2 Z2) = (i Y1) (i Y2) = - Y1 Y2, so if we apply Y1 Y2, it is proportional to X1 X2 Z1 Z2, but with phase -1, so when we apply Y1 Y2, we get expectation -1.</p>
<p>Similarly, if we apply X1 X2 Z1 Z2, we get expectation 1.</p>
<p>But in terms of the operator applied, for the error channel, when we say &ldquo;apply Pauli E&rdquo;, we mean apply the operator with coefficient 1, so for example, apply the matrix Y1 Y2, which has expectation -1.</p>
<p>So for fidelity, |‚ü®œÜ| E |œÜ‚ü©|^2 =1 for E such that E |œÜ‚ü© = ¬± |œÜ‚ü©, which happens when E is in the stabilizer of |œÜ‚ü© or something.</p>
<p>From above, for E on {1,2}, E |œÜ‚ü© = ¬± |œÜ‚ü© only if E is I, X1 X2, Z1 Z2, or Y1 Y2? Let&rsquo;s see.</p>
<p>From earlier, X1 X2 |œÜ‚ü© = |œÜ‚ü©? X1 X2 |a‚ü© = |b‚ü©, X1 X2 |b‚ü© = |a‚ü©, so X1 X2 |œÜ‚ü© = \frac{1}{\sqrt{2}} ( |b‚ü© + |a‚ü© ) = |œÜ‚ü©, so yes.</p>
<p>Z1 Z2 |œÜ‚ü© = |œÜ‚ü© as above.</p>
<p>Y1 Y2 |œÜ‚ü© = - |œÜ‚ü© as above.</p>
<p>Now for X1 X2 Z1 Z2, which is the same as - Y1 Y2, so X1 X2 Z1 Z2 |œÜ‚ü© = - Y1 Y2 |œÜ‚ü© = - (- |œÜ‚ü©) = |œÜ‚ü©, so also.</p>
<p>But X1 X2 Z1 Z2 is not a basic Pauli; it is a product, but it is a Pauli operator.</p>
<p>In the list of Pauli operators on two qubits, the operators are uniquely defined by their action on each qubit, so for example, the operator that is X on qubit 1 and X on qubit 2 is X1 X2, etc.</p>
<p>So for E on {1,2}, the Pauli operators that have E |œÜ‚ü© = ¬± |œÜ‚ü© are: 
- I
- X1 X2
- Z1 Z2
- X1 X2 Z1 Z2
- Y1 Y2</p>
<p>But X1 X2 Z1 Z2 and Y1 Y2 are different operators? Yes, because X1 X2 Z1 Z2 has matrix that is tensor product of X and X times Z and Z, but since it acts on two qubits, it is a single operator.</p>
<p>But note that X1 X2 Z1 Z2 = (X1 Z1) (X2 Z2) = (i Y1) (i Y2) = - Y1 Y2, so indeed, X1 X2 Z1 Z2 is proportional to Y1 Y2.</p>
<p>So in terms of the set of Pauli operators, there are four operators that have expectation magnitude 1: namely, the identity, and the three operators X1 X2, Z1 Z2, and Y1 Y2.</p>
<p>Because X1 X2 Z1 Z2 is not independent; it is equal to - Y1 Y2, so when we apply the operator, if we apply Y1 Y2, we get expectation -1, if we apply X1 X2 Z1 Z2, we get expectation 1, but X1 X2 Z1 Z2 is the same as applying the operator that is X on both and Z on both, which is a valid Pauli, but in the standard list, when we say &ldquo;non-identity Paulis&rdquo;, we list all products, so for example, the operator with X on qubit 1 and Z on qubit 2 is X1 Z2, etc.</p>
<p>So for the error channel, the Pauli operators on two qubits are all possible combinations of I,X,Y,Z on each qubit with coefficient 1, so there are 16 operators, including for example X1 I2, I1 X2, X1 X2, X1 Z2, Z1 X2, Z1 Z2, Y1 I2, I1 Y2, Y1 Y2, X1 Y2, Y1 X2, Z1 Y2, Y1 Z2, etc.</p>
<p>Now for each, we can compute the expectation with |œÜ‚ü©.</p>
<p>From earlier calculation and symmetry, the only operators that have non-zero expectation are those where the operator on qubit 1 and qubit 2 are the same type and same sign? But from above, for example, X1 X2 has expectation 1, Z1 Z2 has expectation 1, Y1 Y2 has expectation -1.</p>
<p>What about X1 Z2? X1 Z2 |a‚ü© = X1 Z2 |0000‚ü© = X1 |0000‚ü© = |0100‚ü©, not proportional to |a‚ü© or |b‚ü©, so expectation 0.</p>
<p>Similarly for others.</p>
<p>So indeed, for E on {1,2}, ‚ü®œÜ| E |œÜ‚ü© ‚â† 0 only if E is I, X1 X2, Z1 Z2, or Y1 Y2.</p>
<p>And for these, |‚ü®œÜ| E |œÜ‚ü©|^2 =1.</p>
<p>So there are 4 operators out of 16 that give fidelity 1, but since I is identity, for non-identity, there are 3 operators that give fidelity 1.</p>
<p>In the error channel, when error occurs, we have non-identity Paulis, so for E non-identity, there are 15 possible, and for 3 of them, |‚ü®œÜ| E |œÜ‚ü©|^2 =1, for other 12, it is 0.</p>
<p>But in case 2, when we have error E after CNOT21, then for the final state without F error, we have final state CNOT03 H0 E |œà2‚ü©, and ‚ü®œà_ideal| this state = ‚ü®œÜ| E |œÜ‚ü© as above, so |‚ü®|^2 = |‚ü®œÜ| E |œÜ‚ü©|^2</p>
<p>So if E is one of the 3 non-identity Paulis that give |‚ü®œÜ| E |œÜ‚ü©|^2=1, then this term has fidelity 1, otherwise 0.</p>
<p>Then for with F error, we have final state F CNOT03 H0 E |œà2‚ü©, and ‚ü®œà_ideal| this state = ‚ü®œÜ| H0^\dagger CNOT03^\dagger F CNOT03 H0 E |œÜ‚ü©</p>
<p>Now, CNOT03^\dagger F CNOT03 is a Pauli on {0,3} because CNOT conjugates Pauli to Pauli.</p>
<p>Similarly, H0^\dagger something H0 may change it.</p>
<p>But note that H0 acts on qubit 0, and CNOT03 acts on qubits 0 and 3, so let&rsquo;s define O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>Since F is on {0,3}, CNOT03^\dagger F CNOT03 is on {0,3}, and then H0^\dagger ( that ) H0 is on qubit 0, so it is still an operator on qubits 0 and 3, but may be different Pauli.</p>
<p>Then we need ‚ü®œÜ| O E |œÜ‚ü©</p>
<p>But E is on {1,2}, and O is on {0,3}, and |œÜ‚ü© is on all qubits, and since they act on different sets of qubits, O and E commute, so ‚ü®œÜ| O E |œÜ‚ü© = ‚ü®œÜ| O |œÜ‚ü© ‚ü®œÜ| E |œÜ‚ü©? No, because |œÜ‚ü© is not necessarily product, but since O acts on 0 and3, E acts on 1 and2, and |œÜ‚ü© might be product between {0,3} and {1,2}, let&rsquo;s see.</p>
<p>From |œÜ‚ü© = \frac{1}{\sqrt{2}} ( |0000‚ü© + |0110‚ü© ) = \frac{1}{\sqrt{2}} ( |0\rangle_0 |0\rangle_3 |0\rangle_1 |0\rangle_2 + |0\rangle_0 |0\rangle_3 |1\rangle_1 |1\rangle_2 ) = |0\rangle_0 |0\rangle_3 \otimes \frac{1}{\sqrt{2}} ( |00\rangle_{12} + |11\rangle_{12} )</p>
<p>So indeed, |œÜ‚ü© is product between qubits {0,3} and {1,2}, specifically, qubits 0 and 3 are in state |00\rangle_{03}, and qubits 1 and 2 are in state \frac{1}{\sqrt{2}} ( |00\rangle + |11\rangle ) which is Bell state.</p>
<p>So for operator O on {0,3}, and E on {1,2}, we have ‚ü®œÜ| O E |œÜ‚ü© = ‚ü®00|<em>{03} O |00\rangle</em>{03} \cdot \langle Bell| E | Bell\rangle_{12}</p>
<p>Because |œÜ‚ü© = |00\rangle_{03} \otimes |\Phi^+\rangle_{12} where |\Phi^+\rangle = \frac{1}{\sqrt{2}} ( |00\rangle + |11\rangle )</p>
<p>So ‚ü®œÜ| O E |œÜ‚ü© = [ ‚ü®00|<em>{03} O |00\rangle</em>{03} ] [ ‚ü®\Phi^+| E |\Phi^+\rangle_{12} ]</p>
<p>Now, ‚ü®00|<em>{03} O |00\rangle</em>{03} is the expectation of O in state |00‚ü©_{03}</p>
<p>Similarly, ‚ü®\Phi^+| E |\Phi^+\rangle_{12} is the expectation of E in Bell state.</p>
<p>Now, for the Bell state |\Phi^+\rangle = \frac{1}{\sqrt{2}} ( |00\rangle + |11\rangle ), what is ‚ü®\Phi^+| E |\Phi^+\rangle for E on {1,2}?</p>
<p>Similarly to before, for E on {1,2}, ‚ü®\Phi^+| E |\Phi^+\rangle is non-zero only if E is I, X1 X2, Z1 Z2, or Y1 Y2, and for these, it is 1,1,1,-1 respectively? Let&rsquo;s compute.</p>
<p>For E=I, ‚ü®E‚ü©=1</p>
<p>For E=X1 X2, X1 X2 |\Phi^+\rangle = X1 X2 \frac{1}{\sqrt{2}} ( |00\rangle + |11\rangle ) = \frac{1}{\sqrt{2}} ( |11\rangle + |00\rangle ) = |\Phi^+\rangle, so ‚ü®E‚ü©=1</p>
<p>For E=Z1 Z2, Z1 Z2 |\Phi^+\rangle = \frac{1}{\sqrt{2}} ( Z1 Z2 |00\rangle + Z1 Z2 |11\rangle ) = \frac{1}{\sqrt{2}} ( |00\rangle + (-1)(-1)|11\rangle ) = |\Phi^+\rangle, so ‚ü®E‚ü©=1</p>
<p>For E=Y1 Y2, Y1 Y2 |\Phi^+\rangle = i X1 Z1 i X2 Z2 |\Phi^+\rangle = - X1 X2 Z1 Z2 |\Phi^+\rangle = - X1 X2 |\Phi^+\rangle since Z1 Z2 |\Phi^+\rangle=|\Phi^+\rangle, so - |\Phi^+\rangle, so ‚ü®E‚ü©= -1</p>
<p>For other E, ‚ü®E‚ü©=0.</p>
<p>So indeed, ‚ü®\Phi^+| E |\Phi^+\rangle =1 for E=I, X1 X2, Z1 Z2, and -1 for Y1 Y2, and 0 otherwise.</p>
<p>So |‚ü®\Phi^+| E |\Phi^+\rangle|^2 =1 for these4 operators, and 0 for others.</p>
<p>But since E is for error on {1,2}, and in case 2, E is applied after CNOT21, so for the overlap, we have ‚ü®œÜ| E |œÜ‚ü© = ‚ü®00|<em>{03} |00\rangle</em>{03} ‚ü®\Phi^+| E |\Phi^+\rangle = 1 * ‚ü®\Phi^+| E |\Phi^+\rangle</p>
<p>So from above, if E is I, X1 X2, Z1 Z2, or Y1 Y2, then ‚ü®œÜ| E |œÜ‚ü© =1,1,1,-1 respectively, so |‚ü®œÜ| E |œÜ‚ü©|^2=1 for these4 cases.</p>
<p>Otherwise, |‚ü®œÜ| E |œÜ‚ü©|^2=0.</p>
<p>But for non-identity E, there are 3 operators that give |‚ü®œÜ| E |œÜ‚ü©|^2=1: X1 X2, Z1 Z2, Y1 Y2.</p>
<p>Now back to case 2.</p>
<p>For case 2, with error E after CNOT21, which happens with probability p for error, and for each E, prob p/15.</p>
<p>Then after that, we apply H0 and CNOT03 ideally, so state becomes CNOT03 H0 E |œà2‚ü©</p>
<p>Then with probability 1-p, no error after CNOT03, so final state is CNOT03 H0 E |œà2‚ü©</p>
<p>Then fidelity |‚ü®œà_ideal| this state‚ü©|^2 = |‚ü®œÜ| E |œÜ‚ü©|^2</p>
<p>So if E is one of the 3 good non-identity Paulis, fidelity 1, else fidelity 0.</p>
<p>With probability p, error F after CNOT03, so final state F CNOT03 H0 E |œà2‚ü©</p>
<p>Then fidelity |‚ü®œà_ideal| this state‚ü©|^2 = |‚ü®œÜ| H0^\dagger CNOT03^\dagger F CNOT03 H0 E |œÜ‚ü©|^2</p>
<p>But as above, this is | [ ‚ü®00|<em>{03} O |00\rangle</em>{03} ] [ ‚ü®\Phi^+| E |\Phi^+\rangle ] |^2 where O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>Now O is an operator on {0,3}, and we need ‚ü®00|<em>{03} O |00\rangle</em>{03}</p>
<p>Now |00\rangle_{03} is a state, and O is a Pauli operator on {0,3} after conjugation.</p>
<p>First, CNOT03^\dagger F CNOT03 for F on {0,3}.</p>
<p>CNOT03 with control 0 target 3.</p>
<p>The conjugation of Pauli by CNOT03.</p>
<p>For example, if F = X0, then CNOT03^\dagger X0 CNOT03 = X0 X3? Let&rsquo;s recall.</p>
<p>Generally, CNOT conjugation: 
- CNOT^\dagger X_c CNOT = X_c X_t
- CNOT^\dagger X_t CNOT = X_t
- CNOT^\dagger Z_c CNOT = Z_c
- CNOT^\dagger Z_t CNOT = Z_c Z_t</p>
<p>Where c is control, t is target.</p>
<p>So for CNOT03, c=0, t=3.</p>
<p>So CNOT03^\dagger F CNOT03 for F on {0,3}.</p>
<p>For example, if F = X0, then CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>If F = X3, then CNOT03^\dagger X3 CNOT03 = X3</p>
<p>If F = Z0, then CNOT03^\dagger Z0 CNOT03 = Z0</p>
<p>If F = Z3, then CNOT03^\dagger Z3 CNOT03 = Z0 Z3</p>
<p>And for other Paulis, similarly.</p>
<p>Then after that, we apply H0^\dagger &hellip; H0</p>
<p>H0 conjugation on qubit 0: 
H0^\dagger X0 H0 = Z0
H0^\dagger Z0 H0 = X0</p>
<p>So for O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>So let&rsquo;s compute for each type of F.</p>
<p>But since we need ‚ü®00|<em>{03} O |00\rangle</em>{03}, and O is a Pauli operator on {0,3}, so ‚ü®00| O |00‚ü© is non-zero only if O is I or something, but |00‚ü© is eigenstate of Z0 and Z3, so ‚ü®00| O |00‚ü© ‚â†0 only if O has no X or Y on either qubit, i.e., if O is product of Z operators or I.</p>
<p>Specifically, for |00‚ü©, ‚ü®00| O |00‚ü© =1 if O=I, or if O=Z0, or O=Z3, or O=Z0 Z3, but since |00‚ü© is |0‚ü© for both, Z0 |00‚ü© = |00‚ü©, Z3 |00‚ü© = |00‚ü©, so ‚ü®00| Z0 |00‚ü©=1, similarly for Z3, Z0 Z3.</p>
<p>But if O has X or Y, then O |00‚ü© has |1‚ü©, so ‚ü®00| O |00‚ü©=0.</p>
<p>So ‚ü®00| O |00‚ü© =1 only if O is I, Z0, Z3, or Z0 Z3.</p>
<p>Otherwise, 0.</p>
<p>Now for our case, we need O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>So we need to see for which F, this O is one of I, Z0, Z3, or Z0 Z3.</p>
<p>Since H0 acts only on qubit 0, and CNOT03 on 0 and3, we can compute for each F what is O.</p>
<p>But note that we have average over F, and also over E.</p>
<p>For case 2, when we have error F after CNOT03, the fidelity is | [ ‚ü®00| O |00‚ü© ] [ ‚ü®Œ¶+| E |Œ¶+‚ü© ] |^2</p>
<p>Since both are scalars, so | ab |^2 = |a|^2 |b|^2</p>
<p>And from above, ‚ü®00| O |00‚ü© is either 0 or 1, and similarly ‚ü®Œ¶+| E |Œ¶+‚ü© is either 0 or ¬±1, so |b|^2 is 0 or 1.</p>
<p>So for fidelity to be 1, we need both ‚ü®00| O |00‚ü© =1 and ‚ü®Œ¶+| E |Œ¶+‚ü© = ¬±1, so |b|^2=1.</p>
<p>Otherwise, fidelity 0.</p>
<p>So for case 2 with F error, the fidelity is 1 only if E is one of the good Paulis (X1 X2, Z1 Z2, Y1 Y2) and O is one of I, Z0, Z3, Z0 Z3.</p>
<p>Otherwise, fidelity 0.</p>
<p>Now, for given F, what is O, and for which F is O one of those.</p>
<p>But since we average over F, and F is random, we need to find the probability that for random F, O is in that set.</p>
<p>But O depends on F.</p>
<p>Now let&rsquo;s compute O for each F.</p>
<p>First, let&rsquo;s find CNOT03^\dagger F CNOT03 for F on {0,3}.</p>
<p>As above, for F = X0, CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>For F = X3, CNOT03^\dagger X3 CNOT03 = X3</p>
<p>For F = Z0, CNOT03^\dagger Z0 CNOT03 = Z0</p>
<p>For F = Z3, CNOT03^\dagger Z3 CNOT03 = Z0 Z3</p>
<p>For F = X0 X3, CNOT03^\dagger X0 X3 CNOT03 = (X0 X3) (X3) = X0 X3 X3 = X0 I3? Let&rsquo;s compute carefully.</p>
<p>CNOT03^\dagger X0 X3 CNOT03 = CNOT03^\dagger X0 CNOT03 CNOT03^\dagger X3 CNOT03 because CNOT03 is unitary, so it distributes.</p>
<p>CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>CNOT03^\dagger X3 CNOT03 = X3</p>
<p>So product is X0 X3 * X3 = X0 X3 X3 = X0 I3 = X0</p>
<p>Similarly, for F = X0 Z3, etc., but we may not need all.</p>
<p>Now for O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>So for example, if F = X0, then CNOT03^\dagger F CNOT03 = X0 X3</p>
<p>Then H0^\dagger (X0 X3) H0 = H0^\dagger X0 H0 H0^\dagger X3 H0 = Z0 X3 because H0^\dagger X0 H0 = Z0, and H0^\dagger X3 H0 = X3 since H0 acts only on qubit 0.</p>
<p>So O = Z0 X3</p>
<p>Similarly, if F = X3, then CNOT03^\dagger X3 CNOT03 = X3</p>
<p>Then O = H0^\dagger X3 H0 = X3</p>
<p>If F = Z0, then CNOT03^\dagger Z0 CNOT03 = Z0</p>
<p>Then O = H0^\dagger Z0 H0 = X0</p>
<p>If F = Z3, then CNOT03^\dagger Z3 CNOT03 = Z0 Z3</p>
<p>Then O = H0^\dagger (Z0 Z3) H0 = H0^\dagger Z0 H0 H0^\dagger Z3 H0 = X0 Z3</p>
<p>Now for F = X0 X3, then CNOT03^\dagger X0 X3 CNOT03 = X0 as above</p>
<p>Then O = H0^\dagger X0 H0 = Z0</p>
<p>If F = Z0 Z3, then CNOT03^\dagger Z0 Z3 CNOT03 = CNOT03^\dagger Z0 CNOT03 CNOT03^\dagger Z3 CNOT03 = Z0 * (Z0 Z3) = Z0 Z0 Z3 = I0 Z3 = Z3</p>
<p>Then O = H0^\dagger Z3 H0 = Z3</p>
<p>If F = X0 Z3, then CNOT03^\dagger X0 Z3 CNOT03 = [CNOT03^\dagger X0 CNOT03] [CNOT03^\dagger Z3 CNOT03] = (X0 X3) (Z0 Z3) = X0 Z0 X3 Z3</p>
<p>Then O = H0^\dagger (X0 Z0 X3 Z3) H0 = H0^\dagger X0 Z0 H0 X3 Z3 = H0^\dagger X0 H0 H0^\dagger Z0 H0 X3 Z3 = Z0 X0 X3 Z3 = - X0 Z0 X3 Z3? Let&rsquo;s compute:</p>
<p>H0^\dagger X0 Z0 H0 = since H0 X0 H0^\dagger = Z0, but careful: H0^\dagger X0 H0 = Z0, and H0^\dagger Z0 H0 = X0, so H0^\dagger X0 Z0 H0 = H0^\dagger X0 H0 H0^\dagger Z0 H0 = Z0 X0</p>
<p>So then O = (Z0 X0) X3 Z3 = Z0 X0 X3 Z3</p>
<p>Now X0 X3 Z3 is not simple, but for ‚ü®00| O |00‚ü©, O has X0 and X3, so it will have off-diagonal, so ‚ü®00| O |00‚ü©=0.</p>
<p>Similarly for other F, we need to see when O has only Z operators.</p>
<p>From the examples, when O has any X or Y, then ‚ü®00| O |00‚ü©=0.</p>
<p>So we need O to be I, Z0, Z3, or Z0 Z3.</p>
<p>From above, when F = X0, O= Z0 X3, which has X3, so not good.</p>
<p>F=X3, O=X3, has X3, not good.</p>
<p>F=Z0, O=X0, has X0, not good.</p>
<p>F=Z3, O=X0 Z3, has X0, not good.</p>
<p>F=X0 X3, O=Z0, which is good, since Z0 is one of the desired.</p>
<p>F=Z0 Z3, O=Z3, which is good.</p>
<p>Now what about F= Y0 Y3? But let&rsquo;s list all F that give O with only Z.</p>
<p>Perhaps from the conjugation, since H0 and CNOT03 are Clifford, the map F to O is a permutation of Paulis, so for each O, there is some F.</p>
<p>But we need for which F, O is in {I, Z0, Z3, Z0 Z3}</p>
<p>From above, when F=X0 X3, O=Z0</p>
<p>When F=Z0 Z3, O=Z3</p>
<p>Now what about when O=I? For example, if F=I, then CNOT03^\dagger I CNOT03=I, then O= H0^\dagger I H0=I, so O=I, good.</p>
<p>But F=I is identity, but in error channel, F is non-identity for error, but when no error, we already handled, so for error F, F is non-identity, so we need non-identity F such that O is in {I, Z0, Z3, Z0 Z3}</p>
<p>But O=I corresponds to F such that H0^\dagger CNOT03^\dagger F CNOT03 H0 = I, so CNOT03^\dagger F CNOT03 = H0 I H0^\dagger = I, so F=I, but F=I is identity, not non-identity.</p>
<p>So for non-identity F, O cannot be I.</p>
<p>Similarly, O=Z0, from above, when F=X0 X3, O=Z0</p>
<p>O=Z3, when F=Z0 Z3, O=Z3</p>
<p>O=Z0 Z3, when is O=Z0 Z3?</p>
<p>For example, if F= X3 Z0? Let&rsquo;s find.</p>
<p>Suppose we want O=Z0 Z3</p>
<p>Then H0^\dagger CNOT03^\dagger F CNOT03 H0 = Z0 Z3</p>
<p>So CNOT03^\dagger F CNOT03 = H0 Z0 Z3 H0^\dagger = H0 Z0 H0^\dagger H0 Z3 H0^\dagger = X0 Z3</p>
<p>So CNOT03^\dagger F CNOT03 = X0 Z3</p>
<p>Thus F = CNOT03 X0 Z3 CNOT03^\dagger</p>
<p>Now CNOT03 X0 Z3 CNOT03^\dagger = CNOT03 X0 CNOT03^\dagger CNOT03 Z3 CNOT03^\dagger</p>
<p>CNOT03 X0 CNOT03^\dagger = since CNOT03^\dagger X0 CNOT03 = X0 X3, so CNOT03 X0 CNOT03^\dagger = X0 X3? Let&rsquo;s see.</p>
<p>From earlier, CNOT03^\dagger X0 CNOT03 = X0 X3, so by multiplying on left by CNOT03 and on right by CNOT03^\dagger, CNOT03 CNOT03^\dagger X0 CNOT03 CNOT03^\dagger = CNOT03 (X0 X3) CNOT03^\dagger, so X0 = CNOT03 X0 X3 CNOT03^\dagger</p>
<p>Similarly, CNOT03^\dagger Z3 CNOT03 = Z0 Z3, so Z3 = CNOT03 Z0 Z3 CNOT03^\dagger</p>
<p>So for CNOT03 X0 Z3 CNOT03^\dagger = [CNOT03 X0 CNOT03^\dagger] [CNOT03 Z3 CNOT03^\dagger] = [ X0 X3 ] [ Z0 Z3 ] from above? From X0 = CNOT03 X0 X3 CNOT03^\dagger, so CNOT03 X0 CNOT03^\dagger = X0 X3? Let&rsquo;s solve.</p>
<p>From CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>So by taking dagger, (CNOT03^\dagger X0 CNOT03)^\dagger = (X0 X3)^\dagger, so CNOT03^\dagger X0 CNOT03 = X0 X3 since Pauli self-adjoint.</p>
<p>So from this, we have CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>Then multiply on left by CNOT03, CNOT03 CNOT03^\dagger X0 CNOT03 = CNOT03 X0 X3</p>
<p>So X0 CNOT03 = CNOT03 X0 X3</p>
<p>Thus CNOT03 X0 = X0 X3 CNOT03</p>
<p>So CNOT03 X0 CNOT03^\dagger = X0 X3 CNOT03 CNOT03^\dagger = X0 X3</p>
<p>Similarly, from CNOT03^\dagger Z3 CNOT03 = Z0 Z3</p>
<p>Then CNOT03 Z3 CNOT03^\dagger = Z0 Z3 CNOT03 CNOT03^\dagger = Z0 Z3</p>
<p>So back to CNOT03 X0 Z3 CNOT03^\dagger = [CNOT03 X0 CNOT03^\dagger] [CNOT03 Z3 CNOT03^\dagger] = (X0 X3) (Z0 Z3) = X0 Z0 X3 Z3</p>
<p>So F = X0 Z0 X3 Z3</p>
<p>But X0 Z0 X3 Z3 is a Pauli operator, and it is non-identity.</p>
<p>Then O = H0^\dagger CNOT03^\dagger F CNOT03 H0 = from above, we wanted O=Z0 Z3, and we have it.</p>
<p>So for F = X0 Z0 X3 Z3, O=Z0 Z3</p>
<p>Similarly, for other desired O.</p>
<p>But for our purpose, we need when O is in {I, Z0, Z3, Z0 Z3} for non-identity F.</p>
<p>From above, for F=X0 X3, O=Z0</p>
<p>For F=Z0 Z3, O=Z3</p>
<p>For F=X0 Z0 X3 Z3, O=Z0 Z3</p>
<p>Are there other F? For example, if F= something that gives O=Z0, but from above, when F=X0 X3, O=Z0</p>
<p>Similarly, if F=Y0 Y3, let&rsquo;s compute.</p>
<p>F=Y0 Y3 = i X0 Z0 i X3 Z3 = - X0 X3 Z0 Z3</p>
<p>Then CNOT03^\dagger F CNOT03 = CNOT03^\dagger (- X0 X3 Z0 Z3) CNOT03 = - [CNOT03^\dagger X0 X3 CNOT03] [CNOT03^\dagger Z0 Z3 CNOT03] because Z0 Z3 commutes with CNOT03? Not necessarily, but since CNOT03^\dagger (AB) CNOT03 = (CNOT03^\dagger A CNOT03) (CNOT03^\dagger B CNOT03) if A and B commute with CNOT03? But better to compute separately.</p>
<p>CNOT03^\dagger X0 X3 CNOT03 = from earlier, for X0 X3, we had CNOT03^\dagger X0 X3 CNOT03 = X0 as above</p>
<p>CNOT03^\dagger Z0 Z3 CNOT03 = CNOT03^\dagger Z0 CNOT03 CNOT03^\dagger Z3 CNOT03 = Z0 * (Z0 Z3) = Z0 Z0 Z3 = Z3</p>
<p>So CNOT03^\dagger F CNOT03 = - X0 Z3</p>
<p>Then O = H0^\dagger (- X0 Z3) H0 = - H0^\dagger X0 H0 H0^\dagger Z3 H0 = - Z0 X3</p>
<p>So O = - Z0 X3, which has X3, so not good.</p>
<p>So for non-identity F, the only F that give O in {Z0, Z3, Z0 Z3} are F=X0 X3, F=Z0 Z3, and F=X0 Z0 X3 Z3.</p>
<p>But F=X0 Z0 X3 Z3 is the same as - Y0 Y3 up to phase, but as operator, it is applied.</p>
<p>So there are 3 non-identity F that make O good.</p>
<p>Now, back to case 2 with F error.</p>
<p>The fidelity is 1 only if E is good (one of X1 X2, Z1 Z2, Y1 Y2) and F is good (one of X0 X3, Z0 Z3, X0 Z0 X3 Z3)</p>
<p>Otherwise, fidelity 0.</p>
<p>Now, for case 2, we have probability for error E after CNOT21, and error F after CNOT03.</p>
<p>But in case 2, when we have error E after CNOT21, then with probability 1-p, no error after CNOT03, so fidelity depends only on E, and is 1 if E good, else 0.</p>
<p>With probability p, error F after CNOT03, so fidelity is 1 only if both E and F good, else 0.</p>
<p>Now, the probability that E is good: there are 15 non-identity Paulis on {1,2}, and 3 of them are good, so prob E good is 3/15 = 1/5</p>
<p>Similarly for F, prob F good is 3/15 = 1/5</p>
<p>Now, for case 2, which happens with probability p for error after CNOT21, and for each E, but since we average, the contribution from case 2 to fidelity is:</p>
<p>When no error after CNOT03: prob (1-p) times fidelity which is 1 if E good, else 0, so average over E: (1-p) * (1/5) <em>1 + (1-p) * (4/5) </em>0 = (1-p)/5</p>
<p>When error after CNOT03: prob p times, and fidelity is 1 only if both E and F good, so average over E and F: p * (1/5) * (1/5) *1 = p/25</p>
<p>So for case 2, the average fidelity is (1-p)/5 + p/25</p>
<p>Now, recall case 1: no error after CNOT21, which has probability (1-p), and average fidelity 1 - (4/5)p as earlier.</p>
<p>Now, the overall fidelity is the average over both error locations.</p>
<p>So total fidelity F = probability case 1 * fidelity case 1 + probability case 2 * fidelity case 2</p>
<p>Probability case 1: no error after CNOT21, prob = 1-p</p>
<p>Fidelity case 1: 1 - (4/5)p</p>
<p>Probability case 2: error after CNOT21, prob = p</p>
<p>Fidelity case 2: (1-p)/5 + p/25</p>
<p>So F = (1-p) [1 - (4/5)p] + p [ (1-p)/5 + p/25 ]</p>
<p>Now simplify this expression.</p>
<p>First, (1-p) [1 - (4/5)p] = (1-p) (1 - 0.8p) = 1 - 0.8p - p + 0.8p^2 = 1 - 1.8p + 0.8p^2</p>
<p>Better to use fractions: (1-p) (1 - 4p/5) = 1 - 4p/5 - p + 4p^2/5 = 1 - (4/5)p - (5/5)p + (4/5)p^2 = 1 - (9/5)p + (4/5)p^2</p>
<p>Now second part: p [ (1-p)/5 + p/25 ] = p [ (1-p)/5 + p/25 ] = p [ (5(1-p) + p)/25 ] = p [ (5 -5p + p)/25 ] = p (5 -4p)/25 = (5p -4p^2)/25</p>
<p>So total F = [1 - (9/5)p + (4/5)p^2] + [ (5p -4p^2)/25 ]</p>
<p>Now get common denominator, which is 25.</p>
<p>First term: 1 - (9/5)p + (4/5)p^2 = 25/25 - (45/25)p + (20/25)p^2</p>
<p>Second term: (5p -4p^2)/25</p>
<p>So F = [25 -45p +20p^2 +5p -4p^2]/25 = [25 -40p +16p^2]/25</p>
<p>So F = 1 - (40/25)p + (16/25)p^2 = 1 - (8/5)p + (16/25)p^2</p>
<p>Now, this is the physical state fidelity.</p>
<p>But is this correct? Let me verify.</p>
<p>When p=0, no errors, F=1, good.</p>
<p>When p=1, always errors, but let&rsquo;s see.</p>
<p>But for small p, we have F ‚âà 1 - (8/5)p</p>
<p>Now, the problem asks for physical state fidelity as a function of p.</p>
<p>So perhaps this is the answer.</p>
<p>But let me confirm if I missed something.</p>
<p>In the circuit, there are two CNOT gates, each with error probability p, so yes.</p>
<p>And I think I covered all cases.</p>
<p>So the fidelity is F = 1 - \frac{8}{5} p + \frac{16}{25} p^2</p>
<p>But since p is small, we often keep up to linear terms, but here we have exact.</p>
<p>Now, for the final answer, I think we need to box it.</p>
<p>But let me write it neatly.</p>
<p>So the physical state fidelity is</p>
<div class="arithmatex">\[
F = 1 - \frac{8}{5} p + \frac{16}{25} p^2
\]</div>
<p>We can write as</p>
<div class="arithmatex">\[
F = \frac{25 - 40p + 16p^2}{25}
\]</div>
<p>But either way.</p>
<p>Now, for the output, I need to present it.</p>
<p>So finally.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p>The goal is to find the physical state fidelity of the final 4-qubit state after applying the circuit <span class="arithmatex">\( \text{CNOT}_{03} H_0 \text{CNOT}_{21} H_2 \)</span> (operations applied from right to left) with initial state <span class="arithmatex">\( |0000\rangle \)</span>, where each CNOT gate is followed by a two-qubit depolarizing error channel with error probability <span class="arithmatex">\( p \)</span>. The error channel applies one of the 15 non-identity two-qubit Pauli operators with probability <span class="arithmatex">\( p/15 \)</span> each. The Hadamard gates are perfect.</p>
<h4 id="ideal-state-preparation">Ideal State Preparation</h4>
<ol>
<li>Apply <span class="arithmatex">\( H_2 \)</span> to <span class="arithmatex">\( |0000\rangle \)</span>:</li>
</ol>
<div class="arithmatex">\[
   H_2 |0000\rangle = \frac{1}{\sqrt{2}} (|0000\rangle + |0010\rangle)
\]</div>
<ol start="2">
<li>Apply <span class="arithmatex">\( \text{CNOT}_{21} \)</span> (control qubit 2, target qubit 1):</li>
</ol>
<div class="arithmatex">\[
   \text{CNOT}_{21} \left( \frac{1}{\sqrt{2}} (|0000\rangle + |0010\rangle) \right) = \frac{1}{\sqrt{2}} (|0000\rangle + |0110\rangle)
\]</div>
<ol start="3">
<li>Apply <span class="arithmatex">\( H_0 \)</span>:</li>
</ol>
<div class="arithmatex">\[
   H_0 \left( \frac{1}{\sqrt{2}} (|0000\rangle + |0110\rangle) \right) = \frac{1}{2} (|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)
\]</div>
<ol start="4">
<li>Apply <span class="arithmatex">\( \text{CNOT}_{03} \)</span> (control qubit 0, target qubit 3):</li>
</ol>
<div class="arithmatex">\[
   \text{CNOT}_{03} \left( \frac{1}{2} (|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle) \right) = \frac{1}{2} (|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<p>Thus, the ideal final state is:</p>
<div class="arithmatex">\[
   |\psi_{\text{ideal}}\rangle = \frac{1}{2} (|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<h4 id="error-model">Error Model</h4>
<p>Each CNOT gate is followed by a depolarizing error channel:
- After <span class="arithmatex">\( \text{CNOT}_{21} \)</span>, with probability <span class="arithmatex">\( 1-p \)</span>, no error; with probability <span class="arithmatex">\( p \)</span>, a Pauli error <span class="arithmatex">\( E \)</span> on qubits {1,2} is applied (each of the 15 non-identity Paulis with probability <span class="arithmatex">\( p/15 \)</span>).
- After <span class="arithmatex">\( \text{CNOT}_{03} \)</span>, with probability <span class="arithmatex">\( 1-p \)</span>, no error; with probability <span class="arithmatex">\( p \)</span>, a Pauli error <span class="arithmatex">\( F \)</span> on qubits {0,3} is applied (each with probability <span class="arithmatex">\( p/15 \)</span>).</p>
<p>The fidelity between the ideal pure state <span class="arithmatex">\( |\psi_{\text{ideal}}\rangle \)</span> and the actual mixed state <span class="arithmatex">\( \rho \)</span> is <span class="arithmatex">\( F = \langle \psi_{\text{ideal}} | \rho | \psi_{\text{ideal}} \rangle \)</span>.</p>
<h4 id="case-analysis">Case Analysis</h4>
<ul>
<li><strong>Case 1: No error after <span class="arithmatex">\( \text{CNOT}_{21} \)</span></strong></li>
<li>Probability: <span class="arithmatex">\( 1-p \)</span></li>
<li>After <span class="arithmatex">\( \text{CNOT}_{03} \)</span>, the state is <span class="arithmatex">\( |\psi_{\text{ideal}}\rangle \)</span>.</li>
<li>After error channel for <span class="arithmatex">\( \text{CNOT}_{03} \)</span>:<ul>
<li>With probability <span class="arithmatex">\( 1-p \)</span>, no error, fidelity = 1.</li>
<li>With probability <span class="arithmatex">\( p \)</span>, error <span class="arithmatex">\( F \)</span> on {0,3}:</li>
<li>For <span class="arithmatex">\( F \)</span> such that <span class="arithmatex">\( \langle \psi_{\text{ideal}} | F | \psi_{\text{ideal}} \rangle \neq 0 \)</span>, fidelity = 1; otherwise, 0.</li>
<li>From analysis, only 3 of the 15 non-identity Paulis on {0,3} yield fidelity 1: <span class="arithmatex">\( X_0 X_3 \)</span>, <span class="arithmatex">\( Z_0 Z_3 \)</span>, <span class="arithmatex">\( Y_0 Y_3 \)</span>.</li>
</ul>
</li>
<li>Average fidelity for Case 1:</li>
</ul>
<div class="arithmatex">\[
    F_1 = (1-p) \cdot 1 + p \cdot \frac{3}{15} \cdot 1 = 1 - p + \frac{p}{5} = 1 - \frac{4}{5}p
\]</div>
<ul>
<li><strong>Case 2: Error <span class="arithmatex">\( E \)</span> after <span class="arithmatex">\( \text{CNOT}_{21} \)</span></strong></li>
<li>Probability: <span class="arithmatex">\( p \)</span></li>
<li>After applying <span class="arithmatex">\( E \)</span>, state is <span class="arithmatex">\( E |\psi_2\rangle \)</span>, where <span class="arithmatex">\( |\psi_2\rangle = \frac{1}{\sqrt{2}} (|0000\rangle + |0110\rangle) \)</span>.</li>
<li>Then apply <span class="arithmatex">\( H_0 \)</span> and <span class="arithmatex">\( \text{CNOT}_{03} \)</span> ideally, so state becomes <span class="arithmatex">\( \text{CNOT}_{03} H_0 E |\psi_2\rangle \)</span>.</li>
<li>After error channel for <span class="arithmatex">\( \text{CNOT}_{03} \)</span>:<ul>
<li>With probability <span class="arithmatex">\( 1-p \)</span>, no error, fidelity = <span class="arithmatex">\( |\langle \psi_{\text{ideal}} | \text{CNOT}_{03} H_0 E |\psi_2\rangle |^2 = |\langle \psi_2 | E | \psi_2\rangle |^2 \)</span>.</li>
<li>From analysis, only 3 of the 15 non-identity Paulis on {1,2} yield fidelity 1: <span class="arithmatex">\( X_1 X_2 \)</span>, <span class="arithmatex">\( Z_1 Z_2 \)</span>, <span class="arithmatex">\( Y_1 Y_3 \)</span>.</li>
<li>With probability <span class="arithmatex">\( p \)</span>, error <span class="arithmatex">\( F \)</span> on {0,3}, fidelity = <span class="arithmatex">\( |\langle \psi_2 | H_0^\dagger \text{CNOT}_{03}^\dagger F \text{CNOT}_{03} H_0 E | \psi_2\rangle |^2 \)</span>.</li>
<li>This fidelity is 1 only if both <span class="arithmatex">\( E \)</span> and <span class="arithmatex">\( F \)</span> are &ldquo;good&rdquo; (i.e., from the sets above).</li>
</ul>
</li>
<li>Average fidelity for Case 2:</li>
</ul>
<div class="arithmatex">\[
    F_2 = (1-p) \cdot \frac{3}{15} + p \cdot \frac{3}{15} \cdot \frac{3}{15} = \frac{1-p}{5} + \frac{p}{25}
\]</div>
<h4 id="total-fidelity">Total Fidelity</h4>
<p>The overall fidelity is the weighted sum:</p>
<div class="arithmatex">\[
F = (1-p) F_1 + p F_2 = (1-p) \left(1 - \frac{4}{5}p\right) + p \left( \frac{1-p}{5} + \frac{p}{25} \right)
\]</div>
<p>Simplifying:</p>
<div class="arithmatex">\[
F = (1-p) \left(1 - \frac{4}{5}p\right) + p \left( \frac{5(1-p) + p}{25} \right) = (1-p) \left(1 - \frac{4}{5}p\right) + \frac{p(5 - 4p)}{25}
\]</div>
<div class="arithmatex">\[
= 1 - \frac{4}{5}p - p + \frac{4}{5}p^2 + \frac{5p - 4p^2}{25} = 1 - \frac{9}{5}p + \frac{4}{5}p^2 + \frac{5p - 4p^2}{25}
\]</div>
<p>Using a common denominator of 25:</p>
<div class="arithmatex">\[
F = \frac{25}{25} - \frac{45}{25}p + \frac{20}{25}p^2 + \frac{5p - 4p^2}{25} = \frac{25 - 45p + 20p^2 + 5p - 4p^2}{25} = \frac{25 - 40p + 16p^2}{25}
\]</div>
<p>Thus,</p>
<div class="arithmatex">\[
F = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<p><strong>Final Answer:</strong>  </p>
<div class="arithmatex">\[
F = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given the expression for the physical state fidelity: F = 1 - (8/5)<em>p + (16/25)</em>p^2
 We will represent this using SymPy.
 Note: We must use rational numbers (like sp.Rational) or exact fractions to avoid floating point.
 Alternatively, we can write it as: 1 - 8<em>p/5 + 16</em>p**2/25</p>
<p>However, note that the problem expects an exact expression. We can use integers and the symbol p.</p>
<p>Let&rsquo;s write the expression accordingly.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p><strong>Final Answer:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.642335
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>