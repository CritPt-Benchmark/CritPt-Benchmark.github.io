<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>First, I need to find the physical state fidelity of the final state after the circuit, considering errors from the CNOT gates. The circuit is given as: (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). But since quantum operations are applied from right to left, the actual order of operations is:</p>
<ol>
<li>
<p>Apply H_2</p>
</li>
<li>
<p>Apply CNOT_{21}</p>
</li>
<li>
<p>Apply H_0</p>
</li>
<li>
<p>Apply CNOT_{03}</p>
</li>
</ol>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel with error probability p. That means after each CNOT, with probability p, one of the 15 non-identity two-qubit Paulis is applied, each with probability p/15. But since the error channel is applied after the gate, I need to model the errors separately for each CNOT.</p>
<p>The fidelity is between the ideal state and the actual state with errors. So I need to find the ideal state first, then find the actual state with errors, and then compute the fidelity.</p>
<p>The ideal state is what we get without any errors. Let&rsquo;s compute that step by step.</p>
<p>Start with all qubits in |0⟩ state, I assume? The problem doesn&rsquo;t specify the initial state, but typically for state preparation, we start with all qubits in |0⟩. So let&rsquo;s assume initial state is |0000⟩.</p>
<p>Now, apply the operations in order:</p>
<p>First, apply H_2. H_2 is Hadamard on qubit 2. So after H_2: |0⟩_2 becomes (|0⟩ + |1⟩)/√2, so state is |00⟩ (qubits 0,1) ⊗ (|0⟩ + |1⟩)/√2 ⊗ |0⟩_3? Let&rsquo;s label qubits: qubit 0,1,2,3.</p>
<p>After H_2: qubit 2 is now in |+⟩ = (|0⟩ + |1⟩)/√2, so state is |0⟩_0 |0⟩_1 (|0⟩ + |1⟩)/√2 |0⟩_3 = (|0000⟩ + |0010⟩)/√2? No: qubit 2 is the third qubit? Qubits are labelled 0,1,2,3, so after H_2, state is |0⟩_0 |0⟩_1 |+⟩_2 |0⟩_3 = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle ) but |0010⟩ means qubit 0=0,1=0,2=1,3=0, so yes.</p>
<p>But better to write as \frac{1}{\sqrt{2}} ( |00\rangle_{01} |0\rangle_2 |0\rangle_3 + |00\rangle_{01} |1\rangle_2 |0\rangle_3 ) = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )</p>
<p>Now, next operation: CNOT_{21}. CNOT with control qubit 2 and target qubit 1.</p>
<p>So apply CNOT_{21} to the state. CNOT_{21} flips qubit 1 if qubit 2 is |1⟩.</p>
<p>So on the state \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )</p>
<p>After CNOT_{21}:</p>
<ul>
<li>
<p>For |0000⟩: control qubit 2 is |0⟩, so no flip, remains |0000⟩</p>
</li>
<li>
<p>For |0010⟩: control qubit 2 is |1⟩, so flip qubit 1, which is |0⟩ to |1⟩, so becomes |0110⟩? Qubit 1 was |0⟩, so after flip, |1⟩, so state is |0⟩_0 |1⟩_1 |1⟩_2 |0⟩_3, so |0110⟩.</p>
</li>
</ul>
<p>So state becomes \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>Now, next operation: H_0. Hadamard on qubit 0.</p>
<p>Apply H_0 to each term.</p>
<p>H_0 |0⟩_0 = (|0⟩ + |1⟩)/√2</p>
<p>H_0 |1⟩_0 = (|0⟩ - |1⟩)/√2</p>
<p>But in our state, qubit 0 is always |0⟩ in both terms? |0000⟩ has qubit 0=0, |0110⟩ has qubit 0=0, so both have qubit 0 in |0⟩.</p>
<p>So after H_0:</p>
<p>For |0000⟩: H_0 applied, so becomes (|0⟩<em>0 + |1⟩_0)/√2 ⊗ |000⟩</em>{123}? No, the state is |0000⟩, so after H_0 on qubit 0, it becomes \frac{1}{\sqrt{2}} ( |0000\rangle + |1000\rangle ) but since we have a global factor, let&rsquo;s see.</p>
<p>The state before H_0 is \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>After H_0 on qubit 0:</p>
<p>|0000⟩ → \frac{1}{\sqrt{2}} ( |0000\rangle + |1000\rangle )</p>
<p>|0110⟩ → \frac{1}{\sqrt{2}} ( |0110\rangle + |1110\rangle )? No: H_0 |0⟩_0 = (|0⟩ + |1⟩)/√2, so |0110⟩ becomes \frac{1}{\sqrt{2}} ( |0110\rangle + |1110\rangle )</p>
<p>But since we have a global 1/√2, the state becomes:</p>
<p>\frac{1}{\sqrt{2}} \left[ \frac{1}{\sqrt{2}} ( |0000\rangle + |1000\rangle ) + \frac{1}{\sqrt{2}} ( |0110\rangle + |1110\rangle ) \right] = \frac{1}{2} ( |0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle )</p>
<p>Now, finally, apply CNOT_{03}. CNOT with control qubit 0 and target qubit 3.</p>
<p>So apply CNOT_{03} to this state.</p>
<p>CNOT_{03} flips qubit 3 if qubit 0 is |1⟩.</p>
<p>So let&rsquo;s apply to each term:</p>
<ul>
<li>
<p>|0000⟩: control qubit 0 is |0⟩, so no flip, remains |0000⟩</p>
</li>
<li>
<p>|1000⟩: control qubit 0 is |1⟩, so flip qubit 3 from |0⟩ to |1⟩, so becomes |1001⟩</p>
</li>
<li>
<p>|0110⟩: control qubit 0 is |0⟩, so no flip, remains |0110⟩</p>
</li>
<li>
<p>|1110⟩: control qubit 0 is |1⟩, so flip qubit 3 from |0⟩ to |1⟩, so becomes |1111⟩</p>
</li>
</ul>
<p>So the ideal final state is:</p>
<p>\frac{1}{2} ( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle )</p>
<p>Now, is this the logical GHZ state? The logical GHZ state for qubits A and B should be (|00⟩_AB + |11⟩_AB)/√2.</p>
<p>But what are the logical states? From the problem, the logical operators are given, but I need to know the code states.</p>
<p>The [[4,2,2]] code has stabilizers XXXX and ZZZZ. The logical states are defined with respect to these.</p>
<p>For example, the logical |00⟩_AB might be a state that is +1 eigenstate of stabilizers and logical Z operators.</p>
<p>But in this state, we have |0000⟩, |1001⟩, etc. I need to see if this is indeed the logical GHZ state.</p>
<p>Perhaps for fidelity calculation, I don&rsquo;t need to know the logical part, since fidelity is about the physical state.</p>
<p>The question is to find the physical state fidelity, which is the fidelity between the ideal physical state and the actual physical state with errors.</p>
<p>So for the ideal state, we have it as above.</p>
<p>Now, for the actual state, we have errors after each CNOT gate.</p>
<p>There are two CNOT gates: CNOT_{21} and CNOT_{03}.</p>
<p>Each CNOT is followed by a depolarizing error channel on the two qubits involved.</p>
<p>So, after CNOT_{21}, with probability 1-p, no error, and with probability p, an error occurs, which is one of the 15 Pauli errors on qubits 2 and 1, each with probability p/15.</p>
<p>Similarly, after CNOT_{03}, with probability 1-p, no error, and with probability p, an error occurs on qubits 0 and 3.</p>
<p>The Hadamard gates are assumed to be perfect, I think? The problem only mentions errors for CNOT gates, so H gates are noiseless.</p>
<p>So, the actual state is affected by errors after CNOT gates.</p>
<p>I need to find the output state after the circuit with errors, and then find the fidelity with the ideal state.</p>
<p>Fidelity F = |⟨ψ_ideal | ψ_actual ⟩|^2, but since there might be multiple error possibilities, ψ_actual is a mixed state, so fidelity is for pure state and mixed state? The ideal state is pure, but actual state is mixed due to errors.</p>
<p>The fidelity between a pure state |ψ⟩ and a mixed state ρ is ⟨ψ| ρ |ψ⟩.</p>
<p>So I need to find the density matrix of the actual output state, and then compute ⟨ψ_ideal| ρ |ψ_ideal⟩.</p>
<p>Since the errors are stochastic, I need to average over all possible error patterns.</p>
<p>There are two error locations: after CNOT_{21} and after CNOT_{03}.</p>
<p>For each CNOT, the error channel is: after the gate, with prob 1-p, identity, with prob p, a Pauli error E chosen uniformly from the 15 non-identity two-qubit Paulis on the pair.</p>
<p>The Pauli errors are applied after the gate, so they affect the state.</p>
<p>I need to find the state after each step, considering errors.</p>
<p>Start with initial state ρ_0 = |0000⟩⟨0000|</p>
<p>First, apply H_2. No error, so after H_2, state is |ψ1⟩⟨ψ1| where |ψ1⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )  as before.</p>
<p>Now, apply CNOT_{21}. First, apply the ideal CNOT_{21} to |ψ1⟩, which gives |ψ2⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )  as before.</p>
<p>But after applying CNOT_{21}, we have the error channel. So after CNOT_{21}, we have a state, then we apply the error channel.</p>
<p>Let me denote the state after ideal CNOT_{21} as |ψ2⟩.</p>
<p>Then, after error channel, the state becomes:</p>
<p>With probability 1-p, no error, so state remains |ψ2⟩</p>
<p>With probability p, an error E is applied, where E is a Pauli on qubits 2 and 1. Since |ψ2⟩ is a state, after error, it becomes E |ψ2⟩, but since E is Pauli, it changes the state.</p>
<p>But for the density matrix, after error channel, the state is a mixture: (1-p) |ψ2⟩⟨ψ2| + (p/15) sum_{E in Paulis on {1,2}, E≠I} E |ψ2⟩⟨ψ2| E^\dagger</p>
<p>Since Paulis are unitary, E^\dagger E = I, so it&rsquo;s (1-p) |ψ2⟩⟨ψ2| + (p/15) sum_{E} E |ψ2⟩⟨ψ2| E^\dagger</p>
<p>But since the sum is over all non-identity Paulis on two qubits, and there are 15 of them.</p>
<p>Now, after this, we apply H_0, which is perfect, so we apply H_0 to this density matrix.</p>
<p>Then, after H_0, we apply CNOT_{03} ideally, and then after that, we apply the error channel for CNOT_{03}.</p>
<p>So, let&rsquo;s do this step by step.</p>
<p>First, after CNOT_{21} and error channel, the density matrix ρ_2 is:</p>
<p>ρ_2 = (1-p) |ψ2⟩⟨ψ2| + \frac{p}{15} \sum_{E \in \mathcal{P}_{21} \setminus {I}} E |ψ2⟩⟨ψ2| E^\dagger</p>
<p>where \mathcal{P}_{21} is the set of Pauli operators on qubits 2 and 1.</p>
<p>Now, |ψ2⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>Now, we apply H_0 to ρ_2. Since H_0 is unitary, the new density matrix is H_0 ρ_2 H_0^\dagger</p>
<p>H_0 acts only on qubit 0, so it commutes with operators on other qubits, but since ρ_2 involves qubits 0,1,2,3, we apply H_0 to it.</p>
<p>After H_0, we have ρ_3 = H_0 ρ_2 H_0^\dagger</p>
<p>Now, we apply ideal CNOT_{03} to ρ_3. Let U_{03} be the unitary for CNOT_{03}, so after CNOT_{03}, we have ρ_4 = U_{03} ρ_3 U_{03}^\dagger</p>
<p>Then, after CNOT_{03}, we apply the error channel for CNOT_{03}, which is on qubits 0 and 3. So the final density matrix ρ_final is:</p>
<p>ρ_final = (1-p) ρ_4 + \frac{p}{15} \sum_{F \in \mathcal{P}_{03} \setminus {I}} F ρ_4 F^\dagger</p>
<p>where \mathcal{P}_{03} is Paulis on qubits 0 and 3.</p>
<p>Now, we need to find the fidelity F = ⟨ψ_ideal| ρ_final |ψ_ideal⟩</p>
<p>where |ψ_ideal⟩ = \frac{1}{2} ( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle ) as derived earlier.</p>
<p>Since the error channels are Pauli errors, and the initial state and operations are Clifford, perhaps I can compute the effect of errors on the ideal state.</p>
<p>Notice that the ideal state is a stabilizer state, and errors are Pauli errors, so the fidelity might be computed by finding the probability that no error occurs or errors that cancel, but since errors happen during the circuit, it might be messy.</p>
<p>I recall that for depolarizing noise, the fidelity can be related to the probability that the state is not affected by errors.</p>
<p>But here errors are after specific gates, so I need to see how errors propagate through the circuit.</p>
<p>Since the circuit consists of Clifford gates, and errors are Pauli, I can track how Pauli errors affect the state.</p>
<p>But for fidelity, I need ⟨ψ| ρ |ψ⟩, which is the probability that the actual state is the ideal state.</p>
<p>Since ρ_final is a mixture of states obtained by applying Pauli errors at different points, and then the gates, I can think of all possible error sequences and find the final state for each error pattern, and then average the fidelity.</p>
<p>There are two error locations: after CNOT21 and after CNOT03.</p>
<p>For each error location, there are 16 possibilities: no error or one of 15 Pauli errors.</p>
<p>But since the errors are applied after the gate, and then subsequent gates are applied, I need to see what happens when errors occur.</p>
<p>Let me define the ideal circuit without errors as U_circuit = CNOT03 H0 CNOT21 H2</p>
<p>And the ideal output |ψ_ideal⟩ = U_circuit |0000⟩</p>
<p>With errors, after each CNOT, an error may occur.</p>
<p>So, let me denote the actual operation.</p>
<p>Start with |0000⟩</p>
<p>Apply H2: no error, so |ψ1⟩ = H2 |0000⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )</p>
<p>Now apply CNOT21: first apply CNOT21 ideally, so |ψ2⟩ = CNOT21 |ψ1⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>Then after CNOT21, with prob 1-p, no error, state remains |ψ2⟩</p>
<p>With prob p, an error E on {2,1} is applied, so state becomes E |ψ2⟩</p>
<p>Then after this, apply H0: so if no error, H0 |ψ2⟩ = |ψ3⟩ where |ψ3⟩ = H0 |ψ2⟩ = \frac{1}{2} ( |0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle ) as before? Earlier we had after H0, the state was \frac{1}{2} ( |0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle ) but that was after H0 on |ψ2⟩, which is correct.</p>
<p>But after error, if error E occurred, then we apply H0 to E |ψ2⟩.</p>
<p>Then after H0, we apply CNOT03 ideally: so first apply CNOT03 to the state after H0.</p>
<p>Then after CNOT03, with prob 1-p, no error, or with prob p, error F on {0,3} applied.</p>
<p>So for each error pattern, we have a final state, and then we average over the error probabilities.</p>
<p>Then fidelity is |⟨ψ_ideal| ψ_actual ⟩|^2 for each pure state ψ_actual, but since we have mixture, we need the average of |⟨ψ_ideal| ψ_final ⟩|^2 over error patterns, but for fidelity between pure and mixed, it is the average of |⟨ψ_ideal| ψ⟩|^2 for each |ψ⟩ in the mixture, which is exactly what we have since ρ_final is a mixture of pure states.</p>
<p>So let&rsquo;s find for each error pattern, what is the final state, and then what is |⟨ψ_ideal| ψ_final ⟩|^2, and then average over error probabilities.</p>
<p>First, define the states after each step without errors.</p>
<p>After H2: |ψ1⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0010\rangle )</p>
<p>After CNOT21: |ψ2⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>After H0: |ψ3⟩ = H0 |ψ2⟩ = \frac{1}{2} ( |0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle )</p>
<p>After CNOT03: |ψ_ideal⟩ = CNOT03 |ψ3⟩ = \frac{1}{2} ( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle )</p>
<p>Now, with errors.</p>
<p>Case 1: no error after CNOT21.</p>
<p>Then after CNOT21, state is |ψ2⟩.</p>
<p>Then apply H0: state becomes |ψ3⟩.</p>
<p>Then apply CNOT03 ideally: state becomes |ψ_ideal⟩.</p>
<p>Then after CNOT03, we have error channel.</p>
<p>So after CNOT03, state is |ψ_ideal⟩.</p>
<p>Then with probability 1-p, no error, so final state |ψ_ideal⟩</p>
<p>With probability p, error F on {0,3} is applied, so final state F |ψ_ideal⟩</p>
<p>So for no error after CNOT21, the final state is:</p>
<ul>
<li>
<p>With prob (1-p) from error after CNOT03: |ψ_ideal⟩</p>
</li>
<li>
<p>With prob p from error after CNOT03: F |ψ_ideal⟩ for each F, with prob p/15 each F.</p>
</li>
</ul>
<p>But since we have multiple F, we need to average.</p>
<p>Now, case 2: error E after CNOT21.</p>
<p>With probability p/15 for each E, after CNOT21, state is E |ψ2⟩</p>
<p>Then apply H0: state becomes H0 E |ψ2⟩</p>
<p>Then apply CNOT03 ideally: state becomes CNOT03 H0 E |ψ2⟩</p>
<p>Then after CNOT03, with probability 1-p, no error, so final state CNOT03 H0 E |ψ2⟩</p>
<p>With probability p, error F on {0,3} applied, so final state F CNOT03 H0 E |ψ2⟩</p>
<p>Now, we need to find for each such final state, what is |⟨ψ_ideal| ψ_final ⟩|^2</p>
<p>Since |ψ_ideal⟩ is a state, and ψ_final is some state, we need the overlap.</p>
<p>Notice that |ψ_ideal⟩ = CNOT03 H0 |ψ2⟩, because |ψ2⟩ = CNOT21 H2 |0000⟩, and U_circuit = CNOT03 H0 CNOT21 H2, so |ψ_ideal⟩ = CNOT03 H0 CNOT21 H2 |0000⟩ = CNOT03 H0 |ψ2⟩</p>
<p>So |ψ_ideal⟩ = CNOT03 H0 |ψ2⟩</p>
<p>Therefore, for any operator O, ⟨ψ_ideal| O |ψ_ideal⟩ = ⟨ψ2| H0^\dagger CNOT03^\dagger O CNOT03 H0 |ψ2⟩</p>
<p>But for our case, we need ⟨ψ_ideal| ψ_final ⟩ for various ψ_final.</p>
<p>First, for case 1: no error after CNOT21.</p>
<p>Then after CNOT03, if no error, ψ_final = |ψ_ideal⟩, so ⟨ψ_ideal| ψ_final ⟩ =1, so |⟨|^2=1</p>
<p>If error F after CNOT03, ψ_final = F |ψ_ideal⟩, so ⟨ψ_ideal| F |ψ_ideal⟩</p>
<p>So |⟨ψ_ideal| F |ψ_ideal⟩|^2</p>
<p>Since F is Pauli on {0,3}, and |ψ_ideal⟩ is a state, we need to see how F acts on |ψ_ideal⟩.</p>
<p>Similarly for other cases.</p>
<p>Now, |ψ_ideal⟩ = \frac{1}{2} ( |0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle )</p>
<p>This state might have some symmetry or stabilizers.</p>
<p>Notice that the circuit is designed to create the logical GHZ state, but for physical fidelity, we care about the physical state.</p>
<p>Let me write |ψ_ideal⟩ explicitly.</p>
<p>|ψ_ideal⟩ = \frac{1}{2} ( |0\rangle_0 |0\rangle_1 |0\rangle_2 |0\rangle_3 + |1\rangle_0 |0\rangle_1 |0\rangle_2 |1\rangle_3 + |0\rangle_0 |1\rangle_1 |1\rangle_2 |0\rangle_3 + |1\rangle_0 |1\rangle_1 |1\rangle_2 |1\rangle_3 )</p>
<p>Now, let&rsquo;s find the stabilizers of this state. Since it&rsquo;s a GHZ-like state, it might be stabilized by some Paulis.</p>
<p>For example, XXXX applied to |ψ_ideal⟩: XXXX |ψ_ideal⟩ = \frac{1}{2} ( |1111\rangle + |0110\rangle + |1001\rangle + |0000\rangle ) = |ψ_ideal⟩, so it is stabilized by XXXX.</p>
<p>Similarly, ZZZZ |ψ_ideal⟩ = \frac{1}{2} ( |0000\rangle + (-1) |1001\rangle + (-1) |0110\rangle + (1) |1111\rangle )? Let&rsquo;s see: ZZZZ means Z on each qubit, so for each term, phase based on number of |1⟩.</p>
<p>|0000⟩: all |0⟩, so phase +1</p>
<p>|1001⟩: qubit 0=1,1=0,2=0,3=1, so three |1⟩? qubit 0=1,1=0,2=0,3=1, so two |1⟩? |1⟩ on qubit 0 and 3, so two |1⟩, so ZZZZ gives phase (-1)^2 = +1? Z applied to |1⟩ gives -|1⟩, but for basis state, Z_i |x_i⟩ = (-1)^{x_i} |x_i⟩, so for state, ZZZZ |ket&gt; = product of (-1)^{x_i} for each qubit.</p>
<p>For |1001⟩, x0=1, x1=0, x2=0, x3=1, so (-1)^{1+0+0+1} = (-1)^2 =1, so phase +1.</p>
<p>Similarly, |0110⟩: x0=0,x1=1,x2=1,x3=0, so (-1)^{0+1+1+0} = (-1)^2=1</p>
<p>|1111⟩: all 1, (-1)^4=1</p>
<p>So ZZZZ |ψ_ideal⟩ = |ψ_ideal⟩, so it is also stabilized by ZZZZ.</p>
<p>So |ψ_ideal⟩ is indeed a stabilizer state of the [[4,2,2]] code? But the code has multiple logical states, so this is one of them.</p>
<p>Now, back to fidelity.</p>
<p>First, for case 1: no error after CNOT21.</p>
<p>Then after CNOT03, with prob 1-p, no error, final state |ψ_ideal⟩, fidelity |⟨ψ_ideal|ψ_ideal⟩|^2 =1</p>
<p>With prob p, error F on {0,3}, final state F |ψ_ideal⟩, so fidelity |⟨ψ_ideal| F |ψ_ideal⟩|^2</p>
<p>Now, since F is Pauli on qubits 0 and 3, and |ψ_ideal⟩ is stabilized by XXXX and ZZZZ, but F acts only on 0 and 3, so we need to see if F commutes with the stabilizers or not, but for the overlap, ⟨ψ_ideal| F |ψ_ideal⟩ is the expectation value of F in state |ψ_ideal⟩.</p>
<p>Since |ψ_ideal⟩ is a stabilizer state, for any Pauli operator P, ⟨ψ| P |ψ⟩ is either 0 or ±1, depending on whether P is in the stabilizer or not.</p>
<p>Specifically, for a stabilizer state |ψ⟩ with stabilizer group S, ⟨ψ| P |ψ⟩ = 1 if P ∈ S, -1 if P ∈ -S, and 0 otherwise.</p>
<p>But here, F is on qubits 0 and 3, so we need to see if F is in the stabilizer of |ψ_ideal⟩ or not.</p>
<p>The stabilizer of |ψ_ideal⟩ includes XXXX and ZZZZ, but also other operators? Since it&rsquo;s a stabilizer state, the full stabilizer group has 4 generators for 4 qubits, but here we have two generators mentioned, but for this state, it might have more.</p>
<p>From the state, let&rsquo;s find what stabilizes it.</p>
<p>For example, consider operator Z I Z I? Let&rsquo;s see.</p>
<p>First, list the basis states: |0000⟩, |1001⟩, |0110⟩, |1111⟩</p>
<p>Notice that the parity of qubits 0 and 3 is the same: in |0000⟩, both 0, |1001⟩ both 1, |0110⟩ both 0? |0110⟩ has qubit 0=0, qubit 3=0, so both 0, |1111⟩ both 1. So qubit 0 and qubit 3 are always equal. So the operator that measures if they are equal? For example, the operator that is I if both same, -I if different, but for stabilizer, we need operators that fix the state.</p>
<p>Since always same, the operator X0 X3 should have expectation, but X0 X3 |ψ_ideal⟩ = ?</p>
<p>X0 X3 |0000⟩ = |1001⟩</p>
<p>X0 X3 |1001⟩ = |0000⟩</p>
<p>X0 X3 |0110⟩ = |1111⟩? X0 on |0&gt; = |1&gt;, X3 on |0&gt; = |1&gt;, so |1111⟩? |0110⟩ with X0 X3: X0 on qubit 0: |0&gt; to |1&gt;, so |1110⟩? No: |0110⟩ means qubit 0=0,1=1,2=1,3=0. After X0, qubit 0=1, so |1110⟩? Then X3 on qubit 3=0 to 1, so |1111⟩. Similarly X0 X3 |1111⟩ = |0110⟩? X0 on |1&gt; = |0&gt;, X3 on |1&gt; = |0&gt;, so |0110⟩. So X0 X3 |ψ_ideal⟩ = |ψ_ideal⟩, so it is stabilized by X0 X3.</p>
<p>Similarly, since XXXX stabilizes, and X0 X3 stabilizes, then X1 X2 must also stabilize? XXXX = X0 X1 X2 X3, so if X0 X3 stabilizes, then X1 X2 must stabilize because XXXX (X0 X3) = X1 X2, so yes, X1 X2 also stabilizes |ψ_ideal⟩.</p>
<p>Similarly for Z operators. From ZZZZ, and since qubit 0 and 3 are always same, but let&rsquo;s see Z0 Z3.</p>
<p>Z0 Z3 |0000⟩ = |0000⟩</p>
<p>Z0 Z3 |1001⟩ = (-1) * (-1) |1001⟩ = |1001⟩? Z0 on |1&gt; = -|1&gt;, Z3 on |1&gt; = -|1&gt;, so product phase (-1)(-1)=1, so yes.</p>
<p>Z0 Z3 |0110⟩ = Z0 on |0&gt; =1, Z3 on |0&gt; =1, so |0110⟩</p>
<p>Z0 Z3 |1111⟩ = (-1)(-1)|1111⟩ = |1111⟩</p>
<p>So Z0 Z3 |ψ_ideal⟩ = |ψ_ideal⟩, so stabilized by Z0 Z3.</p>
<p>Similarly, from ZZZZ, and Z0 Z3, then Z1 Z2 must stabilize.</p>
<p>So the stabilizer group of |ψ_ideal⟩ is generated by XXXX, ZZZZ, X0 X3, Z0 Z3, etc., but since XXXX and X0 X3 imply X1 X2, similarly for Z.</p>
<p>But for our purpose, we need to find for Pauli F on {0,3}, what is ⟨ψ_ideal| F |ψ_ideal⟩.</p>
<p>F is a Pauli on qubits 0 and 3, so it can be I, X0, X3, X0 X3, Z0, Z3, Z0 Z3, Y0, Y3, Y0 Y3, etc., but since it&rsquo;s Pauli, it&rsquo;s products of X and Z.</p>
<p>But since |ψ_ideal⟩ is stabilized by X0 X3 and Z0 Z3, then for any Pauli P on {0,3}, if P commutes with X0 X3 and Z0 Z3, then it might be in the stabilizer, but not necessarily.</p>
<p>Actually, for a stabilizer state, the expectation value of Pauli P is non-zero only if P commutes with all stabilizers, but since the stabilizers include operators on other qubits, P on {0,3} may not commute with, say, X1 X2, but X1 X2 acts on other qubits, so it commutes with P since acting on different qubits, so yes, P commutes with all stabilizers that act on other qubits.</p>
<p>The stabilizer group of |ψ_ideal⟩ includes operators on all qubits, but since P acts only on 0 and 3, it commutes with any operator that doesn&rsquo;t act on 0 or 3, but for operators that act on 0 or 3, we need to see.</p>
<p>The key point is that for |ψ_ideal⟩, since it is a stabilizer state, and the subgroup acting on qubits 0 and 3 can be characterized.</p>
<p>From the state, we see that qubit 0 and qubit 3 are always equal in the basis state, so for any Pauli P on {0,3}, it will have non-zero expectation only if it doesn&rsquo;t change the correlation between 0 and 3.</p>
<p>But let&rsquo;s calculate ⟨ψ_ideal| F |ψ_ideal⟩ for each type of F.</p>
<p>F is a two-qubit Pauli on qubits 0 and 3. There are 16 Paulis, but we need only non-identity for error, but for expectation, we can compute.</p>
<p>Since |ψ_ideal⟩ is normalized, ⟨ψ_ideal| F |ψ_ideal⟩ is the expectation value.</p>
<p>From the state, let&rsquo;s compute for each possible F.</p>
<p>First, if F = I, then ⟨I⟩ =1</p>
<p>If F = X0, then X0 |ψ_ideal⟩ = \frac{1}{2} ( X0 |0000⟩ + X0 |1001⟩ + X0 |0110⟩ + X0 |1111⟩ ) = \frac{1}{2} ( |1000⟩ + |0001⟩ + |1110⟩ + |0111⟩ )</p>
<p>Now ⟨ψ_ideal| X0 |ψ_ideal⟩ = \frac{1}{4} \langle 0000| + \langle 1001| + \langle 0110| + \langle 1111| ) ( |1000⟩ + |0001⟩ + |1110⟩ + |0111⟩ )</p>
<p>Now, dot product: ⟨0000|1000⟩=0, ⟨0000|0001⟩=0, etc., all terms are orthogonal, so each inner product is zero unless same state. But here, |0000⟩ vs |1000⟩, different, so all inner products are zero. So ⟨ψ_ideal| X0 |ψ_ideal⟩ =0</p>
<p>Similarly, if F = X3, similarly, X3 |ψ_ideal⟩ = \frac{1}{2} ( |0001⟩ + |1000⟩ + |0111⟩ + |1110⟩ ) , same as above, so ⟨ψ_ideal| X3 |ψ_ideal⟩ =0</p>
<p>If F = X0 X3, then X0 X3 |ψ_ideal⟩ = |ψ_ideal⟩ as we saw earlier, so ⟨ψ_ideal| X0 X3 |ψ_ideal⟩ =1</p>
<p>Similarly, if F = Z0, then Z0 |ψ_ideal⟩ = \frac{1}{2} ( Z0 |0000⟩ + Z0 |1001⟩ + Z0 |0110⟩ + Z0 |1111⟩ ) = \frac{1}{2} ( |0000⟩ + (-1)|1001⟩ + |0110⟩ + (-1)|1111⟩ )</p>
<p>Now ⟨ψ_ideal| Z0 |ψ_ideal⟩ = \frac{1}{4} ( ⟨0000| + ⟨1001| + ⟨0110| + ⟨1111| ) ( |0000⟩ - |1001⟩ + |0110⟩ - |1111⟩ ) = \frac{1}{4} (1 -1 +1 -1) =0</p>
<p>Similarly for Z3, same thing, because from state, qubit 0 and 3 have same value, so Z0 and Z3 have same effect? Z3 |ψ_ideal⟩ = \frac{1}{2} ( |0000⟩ + (-1)|1001⟩ + |0110⟩ + (-1)|1111⟩ ) same as above, so ⟨Z3⟩=0</p>
<p>If F = Z0 Z3, then Z0 Z3 |ψ_ideal⟩ = |ψ_ideal⟩ as above, so ⟨Z0 Z3⟩=1</p>
<p>Now for Y operators. Y = i X Z, so for example F = Y0 = i X0 Z0</p>
<p>But since expectation is linear, and we have ⟨X0⟩=0, ⟨Z0⟩=0, so ⟨Y0⟩ = i ⟨X0 Z0⟩ but X0 Z0 is another Pauli, so we can compute directly.</p>
<p>Y0 |ψ_ideal⟩ = i X0 Z0 |ψ_ideal⟩ = i X0 [ \frac{1}{2} ( |0000⟩ - |1001⟩ + |0110⟩ - |1111⟩ ) ] from earlier? Z0 |ψ_ideal⟩ = \frac{1}{2} ( |0000⟩ - |1001⟩ + |0110⟩ - |1111⟩ )</p>
<p>Then X0 on that: X0 Z0 |ψ_ideal⟩ = \frac{1}{2} ( X0 |0000⟩ - X0 |1001⟩ + X0 |0110⟩ - X0 |1111⟩ ) = \frac{1}{2} ( |1000⟩ - |0001⟩ + |1110⟩ - |0111⟩ )</p>
<p>So Y0 |ψ_ideal⟩ = i \frac{1}{2} ( |1000⟩ - |0001⟩ + |1110⟩ - |0111⟩ )</p>
<p>Now ⟨ψ_ideal| Y0 |ψ_ideal⟩ = i \frac{1}{4} \langle 0000| + \langle 1001| + \langle 0110| + \langle 1111| ) ( |1000⟩ - |0001⟩ + |1110⟩ - |0111⟩ ) =0 since all inner products zero.</p>
<p>Similarly for Y3, same thing.</p>
<p>For F = Y0 Y3, etc., but similarly, since X0 X3 has expectation 1, Z0 Z3 has expectation 1, but Y0 Y3 = i^2 X0 Z0 X3 Z3 = - X0 X3 Z0 Z3, and since X0 X3 and Z0 Z3 both stabilize, so Y0 Y3 |ψ_ideal⟩ = - |ψ_ideal⟩? Let&rsquo;s see.</p>
<p>Y0 Y3 = (i X0 Z0) (i X3 Z3) = i^2 X0 X3 Z0 Z3 = - X0 X3 Z0 Z3</p>
<p>Now X0 X3 Z0 Z3 |ψ_ideal⟩ = since X0 X3 |ψ_ideal⟩ = |ψ_ideal⟩, and Z0 Z3 |ψ_ideal⟩ = |ψ_ideal⟩, but careful: X0 X3 and Z0 Z3 commute? X0 X3 and Z0 Z3 act on different qubits? No, both act on qubit 0 and 3, so they commute? X0 and Z0 anti-commute, but X0 X3 and Z0 Z3: [X0 X3, Z0 Z3] = X0 X3 Z0 Z3 - Z0 Z3 X0 X3 = X0 Z0 X3 Z3 - Z0 X0 Z3 X3 = (-Z0 X0) (-Z3 X3) - Z0 X0 Z3 X3? Let&rsquo;s compute the commutator.</p>
<p>Since X0 and Z0 anti-commute, {X0,Z0}=0, so X0 Z0 = - Z0 X0</p>
<p>Similarly for X3 and Z3.</p>
<p>So X0 X3 Z0 Z3 = X0 Z0 X3 Z3 = (-Z0 X0) (-Z3 X3) = Z0 X0 Z3 X3</p>
<p>And Z0 Z3 X0 X3 = Z0 X0 Z3 X3</p>
<p>So they are equal, so [X0 X3, Z0 Z3] =0, so they commute.</p>
<p>Therefore X0 X3 Z0 Z3 |ψ_ideal⟩ = X0 X3 (Z0 Z3 |ψ_ideal⟩) = X0 X3 |ψ_ideal⟩ = |ψ_ideal⟩</p>
<p>So Y0 Y3 |ψ_ideal⟩ = - X0 X3 Z0 Z3 |ψ_ideal⟩ = - |ψ_ideal⟩</p>
<p>Thus ⟨ψ_ideal| Y0 Y3 |ψ_ideal⟩ = -1</p>
<p>Similarly, for other products like X0 Z3, etc.</p>
<p>But for fidelity, we need |⟨ψ_ideal| F |ψ_ideal⟩|^2, so for F that gives expectation ±1, | |^2 =1, for expectation 0, | |^2=0.</p>
<p>So for Pauli F on {0,3}, ⟨ψ_ideal| F |ψ_ideal⟩ is non-zero only if F is a product of X0 X3 and Z0 Z3, i.e., if F is in the group generated by X0 X3 and Z0 Z3.</p>
<p>The group generated by X0 X3 and Z0 Z3 has elements: I, X0 X3, Z0 Z3, X0 X3 Z0 Z3 = - Y0 Y3? X0 X3 Z0 Z3 = (X0 Z0) (X3 Z3) but since X0 Z0 = i Y0, etc., but anyway, the expectation is ±1.</p>
<p>Specifically, from above:</p>
<ul>
<li>
<p>If F = I, ⟨F⟩=1</p>
</li>
<li>
<p>F = X0 X3, ⟨F⟩=1</p>
</li>
<li>
<p>F = Z0 Z3, ⟨F⟩=1</p>
</li>
<li>
<p>F = X0 X3 Z0 Z3, which is same as (X0 Z0) (X3 Z3) but since X0 Z0 = i Y0, so i Y0 i Y3 = i^2 Y0 Y3 = - Y0 Y3, and we have ⟨ - Y0 Y3 ⟩ = -1, so for F = X0 X3 Z0 Z3, ⟨F⟩= -1? From above, Y0 Y3 |ψ_ideal⟩ = - |ψ_ideal⟩, so ⟨Y0 Y3⟩ = -1, so for F = Y0 Y3, ⟨F⟩= -1</p>
</li>
</ul>
<p>But Y0 Y3 = i X0 Z0 i X3 Z3 = i^2 X0 X3 Z0 Z3 = - X0 X3 Z0 Z3, so X0 X3 Z0 Z3 = - Y0 Y3, so ⟨ X0 X3 Z0 Z3 ⟩ = - ⟨ Y0 Y3 ⟩ = - (-1) =1</p>
<p>Similarly, other combinations.</p>
<p>The group generated by X0 X3 and Z0 Z3 has four elements: I, X0 X3, Z0 Z3, and (X0 X3)(Z0 Z3) = X0 X3 Z0 Z3.</p>
<p>And from above, all have expectation 1? From calculation: X0 X3 Z0 Z3 |ψ_ideal⟩ = |ψ_ideal⟩, so yes, ⟨X0 X3 Z0 Z3⟩=1.</p>
<p>And for Y0 Y3, which is not in the group, but Y0 Y3 = - X0 X3 Z0 Z3, so ⟨Y0 Y3⟩= -1.</p>
<p>But for Pauli F, if F is proportional to one of these, but since Pauli operators are defined with phase ±1,±i, but in the error channel, the Paulis are applied with phase 1, I think? The depolarizing channel applies Pauli operators without phase, so for example, it applies X0, not i Y0, etc.</p>
<p>In the error model, it says &ldquo;produces one of the 15 non-identity two-qubit Paulis&rdquo;, and Paulis are usually taken as the matrices with eigenvalues ±1, so for two qubits, the Pauli group has elements like X I, X Z, etc., with phase ±1,±i, but typically in error models, we consider the operators with phase 1, so the non-identity Paulis are those like X0, X3, X0 X3, Z0, Z3, Z0 Z3, X0 Z3, Z0 X3, Y0, Y3, Y0 Y3, Y0 X3, etc., all with coefficient 1.</p>
<p>So for F on {0,3}, we need to list all 16 Paulis, but for expectation, we can see which ones have non-zero expectation.</p>
<p>From the state |ψ_ideal⟩, since qubit 0 and 3 are always equal, the reduced density matrix for qubits 0 and 3 is proportional to |00⟩⟨00| + |11⟩⟨11|, so it is classical correlated.</p>
<p>For any Pauli P on {0,3}, ⟨P⟩ is non-zero only if P does not change the parity or something.</p>
<p>Specifically, from earlier calculation:</p>
<ul>
<li>
<p>If P has X0 or X3 alone, ⟨P⟩=0</p>
</li>
<li>
<p>If P has Z0 or Z3 alone, ⟨P⟩=0</p>
</li>
<li>
<p>If P has Y0 or Y3 alone, ⟨P⟩=0</p>
</li>
<li>
<p>If P is X0 X3, ⟨P⟩=1</p>
</li>
<li>
<p>If P is Z0 Z3, ⟨P⟩=1</p>
</li>
<li>
<p>If P is X0 Z3, let&rsquo;s compute: X0 Z3 |ψ_ideal⟩ = X0 Z3 \frac{1}{2} ( |0000⟩ + |1001⟩ + |0110⟩ + |1111⟩ ) = \frac{1}{2} ( X0 Z3 |0000⟩ + X0 Z3 |1001⟩ + X0 Z3 |0110⟩ + X0 Z3 |1111⟩ )</p>
</li>
</ul>
<p>Z3 |0000⟩ = |0000⟩, then X0 |0000⟩ = |1000⟩</p>
<p>Z3 |1001⟩ = (-1) |1001⟩ because qubit 3=1, so - |1001⟩, then X0 |1001⟩ = |0001⟩? X0 on |1&gt; = |0&gt;, so |0001⟩</p>
<p>Similarly, Z3 |0110⟩ = |0110⟩ since qubit 3=0, then X0 |0110⟩ = |1110⟩</p>
<p>Z3 |1111⟩ = (-1) |1111⟩, then X0 |1111⟩ = |0111⟩</p>
<p>So X0 Z3 |ψ_ideal⟩ = \frac{1}{2} ( |1000⟩ + |0001⟩ + |1110⟩ + |0111⟩ )</p>
<p>Now ⟨ψ_ideal| this state =0, so ⟨X0 Z3⟩=0</p>
<p>Similarly for Z0 X3, same thing.</p>
<p>Now for P = Y0 X3 etc., but similarly, will be zero.</p>
<p>Now for P = Y0 Y3, we have ⟨Y0 Y3⟩= -1 as above.</p>
<p>Y0 Y3 = i X0 Z0 i X3 Z3 = - X0 X3 Z0 Z3, but since X0 X3 Z0 Z3 has expectation 1, so Y0 Y3 has expectation -1.</p>
<p>Similarly, for P = X0 X3 Z0 Z3, which is the same as above, expectation 1.</p>
<p>But note that X0 X3 Z0 Z3 is not a basic Pauli; it is a product.</p>
<p>In the Pauli list, for two qubits, the Pauli operators are tensor products of I,X,Y,Z on each qubit, so for example, X0 I3, I0 X3, X0 X3, Z0 I3, I0 Z3, Z0 Z3, X0 Z3, Z0 X3, Y0 I3, I0 Y3, Y0 Y3, X0 Y3, Y0 X3, Z0 Y3, Y0 Z3.</p>
<p>And each can have phase ±1, but in application, we apply the operator with phase 1.</p>
<p>So for expectation, we need to compute for each.</p>
<p>But from symmetry, since the state has qubit 0 and 3 correlated, only Paulis that preserve the correlation will have non-zero expectation.</p>
<p>Specifically, Paulis that commute with X0 X3 and Z0 Z3 will have non-zero expectation.</p>
<p>The Paulis on {0,3} that commute with X0 X3 are those that have the same Pauli type on both qubits or something.</p>
<p>From group theory, the centralizer of {X0 X3, Z0 Z3} in the Pauli group on {0,3} is the group generated by X0 X3 and Z0 Z3, which has four elements: I, X0 X3, Z0 Z3, X0 X3 Z0 Z3.</p>
<p>And for these, expectation is 1 for I, X0 X3, Z0 Z3, and for X0 X3 Z0 Z3, which is equivalent to Y0 Y3 up to phase, but since we apply with phase 1, X0 X3 Z0 Z3 has expectation 1, as calculated.</p>
<p>But Y0 Y3 has expectation -1, so when we apply the error operator, if we apply Y0 Y3, it has phase -1, but the operator itself is applied, so for fidelity, |⟨ψ| Y0 Y3 |ψ⟩|^2 = | -1 |^2 =1.</p>
<p>Similarly, for any Pauli in the group generated by X0 X3 and Z0 Z3, but with phase, but since we apply the Pauli operator with coefficient 1, for example, if we apply the operator Y0 Y3, which is not in the group, but it has expectation -1, so |⟨|^2=1.</p>
<p>From calculation, for any Pauli P on {0,3}, ⟨ψ_ideal| P |ψ_ideal⟩ is either 0 or ±1, and it is ±1 only if P is in the set where P is a product of X0 X3 and Z0 Z3, but since X0 X3 and Z0 Z3 generate a group, and any P that is proportional to I, X0 X3, Z0 Z3, or X0 X3 Z0 Z3 will have expectation ±1.</p>
<p>But let&rsquo;s list all possible P on {0,3} with coefficient 1.</p>
<p>The Pauli operators are:</p>
<ol>
<li>
<p>I I</p>
</li>
<li>
<p>X I</p>
</li>
<li>
<p>I X</p>
</li>
<li>
<p>X X</p>
</li>
<li>
<p>Z I</p>
</li>
<li>
<p>I Z</p>
</li>
<li>
<p>Z Z</p>
</li>
<li>
<p>X Z</p>
</li>
<li>
<p>Z X</p>
</li>
<li>
<p>Y I</p>
</li>
<li>
<p>I Y</p>
</li>
<li>
<p>Y Y</p>
</li>
<li>
<p>X Y</p>
</li>
<li>
<p>Y X</p>
</li>
<li>
<p>Z Y</p>
</li>
<li>
<p>Y Z</p>
</li>
</ol>
<p>Now, from earlier:</p>
<ul>
<li>
<p>I I: expectation 1</p>
</li>
<li>
<p>X I: expectation 0</p>
</li>
<li>
<p>I X: expectation 0</p>
</li>
<li>
<p>X X: expectation 1</p>
</li>
<li>
<p>Z I: expectation 0</p>
</li>
<li>
<p>I Z: expectation 0</p>
</li>
<li>
<p>Z Z: expectation 1</p>
</li>
<li>
<p>X Z: expectation 0 (as computed)</p>
</li>
<li>
<p>Z X: expectation 0</p>
</li>
<li>
<p>Y I: expectation 0</p>
</li>
<li>
<p>I Y: expectation 0</p>
</li>
<li>
<p>Y Y: expectation -1</p>
</li>
<li>
<p>X Y: let&rsquo;s compute quickly? X Y |ψ_ideal⟩ = X0 Y3 |ψ_ideal⟩, likely 0</p>
</li>
<li>
<p>Similarly others, all have expectation 0 except the ones above.</p>
</li>
</ul>
<p>So for P on {0,3}, ⟨ψ_ideal| P |ψ_ideal⟩ ≠ 0 only for P = I, X X, Z Z, and Y Y.</p>
<p>And for these, |⟨ψ_ideal| P |ψ_ideal⟩|^2 =1 since expectation magnitude 1.</p>
<p>So for error F on {0,3}, if F is one of I, X0 X3, Z0 Z3, Y0 Y3, then |⟨ψ_ideal| F |ψ_ideal⟩|^2 =1, otherwise 0.</p>
<p>But I is identity, so for non-identity, the Paulis that have non-zero expectation are X0 X3, Z0 Z3, and Y0 Y3.</p>
<p>There are three such Paulis.</p>
<p>In the depolarizing channel, there are 15 non-identity Paulis, so for most, fidelity is 0.</p>
<p>Now back to case 1: no error after CNOT21.</p>
<p>Then after CNOT03, with prob 1-p, no error, fidelity 1</p>
<p>With prob p, error F, and for each F, with prob p/15, fidelity |⟨ψ_ideal| F |ψ_ideal⟩|^2</p>
<p>So the average fidelity for case 1 is: (1-p) * 1 + p * [ fraction of F that give fidelity 1 ]</p>
<p>There are 15 possible F, and for 3 of them, fidelity 1, for other 12, fidelity 0.</p>
<p>So average from error after CNOT03: (1-p) <em>1 + p * (3/15) </em>1 + p * (12/15) *0 = (1-p) + p * 3/15 = 1-p + p/5 = 1 - (4/5)p</p>
<p>But this is for after CNOT03 error, but this is when there was no error after CNOT21.</p>
<p>So for case 1, which has probability (1-p) for no error after CNOT21, the fidelity is 1 - (4/5)p</p>
<p>Now, case 2: error E after CNOT21.</p>
<p>This happens with probability p for error after CNOT21, and for each E, prob p/15.</p>
<p>After error E, state is E |ψ2⟩</p>
<p>Then apply H0: state becomes H0 E |ψ2⟩</p>
<p>Then apply CNOT03 ideally: state becomes CNOT03 H0 E |ψ2⟩</p>
<p>Then after CNOT03, with prob 1-p, no error, so final state CNOT03 H0 E |ψ2⟩</p>
<p>With prob p, error F, so final state F CNOT03 H0 E |ψ2⟩</p>
<p>Now, we need |⟨ψ_ideal| final state ⟩|^2</p>
<p>But |ψ_ideal⟩ = CNOT03 H0 |ψ2⟩</p>
<p>So for final state without F error, i.e., CNOT03 H0 E |ψ2⟩</p>
<p>Then ⟨ψ_ideal| CNOT03 H0 E |ψ2⟩ = ⟨ψ2| H0^\dagger CNOT03^\dagger CNOT03 H0 E |ψ2⟩ = ⟨ψ2| H0^\dagger H0 E |ψ2⟩ = ⟨ψ2| E |ψ2⟩</p>
<p>Since H0 and CNOT03 are unitary.</p>
<p>Similarly, if with F error, final state F CNOT03 H0 E |ψ2⟩</p>
<p>Then ⟨ψ_ideal| F CNOT03 H0 E |ψ2⟩ = ⟨ψ2| H0^\dagger CNOT03^\dagger F CNOT03 H0 E |ψ2⟩</p>
<p>Now, CNOT03^\dagger F CNOT03 is some operator on qubits 0 and 3, since F acts on 0 and 3, and CNOT03 acts on 0 and 3, so CNOT03^\dagger F CNOT03 is also a Pauli on 0 and 3, because CNOT conjugates Pauli to Pauli.</p>
<p>Similarly, H0 acts on qubit 0, so H0^\dagger (CNOT03^\dagger F CNOT03) H0 may change it, but let&rsquo;s see.</p>
<p>First, for simplicity, let&rsquo;s define |φ⟩ = |ψ2⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle )</p>
<p>And we need ⟨φ| E |φ⟩ for the case without F error.</p>
<p>And for with F error, we need ⟨φ| H0^\dagger CNOT03^\dagger F CNOT03 H0 E |φ⟩</p>
<p>But since E is a Pauli on {2,1}, and |φ⟩ is a state on all qubits, we need to compute these overlaps.</p>
<p>Notice that |φ⟩ = \frac{1}{\sqrt{2}} ( |0000\rangle + |0110\rangle ) = \frac{1}{\sqrt{2}} |0\rangle_0 |0\rangle_1 |0\rangle_2 |0\rangle_3 + \frac{1}{\sqrt{2}} |0\rangle_0 |1\rangle_1 |1\rangle_2 |0\rangle_3</p>
<p>So |φ⟩ is a state where qubit 0 is always |0⟩, qubit 3 is always |0⟩, and qubits 1 and 2 are either both |0⟩ or both |1⟩.</p>
<p>So |φ⟩ is stabilized by some operators? For example, Z0, Z3, and X1 X2, etc.</p>
<p>Now, E is a Pauli on qubits 2 and 1.</p>
<p>So for ⟨φ| E |φ⟩, since E acts on qubits 1 and 2, and |φ⟩ involves only states where qubits 1 and 2 are correlated.</p>
<p>Let&rsquo;s compute ⟨φ| E |φ⟩ for general E on {1,2}.</p>
<p>|φ⟩ = \frac{1}{\sqrt{2}} ( |a\rangle + |b\rangle ) where |a⟩ = |0000⟩, |b⟩ = |0110⟩</p>
<p>So ⟨φ| E |φ⟩ = \frac{1}{2} ( \langle a| E |a\rangle + \langle a| E |b\rangle + \langle b| E |a\rangle + \langle b| E |b\rangle )</p>
<p>Now, |a⟩ and |b⟩ are orthogonal, and E is Pauli, so unless E changes the state, but let&rsquo;s see.</p>
<p>For example, if E = I, then ⟨φ| I |φ⟩ =1</p>
<p>If E = X1, then X1 |a⟩ = X1 |0000⟩ = |0100⟩, not |a⟩ or |b⟩, so ⟨a| X1 |a⟩=0, similarly ⟨a| X1 |b⟩ = ⟨0000| X1 |0110⟩ = ⟨0000| |0110⟩? X1 |0110⟩ = |0010⟩? X1 on qubit 1: |1&gt; to |0&gt;, so |0010⟩, so ⟨0000|0010⟩=0, similarly all terms zero, so ⟨φ| X1 |φ⟩=0</p>
<p>Similarly, if E = X2, X2 |a⟩ = |0010⟩, not in {|a⟩,|b⟩}, so overlap 0</p>
<p>If E = X1 X2, then X1 X2 |a⟩ = X1 X2 |0000⟩ = |0110⟩ = |b⟩</p>
<p>X1 X2 |b⟩ = X1 X2 |0110⟩ = |0000⟩ = |a⟩</p>
<p>So ⟨a| X1 X2 |a⟩ = ⟨a|b⟩=0</p>
<p>⟨a| X1 X2 |b⟩ = ⟨a|a⟩=1</p>
<p>⟨b| X1 X2 |a⟩ = ⟨b|b⟩=1</p>
<p>⟨b| X1 X2 |b⟩ = ⟨b|a⟩=0</p>
<p>So ⟨φ| X1 X2 |φ⟩ = \frac{1}{2} (0 +1 +1 +0) =1</p>
<p>Similarly, if E = Z1, then Z1 |a⟩ = |0000⟩, Z1 |b⟩ = - |0110⟩ = - |b⟩</p>
<p>So ⟨a| Z1 |a⟩=1, ⟨a| Z1 |b⟩= ⟨a| -|b⟩=0, ⟨b| Z1 |a⟩=0, ⟨b| Z1 |b⟩= -1</p>
<p>So ⟨φ| Z1 |φ⟩ = \frac{1}{2} (1 +0 +0 -1) =0</p>
<p>Similarly for Z2, Z2 |a⟩ = |0000⟩, Z2 |b⟩ = - |0110⟩ = - |b⟩? Z2 on |b⟩ = |0110⟩, since qubit2=1, Z2 |1&gt; = -|1&gt;, so - |0110⟩, so similarly ⟨φ| Z2 |φ⟩=0</p>
<p>If E = Z1 Z2, then Z1 Z2 |a⟩ = |0000⟩, Z1 Z2 |b⟩ = (-1)(-1) |0110⟩ = |0110⟩? Z1 Z2 |0110⟩ = Z1 |0&gt;1&gt;1&gt;0&gt; but qubit1=1, qubit2=1, so Z1 gives -1, Z2 gives -1, so product phase (-1)(-1)=1, so |0110⟩</p>
<p>So Z1 Z2 |a⟩ = |a⟩, Z1 Z2 |b⟩ = |b⟩, so ⟨φ| Z1 Z2 |φ⟩ =1</p>
<p>Now for Y operators, e.g., E = Y1 = i X1 Z1</p>
<p>But from above, since ⟨X1⟩=0, ⟨Z1⟩=0, but let&rsquo;s compute directly.</p>
<p>Y1 |a⟩ = i X1 Z1 |0000⟩ = i X1 |0000⟩ = i |0100⟩</p>
<p>Y1 |b⟩ = i X1 Z1 |0110⟩ = i X1 ( - |0110⟩ ) since Z1 |1&gt; = -|1&gt;, so - i X1 |0110⟩ = - i |0010⟩? X1 |0110⟩ = |0010⟩, so -i |0010⟩</p>
<p>Now ⟨a| Y1 |a⟩ = ⟨0000| i |0100⟩ =0</p>
<p>⟨a| Y1 |b⟩ = ⟨0000| -i |0010⟩ =0</p>
<p>Similarly all zero, so ⟨φ| Y1 |φ⟩=0</p>
<p>Similarly for Y2, etc.</p>
<p>Now for products like X1 Z2, etc.</p>
<p>But from the pattern, ⟨φ| E |φ⟩ is non-zero only if E preserves the correlation between qubit 1 and 2, i.e., if E is in the group generated by X1 X2 and Z1 Z2.</p>
<p>Similarly to before, for E on {1,2}, ⟨φ| E |φ⟩ ≠0 only if E is I, X1 X2, Z1 Z2, or Y1 Y2? Let&rsquo;s check Y1 Y2.</p>
<p>Y1 Y2 |a⟩ = Y1 Y2 |0000⟩ = i X1 Z1 i X2 Z2 |0000⟩ = i^2 X1 X2 Z1 Z2 |0000⟩ = - X1 X2 |0000⟩ since Z1 Z2 |0000⟩=|0000⟩, so - |0110⟩ = - |b⟩</p>
<p>Y1 Y2 |b⟩ = Y1 Y2 |0110⟩ = i X1 Z1 i X2 Z2 |0110⟩ = - X1 X2 Z1 Z2 |0110⟩ = - X1 X2 |0110⟩ since Z1 Z2 |0110⟩=|0110⟩, so - |0000⟩ = - |a⟩</p>
<p>So ⟨a| Y1 Y2 |a⟩ = ⟨a| -|b⟩=0</p>
<p>⟨a| Y1 Y2 |b⟩ = ⟨a| -|a⟩= -1</p>
<p>⟨b| Y1 Y2 |a⟩ = ⟨b| -|b⟩= -1</p>
<p>⟨b| Y1 Y2 |b⟩ = ⟨b| -|a⟩=0</p>
<p>So ⟨φ| Y1 Y2 |φ⟩ = \frac{1}{2} (0 -1 -1 +0) = -1</p>
<p>So |⟨φ| Y1 Y2 |φ⟩|^2 =1</p>
<p>Similarly, for other Paulis, only when E is proportional to I, X1 X2, Z1 Z2, or X1 X2 Z1 Z2, but X1 X2 Z1 Z2 |φ⟩ = since X1 X2 Z1 Z2 |a⟩ = X1 X2 |a⟩ = |b⟩, and X1 X2 Z1 Z2 |b⟩ = X1 X2 |b⟩ = |a⟩, so ⟨φ| X1 X2 Z1 Z2 |φ⟩ = \frac{1}{2} (⟨a|b⟩ + ⟨a|a⟩ + ⟨b|b⟩ + ⟨b|a⟩) wait no.</p>
<p>⟨φ| X1 X2 Z1 Z2 |φ⟩ = \frac{1}{2} ( \langle a| X1 X2 Z1 Z2 |a\rangle + \langle a| X1 X2 Z1 Z2 |b\rangle + \langle b| X1 X2 Z1 Z2 |a\rangle + \langle b| X1 X2 Z1 Z2 |b\rangle ) = \frac{1}{2} ( \langle a|b\rangle + \langle a|a\rangle + \langle b|b\rangle + \langle b|a\rangle ) = \frac{1}{2} (0+1+1+0) =1</p>
<p>So indeed, for E on {1,2}, ⟨φ| E |φ⟩ is non-zero only for E in the set where E is I, X1 X2, Z1 Z2, or X1 X2 Z1 Z2.</p>
<p>But X1 X2 Z1 Z2 is the same as Y1 Y2 up to phase? Y1 Y2 = i X1 Z1 i X2 Z2 = - X1 X2 Z1 Z2, so X1 X2 Z1 Z2 = - Y1 Y2, so when we apply the operator, if we apply X1 X2 Z1 Z2, it has expectation 1, if we apply Y1 Y2, it has expectation -1.</p>
<p>But in terms of the operator applied, for the error channel, we apply the Pauli operators with coefficient 1, so for example, we apply X1, I2, etc., or X1 X2, etc.</p>
<p>So from above, the Paulis E on {1,2} that have non-zero expectation are those that are products of X1 X2 and Z1 Z2, i.e., the group generated by X1 X2 and Z1 Z2.</p>
<p>The group has four elements: I, X1 X2, Z1 Z2, and X1 X2 Z1 Z2.</p>
<p>But X1 X2 Z1 Z2 is not a basic Pauli; it is a product. In the list of Pauli operators on two qubits, the operators are things like X1 I2, X1 X2, etc., so for example, X1 X2 is one operator, Z1 Z2 is another, and X1 X2 Z1 Z2 is another operator, which is the same as - Y1 Y2 but with coefficient 1, so when we apply the operator X1 X2 Z1 Z2, it is applied as is.</p>
<p>In the depolarizing channel, the Paulis are all possible tensor products, so including X1 X2, Z1 Z2, and also X1 Z2, etc., and also products like X1 X2 Z1 Z2, which is a valid Pauli operator.</p>
<p>Similarly for others.</p>
<p>So for E on {1,2}, there are 16 Paulis, but only 4 of them have |⟨φ| E |φ⟩|^2 =1, and the other 12 have |⟨φ| E |φ⟩|^2 =0.</p>
<p>From above, when E is I, X1 X2, Z1 Z2, or X1 X2 Z1 Z2, then ⟨φ| E |φ⟩ =1,1,1,1 respectively? From calculation:</p>
<ul>
<li>
<p>I: ⟨φ| I |φ⟩ =1</p>
</li>
<li>
<p>X1 X2: ⟨φ| X1 X2 |φ⟩ =1</p>
</li>
<li>
<p>Z1 Z2: ⟨φ| Z1 Z2 |φ⟩ =1</p>
</li>
<li>
<p>X1 X2 Z1 Z2: ⟨φ| X1 X2 Z1 Z2 |φ⟩ =1</p>
</li>
</ul>
<p>And for Y1 Y2, which is another Pauli, ⟨φ| Y1 Y2 |φ⟩ = -1, so |⟨|^2=1</p>
<p>But Y1 Y2 is not the same as X1 X2 Z1 Z2; they are different operators.</p>
<p>In the list, Y1 Y2 is a Pauli operator, and it has |⟨φ| Y1 Y2 |φ⟩|^2 =1.</p>
<p>Similarly, are there others?</p>
<p>Let&rsquo;s list all Paulis on {1,2} that have non-zero expectation.</p>
<p>From the state |φ⟩, since qubits 1 and 2 are always equal in the sense that in |a⟩ they are both 0, in |b⟩ they are both 1, so the reduced density matrix is |00⟩⟨00| + |11⟩⟨11| for qubits 1 and2.</p>
<p>So for Pauli P on {1,2}, ⟨P⟩ is non-zero only if P does not change the basis or something.</p>
<p>Specifically, P must commute with X1 X2 and Z1 Z2.</p>
<p>The Paulis that commute with X1 X2 are those that have the same Pauli on both qubits or something.</p>
<p>From earlier calculation, only Paulis that are products of X1 X2 and Z1 Z2 have non-zero expectation, but that includes I, X1 X2, Z1 Z2, and X1 X2 Z1 Z2.</p>
<p>But X1 X2 Z1 Z2 = (X1 Z1) (X2 Z2) = (i Y1) (i Y2) = - Y1 Y2, so if we apply Y1 Y2, it is proportional to X1 X2 Z1 Z2, but with phase -1, so when we apply Y1 Y2, we get expectation -1.</p>
<p>Similarly, if we apply X1 X2 Z1 Z2, we get expectation 1.</p>
<p>But in terms of the operator applied, for the error channel, when we say &ldquo;apply Pauli E&rdquo;, we mean apply the operator with coefficient 1, so for example, apply the matrix Y1 Y2, which has expectation -1.</p>
<p>So for fidelity, |⟨φ| E |φ⟩|^2 =1 for E such that E |φ⟩ = ± |φ⟩, which happens when E is in the stabilizer of |φ⟩ or something.</p>
<p>From above, for E on {1,2}, E |φ⟩ = ± |φ⟩ only if E is I, X1 X2, Z1 Z2, or Y1 Y2? Let&rsquo;s see.</p>
<p>From earlier, X1 X2 |φ⟩ = |φ⟩? X1 X2 |a⟩ = |b⟩, X1 X2 |b⟩ = |a⟩, so X1 X2 |φ⟩ = \frac{1}{\sqrt{2}} ( |b⟩ + |a⟩ ) = |φ⟩, so yes.</p>
<p>Z1 Z2 |φ⟩ = |φ⟩ as above.</p>
<p>Y1 Y2 |φ⟩ = - |φ⟩ as above.</p>
<p>Now for X1 X2 Z1 Z2, which is the same as - Y1 Y2, so X1 X2 Z1 Z2 |φ⟩ = - Y1 Y2 |φ⟩ = - (- |φ⟩) = |φ⟩, so also.</p>
<p>But X1 X2 Z1 Z2 is not a basic Pauli; it is a product, but it is a Pauli operator.</p>
<p>In the list of Pauli operators on two qubits, the operators are uniquely defined by their action on each qubit, so for example, the operator that is X on qubit 1 and X on qubit 2 is X1 X2, etc.</p>
<p>So for E on {1,2}, the Pauli operators that have E |φ⟩ = ± |φ⟩ are: 
- I
- X1 X2
- Z1 Z2
- X1 X2 Z1 Z2
- Y1 Y2</p>
<p>But X1 X2 Z1 Z2 and Y1 Y2 are different operators? Yes, because X1 X2 Z1 Z2 has matrix that is tensor product of X and X times Z and Z, but since it acts on two qubits, it is a single operator.</p>
<p>But note that X1 X2 Z1 Z2 = (X1 Z1) (X2 Z2) = (i Y1) (i Y2) = - Y1 Y2, so indeed, X1 X2 Z1 Z2 is proportional to Y1 Y2.</p>
<p>So in terms of the set of Pauli operators, there are four operators that have expectation magnitude 1: namely, the identity, and the three operators X1 X2, Z1 Z2, and Y1 Y2.</p>
<p>Because X1 X2 Z1 Z2 is not independent; it is equal to - Y1 Y2, so when we apply the operator, if we apply Y1 Y2, we get expectation -1, if we apply X1 X2 Z1 Z2, we get expectation 1, but X1 X2 Z1 Z2 is the same as applying the operator that is X on both and Z on both, which is a valid Pauli, but in the standard list, when we say &ldquo;non-identity Paulis&rdquo;, we list all products, so for example, the operator with X on qubit 1 and Z on qubit 2 is X1 Z2, etc.</p>
<p>So for the error channel, the Pauli operators on two qubits are all possible combinations of I,X,Y,Z on each qubit with coefficient 1, so there are 16 operators, including for example X1 I2, I1 X2, X1 X2, X1 Z2, Z1 X2, Z1 Z2, Y1 I2, I1 Y2, Y1 Y2, X1 Y2, Y1 X2, Z1 Y2, Y1 Z2, etc.</p>
<p>Now for each, we can compute the expectation with |φ⟩.</p>
<p>From earlier calculation and symmetry, the only operators that have non-zero expectation are those where the operator on qubit 1 and qubit 2 are the same type and same sign? But from above, for example, X1 X2 has expectation 1, Z1 Z2 has expectation 1, Y1 Y2 has expectation -1.</p>
<p>What about X1 Z2? X1 Z2 |a⟩ = X1 Z2 |0000⟩ = X1 |0000⟩ = |0100⟩, not proportional to |a⟩ or |b⟩, so expectation 0.</p>
<p>Similarly for others.</p>
<p>So indeed, for E on {1,2}, ⟨φ| E |φ⟩ ≠ 0 only if E is I, X1 X2, Z1 Z2, or Y1 Y2.</p>
<p>And for these, |⟨φ| E |φ⟩|^2 =1.</p>
<p>So there are 4 operators out of 16 that give fidelity 1, but since I is identity, for non-identity, there are 3 operators that give fidelity 1.</p>
<p>In the error channel, when error occurs, we have non-identity Paulis, so for E non-identity, there are 15 possible, and for 3 of them, |⟨φ| E |φ⟩|^2 =1, for other 12, it is 0.</p>
<p>But in case 2, when we have error E after CNOT21, then for the final state without F error, we have final state CNOT03 H0 E |ψ2⟩, and ⟨ψ_ideal| this state = ⟨φ| E |φ⟩ as above, so |⟨|^2 = |⟨φ| E |φ⟩|^2</p>
<p>So if E is one of the 3 non-identity Paulis that give |⟨φ| E |φ⟩|^2=1, then this term has fidelity 1, otherwise 0.</p>
<p>Then for with F error, we have final state F CNOT03 H0 E |ψ2⟩, and ⟨ψ_ideal| this state = ⟨φ| H0^\dagger CNOT03^\dagger F CNOT03 H0 E |φ⟩</p>
<p>Now, CNOT03^\dagger F CNOT03 is a Pauli on {0,3} because CNOT conjugates Pauli to Pauli.</p>
<p>Similarly, H0^\dagger something H0 may change it.</p>
<p>But note that H0 acts on qubit 0, and CNOT03 acts on qubits 0 and 3, so let&rsquo;s define O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>Since F is on {0,3}, CNOT03^\dagger F CNOT03 is on {0,3}, and then H0^\dagger ( that ) H0 is on qubit 0, so it is still an operator on qubits 0 and 3, but may be different Pauli.</p>
<p>Then we need ⟨φ| O E |φ⟩</p>
<p>But E is on {1,2}, and O is on {0,3}, and |φ⟩ is on all qubits, and since they act on different sets of qubits, O and E commute, so ⟨φ| O E |φ⟩ = ⟨φ| O |φ⟩ ⟨φ| E |φ⟩? No, because |φ⟩ is not necessarily product, but since O acts on 0 and3, E acts on 1 and2, and |φ⟩ might be product between {0,3} and {1,2}, let&rsquo;s see.</p>
<p>From |φ⟩ = \frac{1}{\sqrt{2}} ( |0000⟩ + |0110⟩ ) = \frac{1}{\sqrt{2}} ( |0\rangle_0 |0\rangle_3 |0\rangle_1 |0\rangle_2 + |0\rangle_0 |0\rangle_3 |1\rangle_1 |1\rangle_2 ) = |0\rangle_0 |0\rangle_3 \otimes \frac{1}{\sqrt{2}} ( |00\rangle_{12} + |11\rangle_{12} )</p>
<p>So indeed, |φ⟩ is product between qubits {0,3} and {1,2}, specifically, qubits 0 and 3 are in state |00\rangle_{03}, and qubits 1 and 2 are in state \frac{1}{\sqrt{2}} ( |00\rangle + |11\rangle ) which is Bell state.</p>
<p>So for operator O on {0,3}, and E on {1,2}, we have ⟨φ| O E |φ⟩ = ⟨00|<em>{03} O |00\rangle</em>{03} \cdot \langle Bell| E | Bell\rangle_{12}</p>
<p>Because |φ⟩ = |00\rangle_{03} \otimes |\Phi^+\rangle_{12} where |\Phi^+\rangle = \frac{1}{\sqrt{2}} ( |00\rangle + |11\rangle )</p>
<p>So ⟨φ| O E |φ⟩ = [ ⟨00|<em>{03} O |00\rangle</em>{03} ] [ ⟨\Phi^+| E |\Phi^+\rangle_{12} ]</p>
<p>Now, ⟨00|<em>{03} O |00\rangle</em>{03} is the expectation of O in state |00⟩_{03}</p>
<p>Similarly, ⟨\Phi^+| E |\Phi^+\rangle_{12} is the expectation of E in Bell state.</p>
<p>Now, for the Bell state |\Phi^+\rangle = \frac{1}{\sqrt{2}} ( |00\rangle + |11\rangle ), what is ⟨\Phi^+| E |\Phi^+\rangle for E on {1,2}?</p>
<p>Similarly to before, for E on {1,2}, ⟨\Phi^+| E |\Phi^+\rangle is non-zero only if E is I, X1 X2, Z1 Z2, or Y1 Y2, and for these, it is 1,1,1,-1 respectively? Let&rsquo;s compute.</p>
<p>For E=I, ⟨E⟩=1</p>
<p>For E=X1 X2, X1 X2 |\Phi^+\rangle = X1 X2 \frac{1}{\sqrt{2}} ( |00\rangle + |11\rangle ) = \frac{1}{\sqrt{2}} ( |11\rangle + |00\rangle ) = |\Phi^+\rangle, so ⟨E⟩=1</p>
<p>For E=Z1 Z2, Z1 Z2 |\Phi^+\rangle = \frac{1}{\sqrt{2}} ( Z1 Z2 |00\rangle + Z1 Z2 |11\rangle ) = \frac{1}{\sqrt{2}} ( |00\rangle + (-1)(-1)|11\rangle ) = |\Phi^+\rangle, so ⟨E⟩=1</p>
<p>For E=Y1 Y2, Y1 Y2 |\Phi^+\rangle = i X1 Z1 i X2 Z2 |\Phi^+\rangle = - X1 X2 Z1 Z2 |\Phi^+\rangle = - X1 X2 |\Phi^+\rangle since Z1 Z2 |\Phi^+\rangle=|\Phi^+\rangle, so - |\Phi^+\rangle, so ⟨E⟩= -1</p>
<p>For other E, ⟨E⟩=0.</p>
<p>So indeed, ⟨\Phi^+| E |\Phi^+\rangle =1 for E=I, X1 X2, Z1 Z2, and -1 for Y1 Y2, and 0 otherwise.</p>
<p>So |⟨\Phi^+| E |\Phi^+\rangle|^2 =1 for these4 operators, and 0 for others.</p>
<p>But since E is for error on {1,2}, and in case 2, E is applied after CNOT21, so for the overlap, we have ⟨φ| E |φ⟩ = ⟨00|<em>{03} |00\rangle</em>{03} ⟨\Phi^+| E |\Phi^+\rangle = 1 * ⟨\Phi^+| E |\Phi^+\rangle</p>
<p>So from above, if E is I, X1 X2, Z1 Z2, or Y1 Y2, then ⟨φ| E |φ⟩ =1,1,1,-1 respectively, so |⟨φ| E |φ⟩|^2=1 for these4 cases.</p>
<p>Otherwise, |⟨φ| E |φ⟩|^2=0.</p>
<p>But for non-identity E, there are 3 operators that give |⟨φ| E |φ⟩|^2=1: X1 X2, Z1 Z2, Y1 Y2.</p>
<p>Now back to case 2.</p>
<p>For case 2, with error E after CNOT21, which happens with probability p for error, and for each E, prob p/15.</p>
<p>Then after that, we apply H0 and CNOT03 ideally, so state becomes CNOT03 H0 E |ψ2⟩</p>
<p>Then with probability 1-p, no error after CNOT03, so final state is CNOT03 H0 E |ψ2⟩</p>
<p>Then fidelity |⟨ψ_ideal| this state⟩|^2 = |⟨φ| E |φ⟩|^2</p>
<p>So if E is one of the 3 good non-identity Paulis, fidelity 1, else fidelity 0.</p>
<p>With probability p, error F after CNOT03, so final state F CNOT03 H0 E |ψ2⟩</p>
<p>Then fidelity |⟨ψ_ideal| this state⟩|^2 = |⟨φ| H0^\dagger CNOT03^\dagger F CNOT03 H0 E |φ⟩|^2</p>
<p>But as above, this is | [ ⟨00|<em>{03} O |00\rangle</em>{03} ] [ ⟨\Phi^+| E |\Phi^+\rangle ] |^2 where O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>Now O is an operator on {0,3}, and we need ⟨00|<em>{03} O |00\rangle</em>{03}</p>
<p>Now |00\rangle_{03} is a state, and O is a Pauli operator on {0,3} after conjugation.</p>
<p>First, CNOT03^\dagger F CNOT03 for F on {0,3}.</p>
<p>CNOT03 with control 0 target 3.</p>
<p>The conjugation of Pauli by CNOT03.</p>
<p>For example, if F = X0, then CNOT03^\dagger X0 CNOT03 = X0 X3? Let&rsquo;s recall.</p>
<p>Generally, CNOT conjugation: 
- CNOT^\dagger X_c CNOT = X_c X_t
- CNOT^\dagger X_t CNOT = X_t
- CNOT^\dagger Z_c CNOT = Z_c
- CNOT^\dagger Z_t CNOT = Z_c Z_t</p>
<p>Where c is control, t is target.</p>
<p>So for CNOT03, c=0, t=3.</p>
<p>So CNOT03^\dagger F CNOT03 for F on {0,3}.</p>
<p>For example, if F = X0, then CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>If F = X3, then CNOT03^\dagger X3 CNOT03 = X3</p>
<p>If F = Z0, then CNOT03^\dagger Z0 CNOT03 = Z0</p>
<p>If F = Z3, then CNOT03^\dagger Z3 CNOT03 = Z0 Z3</p>
<p>And for other Paulis, similarly.</p>
<p>Then after that, we apply H0^\dagger &hellip; H0</p>
<p>H0 conjugation on qubit 0: 
H0^\dagger X0 H0 = Z0
H0^\dagger Z0 H0 = X0</p>
<p>So for O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>So let&rsquo;s compute for each type of F.</p>
<p>But since we need ⟨00|<em>{03} O |00\rangle</em>{03}, and O is a Pauli operator on {0,3}, so ⟨00| O |00⟩ is non-zero only if O is I or something, but |00⟩ is eigenstate of Z0 and Z3, so ⟨00| O |00⟩ ≠0 only if O has no X or Y on either qubit, i.e., if O is product of Z operators or I.</p>
<p>Specifically, for |00⟩, ⟨00| O |00⟩ =1 if O=I, or if O=Z0, or O=Z3, or O=Z0 Z3, but since |00⟩ is |0⟩ for both, Z0 |00⟩ = |00⟩, Z3 |00⟩ = |00⟩, so ⟨00| Z0 |00⟩=1, similarly for Z3, Z0 Z3.</p>
<p>But if O has X or Y, then O |00⟩ has |1⟩, so ⟨00| O |00⟩=0.</p>
<p>So ⟨00| O |00⟩ =1 only if O is I, Z0, Z3, or Z0 Z3.</p>
<p>Otherwise, 0.</p>
<p>Now for our case, we need O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>So we need to see for which F, this O is one of I, Z0, Z3, or Z0 Z3.</p>
<p>Since H0 acts only on qubit 0, and CNOT03 on 0 and3, we can compute for each F what is O.</p>
<p>But note that we have average over F, and also over E.</p>
<p>For case 2, when we have error F after CNOT03, the fidelity is | [ ⟨00| O |00⟩ ] [ ⟨Φ+| E |Φ+⟩ ] |^2</p>
<p>Since both are scalars, so | ab |^2 = |a|^2 |b|^2</p>
<p>And from above, ⟨00| O |00⟩ is either 0 or 1, and similarly ⟨Φ+| E |Φ+⟩ is either 0 or ±1, so |b|^2 is 0 or 1.</p>
<p>So for fidelity to be 1, we need both ⟨00| O |00⟩ =1 and ⟨Φ+| E |Φ+⟩ = ±1, so |b|^2=1.</p>
<p>Otherwise, fidelity 0.</p>
<p>So for case 2 with F error, the fidelity is 1 only if E is one of the good Paulis (X1 X2, Z1 Z2, Y1 Y2) and O is one of I, Z0, Z3, Z0 Z3.</p>
<p>Otherwise, fidelity 0.</p>
<p>Now, for given F, what is O, and for which F is O one of those.</p>
<p>But since we average over F, and F is random, we need to find the probability that for random F, O is in that set.</p>
<p>But O depends on F.</p>
<p>Now let&rsquo;s compute O for each F.</p>
<p>First, let&rsquo;s find CNOT03^\dagger F CNOT03 for F on {0,3}.</p>
<p>As above, for F = X0, CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>For F = X3, CNOT03^\dagger X3 CNOT03 = X3</p>
<p>For F = Z0, CNOT03^\dagger Z0 CNOT03 = Z0</p>
<p>For F = Z3, CNOT03^\dagger Z3 CNOT03 = Z0 Z3</p>
<p>For F = X0 X3, CNOT03^\dagger X0 X3 CNOT03 = (X0 X3) (X3) = X0 X3 X3 = X0 I3? Let&rsquo;s compute carefully.</p>
<p>CNOT03^\dagger X0 X3 CNOT03 = CNOT03^\dagger X0 CNOT03 CNOT03^\dagger X3 CNOT03 because CNOT03 is unitary, so it distributes.</p>
<p>CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>CNOT03^\dagger X3 CNOT03 = X3</p>
<p>So product is X0 X3 * X3 = X0 X3 X3 = X0 I3 = X0</p>
<p>Similarly, for F = X0 Z3, etc., but we may not need all.</p>
<p>Now for O = H0^\dagger CNOT03^\dagger F CNOT03 H0</p>
<p>So for example, if F = X0, then CNOT03^\dagger F CNOT03 = X0 X3</p>
<p>Then H0^\dagger (X0 X3) H0 = H0^\dagger X0 H0 H0^\dagger X3 H0 = Z0 X3 because H0^\dagger X0 H0 = Z0, and H0^\dagger X3 H0 = X3 since H0 acts only on qubit 0.</p>
<p>So O = Z0 X3</p>
<p>Similarly, if F = X3, then CNOT03^\dagger X3 CNOT03 = X3</p>
<p>Then O = H0^\dagger X3 H0 = X3</p>
<p>If F = Z0, then CNOT03^\dagger Z0 CNOT03 = Z0</p>
<p>Then O = H0^\dagger Z0 H0 = X0</p>
<p>If F = Z3, then CNOT03^\dagger Z3 CNOT03 = Z0 Z3</p>
<p>Then O = H0^\dagger (Z0 Z3) H0 = H0^\dagger Z0 H0 H0^\dagger Z3 H0 = X0 Z3</p>
<p>Now for F = X0 X3, then CNOT03^\dagger X0 X3 CNOT03 = X0 as above</p>
<p>Then O = H0^\dagger X0 H0 = Z0</p>
<p>If F = Z0 Z3, then CNOT03^\dagger Z0 Z3 CNOT03 = CNOT03^\dagger Z0 CNOT03 CNOT03^\dagger Z3 CNOT03 = Z0 * (Z0 Z3) = Z0 Z0 Z3 = I0 Z3 = Z3</p>
<p>Then O = H0^\dagger Z3 H0 = Z3</p>
<p>If F = X0 Z3, then CNOT03^\dagger X0 Z3 CNOT03 = [CNOT03^\dagger X0 CNOT03] [CNOT03^\dagger Z3 CNOT03] = (X0 X3) (Z0 Z3) = X0 Z0 X3 Z3</p>
<p>Then O = H0^\dagger (X0 Z0 X3 Z3) H0 = H0^\dagger X0 Z0 H0 X3 Z3 = H0^\dagger X0 H0 H0^\dagger Z0 H0 X3 Z3 = Z0 X0 X3 Z3 = - X0 Z0 X3 Z3? Let&rsquo;s compute:</p>
<p>H0^\dagger X0 Z0 H0 = since H0 X0 H0^\dagger = Z0, but careful: H0^\dagger X0 H0 = Z0, and H0^\dagger Z0 H0 = X0, so H0^\dagger X0 Z0 H0 = H0^\dagger X0 H0 H0^\dagger Z0 H0 = Z0 X0</p>
<p>So then O = (Z0 X0) X3 Z3 = Z0 X0 X3 Z3</p>
<p>Now X0 X3 Z3 is not simple, but for ⟨00| O |00⟩, O has X0 and X3, so it will have off-diagonal, so ⟨00| O |00⟩=0.</p>
<p>Similarly for other F, we need to see when O has only Z operators.</p>
<p>From the examples, when O has any X or Y, then ⟨00| O |00⟩=0.</p>
<p>So we need O to be I, Z0, Z3, or Z0 Z3.</p>
<p>From above, when F = X0, O= Z0 X3, which has X3, so not good.</p>
<p>F=X3, O=X3, has X3, not good.</p>
<p>F=Z0, O=X0, has X0, not good.</p>
<p>F=Z3, O=X0 Z3, has X0, not good.</p>
<p>F=X0 X3, O=Z0, which is good, since Z0 is one of the desired.</p>
<p>F=Z0 Z3, O=Z3, which is good.</p>
<p>Now what about F= Y0 Y3? But let&rsquo;s list all F that give O with only Z.</p>
<p>Perhaps from the conjugation, since H0 and CNOT03 are Clifford, the map F to O is a permutation of Paulis, so for each O, there is some F.</p>
<p>But we need for which F, O is in {I, Z0, Z3, Z0 Z3}</p>
<p>From above, when F=X0 X3, O=Z0</p>
<p>When F=Z0 Z3, O=Z3</p>
<p>Now what about when O=I? For example, if F=I, then CNOT03^\dagger I CNOT03=I, then O= H0^\dagger I H0=I, so O=I, good.</p>
<p>But F=I is identity, but in error channel, F is non-identity for error, but when no error, we already handled, so for error F, F is non-identity, so we need non-identity F such that O is in {I, Z0, Z3, Z0 Z3}</p>
<p>But O=I corresponds to F such that H0^\dagger CNOT03^\dagger F CNOT03 H0 = I, so CNOT03^\dagger F CNOT03 = H0 I H0^\dagger = I, so F=I, but F=I is identity, not non-identity.</p>
<p>So for non-identity F, O cannot be I.</p>
<p>Similarly, O=Z0, from above, when F=X0 X3, O=Z0</p>
<p>O=Z3, when F=Z0 Z3, O=Z3</p>
<p>O=Z0 Z3, when is O=Z0 Z3?</p>
<p>For example, if F= X3 Z0? Let&rsquo;s find.</p>
<p>Suppose we want O=Z0 Z3</p>
<p>Then H0^\dagger CNOT03^\dagger F CNOT03 H0 = Z0 Z3</p>
<p>So CNOT03^\dagger F CNOT03 = H0 Z0 Z3 H0^\dagger = H0 Z0 H0^\dagger H0 Z3 H0^\dagger = X0 Z3</p>
<p>So CNOT03^\dagger F CNOT03 = X0 Z3</p>
<p>Thus F = CNOT03 X0 Z3 CNOT03^\dagger</p>
<p>Now CNOT03 X0 Z3 CNOT03^\dagger = CNOT03 X0 CNOT03^\dagger CNOT03 Z3 CNOT03^\dagger</p>
<p>CNOT03 X0 CNOT03^\dagger = since CNOT03^\dagger X0 CNOT03 = X0 X3, so CNOT03 X0 CNOT03^\dagger = X0 X3? Let&rsquo;s see.</p>
<p>From earlier, CNOT03^\dagger X0 CNOT03 = X0 X3, so by multiplying on left by CNOT03 and on right by CNOT03^\dagger, CNOT03 CNOT03^\dagger X0 CNOT03 CNOT03^\dagger = CNOT03 (X0 X3) CNOT03^\dagger, so X0 = CNOT03 X0 X3 CNOT03^\dagger</p>
<p>Similarly, CNOT03^\dagger Z3 CNOT03 = Z0 Z3, so Z3 = CNOT03 Z0 Z3 CNOT03^\dagger</p>
<p>So for CNOT03 X0 Z3 CNOT03^\dagger = [CNOT03 X0 CNOT03^\dagger] [CNOT03 Z3 CNOT03^\dagger] = [ X0 X3 ] [ Z0 Z3 ] from above? From X0 = CNOT03 X0 X3 CNOT03^\dagger, so CNOT03 X0 CNOT03^\dagger = X0 X3? Let&rsquo;s solve.</p>
<p>From CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>So by taking dagger, (CNOT03^\dagger X0 CNOT03)^\dagger = (X0 X3)^\dagger, so CNOT03^\dagger X0 CNOT03 = X0 X3 since Pauli self-adjoint.</p>
<p>So from this, we have CNOT03^\dagger X0 CNOT03 = X0 X3</p>
<p>Then multiply on left by CNOT03, CNOT03 CNOT03^\dagger X0 CNOT03 = CNOT03 X0 X3</p>
<p>So X0 CNOT03 = CNOT03 X0 X3</p>
<p>Thus CNOT03 X0 = X0 X3 CNOT03</p>
<p>So CNOT03 X0 CNOT03^\dagger = X0 X3 CNOT03 CNOT03^\dagger = X0 X3</p>
<p>Similarly, from CNOT03^\dagger Z3 CNOT03 = Z0 Z3</p>
<p>Then CNOT03 Z3 CNOT03^\dagger = Z0 Z3 CNOT03 CNOT03^\dagger = Z0 Z3</p>
<p>So back to CNOT03 X0 Z3 CNOT03^\dagger = [CNOT03 X0 CNOT03^\dagger] [CNOT03 Z3 CNOT03^\dagger] = (X0 X3) (Z0 Z3) = X0 Z0 X3 Z3</p>
<p>So F = X0 Z0 X3 Z3</p>
<p>But X0 Z0 X3 Z3 is a Pauli operator, and it is non-identity.</p>
<p>Then O = H0^\dagger CNOT03^\dagger F CNOT03 H0 = from above, we wanted O=Z0 Z3, and we have it.</p>
<p>So for F = X0 Z0 X3 Z3, O=Z0 Z3</p>
<p>Similarly, for other desired O.</p>
<p>But for our purpose, we need when O is in {I, Z0, Z3, Z0 Z3} for non-identity F.</p>
<p>From above, for F=X0 X3, O=Z0</p>
<p>For F=Z0 Z3, O=Z3</p>
<p>For F=X0 Z0 X3 Z3, O=Z0 Z3</p>
<p>Are there other F? For example, if F= something that gives O=Z0, but from above, when F=X0 X3, O=Z0</p>
<p>Similarly, if F=Y0 Y3, let&rsquo;s compute.</p>
<p>F=Y0 Y3 = i X0 Z0 i X3 Z3 = - X0 X3 Z0 Z3</p>
<p>Then CNOT03^\dagger F CNOT03 = CNOT03^\dagger (- X0 X3 Z0 Z3) CNOT03 = - [CNOT03^\dagger X0 X3 CNOT03] [CNOT03^\dagger Z0 Z3 CNOT03] because Z0 Z3 commutes with CNOT03? Not necessarily, but since CNOT03^\dagger (AB) CNOT03 = (CNOT03^\dagger A CNOT03) (CNOT03^\dagger B CNOT03) if A and B commute with CNOT03? But better to compute separately.</p>
<p>CNOT03^\dagger X0 X3 CNOT03 = from earlier, for X0 X3, we had CNOT03^\dagger X0 X3 CNOT03 = X0 as above</p>
<p>CNOT03^\dagger Z0 Z3 CNOT03 = CNOT03^\dagger Z0 CNOT03 CNOT03^\dagger Z3 CNOT03 = Z0 * (Z0 Z3) = Z0 Z0 Z3 = Z3</p>
<p>So CNOT03^\dagger F CNOT03 = - X0 Z3</p>
<p>Then O = H0^\dagger (- X0 Z3) H0 = - H0^\dagger X0 H0 H0^\dagger Z3 H0 = - Z0 X3</p>
<p>So O = - Z0 X3, which has X3, so not good.</p>
<p>So for non-identity F, the only F that give O in {Z0, Z3, Z0 Z3} are F=X0 X3, F=Z0 Z3, and F=X0 Z0 X3 Z3.</p>
<p>But F=X0 Z0 X3 Z3 is the same as - Y0 Y3 up to phase, but as operator, it is applied.</p>
<p>So there are 3 non-identity F that make O good.</p>
<p>Now, back to case 2 with F error.</p>
<p>The fidelity is 1 only if E is good (one of X1 X2, Z1 Z2, Y1 Y2) and F is good (one of X0 X3, Z0 Z3, X0 Z0 X3 Z3)</p>
<p>Otherwise, fidelity 0.</p>
<p>Now, for case 2, we have probability for error E after CNOT21, and error F after CNOT03.</p>
<p>But in case 2, when we have error E after CNOT21, then with probability 1-p, no error after CNOT03, so fidelity depends only on E, and is 1 if E good, else 0.</p>
<p>With probability p, error F after CNOT03, so fidelity is 1 only if both E and F good, else 0.</p>
<p>Now, the probability that E is good: there are 15 non-identity Paulis on {1,2}, and 3 of them are good, so prob E good is 3/15 = 1/5</p>
<p>Similarly for F, prob F good is 3/15 = 1/5</p>
<p>Now, for case 2, which happens with probability p for error after CNOT21, and for each E, but since we average, the contribution from case 2 to fidelity is:</p>
<p>When no error after CNOT03: prob (1-p) times fidelity which is 1 if E good, else 0, so average over E: (1-p) * (1/5) <em>1 + (1-p) * (4/5) </em>0 = (1-p)/5</p>
<p>When error after CNOT03: prob p times, and fidelity is 1 only if both E and F good, so average over E and F: p * (1/5) * (1/5) *1 = p/25</p>
<p>So for case 2, the average fidelity is (1-p)/5 + p/25</p>
<p>Now, recall case 1: no error after CNOT21, which has probability (1-p), and average fidelity 1 - (4/5)p as earlier.</p>
<p>Now, the overall fidelity is the average over both error locations.</p>
<p>So total fidelity F = probability case 1 * fidelity case 1 + probability case 2 * fidelity case 2</p>
<p>Probability case 1: no error after CNOT21, prob = 1-p</p>
<p>Fidelity case 1: 1 - (4/5)p</p>
<p>Probability case 2: error after CNOT21, prob = p</p>
<p>Fidelity case 2: (1-p)/5 + p/25</p>
<p>So F = (1-p) [1 - (4/5)p] + p [ (1-p)/5 + p/25 ]</p>
<p>Now simplify this expression.</p>
<p>First, (1-p) [1 - (4/5)p] = (1-p) (1 - 0.8p) = 1 - 0.8p - p + 0.8p^2 = 1 - 1.8p + 0.8p^2</p>
<p>Better to use fractions: (1-p) (1 - 4p/5) = 1 - 4p/5 - p + 4p^2/5 = 1 - (4/5)p - (5/5)p + (4/5)p^2 = 1 - (9/5)p + (4/5)p^2</p>
<p>Now second part: p [ (1-p)/5 + p/25 ] = p [ (1-p)/5 + p/25 ] = p [ (5(1-p) + p)/25 ] = p [ (5 -5p + p)/25 ] = p (5 -4p)/25 = (5p -4p^2)/25</p>
<p>So total F = [1 - (9/5)p + (4/5)p^2] + [ (5p -4p^2)/25 ]</p>
<p>Now get common denominator, which is 25.</p>
<p>First term: 1 - (9/5)p + (4/5)p^2 = 25/25 - (45/25)p + (20/25)p^2</p>
<p>Second term: (5p -4p^2)/25</p>
<p>So F = [25 -45p +20p^2 +5p -4p^2]/25 = [25 -40p +16p^2]/25</p>
<p>So F = 1 - (40/25)p + (16/25)p^2 = 1 - (8/5)p + (16/25)p^2</p>
<p>Now, this is the physical state fidelity.</p>
<p>But is this correct? Let me verify.</p>
<p>When p=0, no errors, F=1, good.</p>
<p>When p=1, always errors, but let&rsquo;s see.</p>
<p>But for small p, we have F ≈ 1 - (8/5)p</p>
<p>Now, the problem asks for physical state fidelity as a function of p.</p>
<p>So perhaps this is the answer.</p>
<p>But let me confirm if I missed something.</p>
<p>In the circuit, there are two CNOT gates, each with error probability p, so yes.</p>
<p>And I think I covered all cases.</p>
<p>So the fidelity is F = 1 - \frac{8}{5} p + \frac{16}{25} p^2</p>
<p>But since p is small, we often keep up to linear terms, but here we have exact.</p>
<p>Now, for the final answer, I think we need to box it.</p>
<p>But let me write it neatly.</p>
<p>So the physical state fidelity is</p>
<div class="arithmatex">\[
F = 1 - \frac{8}{5} p + \frac{16}{25} p^2
\]</div>
<p>We can write as</p>
<div class="arithmatex">\[
F = \frac{25 - 40p + 16p^2}{25}
\]</div>
<p>But either way.</p>
<p>Now, for the output, I need to present it.</p>
<p>So finally.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p>The goal is to find the physical state fidelity of the final 4-qubit state after applying the circuit <span class="arithmatex">\( \text{CNOT}_{03} H_0 \text{CNOT}_{21} H_2 \)</span> (operations applied from right to left) with initial state <span class="arithmatex">\( |0000\rangle \)</span>, where each CNOT gate is followed by a two-qubit depolarizing error channel with error probability <span class="arithmatex">\( p \)</span>. The error channel applies one of the 15 non-identity two-qubit Pauli operators with probability <span class="arithmatex">\( p/15 \)</span> each. The Hadamard gates are perfect.</p>
<h4 id="ideal-state-preparation">Ideal State Preparation</h4>
<ol>
<li>Apply <span class="arithmatex">\( H_2 \)</span> to <span class="arithmatex">\( |0000\rangle \)</span>:</li>
</ol>
<div class="arithmatex">\[
   H_2 |0000\rangle = \frac{1}{\sqrt{2}} (|0000\rangle + |0010\rangle)
\]</div>
<ol start="2">
<li>Apply <span class="arithmatex">\( \text{CNOT}_{21} \)</span> (control qubit 2, target qubit 1):</li>
</ol>
<div class="arithmatex">\[
   \text{CNOT}_{21} \left( \frac{1}{\sqrt{2}} (|0000\rangle + |0010\rangle) \right) = \frac{1}{\sqrt{2}} (|0000\rangle + |0110\rangle)
\]</div>
<ol start="3">
<li>Apply <span class="arithmatex">\( H_0 \)</span>:</li>
</ol>
<div class="arithmatex">\[
   H_0 \left( \frac{1}{\sqrt{2}} (|0000\rangle + |0110\rangle) \right) = \frac{1}{2} (|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)
\]</div>
<ol start="4">
<li>Apply <span class="arithmatex">\( \text{CNOT}_{03} \)</span> (control qubit 0, target qubit 3):</li>
</ol>
<div class="arithmatex">\[
   \text{CNOT}_{03} \left( \frac{1}{2} (|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle) \right) = \frac{1}{2} (|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<p>Thus, the ideal final state is:</p>
<div class="arithmatex">\[
   |\psi_{\text{ideal}}\rangle = \frac{1}{2} (|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<h4 id="error-model">Error Model</h4>
<p>Each CNOT gate is followed by a depolarizing error channel:
- After <span class="arithmatex">\( \text{CNOT}_{21} \)</span>, with probability <span class="arithmatex">\( 1-p \)</span>, no error; with probability <span class="arithmatex">\( p \)</span>, a Pauli error <span class="arithmatex">\( E \)</span> on qubits {1,2} is applied (each of the 15 non-identity Paulis with probability <span class="arithmatex">\( p/15 \)</span>).
- After <span class="arithmatex">\( \text{CNOT}_{03} \)</span>, with probability <span class="arithmatex">\( 1-p \)</span>, no error; with probability <span class="arithmatex">\( p \)</span>, a Pauli error <span class="arithmatex">\( F \)</span> on qubits {0,3} is applied (each with probability <span class="arithmatex">\( p/15 \)</span>).</p>
<p>The fidelity between the ideal pure state <span class="arithmatex">\( |\psi_{\text{ideal}}\rangle \)</span> and the actual mixed state <span class="arithmatex">\( \rho \)</span> is <span class="arithmatex">\( F = \langle \psi_{\text{ideal}} | \rho | \psi_{\text{ideal}} \rangle \)</span>.</p>
<h4 id="case-analysis">Case Analysis</h4>
<ul>
<li><strong>Case 1: No error after <span class="arithmatex">\( \text{CNOT}_{21} \)</span></strong></li>
<li>Probability: <span class="arithmatex">\( 1-p \)</span></li>
<li>After <span class="arithmatex">\( \text{CNOT}_{03} \)</span>, the state is <span class="arithmatex">\( |\psi_{\text{ideal}}\rangle \)</span>.</li>
<li>After error channel for <span class="arithmatex">\( \text{CNOT}_{03} \)</span>:<ul>
<li>With probability <span class="arithmatex">\( 1-p \)</span>, no error, fidelity = 1.</li>
<li>With probability <span class="arithmatex">\( p \)</span>, error <span class="arithmatex">\( F \)</span> on {0,3}:</li>
<li>For <span class="arithmatex">\( F \)</span> such that <span class="arithmatex">\( \langle \psi_{\text{ideal}} | F | \psi_{\text{ideal}} \rangle \neq 0 \)</span>, fidelity = 1; otherwise, 0.</li>
<li>From analysis, only 3 of the 15 non-identity Paulis on {0,3} yield fidelity 1: <span class="arithmatex">\( X_0 X_3 \)</span>, <span class="arithmatex">\( Z_0 Z_3 \)</span>, <span class="arithmatex">\( Y_0 Y_3 \)</span>.</li>
</ul>
</li>
<li>Average fidelity for Case 1:</li>
</ul>
<div class="arithmatex">\[
    F_1 = (1-p) \cdot 1 + p \cdot \frac{3}{15} \cdot 1 = 1 - p + \frac{p}{5} = 1 - \frac{4}{5}p
\]</div>
<ul>
<li><strong>Case 2: Error <span class="arithmatex">\( E \)</span> after <span class="arithmatex">\( \text{CNOT}_{21} \)</span></strong></li>
<li>Probability: <span class="arithmatex">\( p \)</span></li>
<li>After applying <span class="arithmatex">\( E \)</span>, state is <span class="arithmatex">\( E |\psi_2\rangle \)</span>, where <span class="arithmatex">\( |\psi_2\rangle = \frac{1}{\sqrt{2}} (|0000\rangle + |0110\rangle) \)</span>.</li>
<li>Then apply <span class="arithmatex">\( H_0 \)</span> and <span class="arithmatex">\( \text{CNOT}_{03} \)</span> ideally, so state becomes <span class="arithmatex">\( \text{CNOT}_{03} H_0 E |\psi_2\rangle \)</span>.</li>
<li>After error channel for <span class="arithmatex">\( \text{CNOT}_{03} \)</span>:<ul>
<li>With probability <span class="arithmatex">\( 1-p \)</span>, no error, fidelity = <span class="arithmatex">\( |\langle \psi_{\text{ideal}} | \text{CNOT}_{03} H_0 E |\psi_2\rangle |^2 = |\langle \psi_2 | E | \psi_2\rangle |^2 \)</span>.</li>
<li>From analysis, only 3 of the 15 non-identity Paulis on {1,2} yield fidelity 1: <span class="arithmatex">\( X_1 X_2 \)</span>, <span class="arithmatex">\( Z_1 Z_2 \)</span>, <span class="arithmatex">\( Y_1 Y_3 \)</span>.</li>
<li>With probability <span class="arithmatex">\( p \)</span>, error <span class="arithmatex">\( F \)</span> on {0,3}, fidelity = <span class="arithmatex">\( |\langle \psi_2 | H_0^\dagger \text{CNOT}_{03}^\dagger F \text{CNOT}_{03} H_0 E | \psi_2\rangle |^2 \)</span>.</li>
<li>This fidelity is 1 only if both <span class="arithmatex">\( E \)</span> and <span class="arithmatex">\( F \)</span> are &ldquo;good&rdquo; (i.e., from the sets above).</li>
</ul>
</li>
<li>Average fidelity for Case 2:</li>
</ul>
<div class="arithmatex">\[
    F_2 = (1-p) \cdot \frac{3}{15} + p \cdot \frac{3}{15} \cdot \frac{3}{15} = \frac{1-p}{5} + \frac{p}{25}
\]</div>
<h4 id="total-fidelity">Total Fidelity</h4>
<p>The overall fidelity is the weighted sum:</p>
<div class="arithmatex">\[
F = (1-p) F_1 + p F_2 = (1-p) \left(1 - \frac{4}{5}p\right) + p \left( \frac{1-p}{5} + \frac{p}{25} \right)
\]</div>
<p>Simplifying:</p>
<div class="arithmatex">\[
F = (1-p) \left(1 - \frac{4}{5}p\right) + p \left( \frac{5(1-p) + p}{25} \right) = (1-p) \left(1 - \frac{4}{5}p\right) + \frac{p(5 - 4p)}{25}
\]</div>
<div class="arithmatex">\[
= 1 - \frac{4}{5}p - p + \frac{4}{5}p^2 + \frac{5p - 4p^2}{25} = 1 - \frac{9}{5}p + \frac{4}{5}p^2 + \frac{5p - 4p^2}{25}
\]</div>
<p>Using a common denominator of 25:</p>
<div class="arithmatex">\[
F = \frac{25}{25} - \frac{45}{25}p + \frac{20}{25}p^2 + \frac{5p - 4p^2}{25} = \frac{25 - 45p + 20p^2 + 5p - 4p^2}{25} = \frac{25 - 40p + 16p^2}{25}
\]</div>
<p>Thus,</p>
<div class="arithmatex">\[
F = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<p><strong>Final Answer:</strong>  </p>
<div class="arithmatex">\[
F = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate p, assuming the state is post-selected on all detectable errors in the code?&rdquo;</p>
<p>Interpretation: We have the circuit from subproblem 1. But now we post-select on all detectable errors. That means we measure the stabilizers (XXXX and ZZZZ) and only keep outcomes that are +1? But careful: &ldquo;post-selected on all detectable errors&rdquo; means that we detect errors that are not in the stabilizer? Actually, the [[4,2,2]] code is an error detection code. It can detect any single-qubit error? Actually, it&rsquo;s distance 2, so it can detect any single-qubit error. But here errors come from two-qubit depolarizing channels after CNOT gates. So errors might be on two qubits. But post-selection: we measure the stabilizers. If the outcome is not trivial (i.e., not +1 for both stabilizers), then we discard the state. So we only keep states that are in the code space. So we want the fidelity of the logical state conditioned on being in the code space.</p>
<p>So we need to compute: F_logical = probability that the state is the correct logical state given that it is in the code space.</p>
<p>Let&rsquo;s denote: The ideal logical state is |GHZ&gt;_AB = (|00&gt; + |11&gt;)/√2.</p>
<p>The circuit prepares that ideally. With errors, we get a mixed state. But we post-select on the state being in the code space. That means that we measure the stabilizers S1=XXXX and S2=ZZZZ. If we get +1 on both, then we keep the state. Otherwise discard.</p>
<p>So we want: F = &lt;ψ_ideal| ρ_post |ψ_ideal&gt; where ρ_post is the normalized state after post-selection.</p>
<p>So we need to compute the probability that the state is in the code space and the probability that it is the correct state within the code space.</p>
<p>Let&rsquo;s denote the full state after the circuit (with errors) as ρ. Then the post-selected state is: ρ_post = Π ρ Π / Tr(Π ρ) where Π is the projector onto the code space. The code space of [[4,2,2]] is 4-dimensional? Actually, it encodes 2 qubits, so dimension 4. The stabilizers are XXXX and ZZZZ. The code space is the simultaneous +1 eigenspace of these operators.</p>
<p>We want the fidelity: F = &lt;ψ_ideal| ρ_post |ψ_ideal&gt; = Tr( |ψ_ideal&gt;&lt;ψ_ideal| Π ρ Π ) / Tr(Π ρ).</p>
<p>But since |ψ_ideal&gt; is in the code space, we have Π |ψ_ideal&gt; = |ψ_ideal&gt;. So F = &lt;ψ_ideal| ρ |ψ_ideal&gt; / Tr(Π ρ) because |ψ_ideal&gt;&lt;ψ_ideal| commutes with Π? Actually careful: 
Tr( |ψ_ideal&gt;&lt;ψ_ideal| Π ρ Π ) = &lt;ψ_ideal| Π ρ Π |ψ_ideal&gt; = &lt;ψ_ideal| ρ |ψ_ideal&gt; because Π|ψ_ideal&gt;=|ψ_ideal&gt;.
And Tr(Π ρ) is the probability to be in code space.</p>
<p>So F = (Probability that state is ideal and in code space) / (Probability in code space). But note: if there is an error that is detectable, then it will take the state out of the code space. But some errors might be undetectable? Actually, in a distance-2 code, any error of weight 1 is detectable. But errors from two-qubit depolarizing channels can be weight 2 errors. Some weight 2 errors might be in the normalizer of the stabilizer? Actually, the code has distance 2, so there are weight-1 errors that are not detectable? Actually, distance 2 means that no error of weight 1 is correctable, but they are detectable. Actually, for detection, if an error anti-commutes with at least one stabilizer, then it is detectable. For weight-1 errors on qubits, they will anti-commute with either XXXX or ZZZZ? Check: A single X error on one qubit: It will anti-commute with ZZZZ? Actually, ZZZZ commutes with X? No, X and Z anti-commute. So a single X error will anti-commute with ZZZZ. Similarly, a single Z error will anti-commute with XXXX. So all single-qubit errors are detectable. But what about two-qubit errors? They might be undetectable if they are in the stabilizer or logical operators? But careful: The depolarizing errors occur on specific pairs: after CNOT21, errors on qubits {1,2}; after CNOT03, errors on qubits {0,3}. So these errors are on two qubits. They might be detectable or not. We need to check which errors on these pairs commute with both stabilizers.</p>
<p>Let&rsquo;s list the stabilizers: S1 = XXXX, S2 = ZZZZ.
Consider an error E on qubits {1,2}. E is a Pauli operator on qubits 1 and 2 (and identity on 0 and 3). For E to be undetectable, it must commute with both S1 and S2. 
S1 = X0 X1 X2 X3. For E on {1,2} only, it commutes with S1 if and only if E commutes with X1 X2? Actually, careful: E acts on qubits 1 and 2. S1 acts on all qubits. Since E does not act on qubits 0 and 3, the commutativity with S1 is determined by the part on qubits 1 and 2: S1 has X1 X2. So E commutes with S1 if and only if E commutes with X1 X2. Similarly, S2 = Z0 Z1 Z2 Z3, so E commutes with S2 if and only if E commutes with Z1 Z2.
So for E on {1,2} to be in the normalizer of the stabilizer (i.e., not detected), we need E such that [E, X1X2]=0 and [E, Z1Z2]=0.
What are the Paulis on two qubits that commute with both X1X2 and Z1Z2? The group generated by X1X2 and Z1Z2 itself. That group has elements: I, X1X2, Z1Z2, and X1X2 Z1Z2 (which is proportional to Y1Y2). So these 4 operators commute with both. But wait: Check: X1 alone: Does it commute with X1X2? X1 and X1X2: X1 * X1X2 = X2, and X1X2 * X1 = X2, so they commute? Actually, careful: X1 and X1X2: They act on different qubits? Actually, X1 and X1X2: They commute because X1 commutes with X1 and with X2? Actually, X1 and X2 commute. So X1 commutes with X1X2. But does X1 commute with Z1Z2? X1 and Z1Z2: X1 anti-commutes with Z1, so X1 Z1Z2 = - Z1 X1 Z2 = - Z1 Z2 X1? Actually, let&rsquo;s do properly: [X1, Z1Z2] = X1 Z1Z2 - Z1Z2 X1 = (X1 Z1)Z2 - Z1Z2 X1 = (-Z1 X1)Z2 - Z1Z2 X1 = -Z1 X1 Z2 - Z1Z2 X1 = -Z1 (X1 Z2 + Z2 X1) = -Z1 (0) because X1 and Z2 commute? Actually, careful: X1 and Z2: they act on different qubits, so they commute. So X1 Z2 = Z2 X1. So then X1 Z1Z2 = X1 Z1 Z2 = -Z1 X1 Z2 = -Z1 Z2 X1. And Z1Z2 X1 = Z1 Z2 X1. So indeed, X1 anti-commutes with Z1Z2. So X1 does not commute with S2. So indeed, only the operators that are products of X1X2 and Z1Z2 will commute with both. So on qubits {1,2}, the undetectable errors are: I, X1X2, Z1Z2, and X1X2 Z1Z2 (which is equivalent to Y1Y2 up to phase). But note: I is no error. So among non-identity errors on {1,2}, there are 3 that are undetectable: X1X2, Z1Z2, and X1X2 Z1Z2.
But wait: Check: What about Y1 alone? Y1 = i X1 Z1. That will not commute with Z1Z2? Likely not. So yes.</p>
<p>Now similarly, for errors on {0,3} from the second CNOT. For an error F on qubits {0,3}, it will be undetectable if it commutes with S1 and S2. S1 has X0X3, and S2 has Z0Z3. So F must commute with X0X3 and Z0Z3. So the undetectable F are: I, X0X3, Z0Z3, and X0X3 Z0Z3 (which is Y0Y3 up to phase). So among non-identity, there are 3 undetectable errors on {0,3}: X0X3, Z0Z3, and X0X3 Z0Z3.</p>
<p>Now, in our error model, errors occur after each CNOT. So we have two error locations: after CNOT21 and after CNOT03.
Let E be error on {1,2} and F be error on {0,3}. The total error operator is F * E (order: first E then F? Actually, circuit: After CNOT21, error E. Then apply H0 and CNOT03. Then error F. So the overall effect on the state is: final state = F * (CNOT03 H0) * E * (CNOT21 H2) |0000&gt; but with errors. But we already computed the ideal state is |ψ_ideal&gt;. And under errors, the state becomes something like: if errors are Paulis, then the state becomes a Pauli error applied to |ψ_ideal&gt;? But careful: The circuit is Clifford, and the initial state is |0&gt;^4. The entire circuit is a Clifford operation. So the effect of errors in the middle can be translated to Pauli errors on the final state. But careful: The errors occur after gates. But since the gates are Clifford, we can propagate the errors through the subsequent gates. That is a common technique: instead of applying errors after gates, we can push them to the end as Pauli errors on the final state. But note: The errors are applied after specific gates. But we can commute them through the subsequent Clifford gates. So let&rsquo;s do that.</p>
<p>The circuit: H2, then CNOT21, then error E on {1,2}, then H0, then CNOT03, then error F on {0,3}.
We want to know the final state. Instead, we can propagate the errors to the end. That is: We have U = CNOT03 * H0 * CNOT21 * H2. Then with errors, the actual operation is: F * (CNOT03) * (H0) * E * (CNOT21) * (H2). But since E and F are Paulis, we can commute them through the Clifford gates. Let&rsquo;s define: U_ideal = CNOT03 * H0 * CNOT21 * H2.
We want to compute: U_actual = F * CNOT03 * H0 * E * CNOT21 * H2.
But note: E is after CNOT21. So it is: U_actual = F * CNOT03 * H0 * E * CNOT21 * H2.
We can push E through H0 and CNOT03. But careful: E acts on qubits {1,2}. H0 acts on qubit 0 only, so commutes with E. So E commutes with H0. Then we have CNOT03 which acts on qubits {0,3}. Does E commute with CNOT03? E acts on {1,2} and CNOT03 acts on {0,3}, so they commute. So actually, E commutes with H0 and CNOT03. So then U_actual = F * CNOT03 * H0 * CNOT21 * H2 * E = U_ideal * E? But wait: Check order: U_ideal = CNOT03 * H0 * CNOT21 * H2. So indeed, U_actual = F * U_ideal * E. But careful: The order of multiplication: The circuit is applied from right to left. So the actual operation is: F * (CNOT03) * (H0) * (E) * (CNOT21) * (H2). And since E commutes with H0 and CNOT03, we can move E to the right: = F * (CNOT03) * (H0) * (CNOT21) * (H2) * E = F * U_ideal * E. So indeed, the final state (without post-selection) is: |ψ_actual&gt; = F * U_ideal * E |0000&gt; = F * E * U_ideal |0000&gt;? But careful: E and F might not commute? But they act on disjoint sets, so they do commute. So actually, |ψ_actual&gt; = F * E * U_ideal |0000&gt; = F * E |ψ_ideal&gt;. 
But wait: Is that correct? Check: U_ideal |0000&gt; = |ψ_ideal&gt;. And then we apply E and then F. But note: E is applied after CNOT21, but we pushed it through H0 and CNOT03. But since those gates are Clifford and E commutes with them, it becomes E at the end. But careful: When we push an operator through a Clifford gate, it might change into a different Pauli. But here, we checked that E acts on {1,2} and H0 acts on qubit 0, so they commute. And CNOT03 acts on {0,3}, so it commutes with E because E acts on {1,2}. So indeed, E remains unchanged. Similarly, F is applied after CNOT03. But F acts on {0,3}. There is no gate after F, so F stays as is. So indeed, the overall effect is that the final state is F * E |ψ_ideal&gt;, where E is the error on {1,2} and F is the error on {0,3}. But wait: What about the fact that errors occur with probability? Actually, careful: The errors are not deterministic. They occur with probabilities. So the final state is a mixture over different E and F. And the probability for a particular E (non-identity) is p/15, and for no error on that location is (1-p). Similarly for F.
So the density matrix ρ = sum_{E on {1,2}, F on {0,3}} Prob(E) Prob(F) * (F E) |ψ_ideal&gt;&lt;ψ_ideal| (F E)^†.
But note: F and E commute, so it&rsquo;s E F |ψ_ideal&gt;&lt;ψ_ideal| F E.
And Prob(E) = if E=I, probability 1-p; if E ≠ I, probability p/15.
Similarly for F.</p>
<p>So then the state is: ρ = (1-p)^2 |ψ_ideal&gt;&lt;ψ_ideal| 
+ (1-p) * (p/15) sum_{F ≠ I} F |ψ_ideal&gt;&lt;ψ_ideal| F 
+ (p/15)(1-p) sum_{E ≠ I} E |ψ_ideal&gt;&lt;ψ_ideal| E 
+ (p/15)^2 sum_{E ≠ I, F ≠ I} E F |ψ_ideal&gt;&lt;ψ_ideal| F E.</p>
<p>But careful: The errors E and F are applied independently. So that is correct.</p>
<p>Now, we want to post-select on the state being in the code space. That means we only keep states that are eigenvectors of S1 and S2 with eigenvalue +1. That is, we want the state to be in the code space. The code space is the space where S1=+1 and S2=+1. 
Now, what are the conditions for E F |ψ_ideal&gt; to be in the code space? Since |ψ_ideal&gt; is in the code space, applying a Pauli operator will take it to another state. That state will be in the code space if and only if that Pauli operator is in the normalizer of the stabilizer. Because if G is in the normalizer, then G maps the code space to itself. But careful: The code space is the +1 eigenspace of S1 and S2. If G commutes with S1 and S2, then G |ψ&gt; is also +1 eigenvector if |ψ&gt; is. So indeed, E F will keep the state in the code space if and only if E F is in the normalizer of the stabilizer. But note: E acts on {1,2} and F acts on {0,3}. So E F is in the normalizer if and only if E is in the normalizer on {1,2} and F is in the normalizer on {0,3}? Actually, careful: The normalizer of the stabilizer for the entire code is the set of Paulis that commute with S1 and S2. Since E and F act on disjoint sets, E F commutes with S1 if and only if E commutes with the part on {1,2} and F commutes with the part on {0,3}? Actually, S1 = X0 X1 X2 X3. E acts on {1,2} and F acts on {0,3}. So [E F, S1] = 0 if and only if [E, X1X2]=0 and [F, X0X3]=0. Similarly for S2. So indeed, E F is in the normalizer if and only if E is in the set of Paulis on {1,2} that commute with X1X2 and Z1Z2, and F is in the set of Paulis on {0,3} that commute with X0X3 and Z0Z3. And as we determined, those sets are: For {1,2}: {I, X1X2, Z1Z2, X1X2 Z1Z2} (4 elements). For {0,3}: {I, X0X3, Z0Z3, X0X3 Z0Z3} (4 elements).</p>
<p>So, the state will be in the code space if and only if E is one of these 4 and F is one of these 4. But note: E and F are chosen from the set of all Paulis on their respective pairs. But our error model: E is on {1,2} and F on {0,3}. And the probabilities: For E: P(E=I) = 1-p, and for E being one of the other 15, each with p/15. But among those 15, how many are in the normalizer? There are 3: X1X2, Z1Z2, and X1X2 Z1Z2. Similarly for F: 3 normalizer elements among non-identity.
So, the probability that the state is in the code space is: 
P(code) = [Probability that E is in normalizer] * [Probability that F is in normalizer] because they are independent.
Probability that E is in normalizer = P(E=I) + P(E is one of the 3) = (1-p) + 3*(p/15) = 1-p + p/5 = 1 - (4/5)p.
Similarly for F: 1 - (4/5)p.
So P(code) = [1 - (4/5)p]^2.</p>
<p>Now, within the code space, what is the state? If E and F are both in the normalizer, then E F |ψ_ideal&gt; is in the code space. But note: The normalizer of the stabilizer includes the stabilizers themselves and the logical operators. But here, |ψ_ideal&gt; is a specific logical state. The normalizer elements that are not in the stabilizer will act as logical operators on the logical qubits. So we need to determine the logical effect of these normalizer elements on the logical state.
We have the logical operators given: 
X_A = XIXI, X_B = XXII, Z_A = ZZII, Z_B = ZIZI.
But our errors are on specific qubits: E on {1,2} and F on {0,3}. Let&rsquo;s list the normalizer elements on {1,2}:
N_E: I, X1X2, Z1Z2, X1X2 Z1Z2.
And on {0,3}:
N_F: I, X0X3, Z0Z3, X0X3 Z0Z3.</p>
<p>Now, how do these act on the logical state? We need to see what logical operation they correspond to. But careful: The state |ψ_ideal&gt; is the logical GHZ state: (|00&gt;_AB + |11&gt;_AB)/√2.
We need to know the action of these Paulis on the logical state. But note: These Paulis are in the normalizer, so they map the code space to itself. They can be represented as logical operators (possibly with a phase) on the logical qubits. So we need to compute: For each combination of E and F that are in the normalizer, what is E F |ψ_ideal&gt;? And is it the same as |ψ_ideal&gt; up to a phase? Or does it change the logical state?</p>
<p>Let&rsquo;s determine the logical effect of these operators. We have the code [[4,2,2]]. The logical operators are given. But we need to express our errors in terms of the logical operators and stabilizers.
First, consider errors on {1,2}. 
Take E = X1X2. What is its effect on the logical state? 
We know the logical operators: X_A = X0 I X2 I? Actually, X_A = XIXI means: on qubit 0: X, qubit 1: I, qubit 2: X, qubit 3: I? That pattern: XIXI: positions: 0: X, 1: I, 2: X, 3: I. But wait: The problem says: &ldquo;X_A = XIXI&rdquo;. That likely means: qubit0: X, qubit1: I, qubit2: X, qubit3: I. But then X_B = XXII: qubit0: X, qubit1: X, qubit2: I, qubit3: I.
And Z_A = ZZII: qubit0: Z, qubit1: Z, qubit2: I, qubit3: I.
Z_B = ZIZI: qubit0: Z, qubit1: I, qubit2: Z, qubit3: I.
But our errors: E on {1,2} means qubits 1 and 2. So X1X2: that is on qubit1 and qubit2. Compare with logical operators: X_A involves qubit0 and qubit2. X_B involves qubit0 and qubit1. So X1X2 is not exactly a logical operator? But it is in the normalizer. It must be equivalent to some product of logical operators and stabilizers. Let&rsquo;s find: 
We have stabilizers: S1 = X0X1X2X3, S2 = Z0Z1Z2Z3.
We want to see what X1X2 is. Multiply X1X2 by S1? S1 = X0X1X2X3. So S1 * (X1X2) = X0 X1^2 X2^2 X3 = X0 X3. That is not a logical operator? Alternatively, maybe we can determine the action on the logical state by computing the expectation or something. But maybe we can compute directly on |ψ_ideal&gt;. 
|ψ_ideal&gt; = 1/2 (|0000&gt; + |1001&gt; + |0110&gt; + |1111&gt;). 
Apply X1X2 to |ψ_ideal&gt;. 
X1X2 |0000&gt; = |0110&gt;? Because flip qubit1 and qubit2: |0000&gt; -&gt; |0110&gt;.
X1X2 |1001&gt; = |1111&gt;? Because |1001&gt; -&gt; flip qubit1 and qubit2: qubit1=0-&gt;1, qubit2=0-&gt;1, so becomes |1111&gt;.
X1X2 |0110&gt; = |0000&gt;.
X1X2 |1111&gt; = |1001&gt;.
So X1X2 |ψ_ideal&gt; = 1/2 (|0110&gt; + |1111&gt; + |0000&gt; + |1001&gt;) = |ψ_ideal&gt;. So X1X2 acts as identity on |ψ_ideal&gt;? But wait, check phases: All are positive. So indeed, X1X2 |ψ_ideal&gt; = |ψ_ideal&gt;. So that error does not change the logical state.
Next, E = Z1Z2. 
Z1Z2 |0000&gt; = |0000&gt; (since qubit1=0, qubit2=0, so phase +1)
Z1Z2 |1001&gt; = |1001&gt;? Check: |1001&gt;: qubit1=0, qubit2=0? Actually, |1001&gt;: qubit0=1, qubit1=0, qubit2=0, qubit3=1. So Z1 and Z2 give +1. So remains.
Z1Z2 |0110&gt; = (-1)<em>(-1)|0110&gt; = |0110&gt;? Actually, careful: |0110&gt;: qubit1=1, qubit2=1, so Z1 gives -1, Z2 gives -1, product +1. So remains.
Z1Z2 |1111&gt; = (-1)</em>(-1)|1111&gt; = |1111&gt;.
So Z1Z2 |ψ_ideal&gt; = |ψ_ideal&gt;. So that also acts as identity.
Next, E = X1X2 Z1Z2. But note: X1X2 Z1Z2 = (X1Z1)(X2Z2) = (i Y1)(i Y2) = - Y1 Y2. But let&rsquo;s compute directly:
X1X2 Z1Z2 |0000&gt; = X1X2 (|0000&gt;) = |0110&gt; as before? But careful: Z1Z2 first: Z1Z2 |0000&gt; = |0000&gt;, then X1X2 gives |0110&gt;.
X1X2 Z1Z2 |1001&gt; = X1X2 |1001&gt; = |1111&gt;.
X1X2 Z1Z2 |0110&gt; = X1X2 (Z1Z2 |0110&gt;) = X1X2 (|0110&gt;) because Z1Z2 gives +1? Actually, check: |0110&gt;: qubit1=1, qubit2=1, so Z1 gives -1, Z2 gives -1, product +1. So then X1X2 gives |0000&gt;.
X1X2 Z1Z2 |1111&gt; = X1X2 (Z1Z2 |1111&gt;) = X1X2 (|1111&gt;) because qubit1=1, qubit2=1 so product +1? Actually, careful: |1111&gt;: qubit1=1, qubit2=1, so Z1 gives -1, Z2 gives -1, product +1. Then X1X2 gives |1001&gt;.
So indeed, X1X2 Z1Z2 |ψ_ideal&gt; = 1/2 (|0110&gt;+|1111&gt;+|0000&gt;+|1001&gt;) = |ψ_ideal&gt;. So all errors on {1,2} that are in the normalizer actually act as identity on |ψ_ideal&gt;? That is interesting. But wait: Could it be that these errors are actually stabilizers? Check: X1X2 is not a stabilizer because the stabilizers are XXXX and ZZZZ. X1X2 is not a multiple of those. But it might be that on the code space, X1X2 acts as identity? Let&rsquo;s check: The code space is 4-dimensional. The stabilizers generate a group of order 4. The normalizer modulo the stabilizer gives the logical group of order 16 for 2 qubits. So there should be logical operators that are not identity. But maybe on the particular state |ψ_ideal&gt;, these operators act as identity? That is possible if |ψ_ideal&gt; is a eigenstate of those logical operators with eigenvalue 1. But |ψ_ideal&gt; is the GHZ state for two qubits: (|00&gt;+|11&gt;)/√2. That state is not invariant under all logical operators. For example, logical X on one qubit would change it to (|10&gt;+|01&gt;)/√2. So there are logical operators that change it. So why do these errors on {1,2} seem to act as identity? Let&rsquo;s check: Consider the logical operator X_A. X_A = XIXI. That means apply X on qubit0 and qubit2. So if we apply X_A to |ψ_ideal&gt;, what happens?
X_A |0000&gt; = |1010&gt;? But wait, |ψ_ideal&gt; is: |0000&gt;, |1001&gt;, |0110&gt;, |1111&gt;. 
X_A applied: 
X_A |0000&gt; = X0 X2 |0000&gt; = |1010&gt; but that is not in the set? So maybe |1010&gt; is not in the code space? Actually, the code space is not spanned by these four states? They are a basis? Actually, the code space is 4-dimensional. The state |ψ_ideal&gt; is one state in the code space. The logical operators should map the code space to itself. So X_A should map |ψ_ideal&gt; to some other state in the code space. Let&rsquo;s find the code space explicitly. The stabilizers are XXXX and ZZZZ. The code space is the common +1 eigenspace. A basis for the code space can be taken as the simultaneous eigenvectors of logical operators. Often, the logical states are defined by: 
|00&gt;_L = (|0000&gt;+|1111&gt;)/√2? But our |ψ_ideal&gt; is different: it is (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;)/2. That is actually (|00&gt;_L + |11&gt;_L)/√2? Because if |00&gt;_L = (|0000&gt;+|1111&gt;)/√2 and |11&gt;_L = (|1001&gt;+|0110&gt;)/√2, then indeed (|00&gt;_L+|11&gt;_L)/√2 = 1/√2 * (1/√2(|0000&gt;+|1111&gt;) + 1/√2(|1001&gt;+|0110&gt;)) = 1/2 (|0000&gt;+|1111&gt;+|1001&gt;+|0110&gt;). So yes, |ψ_ideal&gt; = (|00&gt;_L + |11&gt;_L)/√2. So that is the GHZ state.
Now, what are the logical operators? We have: 
X_A = XIXI. Let&rsquo;s compute X_A on |00&gt;_L. 
|00&gt;_L = (|0000&gt;+|1111&gt;)/√2.
X_A |00&gt;_L = (X0 X2) (|0000&gt;+|1111&gt;)/√2 = (|1010&gt;+|0101&gt;)/√2. That is likely |11&gt;_L? Because |11&gt;_L = (|1001&gt;+|0110&gt;)/√2. So not exactly. So maybe our identification of logical states is different. We need to determine the logical operators properly from the given: 
X_A = XIXI, X_B = XXII, Z_A = ZZII, Z_B = ZIZI.
We want to find a basis for the code space that are eigenstates of Z_A and Z_B. 
Z_A = ZZII. So it acts on qubits 0 and 1. So its eigenvalues: +1 if qubits 0 and 1 are same? Actually, Z on |0&gt; gives +1, on |1&gt; gives -1. So Z_A = Z0 Z1. So +1 if Z0 Z1 = +1, i.e., both 0 or both 1? Actually, careful: Z0 Z1 |00&gt; = |00&gt;, so eigenvalue +1. Z0 Z1 |11&gt; = |11&gt;, so eigenvalue +1. Z0 Z1 |01&gt; = -|01&gt;, so eigenvalue -1. Z0 Z1 |10&gt; = -|10&gt;, so eigenvalue -1. So Z_A has eigenvalue +1 for states where qubits 0 and 1 are equal, and -1 for states where they are different.
Z_B = ZIZI = Z0 Z2? Because qubit0 and qubit2. So similarly, Z_B has eigenvalue +1 if qubit0 and qubit2 are same, and -1 if different.
Now, the code space is the intersection of +1 eigenspace of XXXX and ZZZZ. Let&rsquo;s find a basis. The stabilizers: S1=XXXX, S2=ZZZZ.
We want states that are +1 for both. Consider the state |0000&gt;. S1|0000&gt;=|1111&gt;, so not eigenvector. So we need superpositions.
A common basis for the [[4,2,2]] code is: 
|00&gt;_L = (|0000&gt;+|1111&gt;)/√2,
|01&gt;_L = (|1100&gt;+|0011&gt;)/√2,
|10&gt;_L = (|1010&gt;+|0101&gt;)/√2,
|11&gt;_L = (|1001&gt;+|0110&gt;)/√2.
Check S1: XXXX applied to these gives them back? For |00&gt;_L, XXXX(|0000&gt;+|1111&gt;)=|1111&gt;+|0000&gt;, so yes.
S2: ZZZZ gives: for |0000&gt;, phase +1; for |1111&gt;, phase (-1)^4=+1, so okay.
Now, what are the logical Z operators? 
Z_A = ZZII. On |00&gt;_L, Z_A = Z0Z1. For |0000&gt;, Z0Z1 gives +1; for |1111&gt;, Z0Z1 gives (+1)<em>(+1)? Actually, careful: |1111&gt;: Z0 gives -1, Z1 gives -1, product +1. So Z_A|00&gt;_L = |00&gt;_L. So |00&gt;_L is eigenvalue +1 for Z_A.
Z_B = ZIZI = Z0Z2. On |00&gt;_L, |0000&gt;: Z0Z2=+1; |1111&gt;: Z0Z2=(-1)</em>(-1)=+1. So |00&gt;_L is eigenvalue +1 for Z_B as well. So |00&gt;_L corresponds to logical |00&gt;.
Now, |11&gt;_L = (|1001&gt;+|0110&gt;)/√2. Check Z_A: On |1001&gt;, Z0Z1: Z0 on qubit0=1 gives -1, Z1 on qubit1=0 gives +1, so product -1. On |0110&gt;, Z0 on 0=0 gives +1, Z1 on 1=1 gives -1, product -1. So Z_A|11&gt;_L = -|11&gt;_L. So logical value for Z_A is -1.
Z_B: On |1001&gt;, Z0Z2: qubit0=1 -&gt; -1, qubit2=0 -&gt; +1, product -1. On |0110&gt;, qubit0=0 -&gt; +1, qubit2=1 -&gt; -1, product -1. So Z_B|11&gt;_L = -|11&gt;_L. So |11&gt;_L is logical |11&gt;.
So then our |ψ_ideal&gt; = (|0000&gt;+|1001&gt;+|0110&gt;+|1111&gt;)/2. That is actually (|00&gt;_L + |11&gt;_L)/√2? Because |00&gt;_L = (|0000&gt;+|1111&gt;)/√2, and |11&gt;_L = (|1001&gt;+|0110&gt;)/√2. So yes, |ψ_ideal&gt; = (|00&gt;_L + |11&gt;_L)/√2. So that is the GHZ state for logical qubits.</p>
<p>Now, let&rsquo;s determine the effect of the normalizer errors on this state.
We are interested in errors on {1,2} that are in the normalizer: 
E can be: I, X1X2, Z1Z2, X1X2 Z1Z2.
We already computed on the physical state |ψ_ideal&gt; that all these seem to give back |ψ_ideal&gt; itself. But wait, check carefully: 
For E = X1X2, we computed: 
X1X2 |0000&gt; = |0110&gt; 
X1X2 |1001&gt; = |1111&gt;
X1X2 |0110&gt; = |0000&gt;
X1X2 |1111&gt; = |1001&gt;
So indeed, X1X2 permutes the terms: it sends |0000&gt; to |0110&gt; and |1111&gt; to |1001&gt;. So the state becomes: 1/2 (|0110&gt;+|1111&gt;+|0000&gt;+|1001&gt;) which is the same set. So yes, X1X2 |ψ_ideal&gt; = |ψ_ideal&gt;.
For E = Z1Z2, we computed that it gives phase +1 on each term? Check: 
|0000&gt;: Z1Z2 gives +1.
|1001&gt;: qubit1=0, qubit2=0 -&gt; +1.
|0110&gt;: qubit1=1, qubit2=1 -&gt; (-1)<em>(-1)=+1.
|1111&gt;: qubit1=1, qubit2=1 -&gt; +1.
So Z1Z2 |ψ_ideal&gt; = |ψ_ideal&gt;.
For E = X1X2 Z1Z2, we computed that it also gives the same permutation as X1X2? Actually, careful: X1X2 Z1Z2 = (X1Z1)(X2Z2) = (iY1)(iY2) = -Y1Y2. But when applied to |0000&gt;, we get: first Z1Z2 gives +1, then X1X2 gives |0110&gt;. So it gives |0110&gt;. Similarly, on |1001&gt;, gives |1111&gt;; on |0110&gt;, gives |0000&gt;; on |1111&gt;, gives |1001&gt;. So it is the same as X1X2? But wait, there might be phases? Check: On |0110&gt;, Z1Z2: qubit1=1, qubit2=1 gives (-1)</em>(-1)=+1, then X1X2 gives |0000&gt;. So no phase. So indeed, X1X2 Z1Z2 |ψ_ideal&gt; = |ψ_ideal&gt;. So all errors on {1,2} that are in the normalizer act as identity on |ψ_ideal&gt;. </p>
<p>Now consider errors on {0,3} that are in the normalizer: 
F can be: I, X0X3, Z0Z3, X0X3 Z0Z3.
Let&rsquo;s compute these on |ψ_ideal&gt;.
F = X0X3:
X0X3 |0000&gt; = |1001&gt; 
X0X3 |1001&gt; = |0000&gt;
X0X3 |0110&gt; = |1111&gt;? Check: |0110&gt;: qubit0=0-&gt;1, qubit3=0-&gt;1, so becomes |1111&gt;.
X0X3 |1111&gt; = |0110&gt;
So X0X3 |ψ_ideal&gt; = 1/2 (|1001&gt;+|0000&gt;+|1111&gt;+|0110&gt;) = |ψ_ideal&gt;. So identity.
F = Z0Z3:
Z0Z3 |0000&gt; = |0000&gt; (+1)
Z0Z3 |1001&gt; = (-1)<em>(-1)|1001&gt; = |1001&gt;? Check: |1001&gt;: qubit0=1 -&gt; -1, qubit3=1 -&gt; -1, product +1.
Z0Z3 |0110&gt; = |0110&gt; (qubit0=0: +1, qubit3=0: +1)
Z0Z3 |1111&gt; = (-1)</em>(-1)|1111&gt; = |1111&gt;
So Z0Z3 |ψ_ideal&gt; = |ψ_ideal&gt;.
F = X0X3 Z0Z3:
This is similar to before, likely gives identity as well. Check: 
X0X3 Z0Z3 |0000&gt; = X0X3 |0000&gt; = |1001&gt;
|1001&gt; -&gt; Z0Z3 gives (+1)? Actually, careful: 
On |0000&gt;, Z0Z3 gives +1, then X0X3 gives |1001&gt;.
On |1001&gt;, Z0Z3: qubit0=1 -&gt; -1, qubit3=1 -&gt; -1, product +1, then X0X3 gives |0000&gt;.
On |0110&gt;, Z0Z3: +1, then X0X3 gives |1111&gt;.
On |1111&gt;, Z0Z3: (-1)*(-1)=+1, then X0X3 gives |0110&gt;.
So indeed, X0X3 Z0Z3 |ψ_ideal&gt; = |ψ_ideal&gt;.
So it appears that all these normalizer errors act as identity on |ψ_ideal&gt;! That is interesting. But wait, are there any normalizer errors that could act as logical operators? They would be products of these with stabilizers? But stabilizers themselves act as identity on the code space. So indeed, any operator in the normalizer that is not a logical operator? Actually, the normalizer modulo the stabilizer gives the logical group. So there should be operators that are not in the stabilizer but act non-trivially on the code space. For example, X_A = XIXI. Is X_A in the normalizer? Check: X_A = X0 I X2 I. Does it commute with S1? S1 = X0X1X2X3. X_A commutes with S1 if and only if? X0 and X2 commute with X0X1X2X3? Actually, X0 commutes with X0, but anti-commutes with? Let&rsquo;s check: X_A and S1: They act on qubits: X_A on 0 and 2; S1 on all. They will commute if the number of anti-commutations is even. X0 with X0: commute; X2 with X2: commute; so overall commute. With S2: Z0Z1Z2Z3. X0 anti-commutes with Z0, so that gives one anti-commutation; X2 anti-commutes with Z2, so that gives another; so overall commute? Actually, product of two anti-commutations gives commute. So yes, X_A is in the normalizer. So why didn&rsquo;t we get X_A from our errors? Because our errors are restricted to pairs: {1,2} and {0,3}. X_A involves qubits 0 and 2, which is not on a single pair from our error locations. So indeed, the errors that occur are only on these specific pairs. And it seems that the errors on these pairs that are in the normalizer actually act trivially on |ψ_ideal&gt;. Let&rsquo;s check: Could there be an error on {0,3} that acts as X_A? X_A = X0 X2. But that involves qubit2, which is not in {0,3}. So no.
What about errors on {1,2} that act as X_B? X_B = X0 X1. That involves qubit0, so no.
So indeed, the errors that occur from these specific depolarizing channels, when they are undetectable (i.e., in the normalizer), they actually do not change the logical state. So that means that if the state is in the code space, then it is actually the correct logical state |ψ_ideal&gt;. </p>
<p>But wait: Is that always true? Let&rsquo;s check one more: What about an error that is a product of an error on {1,2} and an error on {0,3} that together might act as a logical operator? For example, consider E = X1X2 and F = something that gives X0? But we already computed that individually they act as identity. And since they commute, the combined effect is identity. So it seems that for any E and F that are in the normalizer (from our sets), we have E F |ψ_ideal&gt; = |ψ_ideal&gt;. 
I want to double-check: 
Take E = X1X2 and F = X0X3. Then combined: X0X3 X1X2. Does that equal any logical operator? That operator acts on all qubits. Could it be X_A? X_A = X0 X2. Not that.
Could it be X_B? X_B = X0 X1. Not that.
Maybe it is a stabilizer? S1 = X0X1X2X3. Our product is X0X1X2X3? Actually, X0X3 X1X2 = X0X1X2X3 = S1. And S1 acts as identity on the code space. So yes.
What about E = X1X2 and F = Z0Z3? That product is Z0Z3 X1X2. Is that a stabilizer? S2 = Z0Z1Z2Z3. Not exactly. But we computed individually they act as identity. So it&rsquo;s fine.
So indeed, if both E and F are in the normalizer, then the state is exactly |ψ_ideal&gt;.</p>
<p>Therefore, the post-selected state is only those cases where E and F are in their respective normalizer sets. And in all those cases, the state is |ψ_ideal&gt;. So then the fidelity after post-selection is 1. But wait: Is that true? What about the cases where there is no error? That is included: E=I and F=I are in the normalizer. So yes.
So then, if we post-select on the code space, we only keep outcomes where E is in N_E and F is in N_F. And in all those cases, the state is |ψ_ideal&gt;. So the logical state fidelity is 1.</p>
<p>But wait: The question: &ldquo;What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of p, assuming the state is post-selected on all detectable errors?&rdquo; That suggests that after post-selection, the state is perfect. But is that true? That would mean that the fidelity is 1 regardless of p? That seems too good. But wait: There might be a catch: Post-selection on all detectable errors means that we discard any state that is not in the code space. But what about errors that are not detectable? Those are the ones that are in the normalizer. And as we argued, those errors actually do not change the logical state. So indeed, if we post-select, we only keep the states that are in the code space, and those states are exactly the ideal state. So the logical fidelity is 1.</p>
<p>But wait: Could there be any phase factors? We checked that each normalizer error from these sets acts as identity on |ψ_ideal&gt;. So yes.</p>
<p>Therefore, the logical state fidelity after post-selection is 1.</p>
<p>But wait: The problem might be more nuanced: &ldquo;post-selected on all detectable errors&rdquo; might mean that we measure the stabilizers and if we get -1 on either, we discard. That means we keep only when the state is in the code space. And as argued, if the state is in the code space, then it must be that E and F are such that they are in the normalizer. And then the state is E F |ψ_ideal&gt;. And we have shown that for any E in the set of 4 on {1,2} and F in the set of 4 on {0,3}, we get |ψ_ideal&gt;. So indeed, the logical state is always |ψ_ideal&gt;. So the fidelity is 1.</p>
<p>Thus the answer should be: F_logical = 1.</p>
<p>But wait: Is that independent of p? That is interesting. It means that if we can post-select on the code space, then no matter what the error rate p is, the logical state is perfect. But that is only if the errors are exactly these two-qubit depolarizing channels on these specific pairs. And indeed, these errors are such that any error that takes the state out of the code space is detectable, and any error that does not take it out is actually harmless for this particular state. That is a property of this specific circuit and this specific code. So the answer is 1.</p>
<p>I will double-check with an example: Suppose after CNOT21, there is an error X1 (which is detectable because it anti-commutes with Z1Z2? Actually, X1 on qubit1: Does it commute with S1? S1 has X1, so commutes? But with S2: S2 has Z1, so anti-commutes. So detectable). So that state would be discarded. 
What if there is an error Z1? Then with S1: anti-commutes? S1 has X1, so anti-commutes. So detectable.
What if there is an error Y1? That would be detectable as well.
So indeed, any single-qubit error on these pairs is detectable. And any two-qubit error that is not in the normalizer will be detectable. So the only errors that are not detected are those in the normalizer. And we checked that those act trivially on the logical state.
So yes.</p>
<p>Therefore, the logical fidelity after post-selection is 1.</p>
<p>So the answer is: F_logical = 1.</p>
<p>But wait: The problem asks &ldquo;as a function of p&rdquo;. That would be constant 1.</p>
<p>So final answer: \boxed{1}.</p>
<p>I&rsquo;ll provide step-by-step reasoning.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<h4 id="circuit-and-error-model">🔹 Circuit and Error Model</h4>
<p>We aim to prepare the logical GHZ state  </p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle_{AB} = \frac{|00\rangle_{AB} + |11\rangle_{AB}}{\sqrt{2}}
\]</div>
<p>in the <span class="arithmatex">\([[4,2,2]]\)</span> code using the circuit:  </p>
<div class="arithmatex">\[
\text{CNOT}_{03} \cdot H_0 \cdot \text{CNOT}_{21} \cdot H_2,
\]</div>
<p>where operations are applied from right to left. The initial state is <span class="arithmatex">\(|0000\rangle\)</span>.</p>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel:
- After <span class="arithmatex">\(\text{CNOT}_{21}\)</span>, an error <span class="arithmatex">\(E\)</span> occurs on qubits <span class="arithmatex">\(\{1,2\}\)</span> with probability <span class="arithmatex">\(p\)</span>, where <span class="arithmatex">\(E\)</span> is one of the 15 non-identity Pauli operators (each with probability <span class="arithmatex">\(p/15\)</span>).
- After <span class="arithmatex">\(\text{CNOT}_{03}\)</span>, an error <span class="arithmatex">\(F\)</span> occurs on qubits <span class="arithmatex">\(\{0,3\}\)</span> with probability <span class="arithmatex">\(p\)</span>, where <span class="arithmatex">\(F\)</span> is one of the 15 non-identity Pauli operators (each with probability <span class="arithmatex">\(p/15\)</span>).</p>
<p>Hadamard gates are assumed perfect.</p>
<h4 id="ideal-state-preparation">🔹 Ideal State Preparation</h4>
<p>Applying the circuit without errors:</p>
<ol>
<li><span class="arithmatex">\(H_2 |0000\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)\)</span></li>
<li><span class="arithmatex">\(\text{CNOT}_{21} \cdot \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle) = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\)</span></li>
<li><span class="arithmatex">\(H_0 \cdot \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle) = \frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)\)</span></li>
<li><span class="arithmatex">\(\text{CNOT}_{03} \cdot \frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle) = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)\)</span></li>
</ol>
<p>Thus, the ideal physical state is:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<h4 id="error-propagation">🔹 Error Propagation</h4>
<p>Since the circuit consists of Clifford gates, errors can be propagated to the end. The errors <span class="arithmatex">\(E\)</span> (on <span class="arithmatex">\(\{1,2\}\)</span>) and <span class="arithmatex">\(F\)</span> (on <span class="arithmatex">\(\{0,3\}\)</span>) commute with subsequent gates (as they act on disjoint qubit sets), so the final state becomes:</p>
<div class="arithmatex">\[
|\psi_{\text{actual}}\rangle = F \cdot E \cdot |\psi_{\text{ideal}}\rangle
\]</div>
<p>The full density matrix is a mixture over all possible errors:</p>
<div class="arithmatex">\[
\rho = \sum_{E,F} P(E) P(F) \cdot (FE) |\psi_{\text{ideal}}\rangle \langle \psi_{\text{ideal}}| (FE)^\dagger
\]</div>
<p>where:
- <span class="arithmatex">\(P(E = I) = 1 - p\)</span>, <span class="arithmatex">\(P(E \neq I) = \frac{p}{15}\)</span>
- <span class="arithmatex">\(P(F = I) = 1 - p\)</span>, <span class="arithmatex">\(P(F \neq I) = \frac{p}{15}\)</span></p>
<h4 id="post-selection-on-the-code-space">🔹 Post-Selection on the Code Space</h4>
<p>The <span class="arithmatex">\([[4,2,2]]\)</span> code has stabilizers:</p>
<div class="arithmatex">\[
S_1 = X_0 X_1 X_2 X_3, \quad S_2 = Z_0 Z_1 Z_2 Z_3
\]</div>
<p>The code space is the simultaneous <span class="arithmatex">\(+1\)</span> eigenspace of <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>. We post-select by measuring <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>, keeping only outcomes where both yield <span class="arithmatex">\(+1\)</span>.</p>
<p>A Pauli error <span class="arithmatex">\(G\)</span> will keep the state in the code space iff it commutes with both <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>. Since <span class="arithmatex">\(E\)</span> and <span class="arithmatex">\(F\)</span> act on disjoint sets, <span class="arithmatex">\(FE\)</span> is in the normalizer iff:
- <span class="arithmatex">\(E\)</span> commutes with <span class="arithmatex">\(X_1 X_2\)</span> and <span class="arithmatex">\(Z_1 Z_2\)</span>
- <span class="arithmatex">\(F\)</span> commutes with <span class="arithmatex">\(X_0 X_3\)</span> and <span class="arithmatex">\(Z_0 Z_3\)</span></p>
<p>The Paulis on <span class="arithmatex">\(\{1,2\}\)</span> that satisfy this are:</p>
<div class="arithmatex">\[
\mathcal{N}_E = \{I, X_1 X_2, Z_1 Z_2, X_1 X_2 Z_1 Z_2\}
\]</div>
<p>The Paulis on <span class="arithmatex">\(\{0,3\}\)</span> that satisfy this are:</p>
<div class="arithmatex">\[
\mathcal{N}_F = \{I, X_0 X_3, Z_0 Z_3, X_0 X_3 Z_0 Z_3\}
\]</div>
<p>The probability that <span class="arithmatex">\(E \in \mathcal{N}_E\)</span> is:</p>
<div class="arithmatex">\[
P(E \in \mathcal{N}_E) = (1 - p) + 3 \cdot \frac{p}{15} = 1 - \frac{4}{5}p
\]</div>
<p>Similarly, <span class="arithmatex">\(P(F \in \mathcal{N}_F) = 1 - \frac{4}{5}p\)</span>. Since <span class="arithmatex">\(E\)</span> and <span class="arithmatex">\(F\)</span> are independent:</p>
<div class="arithmatex">\[
P(\text{code}) = \left(1 - \frac{4}{5}p\right)^2
\]</div>
<h4 id="effect-of-normalizer-errors-on-logical-state">🔹 Effect of Normalizer Errors on Logical State</h4>
<p>We now examine the action of errors in <span class="arithmatex">\(\mathcal{N}_E\)</span> and <span class="arithmatex">\(\mathcal{N}_F\)</span> on <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span>.</p>
<ul>
<li>For any <span class="arithmatex">\(E \in \mathcal{N}_E\)</span>, direct computation shows:</li>
</ul>
<div class="arithmatex">\[
  E |\psi_{\text{ideal}}\rangle = |\psi_{\text{ideal}}\rangle
\]</div>
<ul>
<li>Similarly, for any <span class="arithmatex">\(F \in \mathcal{N}_F\)</span>:</li>
</ul>
<div class="arithmatex">\[
  F |\psi_{\text{ideal}}\rangle = |\psi_{\text{ideal}}\rangle
\]</div>
<p>Since <span class="arithmatex">\(E\)</span> and <span class="arithmatex">\(F\)</span> act on disjoint qubits, they commute, so:</p>
<div class="arithmatex">\[
FE |\psi_{\text{ideal}}\rangle = |\psi_{\text{ideal}}\rangle
\]</div>
<p>for all <span class="arithmatex">\(E \in \mathcal{N}_E\)</span>, <span class="arithmatex">\(F \in \mathcal{N}_F\)</span>.</p>
<p>Thus, if the state is in the code space (i.e., <span class="arithmatex">\(E \in \mathcal{N}_E\)</span> and <span class="arithmatex">\(F \in \mathcal{N}_F\)</span>), the logical state is exactly <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span>.</p>
<h4 id="logical-fidelity-after-post-selection">🔹 Logical Fidelity After Post-Selection</h4>
<p>After post-selection, the state is:</p>
<div class="arithmatex">\[
\rho_{\text{post}} = \frac{\Pi \rho \Pi}{\operatorname{Tr}(\Pi \rho)}
\]</div>
<p>where <span class="arithmatex">\(\Pi\)</span> is the projector onto the code space. Since <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span> is in the code space, we have:</p>
<div class="arithmatex">\[
\langle \psi_{\text{ideal}} | \rho_{\text{post}} | \psi_{\text{ideal}} \rangle = \frac{\langle \psi_{\text{ideal}} | \rho | \psi_{\text{ideal}} \rangle}{\operatorname{Tr}(\Pi \rho)}
\]</div>
<p>But from above, whenever the state is in the code space, it is exactly <span class="arithmatex">\(|\psi_{\text{ideal}}\rangle\)</span>, so:</p>
<div class="arithmatex">\[
\langle \psi_{\text{ideal}} | \rho | \psi_{\text{ideal}} \rangle = P(\text{code}) \cdot 1
\]</div>
<p>and</p>
<div class="arithmatex">\[
\operatorname{Tr}(\Pi \rho) = P(\text{code})
\]</div>
<p>Hence, the logical fidelity is:</p>
<div class="arithmatex">\[
F_{\text{logical}} = \frac{P(\text{code})}{P(\text{code})} = 1
\]</div>
<hr />
<p><strong>Final Answer:</strong>  </p>
<div class="arithmatex">\[
\boxed{1}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given: &ldquo;Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?&rdquo;</p>
<p>Interpretation: We have a circuit that prepares logical |00&gt;<em>{AB}. The circuit involves an ancilla qubit (qubit 4). The circuit is: 
M_4 (CNOT</em>{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
But careful: The order: &ldquo;matrix multiplication order&rdquo; means that the rightmost operation is applied first. So the actual order of operations is:</p>
<ol>
<li>H_1</li>
<li>CNOT_{12}</li>
<li>CNOT_{10}</li>
<li>CNOT_{23}</li>
<li>CNOT_{34}</li>
<li>CNOT_{04}</li>
<li>M_4 (measurement of qubit 4)</li>
</ol>
<p>We want the logical state fidelity of the final 2-qubit logical state (on qubits 0,1,2,3? Actually, the code is on qubits 0,1,2,3. The ancilla is qubit 4) after the circuit, given that we post-select on:
- The ancilla measurement is |0&gt; (so success)
- And we post-select on all detectable errors in the code? That means we also measure the stabilizers of the [[4,2,2]] code? And only keep if they are +1? So we post-select on the state being in the code space.</p>
<p>And we want the fidelity as a function of p, where p is the two-qubit gate error rate. Each CNOT gate is followed by a two-qubit depolarizing error channel with probability p? The problem statement from previous parts: &ldquo;each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; So yes, each CNOT gate has an error channel after it. Also, what about the Hadamard gate? It says &ldquo;H is a single-qubit Hadamard gate.&rdquo; But does it have errors? The problem statement from the initial setup: &ldquo;As a simple model of quantum errors in hardware, we will suppose that each CNOT_{ij} gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability p/15.&rdquo; So only CNOT gates have errors. The Hadamard gate and measurement are perfect? Possibly yes.</p>
<p>So the circuit has 5 CNOT gates: CNOT_{12}, CNOT_{10}, CNOT_{23}, CNOT_{34}, CNOT_{04}. So there are 5 error locations. Each CNOT gate is followed by an error channel on the two qubits involved. So errors can occur on pairs: 
After CNOT_{12}: error on {1,2}
After CNOT_{10}: error on {1,0}
After CNOT_{23}: error on {2,3}
After CNOT_{34}: error on {3,4}
After CNOT_{04}: error on {0,4}</p>
<p>We also have a Hadamard on qubit 1 at the beginning, and a measurement on qubit 4 at the end.</p>
<p>The goal is to prepare logical |00&gt;_{AB}. We want the logical fidelity after post-selection on:
- Ancilla measurement outcome 0.
- And post-selection on the code space (i.e., no detectable errors in the code, meaning the state is in the +1 eigenspace of XXXX and ZZZZ on qubits 0,1,2,3).</p>
<p>We want the fidelity as a function of p.</p>
<p>Approach: We need to analyze the circuit. The circuit is designed to prepare logical |00&gt; fault-tolerantly. The ancilla is used to detect errors. So likely, if there is an error that can cause a logical error, it will either be detected by the ancilla measurement ( outcome 1) or by the code stabilizers (if it takes the state out of the code space). So after post-selection, we only keep states that are in the code space and with ancilla=0. In that case, the state should be the ideal logical state. But wait: Could there be undetectable errors that still cause a logical error? Possibly. We need to check which errors are not detected and see if they affect the logical state.</p>
<p>So we need to compute the effect of errors on the logical state. The circuit is a Clifford circuit. We can propagate errors through the circuit. But there are 5 error locations. Each error is a Pauli on a pair of qubits. They occur after each CNOT. We can push these errors to the end of the circuit. But careful: The circuit includes a measurement. So we need to see how errors affect the measurement outcome and the final state.</p>
<p>Let&rsquo;s denote the circuit operations in order:</p>
<ol>
<li>H_1</li>
<li>CNOT_{12} → error E1 on {1,2}</li>
<li>CNOT_{10} → error E2 on {1,0}</li>
<li>CNOT_{23} → error E3 on {2,3}</li>
<li>CNOT_{34} → error E4 on {3,4}</li>
<li>CNOT_{04} → error E5 on {0,4}</li>
<li>Measure qubit 4.</li>
</ol>
<p>We want the final state on qubits 0,1,2,3 after the measurement, given that the measurement outcome is 0. And then we also post-select on the code space (so we measure stabilizers and only keep if both are +1).</p>
<p>We want the fidelity of that state to the logical |00&gt;_{AB}.</p>
<p>Let&rsquo;s first understand the ideal circuit without errors. What is the ideal circuit doing? It is preparing logical |00&gt;. The circuit: 
Start with all qubits in |0&gt;? Typically, we start with |0&gt; on all qubits? The circuit: H_1, then CNOT_{12}, CNOT_{10}, CNOT_{23}, CNOT_{34}, CNOT_{04}, then measure qubit 4. If measurement is 0, then the state on qubits 0,1,2,3 is logical |00&gt;. Let&rsquo;s check quickly:
Ideal circuit (no errors):
Initial: |0⟩<em>0, |0⟩_1, |0⟩_2, |0⟩_3, |0⟩_4.
Step 1: H_1 on qubit 1: becomes |0⟩_0, (|0⟩+|1⟩)/√2)_1, |0⟩_2, |0⟩_3, |0⟩_4.
Step 2: CNOT</em>{12} with control 1, target 2: 
So state: |0⟩<em>0, (|0⟩|0⟩_2 + |1⟩|1⟩_2)/√2, |0⟩_3, |0⟩_4.
Step 3: CNOT</em>{10} with control 1, target 0:
State: (|0⟩<em>0|0⟩_1 + |1⟩_0|1⟩_1)/√2 ⊗ |0⟩_2? Actually careful: 
After step 2: state = 1/√2 (|0⟩_0|0⟩_1|0⟩_2 + |0⟩_0|1⟩_1|1⟩_2) |0⟩_3|0⟩_4.
Now CNOT</em>{10}: control qubit 1, target qubit 0.
For first term: |0⟩<em>1 so no flip: remains |0⟩_0|0⟩_1|0⟩_2.
For second term: |1⟩_1 so flip qubit 0: becomes |1⟩_0|1⟩_1|1⟩_2.
So state: 1/√2 (|000⟩</em>{0,1,2} + |111⟩<em>{0,1,2}) |0⟩_3|0⟩_4.
Step 4: CNOT</em>{23} with control 2, target 3:
State: 1/√2 (|0000⟩<em>{0,1,2,3} + |1111⟩</em>{0,1,2,3}) |0⟩<em>4.
Step 5: CNOT</em>{34} with control 3, target 4:
State: 1/√2 (|00000⟩ + |11111⟩) because if qubit3=0, then qubit4 stays 0; if qubit3=1, then qubit4 becomes 1.
Step 6: CNOT_{04} with control 0, target 4:
Now, for first term: qubit0=0 so no flip: remains |00000⟩.
For second term: qubit0=1 so flip qubit4: becomes |11110⟩? Actually, careful: |11111⟩: qubit0=1, so flip qubit4: from 1 to 0, so becomes |11110⟩.
So state: 1/√2 (|00000⟩ + |11110⟩).
Step 7: Measure qubit 4. 
If we measure 0, then both terms have qubit4=0. So the state collapses to: 1/√2 (|0000⟩<em>{0,1,2,3} + |1111⟩</em>{0,1,2,3})? But wait, that is the logical |00&gt; state? Actually, logical |00&gt; in the [[4,2,2]] code is often given as (|0000⟩+|1111⟩)/√2. So yes, that is logical |00&gt;. So ideal circuit produces logical |00&gt; when measurement is 0.</p>
<p>So ideally, fidelity is 1.</p>
<p>Now, with errors. Errors occur after each CNOT. They are Pauli errors on the two qubits involved. We want to know: After post-selection on ancilla=0 and on code space (stabilizers +1), what is the probability that the state is actually logical |00&gt;? That probability is the fidelity.</p>
<p>We need to consider errors that are not detected by either the ancilla measurement or the code stabilizers. These errors will survive post-selection and might change the logical state.</p>
<p>So we need to analyze each error location and determine which errors are undetectable (i.e., they leave the state in the code space and give ancilla measurement 0) but still cause a logical error.</p>
<p>Let&rsquo;s denote the error operators:
E1 on {1,2} after CNOT_{12}
E2 on {1,0} after CNOT_{10}
E3 on {2,3} after CNOT_{23}
E4 on {3,4} after CNOT_{34}
E5 on {0,4} after CNOT_{04}</p>
<p>These errors are Pauli operators on the specified pairs. They occur with probability: For each CNOT, with probability 1-p, no error; with probability p, an error occurs, and that error is one of the 15 non-identity Paulis on that pair, each with probability p/15.</p>
<p>We want to propagate these errors to the end of the circuit. Since the circuit is Clifford, we can compute how each error propagates through subsequent gates. Ultimately, we want to know the effect on the final state on qubits 0,1,2,3 and on the ancilla measurement.</p>
<p>Let&rsquo;s denote the ideal circuit operation as U (from initial state to before measurement). Then with errors, the actual operation is: 
U_actual = (E5) * CNOT_{04} * (E4) * CNOT_{34} * (E3) * CNOT_{23} * (E2) * CNOT_{10} * (E1) * CNOT_{12} * H_1.
We want to push these errors to the end. We can commute them through the Clifford gates. But careful: The errors occur after specific gates, so they will be conjugated by the subsequent gates. Let&rsquo;s do that step by step.</p>
<p>It might be easier to determine the stabilizer of the ideal state during the circuit? Alternatively, we can compute the effect of each error type on the final state. But there are many error locations. However, note that we are post-selecting on ancilla=0 and on code space. So only errors that commute with the measurement outcome and with the stabilizers will survive. So we want to find errors that are in the normalizer of the &ldquo;detection&rdquo; conditions. This is like fault-tolerant preparation. The circuit is designed to be fault-tolerant for preparing |00&gt;. So likely, any error that causes a logical error will be detected either by the ancilla or by the code stabilizers. So the fidelity after post-selection might be 1. But wait, the question asks for fidelity as a function of p. That suggests that there might be some undetectable errors that still cause a logical error? Or maybe the fidelity is 1 - O(p^2) or something? But previous subproblem gave fidelity 1 after post-selection. But here, there are more CNOT gates. Perhaps there are higher-order errors that are undetectable.</p>
<p>We need to check if there is any weight-2 error that could be undetectable and cause a logical error. Since the code distance is 2, any single error is detectable. But here errors are on two qubits from depolarizing channels? But they occur on specific pairs. They might combine from different locations.</p>
<p>Let&rsquo;s try to propagate errors from each location to the end. We&rsquo;ll denote the gates in order:
G1 = H_1
G2 = CNOT_{12}
G3 = CNOT_{10}
G4 = CNOT_{23}
G5 = CNOT_{34}
G6 = CNOT_{04}
Then measurement M_4.</p>
<p>Errors: after G2: E1 on {1,2}
after G3: E2 on {1,0}
after G4: E3 on {2,3}
after G5: E4 on {3,4}
after G6: E5 on {0,4}</p>
<p>We want to push these errors to after G6, so that they become Pauli errors on the final state (on qubits 0,1,2,3,4) before measurement. Then we can see conditions for them to yield ancilla=0 and be in the code space.</p>
<p>Let&rsquo;s do that systematically. Let&rsquo;s denote the Pauli errors by their action on qubits. We&rsquo;ll use notation: X_i, Z_i, etc.</p>
<p>We will propagate each error through the subsequent gates. The rules for Clifford conjugation:
- CNOT_{ij} conjugation:
  - CNOT_{ij} X_i CNOT_{ij} = X_i X_j
  - CNOT_{ij} X_j CNOT_{ij} = X_j
  - CNOT_{ij} Z_i CNOT_{ij} = Z_i
  - CNOT_{ij} Z_j CNOT_{ij} = Z_i Z_j
- Hadamard on qubit i: H_i X_i H_i = Z_i, H_i Z_i H_i = X_i.</p>
<p>Also, note that errors commute if they act on different qubits.</p>
<p>We&rsquo;ll propagate each error location separately. But careful: Errors from different locations will commute with each other if they act on disjoint sets? They might not always commute if they act on same qubits? But since we are interested in the overall effect, we can consider each error independently to first order in p? But errors could combine from different locations. However, since p is small, the dominant undetectable errors will be those that are single errors (from one location) that are undetectable, or two errors that together become undetectable. But post-selection might remove all single errors because they are detectable? Let&rsquo;s check: Single errors: If only one error occurs at one location, will it be detected? likely yes because the circuit is fault-tolerant. So the lowest order undetectable errors would be two errors that cancel each other&rsquo;s detection signals. So we might need to consider second order in p.</p>
<p>But the question: &ldquo;What is the logical state fidelity &hellip; as a function of two-qubit gate error rate p?&rdquo; That suggests that the fidelity might be 1 - A p^2 + &hellip; So we need to find the coefficient A.</p>
<p>Maybe we can determine that any error that survives post-selection must act trivially on the logical state. Is that true? The circuit is designed for fault-tolerant preparation. Often, fault-tolerant preparation circuits have the property that any error that is not detected does not cause a logical error. But wait, the [[4,2,2]] code is a distance-2 code, so it can detect any single error. But here, errors are on two-qubit gates. They could be weight-1 errors? Actually, a two-qubit depolarizing error on a pair could be a weight-1 error if it acts as Pauli on one qubit only? But careful: The error channel applies one of the 15 non-identity two-qubit Paulis. That includes operators like X ⊗ I, I ⊗ X, etc. So yes, there can be weight-1 errors. And those should be detected by the code stabilizers? But wait, the code stabilizers are measured only at the end? But we post-select on the code space. So if a weight-1 error occurs, it will take the state out of the code space, so it will be detected. So single errors are detected. So the lowest order undetectable errors would be two errors that together act as a logical operator? Or they could be errors that are themselves in the normalizer of the stabilizers? But as we saw in subproblem 2, errors on specific pairs that are in the normalizer might act trivially on the logical state? But here, the circuit is different. We need to check.</p>
<p>Maybe we should compute the propagation of errors from each location. Let&rsquo;s do that.</p>
<p>Let&rsquo;s denote the gates in order:</p>
<p>G1: H_1
G2: CNOT_{12}
G3: CNOT_{10}
G4: CNOT_{23}
G5: CNOT_{34}
G6: CNOT_{04}</p>
<p>We want to push an error that occurs after a gate to the end. That means we need to conjugate it by all subsequent gates.</p>
<p>Let&rsquo;s define the subsequent gates for each error:</p>
<p>Error E1 occurs after G2. So it will be conjugated by: G3, G4, G5, G6.
Error E2 occurs after G3. So conjugated by: G4, G5, G6.
Error E3 occurs after G4. So conjugated by: G5, G6.
Error E4 occurs after G5. So conjugated by: G6.
Error E5 occurs after G6. So it stays as is.</p>
<p>Now, let&rsquo;s compute these conjugations. We need to know the actions of these gates on Paulis on specific qubits.</p>
<p>List the qubits: 0,1,2,3,4.
G3 = CNOT_{10} (control 1, target 0)
G4 = CNOT_{23} (control 2, target 3)
G5 = CNOT_{34} (control 3, target 4)
G6 = CNOT_{04} (control 0, target 4)</p>
<p>Let&rsquo;s compute the conjugation rules for each gate on Paulis on each qubit.</p>
<p>For G3 = CNOT_{10}:
It affects qubits 0 and 1.
Conjugation:
X_0 -&gt; X_0? Actually, careful: CNOT_{10} means control=1, target=0.
So:
CNOT_{10} X_0 CNOT_{10} = ? The standard: CNOT_{c,t} X_c CNOT = X_c X_t; CNOT_{c,t} X_t CNOT = X_t; CNOT_{c,t} Z_c CNOT = Z_c; CNOT_{c,t} Z_t CNOT = Z_c Z_t.
So for G3: control=1, target=0.
So:
X_1 -&gt; X_1 X_0
X_0 -&gt; X_0
Z_1 -&gt; Z_1
Z_0 -&gt; Z_1 Z_0
Also, Paulis on other qubits commute.</p>
<p>For G4 = CNOT_{23} (control=2, target=3):
So:
X_2 -&gt; X_2 X_3
X_3 -&gt; X_3
Z_2 -&gt; Z_2
Z_3 -&gt; Z_2 Z_3</p>
<p>For G5 = CNOT_{34} (control=3, target=4):
So:
X_3 -&gt; X_3 X_4
X_4 -&gt; X_4
Z_3 -&gt; Z_3
Z_4 -&gt; Z_3 Z_4</p>
<p>For G6 = CNOT_{04} (control=0, target=4):
So:
X_0 -&gt; X_0 X_4
X_4 -&gt; X_4
Z_0 -&gt; Z_0
Z_4 -&gt; Z_0 Z_4</p>
<p>Now, we want to propagate errors from each location.</p>
<p>Let&rsquo;s start with error E1 on {1,2} after G2.
E1 is a Pauli on qubits 1 and 2. It can be written as a product of X and Z on qubits 1 and 2.
We want to compute: U = G6 G5 G4 G3. So E1 becomes: U^{-1} E1 U actually? Actually, careful: The error occurs after G2. So the actual operation is: &hellip; G3 * (E1) * G2 * &hellip; So when we push E1 to the end, we do: U E1 U^{-1} where U = G3 G4 G5 G6? Actually, if we have a gate sequence: &hellip; A B, and an error E after B, then the overall is A E B = (A E A^{-1}) A B. So indeed, to push an error through subsequent gates, we conjugate it by those gates. So for error after G2, the subsequent gates are G3, G4, G5, G6. So the effective error at the end is: E1&rsquo; = (G6 G5 G4 G3) E1 (G6 G5 G4 G3)^{-1} = (G6 G5 G4 G3) E1 (G3^{-1}G4^{-1}G5^{-1}G6^{-1}). But since these are Clifford, we can compute step by step.</p>
<p>Let&rsquo;s do that for a general Pauli on {1,2}. Let E1 = P1 * P2, where P1 is on qubit 1 and P2 on qubit 2? But careful: It could be products like X1 Z2 etc. But we can use the conjugation rules through each gate.</p>
<p>We will go through each gate in order: First, conjugate E1 by G3. Then by G4, then G5, then G6.</p>
<p>G3 = CNOT_{10}. It acts on qubits 0 and 1. So it will affect any Pauli on qubit 1. It will not affect Pauli on qubit 2 because that commutes.
So after G3, E1 becomes: G3 E1 G3^{-1}. 
Let E1 = A1 * A2, where A1 acts on qubit 1 and A2 on qubit 2.
Under G3, A2 is unchanged because it commutes.
A1 on qubit 1 will change according to CNOT_{10} rules:
If A1 = X1, then becomes X1 X0.
If A1 = Z1, then remains Z1? Actually, check: CNOT_{10} Z1 CNOT_{10} = Z1 (since control stays same).
If A1 = Y1, then Y1 = i X1 Z1, so becomes i (X1 X0) Z1 = i X1 Z1 X0 = Y1 X0? But careful with phases: Actually, Y1 will become? Let&rsquo;s do properly: 
CNOT_{10} Y1 CNOT_{10} = CNOT_{10} (i X1 Z1) CNOT_{10} = i (CNOT_{10} X1 CNOT_{10}) (CNOT_{10} Z1 CNOT_{10}) = i (X1 X0) (Z1) = i X1 Z1 X0 = Y1 X0. But wait, does X0 commute with Y1? Yes, they act on different qubits. So it becomes Y1 X0.
So in summary, under G3:
X1 -&gt; X1 X0
Z1 -&gt; Z1
Y1 -&gt; Y1 X0
And anything on qubit 2 remains same.</p>
<p>So after G3, E1 becomes something that may involve qubit 0 as well.</p>
<p>Then next, G4 = CNOT_{23}. This acts on qubits 2 and 3. So it will affect any Pauli on qubit 2 and might introduce qubit 3.
After G3, E1 has factors on qubits 1,2, and possibly 0 from previous step.
Under G4:
On qubit 2: 
X2 -&gt; X2 X3
Z2 -&gt; Z2
Y2 -&gt; Y2 X3? (Similarly)
On qubits 0,1: unchanged because they commute with G4.
So after G4, E1 will involve qubits 0,1,2,3.</p>
<p>Then G5 = CNOT_{34} acts on qubits 3 and 4. So it will affect any Pauli on qubit 3 and might introduce qubit 4.
After G4, E1 has factors on 0,1,2,3.
Under G5:
On qubit 3:
X3 -&gt; X3 X4
Z3 -&gt; Z3
Y3 -&gt; Y3 X4
On others unchanged.
So after G5, E1 involves qubits 0,1,2,3,4.</p>
<p>Then G6 = CNOT_{04} acts on qubits 0 and 4. So it will affect any Pauli on qubit 0 and qubit 4.
After G5, E1 has factors on 0,1,2,3,4.
Under G6:
On qubit 0:
X0 -&gt; X0 X4
Z0 -&gt; Z0
Y0 -&gt; Y0 X4
On qubit 4:
X4 -&gt; X4
Z4 -&gt; Z0 Z4
Y4 -&gt; ? But careful: Y4 = i X4 Z4, so under G6: X4 remains X4, Z4 becomes Z0 Z4, so Y4 becomes i X4 (Z0 Z4) = i Z0 X4 Z4 = Z0 Y4? But since Z0 commutes with X4 and Z4? Actually, careful: Z0 and Y4 act on different qubits, so they commute. So Y4 -&gt; Z0 Y4.
Also, on qubits 1,2,3: unchanged.</p>
<p>So we can compute the final effect of an error E1 on {1,2} after all conjugations. But maybe we don&rsquo;t need the full details? We are interested in conditions for the error to be undetectable. That means:
1) It must leave the ancilla measurement outcome as 0. The ancilla is qubit 4. After the circuit, we measure qubit 4 in the Z basis. For the state to be accepted, we need that the measurement outcome is 0. That means that the error should not flip the outcome relative to the ideal outcome. Ideal outcome is 0. So we require that the error does not change the Z4 value of the state? Actually, careful: The measurement outcome is determined by the state. If the error changes the state such that it has a component with qubit 4 in |1&gt;, then that might cause measurement outcome 1 sometimes. But since we post-select on outcome 0, we only keep those cases where the error does not cause a bit flip on qubit 4? Actually, wait: The error itself is a Pauli operator applied to the ideal state. The ideal state has qubit 4 in |0⟩ always? Actually, ideal state before measurement is: 1/√2 (|00000⟩ + |11110⟩) from earlier? But after CNOT_{04}, ideal state became: 1/√2 (|00000⟩ + |11110⟩). So in the ideal state, qubit 4 is 0 in both terms? Actually, check: |11110⟩ has qubit4=0. So yes, ideal state has qubit4=0 always. So if an error includes an X4 or Y4, it will flip qubit4 to 1 on some terms. So for the error to not affect the measurement outcome (i.e., still give outcome 0 with certainty), the error must commute with Z4? Actually, if the error is a Pauli that anti-commutes with Z4, then it will flip the measurement outcome. But wait: The state is not necessarily an eigenstate of Z4? Actually, the ideal state is an eigenstate of Z4? Check: Ideal state: 1/√2 (|00000⟩ + |11110⟩). Is that an eigenstate of Z4? Z4 acting on |00000⟩ gives +1, on |11110⟩ gives +1 as well because qubit4=0. So yes, ideal state is eigenstate of Z4 with eigenvalue +1. So if an error anti-commutes with Z4, then it will flip the eigenvalue? Actually, if |ψ⟩ is eigenstate of Z4 with +1, then for a Pauli P that anti-commutes with Z4, we have Z4 P|ψ⟩ = - P Z4|ψ⟩ = - P|ψ⟩, so P|ψ⟩ is eigenstate of Z4 with eigenvalue -1. So that would yield measurement outcome 1. So for the error to not change the measurement outcome, we need that the error commutes with Z4. So condition: The final error (after propagation) should commute with Z4. That is one condition.</p>
<p>2) The error should keep the state in the code space. That means that the error must commute with the stabilizers S1=XXXX and S2=ZZZZ on qubits 0,1,2,3. So the final error should commute with these operators on the code space.</p>
<p>3) Additionally, the error should not change the logical state. If it commutes with the stabilizers, it will act as a logical operator on the code space. We want that logical operator to be the identity on the logical state |00&gt;. So we need that the error acts as identity on the logical state.</p>
<p>So we need to find all errors (from any location) that satisfy: 
- They commute with Z4 (so that ancilla measurement is 0)
- They commute with S1 and S2 (so that state is in code space)
- They act as identity on |00&gt; logical state.</p>
<p>If any error does not act as identity on |00&gt;, then it will reduce the fidelity.</p>
<p>Now, errors can come from different locations. They will propagate to become Pauli operators on qubits 0,1,2,3,4. Let&rsquo;s denote the final effective error as E_final. We want to know for each error location, what is the condition on the error such that E_final commutes with Z4 and with S1, S2, and acts as identity on |00&gt;.</p>
<p>Maybe we can compute the stabilizer of the ideal state during the circuit? Alternatively, we can compute the effect of single errors from each location and see if they can be undetectable.</p>
<p>Let&rsquo;s try error from location E5 first because it&rsquo;s easiest. E5 occurs after G6, so it is already at the end. E5 is on {0,4}. So E5 is a Pauli on qubits 0 and 4. For it to be undetectable, it must commute with Z4 and with S1,S2.
Commute with Z4: Z4 commutes with Paulis on qubit 4? Actually, check: If E5 has an X4 or Y4, then it will anti-commute with Z4? Because Z4 anti-commutes with X4 and Y4. So for E5 to commute with Z4, it must not include X4 or Y4. So E5 can only involve Z4 and I4. But wait, what about Paulis on qubit 0? They commute with Z4 because they act on different qubits. So E5 must be of the form: (anything on qubit 0) ⊗ (I or Z on qubit 4). But also, it must commute with S1 and S2. S1=XXXX on qubits 0,1,2,3. So E5 acts on qubit 0 and 4. For it to commute with S1, since S1 involves X on qubit 0, if E5 has an X or Y on qubit 0, then it will anti-commute with S1? Actually, careful: S1 = X0 X1 X2 X3. E5 acts on qubit 0 and 4. commute with S1 requires that the part on qubit 0 commutes with X0. So if E5 has an X0 or Y0, then it anti-commutes with X0, so would not commute with S1 unless there is something on other qubits? But wait, E5 only acts on qubit 0 and 4. So for E5 to commute with S1, the operator on qubit 0 must commute with X0. That means it should be I or Z0. Similarly, commute with S2=ZZZZ requires that the operator on qubit 0 commutes with Z0? Actually, S2 involves Z0. If E5 has a Z0, that commutes with Z0. If it has X0, that anti-commutes. So actually, for E5 to commute with both S1 and S2, the part on qubit 0 must be I only? Because if it is Z0, then it commutes with S2 but does it commute with S1? Z0 anti-commutes with X0. So yes, Z0 would anti-commute with S1. So actually, E5 must act trivially on qubit 0 as well? But wait, could it be that E5 is something like X0 X4? But then with S1: X0 X4 and X0 X1 X2 X3: commute? They act on different qubits except qubit 0. X0 X4 commutes with X0? Actually, X0 X4 and X0: commute because X0 X4 * X0 = X0^2 X4 = X4, and X0 * X0 X4 = X4, so they commute. So wait, check: E5 = X0 X4. Does it commute with S1? S1 = X0 X1 X2 X3. The commutator between X0 X4 and X0 X1 X2 X3: They commute if the number of anti-commutations is even. X0 with X0: commute. X4 with X1,X2,X3: commute because different qubits. So yes, X0 X4 commutes with S1. Now with S2: S2 = Z0 Z1 Z2 Z3. X0 X4 with Z0: anti-commute because X0 and Z0 anti-commute. So that gives one anti-commutation. But wait, X4 commutes with Z1,Z2,Z3? Yes. So overall, X0 X4 anti-commutes with S2. So that is not allowed. What about E5 = Z0 Z4? Then with S1: Z0 Z4 and X0: anti-commute because Z0 and X0 anti-1) actually, check: Z0 Z4 and X0 X1 X2 X3: Z0 anti-commutes with X0, so overall anti-commute. So that fails.
What about E5 = Y0 Y4? Then Y0 anti-commutes with X0? Actually, Y0 = i X0 Z0, so it anti-commutes with X0? Let&rsquo;s do properly: For commute with S1, we need that the operator on qubit 0 commutes with X0. So if it has any Pauli on qubit 0 that is not I, then it will anti-commute with X0 because X0 anti-commutes with Z0 and Y0? Actually, check: X0 and Z0 anti-commute. X0 and Y0: Y0 = i X0 Z0, so X0 Y0 = i X0^2 Z0 = i Z0, and Y0 X0 = i X0 Z0 X0 = -i X0^2 Z0 = -i Z0, so they anti-commute. So indeed, any non-identity on qubit 0 will anti-commute with X0. But wait, could it be that the operator on qubit 4 helps? No, because S1 does not act on qubit 4. So for E5 to commute with S1, the part on qubit 0 must be identity. Similarly, for S2, S2 acts on qubits 0,1,2,3. So the part on qubit 0 must commute with Z0. If it is X0 or Y0, then anti-commute. So indeed, for E5 to commute with both S1 and S2, the operator on qubit 0 must be I. And then on qubit 4, to commute with Z4, we need that the operator on qubit 4 commutes with Z4, so it must be I or Z4. But if it is Z4, then that is fine because Z4 commutes with Z4. But wait, check: E5 = I0 ⊗ Z4. Does that commute with S1? Yes, because it acts trivially on qubits 0-3. And with S2? Yes. And with Z4? Z4 commutes with itself. So E5 = Z4 is allowed. But does Z4 act trivially on the logical state? Let&rsquo;s check: Z4 on the ideal state. The ideal state has qubit4=0 always, so Z4|ψ⟩ = |ψ⟩ because Z4|0⟩=+|0⟩. So that is identity. So actually, E5 = Z4 is undetectable and acts as identity. What about E5 = I? That is identity. So from location E5, the only undetectable errors are those that are I or Z4 on qubit 4 (with nothing on qubit 0). But wait, could there be an error that is, say, X0 X4 something? But that would involve qubit 0 and would anti-commute with S1 or S2? Let&rsquo;s check: If E5 = X0 X4, then with S1: commute? Actually, we already did: X0 X4 and X0 X1 X2 X3: they commute because X0 and X0 commute. But with S2: X0 X4 and Z0 Z1 Z2 Z3: X0 anti-commutes with Z0, so overall anti-commute. So indeed, no.
What about E5 = Y0 Y4? Then with S1: Y0 anti-commutes with X0, so anti-commute. So no.
So for location E5, the only undetectable errors are those that are proportional to I or Z4 on qubit 4. But wait, what about errors that are on qubit 4 only? Like X4 alone? That would anti-commute with Z4, so would give measurement outcome 1, so detected. Y4 alone? Also anti-commute with Z4. So yes.
So from location E5, the undetectable errors are: I and Z4. But note: Z4 is actually a stabilizer of the ideal state? Is Z4 a stabilizer? The ideal state before measurement is not necessarily stabilized by Z4? But after measurement, we project onto Z4=+1. So effectively, Z4 becomes +1. So indeed, Z4 acts as identity on the post-selected state. So these errors do not cause logical error.
So location E5 does not contribute to logical error.</p>
<p>Now, let&rsquo;s consider location E4 on {3,4} after G5.
E4 is a Pauli on {3,4}. We need to propagate it through G6 only because it occurs after G5.
So E4 becomes: E4&rsquo; = G6 E4 G6^{-1}. G6 = CNOT_{04}. So we need to conjugate a Pauli on {3,4} by CNOT_{04}. But careful: CNOT_{04} acts on qubits 0 and 4. So it will affect any Pauli on qubit 4. It will not affect Pauli on qubit 3 because that commutes.
So let E4 = A3 * A4, where A3 acts on qubit 3 and A4 on qubit 4.
Under G6:
A3 remains unchanged.
A4 changes according to CNOT_{04} rules with control=0, target=4.
For A4:
If A4 = X4, then becomes X4? Actually, careful: CNOT_{04} X4 CNOT_{04} = X4 (since target Pauli X remains unchanged)
If A4 = Z4, then becomes Z0 Z4.
If A4 = Y4, then becomes? Y4 = i X4 Z4, so becomes i X4 (Z0 Z4) = i Z0 X4 Z4 = Z0 Y4? But careful with phase: Actually, check: CNOT_{04} Y4 CNOT_{04} = CNOT_{04} (i X4 Z4) CNOT_{04} = i (CNOT_{04} X4 CNOT_{04})(CNOT_{04} Z4 CNOT_{04}) = i (X4) (Z0 Z4) = i X4 Z0 Z4 = i Z0 X4 Z4 = Z0 (i X4 Z4) = Z0 Y4. So yes, Y4 -&gt; Z0 Y4.
So after G6, E4 becomes: A3 * (transformed A4). So it will involve qubit 0 if A4 has a Z or Y component.
Now, conditions for undetectability: 
We want the final error to commute with Z4. So we need that the resulting operator commutes with Z4.
Also, it must commute with S1 and S2 on qubits 0,1,2,3.
Let&rsquo;s consider different cases for E4.
E4 can be any Pauli on {3,4}. But remember that E4 occurs with probability p/15 for each non-identity. We want to know if any of these can become an error that is undetectable and causes a logical error.
Let&rsquo;s list possible E4 that might be undetectable.
First, if E4 = I, trivial.
If E4 has only action on qubit 3? That is, E4 = something on qubit 3 only times I4. For example, E4 = X3. Then after G6, it remains X3 because A4=I. So then the final error is X3 on qubit 3 alone. Does that commute with Z4? Yes, because it doesn&rsquo;t act on qubit 4. Does it commute with S1? S1=XXXX. X3 commutes with X3 obviously, but wait, S1 involves X0,X1,X2,X3. X3 commutes with itself, so that&rsquo;s fine. But does it commute with S2? S2=ZZZZ. X3 anti-commutes with Z3. So X3 would anti-commute with S2. So that is detectable. So E4 = X3 is detected.
What about E4 = Z3? Then remains Z3. Z3 commutes with S2? Z3 commutes with Z3, but with S1? Z3 anti-commutes with X3. So detected.
What about E4 = Y3? Then remains Y3. Y3 anti-commutes with both X3 and Z3? Actually, check: Y3 = i X3 Z3. commute with X3? X3 Y3 = i X3^2 Z3 = i Z3, Y3 X3 = i X3 Z3 X3 = -i X3^2 Z3 = -i Z3, so anti-commute. Similarly with Z3. So detected.
So if E4 acts only on qubit 3, it will be detected by either S1 or S2 because any single-qubit Pauli on a code qubit will anti-commute with at least one stabilizer? Actually, wait: Is it possible that a single-qubit Pauli on a code qubit commutes with both stabilizers? For [[4,2,2]], the stabilizers are XXXX and ZZZZ. A single-qubit Pauli, say X1, will anti-commute with ZZZZ because Z1 anti-commutes with X1. So yes, any single-qubit Pauli on a code qubit will anti-commute with one of the stabilizers. So that is detected.
So next, consider E4 that acts on both qubits 3 and 4. For example, E4 = X3 X4. Then after G6: X3 remains, X4 remains because X4 is unchanged by CNOT_{04}? Actually, check: For X4, under CNOT_{04}, X4 -&gt; X4. So overall, becomes X3 X4. Now, does this commute with Z4? X4 anti-commutes with Z4, so X3 X4 anti-commutes with Z4. So that would flip the measurement outcome? So detected by ancilla.
What about E4 = X3 Z4? Then after G6: X3 remains, Z4 -&gt; Z0 Z4. So becomes X3 Z0 Z4. Now, check commute with Z4: We need to see if this operator commutes with Z4. Consider X3 Z0 Z4 and Z4. Z4 commutes with itself, so that part is fine. But Z4 anti-commutes with? Actually, careful: The operator is on qubits 0,3,4. Z4 acts only on qubit4. So we check commutativity between Z4 and X3 Z0 Z4. Since X3 and Z0 commute with Z4, the commutativity is determined by Z4 and Z4: they commute. So actually, X3 Z0 Z4 commutes with Z4? Wait, check: (X3 Z0 Z4) Z4 = X3 Z0 Z4^2 = X3 Z0. And Z4 (X3 Z0 Z4) = Z4 X3 Z0 Z4 = X3 Z0 Z4^2 = X3 Z0. So they commute. So condition with Z4 is okay.
Now check with S1=XXXX on qubits 0,1,2,3. Our operator has X3 and Z0. Z0 anti-commutes with X0 (from S1). So overall, will it commute with S1? Let&rsquo;s check: S1 = X0 X1 X2 X3. Our operator is X3 Z0 Z4 actually wait, careful: Our operator is X3 Z0 Z4. But S1 does not act on qubit4. So we only care about the part on qubits 0,1,2,3: that is X3 Z0. Now, does X3 Z0 commute with X0 X1 X2 X3? 
X3 Z0 and X0: Z0 anti-commutes with X0, so that gives a sign flip. But wait, there is also X3 from S1 and X3 from our operator commute? Actually, let&rsquo;s do properly: 
Compute commutator [X3 Z0, X0 X1 X2 X3]. 
This is equal to? We can break it into factors that commute or anti-commute. 
X3 Z0 and X0: anti-commute because Z0 and X0 anti-commute.
X3 Z0 and X1: commute because different qubits.
X3 Z0 and X2: commute.
X3 Z0 and X3: commute? Actually, careful: X3 and X3 commute. So overall, the commutator will be that they anti-commute. So [X3 Z0, X0 X1 X2 X3] is not zero. So this operator would anti-commute with S1. So detected.
What about E4 = Z3 X4? Then after G6: Z3 remains, X4 -&gt; X4. So becomes Z3 X4. Check with Z4: X4 anti-commutes with Z4, so detected.
E4 = Z3 Z4? Then after G6: Z3 remains, Z4 -&gt; Z0 Z4, so becomes Z3 Z0 Z4. Check with Z4: That commutes with Z4 because Z4 commutes with itself and Z0,Z3 commute with Z4. Now check with S1: The part on code qubits is Z3 Z0. Does that commute with S1? S1=X0X1X2X3. Z0 anti-commutes with X0, and Z3 anti-commutes with X3? Actually, Z3 and X3 anti-commute. So product of two anti-commutations gives commute? Let&rsquo;s check: [Z0 Z3, X0 X1 X2 X3]. 
Z0 anti-commutes with X0 -&gt; sign -1.
Z3 anti-commutes with X3 -&gt; sign -1.
So overall, (-1)<em>(-1)=1, so they commute actually. So Z0 Z3 commutes with S1? Check explicitly: 
(Z0 Z3)(X0 X1 X2 X3) = Z0 X0 * Z3 X3 * X1 X2 = (-X0 Z0)</em>(-X3 Z3)<em>X1X2 = (X0 Z0)(X3 Z3)X1X2 = X0 X3 X1 X2 Z0 Z3 = (X0X1X2X3)(Z0Z3) because Z0Z3 commute with X1X2? Actually, careful: Z0 commutes with X1,X2? Yes, different qubits. So indeed, they commute. So with S1, okay.
Now check with S2=ZZZZ. S2=Z0Z1Z2Z3. Our operator has Z0Z3 on code qubits. That commutes with S2 because everything is Z&rsquo;s commute. So this operator commutes with S1 and S2. And it commutes with Z4? We already checked: Z3 Z0 Z4 commutes with Z4 because Z4 commutes with itself. So E4 = Z3 Z4 becomes after G6: Z3 Z0 Z4. So this is an undetectable error? But does it act trivially on the logical state? Let&rsquo;s check: The final error is Z3 Z0 Z4. But wait, does it involve qubit4? But after measurement, we project onto Z4=+1. So on the post-selected state, Z4 acts as identity. So effectively, the error becomes Z0 Z3 on the code qubits. So we need to check what is the logical effect of Z0 Z3 on the logical state |00&gt;. What is Z0 Z3? Is it a logical operator? The logical operators are given: Z_A = ZZII means Z0Z1? Actually, Z_A = ZZII means on qubits 0 and 1: Z0Z1. And Z_B = ZIZI means on qubits 0 and 2: Z0Z2? Wait, careful: Z_A = ZZII likely means: qubit0: Z, qubit1: Z, qubit2: I, qubit3: I. And Z_B = ZIZI means: qubit0: Z, qubit1: I, qubit2: Z, qubit3: I.
So Z0 Z3 is not one of these. What is its effect on |00&gt;? The logical |00&gt; state is (|0000⟩+|1111⟩)/√2. 
Z0 Z3 acting on |0000⟩ gives +|0000⟩ because both are 0.
Z0 Z3 acting on |1111⟩ gives (-1)</em>(-1)|1111⟩ = |1111⟩.
So actually, Z0 Z3 acts as identity on |00&gt;. So that error is harmless.
What about E4 = Y3 Y4? Then Y3 Y4. Under G6: Y3 remains, Y4 -&gt; Z0 Y4, so becomes Y3 Z0 Y4 = Z0 Y3 Y4? But then check commute with Z4? Y4 anti-commutes with Z4? Actually, careful: Y4 and Z4: Y4 = i X4 Z4, so anti-commutes with Z4? Let&rsquo;s check: Z4 Y4 = Z4 (i X4 Z4) = i Z4 X4 Z4 = i X4 Z4^2? Actually, better: use fact that Y4 anti-commutes with Z4 because Y4 has an X4 component. So likely Y3 Y4 will become something that anti-commutes with Z4? Let&rsquo;s do properly: E4 = Y3 Y4. Then after G6: 
Y3 -&gt; Y3 (unchanged)
Y4 -&gt; under CNOT_{04}, Y4 becomes Z0 Y4 (as derived).
So product becomes Y3 * (Z0 Y4) = Z0 Y3 Y4.
Now, does this commute with Z4? Consider Z0 Y3 Y4 and Z4. Z0 commutes with Z4, Y3 commutes with Z4 (different qubits), Y4 anti-commutes with Z4. So overall, anti-commute. So that would be detected by ancilla measurement.
What about E4 = X3 Y4? Then becomes X3 * (Z0 Y4) = Z0 X3 Y4. That will likely anti-commute with Z4 because of Y4. So detected.
E4 = Y3 X4? Then becomes Y3 * X4 = Y3 X4. That anti-commutes with Z4 because X4 anti-commutes with Z4? Actually, X4 and Z4 anti-commute, so detected.
So it seems that from location E4, the only potential undetectable error is E4 = Z3 Z4 (and its multiples) which becomes Z0 Z3 Z4, and that acts as Z0 Z3 on the code, which acts as identity on |00&gt;. What about E4 = I? Trivial.
So location E4 does not cause logical error.</p>
<p>Now, let&rsquo;s consider location E3 on {2,3} after G4.
E3 is on {2,3}. It will be conjugated by G5 and G6.
So we need to compute: E3&rsquo; = G6 G5 E3 (G6 G5)^{-1}.
Let&rsquo;s do step by step.
G5 = CNOT_{34} acts on {3,4}.
G6 = CNOT_{04} acts on {0,4}.
Let E3 be a Pauli on {2,3}. Write E3 = A2 * A3.
First, conjugate by G5:
Under G5, A2 is unchanged because it acts on qubit 2.
A3 changes according to CNOT_{34} rules (control=3, target=4):
If A3 = X3 -&gt; X3 X4
If A3 = Z3 -&gt; Z3
If A3 = Y3 -&gt; Y3 X4? (As before)
So after G5, E3 becomes: A2 * (transformed A3). So it may involve qubit 4.
Then conjugate by G6:
G6 acts on {0,4}. It will affect any Pauli on qubit 4 and possibly introduce qubit 0.
So let&rsquo;s compute for various cases.
We want undetectable errors. They must commute with Z4 eventually. So we want the final operator to commute with Z4.
Also commute with S1 and S2.
Let&rsquo;s consider potential candidates that might be undetectable.
Consider E3 = Z2 Z3. 
Then after G5: Z2 remains, Z3 remains -&gt; so still Z2 Z3.
Then after G6: G6 acts on {0,4}. But Z2 Z3 does not involve qubits 0 or 4, so it remains Z2 Z3.
So final error is Z2 Z3 on code qubits only. Does that commute with Z4? Yes.
Now check with S1: S1=XXXX. Z2 anti-commutes with X2? Actually, Z2 and X2 anti-commute. Z3 and X3 anti-commute. So product gives commute? Because (-1)<em>(-1)=1. So Z2 Z3 commutes with S1.
With S2: Z2 Z3 commutes with Z2 Z3 obviously, so okay.
So Z2 Z3 is undetectable? But wait, does it act trivially on |00&gt;? |00&gt; is (|0000⟩+|1111⟩)/√2. Z2 Z3 on |0000⟩ gives +1. On |1111⟩ gives (-1)</em>(-1)=+1. So it acts as identity. So that is harmless.
What about E3 = X2 X3?
After G5: X2 remains, X3 -&gt; X3 X4, so becomes X2 X3 X4.
After G6: X2 X3 X4. Under G6, X2 and X3 are unchanged because they don&rsquo;t involve 0 or 4? Actually, careful: G6 acts on {0,4}. So X2 and X3 commute with G6. X4 under G6 remains X4 (since target X is unchanged). So final is X2 X3 X4.
Now, does this commute with Z4? X4 anti-commutes with Z4, so overall anti-commute. So detected by ancilla.
What about E3 = Y2 Y3?
After G5: Y2 remains, Y3 -&gt; Y3 X4, so becomes Y2 Y3 X4.
After G6: Y2 and Y3 unchanged, X4 unchanged -&gt; so Y2 Y3 X4. Again, X4 anti-commutes with Z4, so detected.
What about E3 = X2 Z3?
After G5: X2 remains, Z3 remains -&gt; X2 Z3.
After G6: remains X2 Z3. Check with S1: X2 Z3 and X0X1X2X3: X2 commutes with itself, but Z3 anti-commutes with X3, so overall anti-commute? Actually, careful: [X2 Z3, X0X1X2X3] =? X2 and X2 commute, but Z3 and X3 anti-commute, so product gives anti-commute. So detected.
E3 = Z2 X3?
After G5: Z2 remains, X3 -&gt; X3 X4, so becomes Z2 X3 X4.
After G6: Z2 unchanged, X3 unchanged, X4 unchanged -&gt; Z2 X3 X4. Check with Z4: X4 anti-commutes with Z4, so detected.
So it seems that from location E3, the only undetectable errors are those that become something like Z2 Z3, which acts as identity on |00&gt;. What about errors that involve Paulis on qubit 2 and 3 that are not these? They seem to get an X4 factor often, which causes detection by ancilla. What about E3 = I? Trivial.
So location E3 does not cause logical error.</p>
<p>Now, location E2 on {1,0} after G3.
E2 is on {1,0}. It will be conjugated by G4, G5, G6.
G4 = CNOT_{23} acts on {2,3}
G5 = CNOT_{34} acts on {3,4}
G6 = CNOT_{04} acts on {0,4}
Let E2 be a Pauli on {1,0}. Write E2 = A1 * A0.
First, conjugate by G4: G4 acts on {2,3}. So it will not affect qubits 1 and 0 because they are different. So after G4, E2 remains A1 A0.
Then conjugate by G5: G5 acts on {3,4}. Still no effect on qubits 1,0? Actually, careful: G5 acts on qubits 3 and 4. So if A0 or A1 do not involve qubits 3 or 4, they commute. So after G5, still A1 A0.
Then conjugate by G6: G6 acts on {0,4}. This will affect any Pauli on qubit 0. So after G6, A1 remains unchanged because it acts on qubit 1. A0 changes according to CNOT_{04} rules with control=0, target=4.
So if A0 = X0 -&gt; becomes X0 X4
If A0 = Z0 -&gt; becomes Z0
If A0 = Y0 -&gt; becomes Y0 X4? (As before)
So the final error from E2 is: A1 * (transformed A0).
So it will involve qubit 4 if A0 has an X or Y component.
Now, conditions for undetectability: must commute with Z4, and with S1 and S2.
Consider E2 = Z1 Z0. 
Then after conjugation: Z1 remains, Z0 remains -&gt; becomes Z1 Z0.
So final error is Z1 Z0 on code qubits. Does that commute with Z4? Yes.
Check with S1: S1=XXXX. Z1 anti-commutes with X1, Z0 anti-commutes with X0, so product gives commute? (-1)*(-1)=1. So okay.
With S2: Z1 Z0 commutes with Z1 Z0 obviously. So undetectable.
What is the logical effect of Z1 Z0? But wait, Z_A = ZZII means Z0Z1 actually? Because Z_A = ZZII likely means on qubits 0 and 1: Z0 and Z1. So Z0Z1 is actually the logical Z operator for qubit A? But careful: The logical state |00&gt; is an eigenstate of Z_A with eigenvalue +1. So Z0Z1 acting on |00&gt; gives +1. So that is identity on |00&gt;. So harmless.
What about E2 = X1 X0?
Then after conjugation: X1 remains, X0 -&gt; becomes X0 X4 under G6. So final becomes X1 X0 X4.
This involves X4. Check with Z4: X4 anti-commutes with Z4, so detected.
E2 = Y1 Y0?
Then becomes Y1 * (Y0 becomes Y0 X4) so becomes Y1 Y0 X4. Again has X4, so detected.
E2 = X1 Z0?
Then becomes X1 * (Z0 remains) = X1 Z0. Check with S1: X1 Z0 and X0X1X2X3: X1 commutes with itself, but Z0 anti-commutes with X0, so overall anti-commute. So detected.
E2 = Z1 X0?
Then becomes Z1 * (X0 becomes X0 X4) = Z1 X0 X4. Has X4, so detected.
So from location E2, the only undetectable error is Z1 Z0, which acts as identity on |00&gt;. So no logical error.</p>
<p>Now, location E1 on {1,2} after G2.
E1 is on {1,2}. It will be conjugated by G3, G4, G5, G6.
G3 = CNOT_{10} acts on {1,0}
G4 = CNOT_{23} acts on {2,3}
G5 = CNOT_{34} acts on {3,4}
G6 = CNOT_{04} acts on {0,4}
Let E1 be a Pauli on {1,2}. Write E1 = A1 * A2.
First, conjugate by G3: G3 acts on {1,0}. So it will affect A1.
As derived earlier, under G3 (CNOT_{10}):
X1 -&gt; X1 X0
Z1 -&gt; Z1
Y1 -&gt; Y1 X0
A2 is unchanged.
So after G3, E1 becomes: (transformed A1) * A2, and it may involve qubit 0.
Then conjugate by G4: G4 acts on {2,3}. So it will affect A2.
Under G4 (CNOT_{23}):
X2 -&gt; X2 X3
Z2 -&gt; Z2
Y2 -&gt; Y2 X3
The other parts (on qubits 0,1) are unchanged.
So after G4, we get something that may involve qubit 3.
Then conjugate by G5: G5 acts on {3,4}. So it will affect any Pauli on qubit 3.
Under G5:
X3 -&gt; X3 X4
Z3 -&gt; Z3
Y3 -&gt; Y3 X4
Then conjugate by G6: G6 acts on {0,4}. So it will affect any Pauli on qubit 0 and qubit 4.
This is getting complicated. We need to find if there is any E1 that becomes an undetectable error that causes a logical error.
We want the final error to commute with Z4 and with S1,S2.
Let&rsquo;s try some likely candidates. We want errors that might become logical operators that are not identity on |00&gt;. The logical operators on |00&gt; are: 
Z_A = Z0Z1 should act as identity because |00&gt; is +1 eigenstate.
Z_B = Z0Z2? Actually, careful: Z_B = ZIZI means on qubit0 and qubit2? Because ZIZI: qubit0: Z, qubit1: I, qubit2: Z, qubit3: I. So Z_B = Z0 Z2.
X_A = XIXI = X0 X2? Actually, XIXI: qubit0: X, qubit1: I, qubit2: X, qubit3: I. So X_A = X0 X2.
X_B = XXII = X0 X1.
So logical errors that would change |00&gt; would be X_A, X_B, or products that flip to |01&gt;, |10&gt;, |11&gt;. So we want to see if any error from E1 can become, say, X0 X2 (X_A) or X0 X1 (X_B) or something like that.
Let&rsquo;s try E1 = X1 X2. 
Compute its propagation:
E1 = X1 X2.
After G3: 
X1 -&gt; becomes X1 X0 (from G3)
X2 remains -&gt; so becomes X1 X0 X2.
So after G3: X1 X0 X2.
After G4: 
G4 acts on {2,3}. 
X1 and X0 are unchanged.
X2 -&gt; becomes X2 X3 under G4.
So becomes X1 X0 X2 X3.
After G5: 
G5 acts on {3,4}.
X1, X0, X2 unchanged.
X3 -&gt; becomes X3 X4 under G5.
So becomes X1 X0 X2 X3 X4.
After G6: 
G6 acts on {0,4}.
X1, X2, X3 unchanged.
X0 -&gt; becomes X0 X4 under G6? Wait, careful: Under G6, for a Pauli on qubit 0: X0 -&gt; X0 X4.
But we already have an X4 from previous? Actually, we have X4 from the transformation of X3. So then X0 becomes X0 X4. But then we have two X4&rsquo;s? Actually, careful: The operator is X1 * X0 * X2 * X3 * X4. Under G6, we conjugate each factor separately? But careful: They commute? Actually, we should do step-by-step conjugation. But since these are Pauli operators, the conjugation will just multiply the Pauli on qubit 0 by the rule independently. So yes, X0 -&gt; X0 X4. So then the operator becomes: X1 * (X0 X4) * X2 * X3 * X4 = X1 X0 X2 X3 X4^2 = X1 X0 X2 X3 because X4^2=I.
So after G6, E1 = X1 X2 becomes X0 X1 X2 X3. But that is actually S1? Because S1 = X0 X1 X2 X3. And S1 acts as identity on the code space. So this becomes identity. So that is harmless.
What about E1 = Z1 Z2?
E1 = Z1 Z2.
After G3: 
Z1 -&gt; remains Z1 (since Z1 unchanged under G3)
Z2 -&gt; remains Z2
So still Z1 Z2.
After G4: 
Z1 unchanged, Z2 unchanged -&gt; still Z1 Z2.
After G5: 
unchanged -&gt; Z1 Z2.
After G6: 
unchanged -&gt; Z1 Z2.
So final is Z1 Z2. Does that commute with Z4? Yes.
With S1? Z1 Z2 and X0X1X2X3: Z1 anti-commutes with X1, Z2 anti-commutes with X2, so product commute? (-1)<em>(-1)=1. With S2? Z1 Z2 commutes with Z1Z2 obviously. So undetectable. And what is its logical effect? Z1 Z2 is not obviously a logical operator. But check on |00&gt;: |00&gt; = (|0000⟩+|1111⟩)/√2. Z1 Z2 on |0000⟩ gives +1. On |1111⟩ gives (-1)</em>(-1)=+1. So it acts as identity. So harmless.
What about E1 = X1 Z2?
E1 = X1 Z2.
After G3:
X1 -&gt; becomes X1 X0
Z2 -&gt; remains Z2
So becomes X1 X0 Z2.
After G4:
X1, X0 unchanged.
Z2 -&gt; remains Z2 (since Z2 unchanged under G4)
So still X1 X0 Z2.
After G5:
unchanged -&gt; X1 X0 Z2.
After G6:
X1 unchanged.
X0 -&gt; becomes X0 X4 under G6.
Z2 unchanged.
So becomes X1 (X0 X4) Z2 = X1 X0 Z2 X4.
Now, this operator: X1 X0 Z2 X4. Check with Z4: X4 anti-commutes with Z4, so detected by ancilla.
What about E1 = Z1 X2?
E1 = Z1 X2.
After G3:
Z1 -&gt; remains Z1
X2 -&gt; remains X2
So still Z1 X2.
After G4:
Z1 unchanged.
X2 -&gt; becomes X2 X3 under G4.
So becomes Z1 X2 X3.
After G5:
Z1 unchanged.
X2 unchanged.
X3 -&gt; becomes X3 X4 under G5.
So becomes Z1 X2 X3 X4.
After G6:
Z1 unchanged.
X2 unchanged.
X3 unchanged.
X4 -&gt; remains X4 under G6? Actually, careful: Under G6, X4 is unchanged because it&rsquo;s on target? Yes, rule: X4 -&gt; X4.
So becomes Z1 X2 X3 X4.
Check with Z4: X4 anti-commutes with Z4, so detected.
What about E1 = Y1 Y2? 
Y1 Y2 = (i X1 Z1)(i X2 Z2) = - X1 Z1 X2 Z2. This might become complicated. But likely it will introduce an X4 somewhere and be detected.
What about E1 = X1 alone? 
E1 = X1.
After G3: X1 -&gt; becomes X1 X0.
After G4: unchanged -&gt; X1 X0.
After G5: unchanged -&gt; X1 X0.
After G6: X1 unchanged, X0 -&gt; becomes X0 X4, so becomes X1 X0 X4.
That has X4, so detected.
E1 = Z1 alone? 
Z1 -&gt; remains Z1 through all? Check: G3: Z1 remains; G4: remains; G5: remains; G6: remains because Z1 doesn&rsquo;t involve 0 or 4. So becomes Z1. But Z1 alone on a code qubit will anti-commute with S2? Actually, S2=ZZZZ. Z1 commutes with Z1 but anti-commutes with? Wait, check: Z1 and S2: S2=Z0Z1Z2Z3. Z1 commutes with itself, so that&rsquo;s fine actually. But with S1: S1=X0X1X2X3. Z1 anti-commutes with X1. So Z1 would anti-commute with S1. So detected.
E1 = X2 alone? 
X2 -&gt; after G3: unchanged; after G4: becomes X2 X3; after G5: becomes X2 X3 X4; after G6: remains X2 X3 X4 (since X4 unchanged). That has X4, so detected.
E1 = Z2 alone? 
Z2 -&gt; remains Z2 throughout? Check: G3: unchanged; G4: unchanged; G5: unchanged; G6: unchanged. So becomes Z2. But Z2 alone: with S1, Z2 anti-commutes with X2; so detected.
So it appears that from location E1, the only undetectable errors are those that become something like Z1Z2 or X1X2 which become identity on |00&gt;. So far, from all locations, any single error seems to be either detected or act as identity on the logical state. </p>
<p>What about two errors from different locations? They could cancel each other&rsquo;s detection signals. The fidelity would then be 1 minus something of order p^2. So the logical fidelity after post-selection might be 1 - O(p^2). But wait, the question likely expects an expression in terms of p. Could it be that the fidelity is exactly 1? But then why would they ask &ldquo;as a function of p&rdquo;? Subproblem 2 gave fidelity 1. Subproblem 3 might also give fidelity 1? But then why would they add an ancilla and more gates? That suggests that the preparation might be fault-tolerant, meaning that any single error is detected. So then the only errors that survive post-selection are those that are higher order. So the infidelity would be of order p^2. So we need to find the coefficient.</p>
<p>Maybe we need to compute the probability that an error goes undetected and causes a logical error. That probability will be a function of p. And then the fidelity is 1 minus that probability.</p>
<p>So we need to find all combinations of errors from different locations that result in an overall error that is undetectable (commutes with Z4 and with S1,S2) and that acts as a non-identity logical operator on |00&gt;. And then sum their probabilities.</p>
<p>This is getting very involved. Perhaps there is a known result? Or maybe the circuit is designed such that any single error is detected, so the leading order infidelity is from two errors. And maybe the coefficient is something like? </p>
<p>Maybe we can determine that the only way to get a logical error is if errors occur on two specific locations that together act as a logical operator. For instance, consider errors that together act as X_A = X0 X2. Can that happen? Suppose we have an error from location E2 that gives something like? But we already saw that from E2, the only undetectable error was Z1Z0 which is identity on |00&gt;. What about from E1? We saw that X1X2 became S1. What about from E3? E3 gave Z2Z3 which is identity. What about from E4? E4 gave Z3Z4 which became Z0Z3, identity. What about from E5? E5 gave only Z4, identity.
So maybe no single error can become a logical operator. What about two errors? For example, consider an error from E1 and an error from E2? 
E1: suppose E1 = X1 alone? But that became X1X0X4 after propagation, which is detected because of X4. But if there is another error that cancels the X4? For instance, if we also have an error from E5 that is X4? But E5 cannot be X4 because that would be detected by ancilla? Actually, wait: E5 is on {0,4}. If we take E5 = X4 alone, then that would anti-0) actually, E5 = X4 would anti-commute with Z4, so it would cause measurement outcome 1 normally. But if combined with another error that also gives an X4, they might cancel? But careful: Errors are independent. They would both happen with probability order p. So the probability of two errors is order p^2. So that could be undetectable if the overall effect commutes with Z4.
Let&rsquo;s try: E1 = X1 and E5 = X4.
E1 = X1 propagates to: after G3: becomes X1 X0; after G4: still X1 X0; after G5: still X1 X0; after G6: X1 remains, X0 becomes X0 X4, so becomes X1 X0 X4.
So E1 gives X1 X0 X4.
E5 is on {0,4} and is X4 itself? But careful: E5 occurs after G6, so it is not conjugated by anything. So E5 = X4.
Then the overall error is (X1 X0 X4) * (X4) = X1 X0 X4^2 = X1 X0.
So overall, we get X1 X0 on the code qubits. What is that? X1 X0. Is that undetectable? Check with Z4: fine. With S1: X1 X0 and X0X1X2X3 commute? Yes, because X0 and X1 commute with themselves. With S2: X1 X0 and Z0Z1Z2Z3: X0 anti-commutes with Z0, X1 anti-commutes with Z1, so product gives commute? (-1)<em>(-1)=1. So this is undetectable. And what is its logical effect? X0 X1 is actually X_B because X_B = XXII means X0X1. So that would flip the logical state from |00&gt; to |11&gt;? Actually, wait: X_B on |00&gt; would give |11&gt;? Because logical X on both qubits would swap |00&gt; and |11&gt;. So that is a logical error. So this combination: E1 = X1 and E5 = X4 results in an overall error of X0X1, which is a logical error. 
Now, what are the probabilities? E1 = X1: probability? careful: E1 is on {1,2}. The error X1 means that on qubits {1,2}, the error is X1 ⊗ I2. That is one of the 15 Pauli errors. So its probability is p/15.
E5 = X4 means on {0,4}, the error is I0 ⊗ X4. Probability p/15.
These errors are independent. So the probability of this specific combination is (p/15)</em>(p/15) = p^2/225.
But wait, could there be other errors that yield the same overall? For instance, if E1 had been something else that gives an X4 factor and then another error cancels it? likely yes.
So the infidelity would be the sum over all such pairs that lead to a logical error. That would be order p^2.
Also, there might be pairs from other locations.
So the logical fidelity after post-selection would be 1 - C p^2 + &hellip; where C is some constant.</p>
<p>But wait, the question: &ldquo;What is the logical state fidelity &hellip; as a function of two-qubit gate error rate p?&rdquo; That suggests that the answer might be something like: F = 1 - 4p^2/15? Or something like that. But we need to compute all possible two-error combinations that cause a logical error and are undetectable.</p>
<p>This is getting very complex. Maybe the circuit is designed that only second-order errors can cause logical errors. And maybe the coefficient is determined by the number of such pairs. </p>
<p>I recall that for fault-tolerant preparation, the probability of an error not being detected is often related to the number of ways that errors can cancel. </p>
<p>Maybe we can compute the stabilizer of the circuit during its operation. The circuit prepares |00&gt; fault-tolerantly. likely the only way to get an undetectable logical error is through two errors that happen on specific pairs. </p>
<p>Given the complexity, I suspect that the intended answer might be that the fidelity is 1 because any error is detected. But wait, we already found a combination: E1=X1 and E5=X4 gives an overall X0X1 which is undetectable? But is it truly undetectable? Check: would that combination actually yield ancilla measurement outcome 0? Let&rsquo;s check that combination carefully. Suppose ideal state is |ψ&gt;. With errors, the state becomes E5 E4 &hellip; actually, careful with order: The errors occur at different times. But since they are Pauli, the overall effect is the product of the propagated errors. We found that the propagated effect of E1=X1 is X1 X0 X4. And E5=X4 is just X4. So the product is X1 X0 X4 * X4 = X1 X0. So the final state is X1 X0 |ψ&gt;. And since |ψ&gt; is in the code space and X1X0 commutes with the stabilizers, this state is also in the code space. And does it affect the ancilla measurement? The ancilla is qubit 4. But wait, our propagated errors did not include any action on qubit 4 because they cancelled out. So the state still has qubit 4 in |0&gt; because the ideal state has qubit4=0 and X1X0 does not affect qubit4. So yes, that combination would yield ancilla=0 and code space condition. So it is undetectable. And it causes a logical error because X0X1 is logical X_B which changes |00&gt; to |11&gt;. So the fidelity would not be 1; it would be 1 minus the probability of such events.</p>
<p>So then the fidelity is 1 - (number of such dangerous pairs)* (p/15)^2 + &hellip; likely.</p>
<p>Maybe there are other pairs. What about E1 = X2 and something? 
E1 = X2 alone: propagates to? E1=X2. 
After G3: unchanged -&gt; X2.
After G4: becomes X2 X3.
After G5: becomes X2 X3 X4.
After G6: remains X2 X3 X4 (since no action on these from G6 because G6 acts on 0 and4, so X2,X3 unchanged, X4 unchanged). So becomes X2 X3 X4.
To cancel the X4, we need an error that gives X4. For example, E5 = X4 again. Then product becomes X2 X3 X4 * X4 = X2 X3. Is X2 X3 undetectable? Check with S1: X2X3 commutes with X2X3? Actually, S1=X0X1X2X3. X2X3 commutes with that? Yes, because they commute with X0X1? Actually, careful: X2X3 and X0X1 commute since different qubits. So okay. With S2: X2X3 and Z0Z1Z2Z3: X2 anti-commutes with Z2, X3 anti-3) actually, X2 and Z2 anti-commute, X3 and Z3 anti-commute, so product gives commute. So X2X3 is undetectable. What is its logical effect? X2X3 is not one of the logical operators? The logical operators are X_A=X0X2 and X_B=X0X1. X2X3 is not that. But wait, could it be that X2X3 acts as identity on |00&gt;? Check: |00&gt; = (|0000⟩+|1111⟩)/√2. X2X3|0000⟩ = |0000⟩? Actually, |0000⟩ has qubits2 and3=0, so X2X3 gives |0⟩2|0⟩3? No, X2 flips qubit2, so becomes |0100⟩ actually. So that is not in the code space. So wait, careful: X2X3 acting on |00&gt; will not necessarily give a state in the code space? But we require that the error commutes with the stabilizers. If it commutes, then it maps the code space to itself. So X2X3 should map the code space to itself. But does it act as a logical operator? Let&rsquo;s check: On the basis states of the code space. The code space has basis |00&gt;,|01&gt;,|10&gt;,|11&gt;. We know that logical X_A = X0X2 and logical X_B = X0X1. What is X2X3? Consider its action on |00&gt; which is (|0000⟩+|1111⟩)/√2. X2X3|0000⟩ = |0011⟩? But |0011⟩ is not in the code space because that would be |01&gt;? Actually, wait, the code space basis states are: 
|00&gt; = (|0000⟩+|1111⟩)/√2
|01&gt; = (|0011⟩+|1100⟩)/√2
|10&gt; = (|0101⟩+|1010⟩)/√2
|11&gt; = (|0110⟩+|1001⟩)/√2.
So X2X3|0000⟩ = |0011⟩ which is actually related to |01&gt;. In fact, X2X3 might be equal to logical X something times a stabilizer? Let&rsquo;s see: S1 = X0X1X2X3. If I multiply X2X3 by S1, I get X0X1. So X2X3 = S1 * X0X1? But careful with signs: S1 * X0X1 = (X0X1X2X3)(X0X1) = X0^2 X1^2 X2X3 = X2X3. So indeed, X2X3 = S1 * X0X1. And since S1 acts as identity on the code space, X2X3 acts as X0X1 which is X_B. So yes, X2X3 is actually logical X_B as well. So that combination would also cause a logical error. So that is another pair: E1=X2 and E5=X4 gives overall X2X3 which is logical X_B.
So it seems that from location E1, any error that is a single Pauli on qubit 1 or qubit 2 might combine with an error from E5 that is X4 to yield a logical error. But wait, check: E1=X1 gave X0X1 which is X_B? Actually, X0X1 is X_B. And E1=X2 gave X2X3 which is also X_B? So both give X_B.
What about errors that yield X_A? For X_A, we need something like X0X2. Can that happen? For instance, from E2? E2=X0 would become? E2=X0 alone: 
E2=X0 on {1,0} actually careful: E2 is on {1,0}. If we take E2=X0 alone (I1 times X0), then after conjugation: remains X0 because? Let&rsquo;s check: E2=X0. After G4: unchanged -&gt; X0; after G5: unchanged -&gt; X0; after G6: X0 becomes X0X4. So becomes X0X4. To cancel X4, we need an error from somewhere that gives X4. For example, E5=X4 again. Then product becomes X0X4 * X4 = X0. But X0 alone is not undetectable because it would anti-commute with S1? Check: X0 and S1: X0 anti-commutes with X0 from S1, so detected. What about E2= something else? If we take E2=Z1? That became Z1 alone, detected already. So maybe X_A requires two errors from different locations? 
What about from E3? E3=X2 alone would become? E3=X2: 
E3=X2 on {2,3}. After G5: becomes X2? Actually, careful: E3=X2. After G5: unchanged because G5 acts on {3,4} so X2 unchanged -&gt; remains X2; after G6: unchanged -&gt; remains X2. So that is detected because alone it would anti-commute with S1? Actually, X2 alone: with S1, X2 commutes with itself actually wait: S1=X0X1X2X3. X2 commutes with X2 but anti-commutes with? Actually, no: X2 alone would anti-commute with nothing in S1 because S1 has X2 as well? Actually, check: X2 and X0X1X2X3: they commute because X2 commutes with itself. But wait, then why did we earlier say that a single-qubit Pauli on a code qubit is detected? Because for example, X1 alone would anti-commute with S2? Yes, because S2=Z0Z1Z2Z3 and X1 anti-commutes with Z1. So for X2 alone, check with S2: S2 has Z2, so X2 anti-commutes with Z2. So yes, detected. So to become undetectable, we need another error to cancel that effect. So likely, the leading order logical errors come from two errors. And the coefficient would be something like: there are several ways to get logical X_B errors. What about logical Z errors? Those would leave |00&gt; invariant because |00&gt; is eigenstate of Z. So the dangerous errors are those that act as logical X operations.</p>
<p>Given the complexity, I might need to compute the total probability of an undetectable logical error. But the question likely expects an answer like: 
F = 1 - 4p^2/15 + &hellip; 
Or something like that.</p>
<p>Maybe I can determine that the only way to get an undetectable logical error is through pairs that involve an error from E5 that is X4 and an error from another location that gives an X4 factor upon propagation that then cancels with that X4. And that seems to happen for errors on qubits 1 or 2 from location E1? What about location E2? If E2=X1 alone would become? E2=X1: 
E2=X1 on {1,0}. After conjugation: remains X1 (since no action on qubit1 from subsequent gates? Actually, careful: E2=X1. After G4: unchanged -&gt; X1; after G5: unchanged -&gt; X1; after G6: unchanged because G6 acts on {0,4} so X1 is untouched -&gt; remains X1). So that is detected because alone X1 anti-commutes with S2? So that would not be undetectable unless paired with something else that cancels the anti-commutation? But wait, if we pair it with itself? That would be two errors from same location? That would be order p^2 as well. So likely there are several combinations.</p>
<p>Given the time, I might guess that the logical fidelity is 1 because the circuit is fault-tolerant and post-selection removes all errors. But wait, we already found a counterexample: E1=X1 and E5=X4 gives an overall error that is undetectable and causes logical error. So fidelity is not 1. So it must be 1 - something*p^2.</p>
<p>I will check that combination carefully because it seems plausible:
- After G2, we have an error E1 = X1 on qubit 1 alone (and I on qubit2). 
- After G6, we have an error E5 = X4 on qubit4 alone (and I on qubit0).
These happen with probability (p/15) each.
The overall effect is that the state becomes X0X1 |ψ⟩ because propagation of E1 gives an extra X0 and X4, and then E5 gives X4, product canceling X4^2=1 leaves X0X1.
X0X1 is logical X_B which changes |00&gt; to |11&gt;. So that is a logical error.
So the probability of this specific pair is (p/15)^2.
Are there any other pairs that yield the same logical error? What about E1=X2 and E5=X4? That yields X2X3 which is also logical X_B as argued because X2X3 = S1 * X0X1, and since S1 acts as identity on the code space, that is equivalent to X0X1. So that gives another (p/15)^2.
What about errors from location E3? If E3=X3 alone would become? E3=X3: 
E3=X3 on {2,3}. After G5: becomes X3X4; after G6: remains X3X4 -&gt; so becomes X3X4. To cancel, need an error that gives X4, say E5=X4 again. Then product becomes X3X4 * X4 = X3. But X3 alone is detected because it anti-commutes with S2? So that doesn&rsquo;t work.
What about E3=Z2? That becomes Z2 alone, detected.
So likely only from E1 and E5 seem to give logical X_B errors.
What about logical X_A errors? For X_A, we need something like X0X2. Can that come from somewhere? For instance, if we have E2=X0 alone would become? E2=X0: becomes after G6: X0X4. So then with E5=X4 gives X0. But X0 alone is detected because it anti-commutes with S1? What if we also have an error from somewhere that gives an additional factor to make it commute? For example, if we have E2=X0 and also another error that gives something like? What about E1=Z2? That becomes Z2 alone, not sure.
Or consider E4=X3 alone? E4=X3 becomes after G6: remains X3? Actually, E4=X3: since E4 is on {3,4}, if it is X3 alone, then after G6 it remains X3 because X3 is untouched by G6. So that is detected.
So maybe logical X_A errors require three errors? That would be order p^3, so lower order.
So the leading order logical errors are from pairs that give logical X_B errors. How many such pairs are there? From E1, the errors that give an X4 factor upon propagation are those that involve an X on qubit1 or qubit2? Let&rsquo;s check: E1=X1 gives propagation: becomes X1 -&gt; after G3: X1X0; then after G4: still X1X0; after G5: still X1X0; after G6: X1 remains, X0 becomes X0X4, so becomes X1X0X4. So yes, that gives an X4. What about E1=Y1? Y1 would become? Y1 -&gt; after G3: becomes Y1X0; then after G4: still Y1X0; after G5: still Y1X0; after G6: Y1 remains, X0 becomes X0X4, so becomes Y1X0X4. That has X4 as well. So any error on E1 that has an X or Y on qubit1 will result in an X0 and an X4 from the conjugation? But careful: If it is Y1, then Y1 becomes Y1X0 actually wait, check: Under G3, Y1 -&gt; Y1X0. So yes, then under G6, X0 becomes X0X4, so overall becomes Y1X0X4. So that still has an X4. So then if we also have E5=X4, the product becomes Y1X0X4 * X4 = Y1X0. But Y1X0 is what? Y1X0 = (i X1Z1)X0 = i X0X1Z1. That is not necessarily a logical operator because it has Z1. Does that commute with S1 and S2? likely not. So that might be detected. So not any error on E1 works; it must be that the resulting product after canceling X4 is actually a logical operator. So we need to ensure that the overall error is in the normalizer of the stabilizers. For that, the error on E1 should be such that when propagated, it becomes something that times X4 gives a logical operator. From our earlier, E1=X1 works because it becomes X1X0X4, and with E5=X4 gives X1X0 which is logical X_B.
What about E1=Z1? That becomes Z1 alone, no X4 involved. So that won&rsquo;t combine with E5=X4 to cancel because then product would be Z1X4, which is not undetectable because X4 anti-commutes with Z4.
What about E1=X2 works because it becomes X2X3X4, and with E5=X4 gives X2X3 which is logical X_B.
What about E1=Y2? Y2 would become? Y2 -&gt; after G3: unchanged because G3 doesn&rsquo;t affect qubit2 -&gt; remains Y2; after G4: becomes Y2X3; after G5: becomes Y2X3X4; after G6: remains Y2X3X4. So with E5=X4 gives Y2X3. Is that a logical operator? Y2X3 = i X2Z2 X3 = i X2X3Z2. That likely is not in the normalizer because Z2 would anti-commute with something? Let&rsquo;s check commute with S2: S2=Z0Z1Z2Z3. Y2X3 and Z2: anti-commute? So detected. So likely only errors that are purely X on qubit1 or X on qubit2 from location E1 will combine with E5=X4 to give a logical error. Also, could there be combinations from other locations with E5? What about E2? If E2=X0 alone becomes X0X4 after G6, so with E5=X4 gives X0, which is not allowed because X0 alone is detected. What if E2= something else? If E2=X1 alone becomes X1 alone (since no conjugation affects qubit1), so with E5=X4 gives X1X4, detected because of X4. So that doesn&rsquo;t work.
What about E3? E3=X2 alone becomes X2 alone? Actually, E3=X2: after G5 remains X2; after G6 remains X2. So with E5=X4 gives X2X4, detected.
E3=X3 becomes X3X4 after G5, so with E5=X4 gives X3, detected.
E4 we already did.
So it seems that the only dangerous pairs are from E1 and E5 where E1 is either X1 or X2 ( acting on qubit1 or qubit2 alone) and E5 is X4 alone. That gives 2 possibilities. But wait, could there be also from E1 where the error is on both qubits? What about E1=X1X2? That becomes? E1=X1X2 -&gt; after G3: becomes (X1X0)(X2) = X1X0X2; after G4: becomes X1X0 (X2X3) = X1X0X2X3; after G5: becomes X1X0X2X3X4; after G6: becomes X1 (X0X4) X2X3X4 = X1X0X2X3X4^2 = X1X0X2X3. That is actually S1 times X0X1? Actually, X1X0X2X3 = (X0X1X2X3) which is S1. So that acts as identity. So that is not dangerous.
What about E1= something like that gives alone? So likely only these two.</p>
<p>Also, could there be pairs that involve errors from two different locations both from E1? That would be order p^2 as well but might cancel out? For example, E1=X1 and E1=Z2 would that work? But wait, errors from the same location are independent? They would be two errors happening at the same location? But careful: The error model: after each CNOT, there is an error channel. So you can have more than one error occurring. But they are independent. So yes, you could have two errors at location E1. But then the overall error from E1 would be the product of the two errors. That product could be something that itself propagates to give a logical error without needing an error from elsewhere. But then that would be order p^2 as well. So we should also consider that possibility. For instance, if at location E1, we have an error that is X1 and another error that is X2? But wait, careful: location E1 happens once. The error channel there applies one Pauli error with probability p/15 for each non-identity. So you cannot have two errors at the same location because that would be probability order p^2 already? Actually, wait: The error channel after a CNOT gives with probability p an error. That error is chosen uniformly from 15. So the probability of a specific error is p/15. The probability of two specific errors occurring at the same time is not possible because only one error occurs per gate. So errors at different locations are independent. So we only consider one error per location.</p>
<p>So then the only dangerous pairs are between E1 and E5 that yield logical X_B errors. That gives 2 ways. Also, could there be pairs between E? What about E2 and something? already considered.
So then the probability of an undetectable logical error would be 2*(p/15)^2 = 2p^2/225.
But wait, are there any from E1 and E5 that yield logical X_A? What would that require? For logical X_A, we need X0X2. Can we get that from E1? If E1 itself could become X0X2 something times X4, then with E5=X4 would give X0X2. For that, we need an error on E1 that involves something on qubit2 that gives an X2 term and something that gives an X0 term. But wait, E1 acts on {1,2}. To get an X0 term, that comes from the conjugation through G3 which requires an X on qubit1. So if we take E1 = X1X2, that becomes X0X1X2X3X4? Actually, we computed that becomes X0X1X2X3 after canceling X4? Actually, careful: E1=X1X2 -&gt; after propagation becomes X0X1X2X3 ( because we got X1X0X2X3X4 and then under G6, X0 becomes X0X4, so actually let&rsquo;s do that carefully:
E1 = X1X2.
After G3: X1 -&gt; becomes X1X0; X2 remains -&gt; so becomes X1X0X2.
After G4: X1,X0 unchanged; X2 -&gt; becomes X2X3 -&gt; so becomes X1X0X2X3.
After G5: becomes X1X0X2X3X4 because X3 -&gt; X3X4.
After G6: X1 unchanged; X0 -&gt; becomes X0X4; X2,X3 unchanged; X4 unchanged -&gt; so becomes X1 (X0X4) X2X3X4 = X1X0X2X3X4^2 = X1X0X2X3.
So that is S1 actually because S1=X0X1X2X3. So that acts as identity. So that doesn&rsquo;t give X0X2.
What if E1 = Y1X2? Then propagation would be messy. likely it won&rsquo;t become a clean logical operator because it would involve Z1 terms. So probably only dangerous errors are those that yield logical X_B.
Also, could there be dangerous errors from other pairs like between E3 and E5? 
E3=X2 alone becomes? Actually, E3=X2 becomes after propagation? Let&rsquo;s do E3=X2 carefully:
E3=X2 on {2,3}.
After G5: remains X2 (since G5 acts on {3,4}, so X2 unchanged) -&gt; still X2.
After G6: remains X2 because no action on qubit2 -&gt; so becomes X2.
So that is detected because alone X2 is detected? Actually, check: X2 alone with S2: X2 anti-commutes with Z2, so detected. So if we also have an error from elsewhere that cancels that? What if we have E3=X2 and also another error from E3 itself? That would be two errors at the same location, which is not possible because only one error occurs per gate. So no.
What about E3=X3? becomes X3X4 after G5, so with E5=X4 gives X3, detected.
So seems only dangerous pairs are from E1 and E5.</p>
<p>Therefore, the probability of an undetectable logical error is 2*(p/15)^2 = 2p^2/225.
But wait, could there be also from that would give logical errors from higher order? Those would be order p^3 or more, so the leading order is p^2.
So then the logical fidelity would be F = 1 - 2p^2/225 + O(p^3).</p>
<p>But is that the answer? The question asks for &ldquo;the logical state fidelity &hellip; as a function of two-qubit gate error rate p&rdquo;. That would be F = 1 - \frac{2}{225} p^2. But wait, could there be also contributions from errors that are not detected because they act as identity? Those don&rsquo;t reduce fidelity. So yes.</p>
<p>I will check one more: What about E1=Z1? That becomes Z1 alone, detected because alone Z1 anti-commutes with S1? Actually, check: Z1 with S1: Z1 anti-commutes with X1, so detected. So no.
E1=X1 works.
E1=X2 works.
So yes.</p>
<p>Therefore, the logical fidelity is 1 - 2*(p/15)^2 = 1 - 2p^2/225.</p>
<p>But wait, are there any from E5 itself? What if E5 itself is something that gives a logical error? But E5 alone cannot because that would be order p and would be detected because alone any error on E5 that is not identity or Z4 is detected because it would involve X4 or Y4 which anti-commute with Z4. So that&rsquo;s fine.</p>
<p>Thus, I will answer: 
The logical state fidelity is </p>
<div class="arithmatex">\[
F = 1 - \frac{2}{225} p^2
\]</div>
<p>.</p>
<p>I&rsquo;ll double-check: 
E1=X1: probability p/15.
E5=X4: probability p/15.
These are independent. So probability of both happening is p^2/225.
Similarly, E1=X2: p/15, and E5=X4: p/15 gives another p^2/225.
Total probability of logical error = 2p^2/225.
So fidelity = 1 - that.</p>
<p>Therefore, final answer.</p>
<p>I&rsquo;ll answer: 
\boxed{1 - \frac{2}{225}p^2}</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-1-circuit-and-error-model">🧮 Step 1: Circuit and Error Model</h3>
<p>We aim to prepare the logical state <span class="arithmatex">\( |00\rangle_{AB} \)</span> in the <span class="arithmatex">\([[4,2,2]]\)</span> code using an ancilla qubit (qubit 4). The circuit is:</p>
<div class="arithmatex">\[
M_4 \cdot \text{CNOT}_{04} \cdot \text{CNOT}_{34} \cdot \text{CNOT}_{23} \cdot \text{CNOT}_{10} \cdot \text{CNOT}_{12} \cdot H_1
\]</div>
<p>Operations are applied from right to left. The initial state is <span class="arithmatex">\( |00000\rangle \)</span>, where qubits 0–3 are data qubits and qubit 4 is the ancilla.</p>
<p>Each CNOT gate is followed by a two-qubit depolarizing error channel with error probability <span class="arithmatex">\( p \)</span>. That is, with probability <span class="arithmatex">\( p \)</span>, one of the 15 non-identity two-qubit Pauli operators is applied to the pair involved, each with probability <span class="arithmatex">\( p/15 \)</span>. Hadamard gates and measurements are perfect.</p>
<p>The circuit prepares the logical <span class="arithmatex">\( |00\rangle_{AB} \)</span> state when the ancilla measures <span class="arithmatex">\( |0\rangle \)</span>. We post-select on:
- Ancilla measurement outcome <span class="arithmatex">\( |0\rangle \)</span>,
- The state being in the code space (i.e., <span class="arithmatex">\(+1\)</span> eigenstate of stabilizers <span class="arithmatex">\( S_1 = XXXX \)</span> and <span class="arithmatex">\( S_2 = ZZZZ \)</span>).</p>
<hr />
<h3 id="step-2-fault-tolerance-and-error-propagation">🔍 Step 2: Fault-Tolerance and Error Propagation</h3>
<p>The circuit is designed to be fault-tolerant. Any single error (weight-1 Pauli) is detected either by the ancilla measurement or the code stabilizers. Thus, single errors are eliminated by post-selection.</p>
<p>However, certain pairs of errors can cancel each other’s detectable effects, resulting in an undetectable logical error. These occur at second order in <span class="arithmatex">\( p \)</span>.</p>
<p>Let <span class="arithmatex">\( E \)</span> be an error from one location and <span class="arithmatex">\( F \)</span> from another. After propagation through subsequent gates, the combined effect <span class="arithmatex">\( E \cdot F \)</span> may:
- Commute with <span class="arithmatex">\( Z_4 \)</span> (ancilla measurement remains <span class="arithmatex">\( |0\rangle \)</span>),
- Commute with <span class="arithmatex">\( S_1 \)</span> and <span class="arithmatex">\( S_2 \)</span> (state remains in code space),
- Act as a non-identity logical operator on <span class="arithmatex">\( |00\rangle_{AB} \)</span>.</p>
<p>Such errors reduce the logical fidelity.</p>
<hr />
<h3 id="step-3-dangerous-error-pairs">⚠️ Step 3: Dangerous Error Pairs</h3>
<p>Consider errors at two locations:</p>
<ul>
<li><strong>Location E1</strong>: After <span class="arithmatex">\( \text{CNOT}_{12} \)</span>, error on qubits {1,2}</li>
<li><strong>Location E5</strong>: After <span class="arithmatex">\( \text{CNOT}_{04} \)</span>, error on qubits {0,4}</li>
</ul>
<h4 id="case-1-e1-x_1">Case 1: <span class="arithmatex">\( E1 = X_1 \)</span></h4>
<ul>
<li>Propagates to <span class="arithmatex">\( X_1 X_0 X_4 \)</span></li>
<li>Combined with <span class="arithmatex">\( E5 = X_4 \)</span>:  </li>
</ul>
<div class="arithmatex">\[
  (X_1 X_0 X_4) \cdot X_4 = X_1 X_0
\]</div>
<ul>
<li><span class="arithmatex">\( X_1 X_0 \)</span> is logical <span class="arithmatex">\( X_B \)</span>, which maps <span class="arithmatex">\( |00\rangle_{AB} \to |11\rangle_{AB} \)</span></li>
</ul>
<h4 id="case-2-e1-x_2">Case 2: <span class="arithmatex">\( E1 = X_2 \)</span></h4>
<ul>
<li>Propagates to <span class="arithmatex">\( X_2 X_3 X_4 \)</span></li>
<li>Combined with <span class="arithmatex">\( E5 = X_4 \)</span>:  </li>
</ul>
<div class="arithmatex">\[
  (X_2 X_3 X_4) \cdot X_4 = X_2 X_3
\]</div>
<ul>
<li><span class="arithmatex">\( X_2 X_3 = S_1 \cdot X_0 X_1 \)</span>, and since <span class="arithmatex">\( S_1 \)</span> acts as identity on the code space, this is equivalent to <span class="arithmatex">\( X_0 X_1 = X_B \)</span></li>
</ul>
<p>In both cases, the combined error acts as logical <span class="arithmatex">\( X_B \)</span>, flipping <span class="arithmatex">\( |00\rangle_{AB} \to |11\rangle_{AB} \)</span>.</p>
<p>The probability of each specific error is <span class="arithmatex">\( p/15 \)</span>, and these events are independent. Thus, the probability of each dangerous pair is:</p>
<div class="arithmatex">\[
\left( \frac{p}{15} \right)^2 = \frac{p^2}{225}
\]</div>
<p>There are two such pairs, so the total probability of an undetectable logical error is:</p>
<div class="arithmatex">\[
2 \cdot \frac{p^2}{225} = \frac{2p^2}{225}
\]</div>
<hr />
<h3 id="step-4-logical-fidelity">✅ Step 4: Logical Fidelity</h3>
<p>The logical fidelity is the probability that the state is correct after post-selection. Since only second-order error pairs cause logical errors, we have:</p>
<div class="arithmatex">\[
F = 1 - \frac{2}{225}p^2 + \mathcal{O}(p^3)
\]</div>
<hr />
<h3 id="final-answer">🧾 Final Answer</h3>
<div class="arithmatex">\[
\boxed{1 - \frac{2}{225}p^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p>We are given that the logical state fidelity is 1 - (2/225)*p^2.
 We will return this as a SymPy expression.</p>
<p>Note: The problem states that the fidelity is a function of p, and we have derived that it is 1 - (2/225)*p^2.</p>
<p>Let&rsquo;s write the code accordingly.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>To solve this problem, we need to determine the logical state fidelity of the final 2-qubit logical state after executing a quantum circuit designed to prepare the logical state <span class="arithmatex">\( |00\rangle_{AB} \)</span> in the <span class="arithmatex">\([[4,2,2]]\)</span> code. The fidelity is expressed as a function of the two-qubit gate error rate <span class="arithmatex">\( p \)</span>, considering post-selection on both the ancilla measurement outcome and the code space.</p>
<h3 id="approach">Approach</h3>
<ol>
<li>
<p><strong>Circuit Analysis</strong>: The circuit involves several CNOT gates and a Hadamard gate, with an ancilla qubit used for error detection. Each CNOT gate is followed by a depolarizing error channel with error probability <span class="arithmatex">\( p \)</span>.</p>
</li>
<li>
<p><strong>Error Propagation</strong>: Errors from different gates can propagate through the circuit. Single errors are detected and eliminated by post-selection on the ancilla measurement and code space. However, certain pairs of errors can cancel each other&rsquo;s detectable effects, leading to undetectable logical errors.</p>
</li>
<li>
<p><strong>Dangerous Error Pairs</strong>: Specifically, errors occurring after <span class="arithmatex">\(\text{CNOT}_{12}\)</span> (E1) and <span class="arithmatex">\(\text{CNOT}_{04}\)</span> (E5) can combine to form logical errors. For example:
   - <span class="arithmatex">\( E1 = X_1 \)</span> and <span class="arithmatex">\( E5 = X_4 \)</span> propagate to <span class="arithmatex">\( X_1 X_0 \)</span>, which is logical <span class="arithmatex">\( X_B \)</span>.
   - <span class="arithmatex">\( E1 = X_2 \)</span> and <span class="arithmatex">\( E5 = X_4 \)</span> propagate to <span class="arithmatex">\( X_2 X_3 \)</span>, equivalent to logical <span class="arithmatex">\( X_B \)</span> via stabilizer <span class="arithmatex">\( S_1 \)</span>.</p>
</li>
<li>
<p><strong>Probability Calculation</strong>: Each specific error occurs with probability <span class="arithmatex">\( p/15 \)</span>. The combined probability of these dangerous pairs is <span class="arithmatex">\( 2 \times (p/15)^2 = 2p^2/225 \)</span>.</p>
</li>
<li>
<p><strong>Fidelity Calculation</strong>: The logical fidelity is then <span class="arithmatex">\( 1 \)</span> minus the probability of these undetectable logical errors, resulting in <span class="arithmatex">\( 1 - \frac{2}{225}p^2 \)</span>.</p>
</li>
</ol>
<h3 id="solution-code">Solution Code</h3>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">225</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div>

<h3 id="explanation">Explanation</h3>
<p>The function <code>answer(p)</code> computes the logical fidelity as <span class="arithmatex">\( 1 - \frac{2}{225}p^2 \)</span>. This expression accounts for the probability of undetectable logical errors arising from specific pairs of errors in the circuit. The solution leverages SymPy for symbolic computation, ensuring the result is expressed in terms of the error rate <span class="arithmatex">\( p \)</span>. The approach ensures that all single errors are detected and only second-order error pairs affect the fidelity, which is reflected in the quadratic term in <span class="arithmatex">\( p \)</span>.</p></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.435514
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>