<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><h2 id="step-1-understand-the-given-problem-and-the-state-preparation-circuit">Step 1: Understand the given problem and the state preparation circuit.</h2>
<p>The problem asks us to calculate the physical state fidelity of a 4-qubit state prepared using a specific circuit in the presence of two-qubit depolarizing errors after each <span class="arithmatex">\(CNOT\)</span> gate. The circuit is given by <span class="arithmatex">\((CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span>, and the error model is a two-qubit depolarizing channel with error probability <span class="arithmatex">\(p\)</span>.</p>
<h2 id="step-2-analyze-the-state-preparation-circuit">Step 2: Analyze the state preparation circuit.</h2>
<p>First, let&rsquo;s understand the circuit. The operations are applied from right to left: <span class="arithmatex">\(H_2\)</span>, then <span class="arithmatex">\(CNOT_{21}\)</span>, then <span class="arithmatex">\(H_0\)</span>, and finally <span class="arithmatex">\(CNOT_{03}\)</span>. <span class="arithmatex">\(H_i\)</span> denotes a Hadamard gate on qubit <span class="arithmatex">\(i\)</span>. The initial state is assumed to be <span class="arithmatex">\(|0000\rangle\)</span>.</p>
<h2 id="step-3-apply-the-operations-in-the-circuit-to-the-initial-state">Step 3: Apply the operations in the circuit to the initial state.</h2>
<ol>
<li><span class="arithmatex">\(H_2\)</span> on <span class="arithmatex">\(|0000\rangle\)</span> gives <span class="arithmatex">\(|000\rangle + |001\rangle)/\sqrt{2} = (|00\rangle + |01\rangle)/\sqrt{2} \otimes |00\rangle\)</span>.</li>
<li><span class="arithmatex">\(CNOT_{21}\)</span> gives <span class="arithmatex">\((|00\rangle + |01\rangle)/\sqrt{2} \otimes |00\rangle \rightarrow (|00\rangle|0\rangle + |01\rangle|1\rangle)/\sqrt{2} = (|000\rangle + |011\rangle)/\sqrt{2}\)</span>.</li>
<li><span class="arithmatex">\(H_0\)</span> gives <span class="arithmatex">\(((|0\rangle + |1\rangle)/\sqrt{2} \otimes |00\rangle + (|0\rangle - |1\rangle)/\sqrt{2} \otimes |11\rangle)/\sqrt{2} = (|000\rangle + |100\rangle + |011\rangle - |111\rangle)/2\)</span>.</li>
<li><span class="arithmatex">\(CNOT_{03}\)</span> gives <span class="arithmatex">\((|0000\rangle + |1000\rangle + |0110\rangle - |1110\rangle)/2\)</span>.</li>
</ol>
<h2 id="step-4-simplify-the-final-state-without-errors">Step 4: Simplify the final state without errors.</h2>
<p>Let&rsquo;s simplify the expression for the final state: <span class="arithmatex">\((|0000\rangle + |1000\rangle + |0110\rangle - |1110\rangle)/2\)</span>. This is the ideal state.</p>
<h2 id="step-5-understand-the-effect-of-the-depolarizing-error-channel-on-the-cnot-gates">Step 5: Understand the effect of the depolarizing error channel on the <span class="arithmatex">\(CNOT\)</span> gates.</h2>
<p>Each <span class="arithmatex">\(CNOT\)</span> gate is followed by a two-qubit depolarizing error channel that applies one of the 15 non-identity two-qubit Paulis with probability <span class="arithmatex">\(p/15\)</span>. The probability of no error is <span class="arithmatex">\(1 - p\)</span>.</p>
<h2 id="step-6-calculate-the-probability-of-the-state-being-correct-after-the-errors">Step 6: Calculate the probability of the state being correct after the errors.</h2>
<p>For the final state fidelity, we need to consider how the errors affect the state. The circuit has two <span class="arithmatex">\(CNOT\)</span> gates, so there are two opportunities for errors.</p>
<h2 id="step-7-analyze-the-effect-of-errors-on-the-state">Step 7: Analyze the effect of errors on the state.</h2>
<p>The error channel after each <span class="arithmatex">\(CNOT\)</span> gate can introduce errors. We need to consider the probability that the final state is correct (or equivalently, the fidelity of the final state).</p>
<h2 id="step-8-compute-the-fidelity-of-the-final-state">Step 8: Compute the fidelity of the final state.</h2>
<p>The fidelity <span class="arithmatex">\(F\)</span> of the final state can be related to the probability of no error or errors that do not affect the logical state. However, given the depolarizing noise model, we directly calculate the effect of errors on the state.</p>
<p>For a single <span class="arithmatex">\(CNOT\)</span> gate with depolarizing noise, the output density matrix <span class="arithmatex">\(\rho'\)</span> is given by <span class="arithmatex">\(\rho' = (1-p)\rho + \frac{p}{15}\sum_{i=1}^{15} P_i \rho P_i\)</span>, where <span class="arithmatex">\(P_i\)</span> are the 15 non-identity two-qubit Paulis.</p>
<h2 id="step-9-calculate-the-overall-fidelity-considering-both-cnot-gates">Step 9: Calculate the overall fidelity considering both <span class="arithmatex">\(CNOT\)</span> gates.</h2>
<p>Let&rsquo;s denote the initial state as <span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>. After applying <span class="arithmatex">\(H_2\)</span>, <span class="arithmatex">\(CNOT_{21}\)</span>, <span class="arithmatex">\(H_0\)</span>, and <span class="arithmatex">\(CNOT_{03}\)</span> without errors, we get the ideal final state <span class="arithmatex">\(\rho_{ideal}\)</span>. With errors, the state after the first <span class="arithmatex">\(CNOT\)</span> (<span class="arithmatex">\(CNOT_{21}\)</span>) is <span class="arithmatex">\(\rho_1 = (1-p)CNOT_{21}H_2\rho_0H_2CNOT_{21} + \frac{p}{15}\sum_{i=1}^{15} P_i CNOT_{21}H_2\rho_0H_2CNOT_{21}P_i\)</span>. After <span class="arithmatex">\(H_0\)</span> and the second <span class="arithmatex">\(CNOT\)</span> (<span class="arithmatex">\(CNOT_{03}\)</span>), we apply a similar transformation.</p>
<h2 id="step-10-simplify-the-calculation-by-directly-considering-the-effect-of-p-on-the-fidelity">Step 10: Simplify the calculation by directly considering the effect of <span class="arithmatex">\(p\)</span> on the fidelity.</h2>
<p>The fidelity of the final state is given by <span class="arithmatex">\(F = \langle\psi_{ideal}|\rho_{final}|\psi_{ideal}\rangle\)</span>, where <span class="arithmatex">\(\rho_{final}\)</span> is the density matrix of the final state with errors.</p>
<h2 id="step-11-calculate-the-fidelity-using-the-error-model">Step 11: Calculate the fidelity using the error model.</h2>
<p>For two <span class="arithmatex">\(CNOT\)</span> gates, the probability of no error is <span class="arithmatex">\((1-p)^2\)</span>. The fidelity can be approximated by considering the effect of errors on the state. However, the exact fidelity calculation involves considering all possible error combinations and their effects.</p>
<h2 id="step-12-derive-the-expression-for-the-physical-state-fidelity-as-a-function-of-p">Step 12: Derive the expression for the physical state fidelity as a function of <span class="arithmatex">\(p\)</span>.</h2>
<p>Given that each <span class="arithmatex">\(CNOT\)</span> gate is followed by a depolarizing channel, and there are two such gates, the overall fidelity can be related to the probability of error <span class="arithmatex">\(p\)</span>. The fidelity <span class="arithmatex">\(F = (1-p)^2\)</span> because the errors are independent, and we are considering the probability that both gates are error-free.</p>
<p>The final answer is: <span class="arithmatex">\(\boxed{(1-p)^2}\)</span></p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><h2 id="step-1-understand-the-given-problem-and-the-state-preparation-circuit">Step 1: Understand the given problem and the state preparation circuit.</h2>
<p>The problem asks us to calculate the logical state fidelity of a 2-qubit logical state prepared using a specific circuit in the [[4,2,2]] code, with the state post-selected on all detectable errors. The circuit is given by <span class="arithmatex">\((CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span>.</p>
<h2 id="step-2-analyze-the-effect-of-the-circuit-on-the-logical-qubits">Step 2: Analyze the effect of the circuit on the logical qubits.</h2>
<p>First, we need to understand how the given circuit affects the logical qubits. The initial state is <span class="arithmatex">\(|00\rangle_{AB}\)</span>, and we aim to prepare <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>.</p>
<h2 id="step-3-understand-the-logical-operations-performed-by-the-circuit">Step 3: Understand the logical operations performed by the circuit.</h2>
<p><span class="arithmatex">\(H_2\)</span> acts on the physical qubit 2. <span class="arithmatex">\(CNOT_{21}\)</span> then acts on qubits 2 and 1. <span class="arithmatex">\(H_0\)</span> acts on qubit 0, and <span class="arithmatex">\(CNOT_{03}\)</span> acts on qubits 0 and 3.</p>
<h2 id="step-4-translate-the-physical-operations-into-logical-operations">Step 4: Translate the physical operations into logical operations.</h2>
<p>To prepare the logical GHZ state, we need to understand how these physical operations translate into logical operations on qubits A and B.</p>
<h2 id="step-5-determine-the-logical-state-after-the-circuit">Step 5: Determine the logical state after the circuit.</h2>
<p>The logical <span class="arithmatex">\(X\)</span> operators are <span class="arithmatex">\(X_A = XIXI\)</span> and <span class="arithmatex">\(X_B = XXII\)</span>. The circuit&rsquo;s effect on the logical state can be understood by analyzing how it transforms the logical operators.</p>
<h2 id="step-6-analyze-the-error-detection-capability-of-the-422-code">Step 6: Analyze the error detection capability of the [[4,2,2]] code.</h2>
<p>The [[4,2,2]] code can detect single-qubit errors (among other errors) because its stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, allowing it to detect errors that anti-commute with these stabilizers.</p>
<h2 id="step-7-understand-the-effect-of-post-selection-on-detectable-errors">Step 7: Understand the effect of post-selection on detectable errors.</h2>
<p>Post-selecting on detectable errors means we discard states where errors are detected. This changes the probability distribution of the remaining states.</p>
<h2 id="step-8-calculate-the-logical-fidelity-after-post-selection">Step 8: Calculate the logical fidelity after post-selection.</h2>
<p>The logical fidelity is the probability that the logical state is correct given that no detectable error is observed. We need to consider how the two-qubit depolarizing errors after each <span class="arithmatex">\(CNOT\)</span> gate affect the logical state and how post-selection changes this.</p>
<h2 id="step-9-derive-the-expression-for-the-logical-state-fidelity-as-a-function-of-p">Step 9: Derive the expression for the logical state fidelity as a function of <span class="arithmatex">\(p\)</span>.</h2>
<p>To calculate the logical fidelity, we consider the probability of errors that are not detectable and affect the logical state. The [[4,2,2]] code detects single-qubit errors but not all two-qubit errors.</p>
<h2 id="step-10-simplify-the-calculation-by-focusing-on-the-relevant-error-probabilities">Step 10: Simplify the calculation by focusing on the relevant error probabilities.</h2>
<p>For the logical GHZ state, errors that affect the logical state fidelity are those that are not detectable. We need to consider the probability of such errors.</p>
<h2 id="step-11-compute-the-logical-fidelity">Step 11: Compute the logical fidelity.</h2>
<p>The probability of a two-qubit error (after a <span class="arithmatex">\(CNOT\)</span>) is <span class="arithmatex">\(p\)</span>. Some of these errors are detectable, and some are not. The code detects errors that anti-commute with <span class="arithmatex">\(XXXX\)</span> or <span class="arithmatex">\(ZZZZ\)</span>.</p>
<h2 id="step-12-calculate-the-final-logical-fidelity">Step 12: Calculate the final logical fidelity.</h2>
<p>Let&rsquo;s directly analyze the effect of <span class="arithmatex">\(p\)</span> on the logical fidelity. The circuit has two <span class="arithmatex">\(CNOT\)</span> gates. Errors after these gates can be detectable or not. Post-selection removes states with detectable errors.</p>
<p>The final answer is: <span class="arithmatex">\(\boxed{1}\)</span></p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>

<span class="n">F_logical</span> <span class="o">=</span> <span class="n">answer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">F_logical</span><span class="p">)</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.638940
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>