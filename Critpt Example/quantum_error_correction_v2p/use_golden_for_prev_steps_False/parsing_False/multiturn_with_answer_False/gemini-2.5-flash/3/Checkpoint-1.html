<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>My Thinking on Calculating Fidelity in a Noisy Quantum Circuit</strong></p>
<p>My goal is to figure out how well a prepared four-qubit state survives a circuit designed to create it, particularly given the presence of depolarizing noise on the two-qubit CNOT gates. I&rsquo;m starting with a specific circuit â€“ a Hadamard on qubit 2, a CNOT from qubit 2 to qubit 1, a Hadamard on qubit 0, and a CNOT from qubit 0 to qubit 3. The circuit aims to prepare a logical GHZ state (a superposition of |00&gt; and |11&gt; across two logical qubits), but I need to represent this in terms of the four physical qubits (0, 1, 2, and 3) used in the circuit.</p>
<p>The problem defines a specific encoding for logical qubits A and B using the four physical qubits, and provides stabilizers (<span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>) as well as logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators. After some checking, I&rsquo;ve confirmed that these logical operators are correctly constructed and satisfy the necessary commutation relations with the stabilizers, which means they are a valid representation of the logical qubits. Based on the code structure, I am using logical operators:
<span class="arithmatex">\(X_A = X_0 I_1 X_2 I_3\)</span>
<span class="arithmatex">\(X_B = X_0 X_1 I_2 I_3\)</span>
<span class="arithmatex">\(Z_A = Z_0 Z_1 I_2 I_3\)</span>
<span class="arithmatex">\(Z_B = Z_0 I_1 Z_2 I_3\)</span>
I need to find the physical state that represents the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state, which is stabilized by logical Z operators. I carefully construct the initial state in the physical four-qubit space, and calculate the target state for the given state preparation circuit. This calculation involves finding eigenstates of the stabilisers and logical operators.
My analysis leads to the physical state:</p>
<p><span class="arithmatex">\(|00\rangle_{L} = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span>, and
<span class="arithmatex">\(|11\rangle_{L} = \frac{1}{\sqrt{2}}(|0110\rangle + |1001\rangle)\)</span>.</p>
<p>and for the logical GHZ state:</p>
<p><span class="arithmatex">\(|\psi_{target}\rangle = \frac{1}{2}(|0000\rangle + |1111\rangle + |0110\rangle + |1001\rangle)\)</span></p>
<p>The next challenge is accounting for the noise. The CNOT gates in the circuit are followed by two-qubit depolarizing channels, so I need to compute the final state by applying the depolarizing channels. The Hadamard gates are assumed to be perfect. Depolarizing channels scramble the quantum state by introducing a mixture of Pauli operators. For this, I am using the standard formula for fidelity: <span class="arithmatex">\(\text{Tr}(\rho_{target} \rho_{final})\)</span>. I need to figure out what happens to the state, step-by-step, as it goes through the circuit and the two CNOT depolarizing gates.</p>
<p>The noise adds complexities:</p>
<ol>
<li>The first CNOT and its error.</li>
<li>The Hadamard gate on the 0 qubit.</li>
<li>The second CNOT and its noise.</li>
<li>The target state I need to find the fidelity to.
I&rsquo;m carefully considering how each gate and error channel affects the state. Specifically, I know that the noisy state will become a sum of all possible Pauli errors.</li>
</ol>
<p>I&rsquo;ve worked to correctly derive the state after each channel, and then to properly compute the fidelity. The end results I get after all these calculations is a formula:
<span class="arithmatex">\(F = 1 - \frac{8p}{5} + \frac{16p^2}{25}\)</span>.
This reduces to  <span class="arithmatex">\(F = (1 - \frac{4p}{5})^2\)</span>, where <span class="arithmatex">\(p\)</span> is the error rate. This provides a clear mathematical expression of fidelity as a function of the noise strength, and it&rsquo;s something I can use to understand the performance of this circuit under depolarizing noise.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>The problem asks for the physical state fidelity of the final 4-qubit state after a given state preparation circuit, subjected to depolarizing errors.</p>
<p><strong>1. Determine the target physical state:</strong>
The goal is to prepare the logical two-qubit GHZ state <span class="arithmatex">\(|\psi_{GHZ}\rangle_L = \frac{1}{\sqrt{2}}(|00\rangle_{AB}+|11\rangle_{AB})\)</span>.
First, we need to find the physical representations of the logical basis states <span class="arithmatex">\(|00\rangle_{AB}\)</span> and <span class="arithmatex">\(|11\rangle_{AB}\)</span>. These states must be in the <span class="arithmatex">\(+1\)</span> eigenspace of the stabilizers <span class="arithmatex">\(S_1 = X_0 X_1 X_2 X_3\)</span> and <span class="arithmatex">\(S_2 = Z_0 Z_1 Z_2 Z_3\)</span>.
The logical state <span class="arithmatex">\(|00\rangle_{AB}\)</span> is a <span class="arithmatex">\(+1\)</span> eigenstate of <span class="arithmatex">\(Z_A = Z_0 Z_1 I_2 I_3\)</span> and <span class="arithmatex">\(Z_B = Z_0 I_1 Z_2 I_3\)</span>.
For a Z-basis state <span class="arithmatex">\(|q_0 q_1 q_2 q_3\rangle\)</span> to be a <span class="arithmatex">\(+1\)</span> eigenstate of <span class="arithmatex">\(Z_0Z_1\)</span> and <span class="arithmatex">\(Z_0Z_2\)</span>:
<span class="arithmatex">\(Z_0Z_1|q_0 q_1 q_2 q_3\rangle = |q_0 q_1 q_2 q_3\rangle \implies (-1)^{q_0+q_1} = 1 \implies q_0+q_1\)</span> is even (i.e., <span class="arithmatex">\(q_0=q_1\)</span>).
<span class="arithmatex">\(Z_0Z_2|q_0 q_1 q_2 q_3\rangle = |q_0 q_1 q_2 q_3\rangle \implies (-1)^{q_0+q_2} = 1 \implies q_0=q_2\)</span>.
From <span class="arithmatex">\(S_2 = Z_0Z_1Z_2Z_3 = I\)</span>, and <span class="arithmatex">\(q_0=q_1=q_2\)</span>, we have <span class="arithmatex">\(Z_0Z_0Z_0Z_3 = I \implies Z_0Z_3 = I \implies q_0=q_3\)</span>.
So, any Z-basis state satisfying these conditions must be of the form <span class="arithmatex">\(|cccc\rangle\)</span>.
Now, apply the <span class="arithmatex">\(S_1 = X_0X_1X_2X_3\)</span> condition. <span class="arithmatex">\(S_1|0000\rangle = |1111\rangle\)</span> and <span class="arithmatex">\(S_1|1111\rangle = |0000\rangle\)</span>.
To be a <span class="arithmatex">\(+1\)</span> eigenstate of <span class="arithmatex">\(S_1\)</span>, the state must be a superposition:
<span class="arithmatex">\(|00\rangle_{AB} = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span>.</p>
<p>The logical state <span class="arithmatex">\(|11\rangle_{AB}\)</span> is a <span class="arithmatex">\(-1\)</span> eigenstate of <span class="arithmatex">\(Z_A\)</span> and <span class="arithmatex">\(Z_B\)</span>.
<span class="arithmatex">\(Z_0Z_1|q_0 q_1 q_2 q_3\rangle = -|q_0 q_1 q_2 q_3\rangle \implies q_0 \ne q_1\)</span>.
<span class="arithmatex">\(Z_0Z_2|q_0 q_1 q_2 q_3\rangle = -|q_0 q_1 q_2 q_3\rangle \implies q_0 \ne q_2\)</span>.
From <span class="arithmatex">\(S_2 = Z_0Z_1Z_2Z_3 = I\)</span>, we use <span class="arithmatex">\(Z_0Z_1 = -I\)</span> and <span class="arithmatex">\(Z_0Z_2 = -I\)</span>:
<span class="arithmatex">\((Z_0Z_1)(Z_0Z_2)Z_0Z_3 = I \implies (-I)(-I)Z_0Z_3 = I \implies Z_0Z_3 = I \implies q_0 = q_3\)</span>.
This implies that <span class="arithmatex">\(q_0=q_3\)</span>, <span class="arithmatex">\(q_0 \ne q_1\)</span>, <span class="arithmatex">\(q_0 \ne q_2\)</span>.
Example basis states: <span class="arithmatex">\(|0110\rangle\)</span> or <span class="arithmatex">\(|1001\rangle\)</span>.
Check <span class="arithmatex">\(S_1\)</span> action: <span class="arithmatex">\(S_1|0110\rangle = |1001\rangle\)</span>.
So, <span class="arithmatex">\(|11\rangle_{AB} = \frac{1}{\sqrt{2}}(|0110\rangle + |1001\rangle)\)</span>.</p>
<p>The target logical GHZ state is thus:</p>
<div class="arithmatex">\[
|\psi_{target}\rangle = \frac{1}{\sqrt{2}}(|00\rangle_{AB} + |11\rangle_{AB}) = \frac{1}{2}(|0000\rangle + |1111\rangle + |0110\rangle + |1001\rangle)
\]</div>
<p><strong>2. Verify the circuit prepares the target state from <span class="arithmatex">\(|0000\rangle\)</span> (physical):</strong>
The circuit operations (from right to left) are <span class="arithmatex">\(H_2\)</span>, <span class="arithmatex">\(CNOT_{21}\)</span>, <span class="arithmatex">\(H_0\)</span>, <span class="arithmatex">\(CNOT_{03}\)</span>.
Starting with <span class="arithmatex">\(|\psi_{in}\rangle = |0000\rangle\)</span>:</p>
<ol>
<li><span class="arithmatex">\(H_2|0000\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)\)</span>.</li>
<li><span class="arithmatex">\(CNOT_{21}\left(\frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)\right) = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\)</span>. (Qubit 1 is target, Qubit 2 is control)</li>
<li><span class="arithmatex">\(H_0\left(\frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\right) = \frac{1}{2}((|0000\rangle + |1000\rangle) + (|0110\rangle + |1110\rangle))\)</span>.</li>
<li><span class="arithmatex">\(CNOT_{03}\left(\frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)\right) = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)\)</span>. (Qubit 3 is target, Qubit 0 is control)
This final state is precisely <span class="arithmatex">\(|\psi_{target}\rangle\)</span>.</li>
</ol>
<p><strong>3. Analyze the error model and calculate fidelity:</strong>
Each <span class="arithmatex">\(CNOT_{ij}\)</span> gate is followed by a two-qubit depolarizing error channel, <span class="arithmatex">\(\mathcal{D}(\rho) = (1-p)\rho + \frac{p}{15} \sum_{P \in \mathcal{P}_2^*} P \rho P\)</span>, where <span class="arithmatex">\(\mathcal{P}_2^*\)</span> is the set of 15 non-identity two-qubit Pauli operators.
There are two <span class="arithmatex">\(CNOT\)</span> gates: <span class="arithmatex">\(CNOT_{21}\)</span> and <span class="arithmatex">\(CNOT_{03}\)</span>. The Hadamard gates are assumed perfect.
Let <span class="arithmatex">\(U_1=H_2\)</span>, <span class="arithmatex">\(U_2=CNOT_{21}\)</span>, <span class="arithmatex">\(U_3=H_0\)</span>, <span class="arithmatex">\(U_4=CNOT_{03}\)</span>.
The initial state is <span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>.
The overall evolution is <span class="arithmatex">\(\rho_{final} = \mathcal{D}_{03}(U_4 U_3 \mathcal{D}_{21}(U_2 U_1 \rho_0 U_1^\dagger U_2^\dagger) U_3^\dagger U_4^\dagger)\)</span>.
Let <span class="arithmatex">\(\rho_{ideal} = U_4 U_3 U_2 U_1 \rho_0 U_1^\dagger U_2^\dagger U_3^\dagger U_4^\dagger = |\psi_{target}\rangle\langle\psi_{target}|\)</span>.
The physical state fidelity is <span class="arithmatex">\(F = \text{Tr}(\rho_{ideal} \rho_{final}) = \langle \psi_{target} | \rho_{final} | \psi_{target} \rangle\)</span>.</p>
<p>Let&rsquo;s expand <span class="arithmatex">\(\rho_{final}\)</span>:
Define <span class="arithmatex">\(\rho_A = U_2 U_1 \rho_0 U_1^\dagger U_2^\dagger\)</span>. This is the ideal state before the first error.
Then <span class="arithmatex">\(\mathcal{D}_{21}(\rho_A) = (1-p)\rho_A + \frac{p}{15} \sum_{P_{21}^*} P_{21} \rho_A P_{21}\)</span>.
Next, <span class="arithmatex">\(\rho_B = U_3 \mathcal{D}_{21}(\rho_A) U_3^\dagger = (1-p) U_3 \rho_A U_3^\dagger + \frac{p}{15} \sum_{P_{21}^*} U_3 P_{21} \rho_A P_{21} U_3^\dagger\)</span>.
Since <span class="arithmatex">\(U_3=H_0\)</span> acts on qubit 0 and <span class="arithmatex">\(P_{21}\)</span> acts on qubits 1 and 2, <span class="arithmatex">\(U_3\)</span> commutes with <span class="arithmatex">\(P_{21}\)</span>. So <span class="arithmatex">\(U_3 P_{21} U_3^\dagger = P_{21}\)</span>.
Let <span class="arithmatex">\(\rho_C = U_3 \rho_A U_3^\dagger\)</span>. This is the ideal state after <span class="arithmatex">\(H_0\)</span> and before the <span class="arithmatex">\(CNOT_{03}\)</span>.
So <span class="arithmatex">\(\rho_B = (1-p)\rho_C + \frac{p}{15} \sum_{P_{21}^*} P_{21} \rho_C P_{21}\)</span>.
Finally, <span class="arithmatex">\(\rho_{final} = \mathcal{D}_{03}(U_4 \rho_B U_4^\dagger) = (1-p) U_4 \rho_B U_4^\dagger + \frac{p}{15} \sum_{P_{03}^*} P_{03} U_4 \rho_B U_4^\dagger P_{03}\)</span>.
Substitute <span class="arithmatex">\(\rho_B\)</span>:
<span class="arithmatex">\(\rho_{final} = (1-p) U_4 \left[ (1-p)\rho_C + \frac{p}{15} \sum_{P_{21}^*} P_{21} \rho_C P_{21} \right] U_4^\dagger + \frac{p}{15} \sum_{P_{03}^*} P_{03} U_4 \left[ (1-p)\rho_C + \frac{p}{15} \sum_{P_{21}^*} P_{21} \rho_C P_{21} \right] U_4^\dagger P_{03}\)</span>.
Let <span class="arithmatex">\(\rho_T = U_4 \rho_C U_4^\dagger = |\psi_{target}\rangle\langle\psi_{target}|\)</span>.
Note that <span class="arithmatex">\(U_4=CNOT_{03}\)</span> acts on qubits 0 and 3. <span class="arithmatex">\(P_{21}\)</span> acts on qubits 1 and 2. Thus <span class="arithmatex">\(U_4\)</span> commutes with <span class="arithmatex">\(P_{21}\)</span>.
So <span class="arithmatex">\(U_4 P_{21} \rho_C P_{21} U_4^\dagger = P_{21} (U_4 \rho_C U_4^\dagger) P_{21} = P_{21} \rho_T P_{21}\)</span>.
Thus, <span class="arithmatex">\(\rho_{final} = (1-p) \left[ (1-p)\rho_T + \frac{p}{15} \sum_{P_{21}^*} P_{21} \rho_T P_{21} \right] + \frac{p}{15} \sum_{P_{03}^*} P_{03} \left[ (1-p)\rho_T + \frac{p}{15} \sum_{P_{21}^*} P_{21} \rho_T P_{21} \right] P_{03}\)</span>.
The fidelity is <span class="arithmatex">\(F = \text{Tr}(\rho_T \rho_{final})\)</span>.
Using <span class="arithmatex">\(\text{Tr}(\rho_T P_1 \rho_T P_2) = \text{Tr}(\rho_T P_1 \rho_T P_1 P_1 P_2) = \langle \psi_{target} | P_1 | \psi_{target} \rangle \langle \psi_{target} | P_2 | \psi_{target} \rangle\)</span> if <span class="arithmatex">\(P_1\)</span> and <span class="arithmatex">\(P_2\)</span> are independent, or more simply, <span class="arithmatex">\(\text{Tr}(\rho_T P_i \rho_T P_i) = |\langle \psi_{target} | P_i | \psi_{target} \rangle|^2\)</span>.
<span class="arithmatex">\(F = (1-p)^2 \text{Tr}(\rho_T \rho_T) + (1-p)\frac{p}{15} \sum_{P_{21}^*} \text{Tr}(\rho_T P_{21} \rho_T P_{21}) + \frac{p}{15}(1-p) \sum_{P_{03}^*} \text{Tr}(\rho_T P_{03} \rho_T P_{03}) + \left(\frac{p}{15}\right)^2 \sum_{P_{03}^*} \sum_{P_{21}^*} \text{Tr}(\rho_T P_{03} P_{21} \rho_T P_{21} P_{03})\)</span>.
Since <span class="arithmatex">\(\rho_T\)</span> is a pure state, <span class="arithmatex">\(\text{Tr}(\rho_T \rho_T) = 1\)</span>. The other terms are <span class="arithmatex">\(|\langle \psi_{target} | P | \psi_{target} \rangle|^2\)</span>.
<span class="arithmatex">\(F = (1-p)^2 + (1-p)\frac{p}{15} \sum_{P_{21}^*} |\langle \psi_{target} | P_{21} | \psi_{target} \rangle|^2 + \frac{p}{15}(1-p) \sum_{P_{03}^*} |\langle \psi_{target} | P_{03} | \psi_{target} \rangle|^2 + \left(\frac{p}{15}\right)^2 \sum_{P_1 \in \mathcal{P}_{03}^*} \sum_{P_2 \in \mathcal{P}_{21}^*} |\langle \psi_{target} | P_1 P_2 | \psi_{target} \rangle|^2\)</span>.</p>
<p><strong>4. Calculate the overlaps <span class="arithmatex">\(\langle \psi_{target} | P | \psi_{target} \rangle\)</span>:</strong>
<span class="arithmatex">\(|\psi_{target}\rangle = \frac{1}{2}(|0000\rangle + |1111\rangle + |0110\rangle + |1001\rangle)\)</span>.
An overlap <span class="arithmatex">\(\langle \psi_{target} | P | \psi_{target} \rangle\)</span> is non-zero only if <span class="arithmatex">\(P|\psi_{target}\rangle = \pm |\psi_{target}\rangle\)</span>. Such operators are in the stabilizer group of <span class="arithmatex">\(|\psi_{target}\rangle\)</span>.
The stabilizer group <span class="arithmatex">\(\mathcal{G}\)</span> of <span class="arithmatex">\(|\psi_{target}\rangle\)</span> is generated by:
<span class="arithmatex">\(g_1 = X_0X_1X_2X_3\)</span> (from <span class="arithmatex">\(S_1\)</span>)
<span class="arithmatex">\(g_2 = Z_0Z_1Z_2Z_3\)</span> (from <span class="arithmatex">\(S_2\)</span>)
<span class="arithmatex">\(g_3 = X_A X_B = X_0 I_1 X_2 I_3 X_0 X_1 I_2 I_3 = I_0 X_1 X_2 I_3\)</span> (physical <span class="arithmatex">\(X_1X_2\)</span>)
<span class="arithmatex">\(g_4 = Z_A Z_B = Z_0 Z_1 I_2 I_3 Z_0 I_1 Z_2 I_3 = I_0 Z_1 Z_2 I_3\)</span> (physical <span class="arithmatex">\(Z_1Z_2\)</span>)
Any product of these generators, including <span class="arithmatex">\(I\)</span>, will result in <span class="arithmatex">\(P|\psi_{target}\rangle = \pm |\psi_{target}\rangle\)</span>, meaning <span class="arithmatex">\(|\langle \psi_{target} | P | \psi_{target} \rangle|^2 = 1\)</span>. Otherwise, the overlap is 0.
The elements of <span class="arithmatex">\(\mathcal{G}\)</span> are <span class="arithmatex">\(I, g_1, g_2, g_3, g_4\)</span> and their products (16 elements).</p>
<ul>
<li>
<p><strong>Sum for <span class="arithmatex">\(P_{21}^*\)</span> (acting on <span class="arithmatex">\(q_1,q_2\)</span>):</strong>
    The elements of <span class="arithmatex">\(\mathcal{G}\)</span> that act only on <span class="arithmatex">\(q_1,q_2\)</span> are <span class="arithmatex">\(I, X_1X_2, Z_1Z_2, Y_1Y_2\)</span>.
    The non-identity ones are <span class="arithmatex">\(X_1X_2, Z_1Z_2, Y_1Y_2\)</span>. There are 3 such Paulis in <span class="arithmatex">\(\mathcal{P}_{21}^*\)</span>.
    For these 3 Paulis, <span class="arithmatex">\(|\langle \psi_{target} | P | \psi_{target} \rangle|^2 = 1\)</span>. For the other <span class="arithmatex">\(15-3=12\)</span> Paulis, it&rsquo;s 0.
    So, <span class="arithmatex">\(\sum_{P_{21}^*} |\langle \psi_{target} | P_{21} | \psi_{target} \rangle|^2 = 3\)</span>.</p>
</li>
<li>
<p><strong>Sum for <span class="arithmatex">\(P_{03}^*\)</span> (acting on <span class="arithmatex">\(q_0,q_3\)</span>):</strong>
    The elements of <span class="arithmatex">\(\mathcal{G}\)</span> that act only on <span class="arithmatex">\(q_0,q_3\)</span> are <span class="arithmatex">\(I, g_1 g_3 = (X_0X_1X_2X_3)(X_1X_2) = X_0X_3\)</span>, <span class="arithmatex">\(g_2 g_4 = (Z_0Z_1Z_2Z_3)(Z_1Z_2) = Z_0Z_3\)</span>, and <span class="arithmatex">\((g_1g_3)(g_2g_4) = X_0X_3Z_0Z_3 = Y_0Y_3\)</span>.
    The non-identity ones are <span class="arithmatex">\(X_0X_3, Z_0Z_3, Y_0Y_3\)</span>. There are 3 such Paulis in <span class="arithmatex">\(\mathcal{P}_{03}^*\)</span>.
    For these 3 Paulis, <span class="arithmatex">\(|\langle \psi_{target} | P | \psi_{target} \rangle|^2 = 1\)</span>. For the other <span class="arithmatex">\(15-3=12\)</span> Paulis, it&rsquo;s 0.
    So, <span class="arithmatex">\(\sum_{P_{03}^*} |\langle \psi_{target} | P_{03} | \psi_{target} \rangle|^2 = 3\)</span>.</p>
</li>
<li>
<p><strong>Sum for <span class="arithmatex">\(P_1 P_2\)</span> where <span class="arithmatex">\(P_1 \in \mathcal{P}_{03}^*\)</span> and <span class="arithmatex">\(P_2 \in \mathcal{P}_{21}^*\)</span>:</strong>
    The product <span class="arithmatex">\(P_1 P_2\)</span> is a four-qubit Pauli. We need to identify how many of these are in <span class="arithmatex">\(\mathcal{G}\)</span>.
    The group of Paulis acting on <span class="arithmatex">\((q_0,q_3)\)</span> that stabilize <span class="arithmatex">\(|\psi_{target}\rangle\)</span> is <span class="arithmatex">\(G_{03}=\{I, X_0X_3, Z_0Z_3, Y_0Y_3\}\)</span>.
    The group of Paulis acting on <span class="arithmatex">\((q_1,q_2)\)</span> that stabilize <span class="arithmatex">\(|\psi_{target}\rangle\)</span> is <span class="arithmatex">\(G_{12}=\{I, X_1X_2, Z_1Z_2, Y_1Y_2\}\)</span>.
    The product set <span class="arithmatex">\(G_{03} \times G_{12}\)</span> consists of <span class="arithmatex">\(4 \times 4 = 16\)</span> elements. These 16 elements are precisely the stabilizer group <span class="arithmatex">\(\mathcal{G}\)</span>.
    We are summing over <span class="arithmatex">\(P_1 \in \mathcal{P}_{03}^*\)</span> and <span class="arithmatex">\(P_2 \in \mathcal{P}_{21}^*\)</span>. This means <span class="arithmatex">\(P_1 \in G_{03}\setminus\{I\}\)</span> and <span class="arithmatex">\(P_2 \in G_{12}\setminus\{I\}\)</span>. There are <span class="arithmatex">\(3 \times 3 = 9\)</span> such products.
    For these 9 products, <span class="arithmatex">\(|\langle \psi_{target} | P_1 P_2 | \psi_{target} \rangle|^2 = 1\)</span>. For the other <span class="arithmatex">\(15 \times 15 - 9 = 216\)</span> products, it&rsquo;s 0.
    So, <span class="arithmatex">\(\sum_{P_1 \in \mathcal{P}_{03}^*} \sum_{P_2 \in \mathcal{P}_{21}^*} |\langle \psi_{target} | P_1 P_2 | \psi_{target} \rangle|^2 = 9\)</span>.</p>
</li>
</ul>
<p><strong>5. Substitute values into the fidelity formula:</strong></p>
<div class="arithmatex">\[
F = (1-p)^2 + (1-p)\frac{p}{15}(3) + (1-p)\frac{p}{15}(3) + \left(\frac{p}{15}\right)^2(9)
\]</div>
<div class="arithmatex">\[
F = (1-p)^2 + \frac{6p(1-p)}{15} + \frac{9p^2}{225}
\]</div>
<div class="arithmatex">\[
F = (1-p)^2 + \frac{2p(1-p)}{5} + \frac{p^2}{25}
\]</div>
<p>Expand and combine terms:</p>
<div class="arithmatex">\[
F = (1 - 2p + p^2) + \left(\frac{2p}{5} - \frac{2p^2}{5}\right) + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = 1 - 2p + \frac{2p}{5} + p^2 - \frac{2p^2}{5} + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{10p}{5} + \frac{2p}{5} + p^2 \left(1 - \frac{2}{5} + \frac{1}{25}\right)
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + p^2 \left(\frac{25 - 10 + 1}{25}\right)
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + p^2 \left(\frac{16}{25}\right)
\]</div>
<p>This expression can be factored as:</p>
<div class="arithmatex">\[
F = \left(1 - \frac{4p}{5}\right)^2
\]</div>
<p>The final answer is <span class="arithmatex">\(\boxed{\left(1 - \frac{4p}{5}\right)^2}\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.351485
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>