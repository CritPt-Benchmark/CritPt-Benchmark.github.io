<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Alright, here&rsquo;s my understanding of the problem and the solution:</strong></p>
<p>I&rsquo;m being asked to calculate the fidelity of a 4-qubit state preparation circuit, focusing on the impact of two-qubit depolarizing errors after each CNOT gate. The circuit is defined in reverse order of operations, so I&rsquo;ve carefully determined the correct sequence: applying a Hadamard on qubit 2, then a CNOT from qubit 2 to qubit 1, another Hadamard on qubit 0, and finally a CNOT from qubit 0 to qubit 3. The initial state is the computational basis state |0000&gt;.</p>
<p>First, I traced the state evolution <em>without</em> any errors to find the ideal final state. I meticulously followed each gate&rsquo;s operation, step by step, which led me to the ideal final state.  I&rsquo;ve verified that the ideal final state is equivalent to a logical two-qubit GHZ state encoded in the [[4,2,2]] code. I verified that each component of the final state is in the code space, meaning it is an eigenstate of all the stabilizer operators (XXXX and ZZZZ).</p>
<p>Next, I tackled the errors. I knew that after each CNOT gate, there&rsquo;s a two-qubit depolarizing error channel acting on the two qubits involved in the CNOT. Each CNOT introduces an error from a set of 15 non-identity two-qubit Pauli operators with equal probability <span class="arithmatex">\(p/15\)</span>. The Hadamard gates are assumed to be perfect. Using density matrix formalism, I carefully tracked the state evolution, considering the errors after each CNOT. This required applying the two-qubit depolarizing channel <em>twice</em> (after each CNOT gate).</p>
<p>The real challenge was dealing with the error channels. I broke down the problem, carefully applying the error channel formula after each gate.  I then needed to consider the fact that the depolarizing channel is not a standard one, rather one that selects one of the 15 Pauli operators with equal probability. I used the fact that the sum of the Pauli operators applied to a pure state results in the state itself.</p>
<p>To simplify the math, I defined the ideal final state, and from there I calculated the fidelity: <span class="arithmatex">\(F = \langle \psi_F | \rho_F | \psi_F \rangle\)</span>. After detailed calculations, I found the physical state fidelity is <span class="arithmatex">\(F = 1 - \frac{8p}{5} + \frac{64p^2}{75}\)</span>, where <em>p</em> is the error probability of the two-qubit depolarizing channel.</p>
<p>This formula should correctly capture how fidelity decreases with increasing error rate.  I&rsquo;m confident in my work as I&rsquo;ve double checked each step, verifying the application of the noise model.  The derivation used the appropriate properties of the noise model.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>The problem asks for the physical state fidelity of a specific 4-qubit state preparation circuit, considering two-qubit depolarizing errors after each CNOT gate. The fidelity is defined as <span class="arithmatex">\(F = \langle \psi_F | \rho_F | \psi_F \rangle\)</span>, where <span class="arithmatex">\(|\psi_F\rangle\)</span> is the ideal final state and <span class="arithmatex">\(\rho_F\)</span> is the actual final density matrix after errors.</p>
<p>The circuit operations, applied from right to left, are:</p>
<ol>
<li><span class="arithmatex">\(H_2\)</span> (Hadamard on qubit 2)</li>
<li><span class="arithmatex">\(CNOT_{21}\)</span> (Controlled-NOT with control qubit 2, target qubit 1)</li>
<li><span class="arithmatex">\(H_0\)</span> (Hadamard on qubit 0)</li>
<li><span class="arithmatex">\(CNOT_{03}\)</span> (Controlled-NOT with control qubit 0, target qubit 3)</li>
</ol>
<p>We start with the initial state <span class="arithmatex">\(|\psi_0\rangle = |0000\rangle\)</span>. Let <span class="arithmatex">\(U_1=H_2\)</span>, <span class="arithmatex">\(U_2=CNOT_{21}\)</span>, <span class="arithmatex">\(U_3=H_0\)</span>, <span class="arithmatex">\(U_4=CNOT_{03}\)</span>.
The ideal final state is <span class="arithmatex">\(|\psi_F\rangle = U_4 U_3 U_2 U_1 |0000\rangle\)</span>.</p>
<p>The error model states that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate is followed by a two-qubit depolarizing error channel <span class="arithmatex">\(\mathcal{E}_{ij}\)</span>. This channel applies one of the 15 non-identity two-qubit Pauli operators (<span class="arithmatex">\(P \in \{I,X,Y,Z\}^{\otimes 2} \setminus \{II\}\)</span>) with equal probability <span class="arithmatex">\(p/15\)</span>, or no error (identity operator) with probability <span class="arithmatex">\(1-p\)</span>.
Thus, for a general density matrix <span class="arithmatex">\(\rho\)</span> of 4 qubits, where the error acts on qubits <span class="arithmatex">\(i\)</span> and <span class="arithmatex">\(j\)</span>, the channel is:</p>
<div class="arithmatex">\[
\mathcal{E}_{ij}(\rho) = (1-p)\rho + \sum_{P_{ij} \in \mathcal{P}_{ij}, P_{ij} \ne I_4} \frac{p}{15} P_{ij} \rho P_{ij}^\dagger
\]</div>
<p>Here, <span class="arithmatex">\(\mathcal{P}_{ij}\)</span> is the set of <span class="arithmatex">\(4^2=16\)</span> two-qubit Pauli operators acting on qubits <span class="arithmatex">\(i,j\)</span> (with identity on other qubits). The identity operator for the entire 4-qubit system is <span class="arithmatex">\(I_4\)</span>.
A key identity for depolarizing channels on a <span class="arithmatex">\(D\)</span>-dimensional Hilbert space is <span class="arithmatex">\(\sum_{P_k \in \mathcal{P}_D} P_k \rho P_k^\dagger = D \mathrm{Tr}(\rho) I_D\)</span>. For 2-qubit Paulis (<span class="arithmatex">\(D=4\)</span>), and considering <span class="arithmatex">\(\rho\)</span> as a 4-qubit state (so <span class="arithmatex">\(I_D\)</span> is effectively <span class="arithmatex">\(I_4\)</span>), this means:</p>
<div class="arithmatex">\[
\sum_{P_{ij} \in \mathcal{P}_{ij}} P_{ij} \rho P_{ij}^\dagger = 4 I_4
\]</div>
<p>This is because <span class="arithmatex">\(\mathrm{Tr}(\rho_{ij})\)</span> (the partial trace over qubits not involved in <span class="arithmatex">\(P_{ij}\)</span>) is 1, and the identity on the other qubits just propagates.
Therefore, the sum over non-identity Paulis can be written as:</p>
<div class="arithmatex">\[
\sum_{P_{ij} \in \mathcal{P}_{ij}, P_{ij} \ne I_4} P_{ij} \rho P_{ij}^\dagger = \left( \sum_{P_{ij} \in \mathcal{P}_{ij}} P_{ij} \rho P_{ij}^\dagger \right) - I_4 \rho I_4^\dagger = 4 I_4 - \rho
\]</div>
<p>Substituting this into the channel definition:</p>
<div class="arithmatex">\[
\mathcal{E}_{ij}(\rho) = (1-p)\rho + \frac{p}{15} (4 I_4 - \rho)
\]</div>
<p>Now, let&rsquo;s track the density matrix step-by-step:</p>
<ol>
<li><strong>Initial state:</strong> <span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>.</li>
<li><strong>After <span class="arithmatex">\(H_2\)</span>:</strong> <span class="arithmatex">\(\rho_1 = U_1 \rho_0 U_1^\dagger = |\psi_1\rangle\langle\psi_1|\)</span>, where <span class="arithmatex">\(|\psi_1\rangle = U_1|0000\rangle\)</span>.</li>
<li><strong>After <span class="arithmatex">\(CNOT_{21}\)</span> (before error):</strong> <span class="arithmatex">\(\rho_{2,no\_err} = U_2 \rho_1 U_2^\dagger = |\psi_2\rangle\langle\psi_2|\)</span>, where <span class="arithmatex">\(|\psi_2\rangle = U_2|\psi_1\rangle\)</span>.</li>
<li><strong>After error <span class="arithmatex">\(\mathcal{E}_{21}\)</span> (on qubits 1 and 2):</strong></li>
</ol>
<div class="arithmatex">\[
\rho_2 = \mathcal{E}_{21}(\rho_{2,no\_err}) = (1-p)\rho_{2,no\_err} + \frac{p}{15} (4 I_4 - \rho_{2,no\_err})
\]</div>
<ol start="5">
<li><strong>After <span class="arithmatex">\(H_0\)</span>:</strong> <span class="arithmatex">\(\rho_3 = U_3 \rho_2 U_3^\dagger\)</span>. Since <span class="arithmatex">\(U_3\)</span> is unitary (<span class="arithmatex">\(U_3 I_4 U_3^\dagger = I_4\)</span>), this gives:</li>
</ol>
<div class="arithmatex">\[
\rho_3 = (1-p)U_3 \rho_{2,no\_err} U_3^\dagger + \frac{p}{15} (4 I_4 - U_3 \rho_{2,no\_err} U_3^\dagger)
\]</div>
<p>Let <span class="arithmatex">\(\rho_{3,no\_err} = U_3 \rho_{2,no\_err} U_3^\dagger = |\psi_3\rangle\langle\psi_3|\)</span>, where <span class="arithmatex">\(|\psi_3\rangle = U_3|\psi_2\rangle\)</span>.</p>
<div class="arithmatex">\[
\rho_3 = (1-p)\rho_{3,no\_err} + \frac{p}{15} (4 I_4 - \rho_{3,no\_err})
\]</div>
<ol start="6">
<li><strong>After <span class="arithmatex">\(CNOT_{03}\)</span> (before error):</strong> <span class="arithmatex">\(\rho_{4,no\_err\_pre} = U_4 \rho_3 U_4^\dagger\)</span>. Similarly:</li>
</ol>
<div class="arithmatex">\[
\rho_{4,no\_err\_pre} = (1-p)U_4 \rho_{3,no\_err} U_4^\dagger + \frac{p}{15} (4 I_4 - U_4 \rho_{3,no\_err} U_4^\dagger)
\]</div>
<p>Let <span class="arithmatex">\(\rho_{4,no\_err} = U_4 \rho_{3,no\_err} U_4^\dagger = |\psi_F\rangle\langle\psi_F|\)</span>, where <span class="arithmatex">\(|\psi_F\rangle = U_4|\psi_3\rangle\)</span> is the ideal final state.</p>
<div class="arithmatex">\[
\rho_{4,no\_err\_pre} = (1-p)\rho_{4,no\_err} + \frac{p}{15} (4 I_4 - \rho_{4,no\_err})
\]</div>
<ol start="7">
<li><strong>After error <span class="arithmatex">\(\mathcal{E}_{03}\)</span> (on qubits 0 and 3):</strong> This is the final density matrix <span class="arithmatex">\(\rho_F\)</span>.</li>
</ol>
<div class="arithmatex">\[
\rho_F = \mathcal{E}_{03}(\rho_{4,no\_err\_pre}) = (1-p)\rho_{4,no\_err\_pre} + \frac{p}{15} (4 I_4 - \rho_{4,no\_err\_pre})
\]</div>
<p>The physical state fidelity is <span class="arithmatex">\(F = \langle \psi_F | \rho_F | \psi_F \rangle\)</span>.
Let&rsquo;s substitute the expressions:</p>
<div class="arithmatex">\[
F = \langle \psi_F | (1-p)\rho_{4,no\_err\_pre} + \frac{p}{15} (4 I_4 - \rho_{4,no\_err\_pre}) | \psi_F \rangle
\]</div>
<p>Since <span class="arithmatex">\(\langle \psi_F | I_4 | \psi_F \rangle = 1\)</span> (as <span class="arithmatex">\(|\psi_F\rangle\)</span> is a normalized state), we can define <span class="arithmatex">\(F' = \langle \psi_F | \rho_{4,no\_err\_pre} | \psi_F \rangle\)</span>:</p>
<div class="arithmatex">\[
F = (1-p)F' + \frac{p}{15} (4 - F')
\]</div>
<p>Now, let&rsquo;s calculate <span class="arithmatex">\(F'\)</span>:</p>
<div class="arithmatex">\[
F' = \langle \psi_F | \left[ (1-p)\rho_{4,no\_err} + \frac{p}{15} (4 I_4 - \rho_{4,no\_err}) \right] | \psi_F \rangle
\]</div>
<p>Since <span class="arithmatex">\(\rho_{4,no\_err} = |\psi_F\rangle\langle\psi_F|\)</span> and <span class="arithmatex">\(\langle \psi_F | \psi_F\rangle = 1\)</span>:</p>
<div class="arithmatex">\[
F' = (1-p)\langle \psi_F | \psi_F\rangle\langle\psi_F | \psi_F \rangle + \frac{p}{15} (4 \langle \psi_F | I_4 | \psi_F \rangle - \langle \psi_F | \psi_F\rangle\langle\psi_F | \psi_F \rangle)
\]</div>
<div class="arithmatex">\[
F' = (1-p)(1) + \frac{p}{15}(4 \times 1 - 1) = 1-p + \frac{3p}{15} = 1-p + \frac{p}{5} = 1 - \frac{4p}{5}
\]</div>
<p>Finally, substitute <span class="arithmatex">\(F'\)</span> back into the expression for <span class="arithmatex">\(F\)</span>:</p>
<div class="arithmatex">\[
F = (1-p)\left(1 - \frac{4p}{5}\right) + \frac{p}{15}\left(4 - \left(1 - \frac{4p}{5}\right)\right)
\]</div>
<div class="arithmatex">\[
F = (1-p)\left(1 - \frac{4p}{5}\right) + \frac{p}{15}\left(3 + \frac{4p}{5}\right)
\]</div>
<p>Expand the terms:</p>
<div class="arithmatex">\[
F = \left(1 - \frac{4p}{5} - p + \frac{4p^2}{5}\right) + \left(\frac{3p}{15} + \frac{4p^2}{75}\right)
\]</div>
<div class="arithmatex">\[
F = \left(1 - \frac{9p}{5} + \frac{4p^2}{5}\right) + \left(\frac{p}{5} + \frac{4p^2}{75}\right)
\]</div>
<p>Combine like terms:</p>
<div class="arithmatex">\[
F = 1 - \frac{9p}{5} + \frac{p}{5} + \frac{4p^2}{5} + \frac{4p^2}{75}
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + \frac{60p^2}{75} + \frac{4p^2}{75}
\]</div>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + \frac{64p^2}{75}
\]</div>
<p>The final answer is <span class="arithmatex">\(\boxed{1 - \frac{8p}{5} + \frac{64p^2}{75}}\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><p>The problem asks for the logical state fidelity of the final 2-qubit logical state, assuming post-selection on all detectable errors. This means we consider only the cases where the error syndrome is trivial (i.e., the state remains in the code space). The logical fidelity is then the probability that the final state is the ideal logical state, conditioned on not detecting an error.</p>
<p>The ideal logical state for the circuit is the physical state <span class="arithmatex">\(|\psi_F\rangle\)</span> derived in Subproblem 1:</p>
<div class="arithmatex">\[
|\psi_F\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<p>This state is a valid codeword, being a +1 eigenstate of the stabilizers <span class="arithmatex">\(S_1 = XXXX\)</span> and <span class="arithmatex">\(S_2 = ZZZZ\)</span>. We are seeking the fidelity <span class="arithmatex">\(F_L\)</span> with this state.</p>
<p>The errors occur after each CNOT gate. Let <span class="arithmatex">\(E_1\)</span> be the error (a 2-qubit Pauli operator) after <span class="arithmatex">\(CNOT_{21}\)</span> and <span class="arithmatex">\(E_2\)</span> be the error after <span class="arithmatex">\(CNOT_{03}\)</span>.
The errors are applied to the physical qubits. <span class="arithmatex">\(E_1\)</span> acts on qubits (1,2) and <span class="arithmatex">\(E_2\)</span> acts on qubits (0,3). Hadamard gates (<span class="arithmatex">\(H_0, H_2\)</span>) are assumed perfect and do not introduce errors.
The errors are chosen from a set of 15 non-identity two-qubit Paulis (<span class="arithmatex">\(P_{ij} \ne I_{ij}\)</span>) with probability <span class="arithmatex">\(p/15\)</span>, or no error (identity <span class="arithmatex">\(I_{ij}\)</span>) with probability <span class="arithmatex">\(1-p\)</span>. The total probability for <span class="arithmatex">\(E_1\)</span> (and <span class="arithmatex">\(E_2\)</span>) is 1.</p>
<p>The ideal circuit transforms <span class="arithmatex">\(|0000\rangle\)</span> to <span class="arithmatex">\(|\psi_F\rangle\)</span>.
If an error <span class="arithmatex">\(E_1\)</span> (on <span class="arithmatex">\(Q_1, Q_2\)</span>) occurs, followed by <span class="arithmatex">\(E_2\)</span> (on <span class="arithmatex">\(Q_0, Q_3\)</span>), the final state is <span class="arithmatex">\(E_2 U_4 E_1 U_3 U_2 U_1 |0000\rangle\)</span>.
Since <span class="arithmatex">\(E_1\)</span> acts on qubits (1,2) and <span class="arithmatex">\(U_4=CNOT_{03}\)</span> acts on (0,3) and <span class="arithmatex">\(U_3=H_0\)</span> acts on (0), <span class="arithmatex">\(E_1\)</span> commutes with <span class="arithmatex">\(U_4 U_3\)</span>.
Therefore, the sequence of operations with errors applied is equivalent to applying <span class="arithmatex">\(E_2 E_1\)</span> to the ideal final state <span class="arithmatex">\(|\psi_F\rangle\)</span>.
The final (unnormalized) state is given by:</p>
<div class="arithmatex">\[
\rho_F = \sum_{E_1, E_2} \mathrm{Pr}(E_1)\mathrm{Pr}(E_2) (E_2 E_1) |\psi_F\rangle\langle\psi_F| (E_2 E_1)^\dagger
\]</div>
<p>where <span class="arithmatex">\(E_1\)</span> is a Pauli on <span class="arithmatex">\(Q_1Q_2\)</span> (identity on <span class="arithmatex">\(Q_0Q_3\)</span>) and <span class="arithmatex">\(E_2\)</span> is a Pauli on <span class="arithmatex">\(Q_0Q_3\)</span> (identity on <span class="arithmatex">\(Q_1Q_2\)</span>). <span class="arithmatex">\(\mathrm{Pr}(I) = 1-p\)</span>, <span class="arithmatex">\(\mathrm{Pr}(P \ne I) = p/15\)</span>.</p>
<p><strong>1. Determine Undetectable Errors:</strong>
An error <span class="arithmatex">\(E\)</span> is undetectable if it commutes with all stabilizers <span class="arithmatex">\(S_k\)</span>. For Pauli errors, this means <span class="arithmatex">\(S_k E S_k^\dagger = E\)</span> for all <span class="arithmatex">\(k\)</span>.
The stabilizers are <span class="arithmatex">\(S_1 = X_0X_1X_2X_3\)</span> and <span class="arithmatex">\(S_2 = Z_0Z_1Z_2Z_3\)</span>.
Let <span class="arithmatex">\(E_1 = P_1P_2\)</span> where <span class="arithmatex">\(P_1\)</span> acts on <span class="arithmatex">\(Q_1\)</span> and <span class="arithmatex">\(P_2\)</span> acts on <span class="arithmatex">\(Q_2\)</span>. <span class="arithmatex">\(E_1\)</span> is implicitly <span class="arithmatex">\(I_0 P_1 P_2 I_3\)</span>.
Let <span class="arithmatex">\(E_2 = P_0P_3\)</span> where <span class="arithmatex">\(P_0\)</span> acts on <span class="arithmatex">\(Q_0\)</span> and <span class="arithmatex">\(P_3\)</span> acts on <span class="arithmatex">\(Q_3\)</span>. <span class="arithmatex">\(E_2\)</span> is implicitly <span class="arithmatex">\(P_0 I_1 I_2 P_3\)</span>.
Consider <span class="arithmatex">\(S_1 E_1 S_1\)</span>. <span class="arithmatex">\(S_1 = X_0(X_1X_2)X_3\)</span>. Since <span class="arithmatex">\(E_1\)</span> only acts on <span class="arithmatex">\(Q_1Q_2\)</span>, and <span class="arithmatex">\(S_1\)</span> has parts on <span class="arithmatex">\(Q_0Q_3\)</span> and <span class="arithmatex">\(Q_1Q_2\)</span>:
<span class="arithmatex">\(S_1 E_1 S_1 = (X_0X_3)(X_1X_2) E_1 (X_0X_3)(X_1X_2)\)</span>.
Since <span class="arithmatex">\(E_1\)</span> acts only on <span class="arithmatex">\(Q_1Q_2\)</span>, it commutes with <span class="arithmatex">\(X_0X_3\)</span>.
So <span class="arithmatex">\(S_1 E_1 S_1 = (X_1X_2) E_1 (X_1X_2)\)</span>.
An operator <span class="arithmatex">\(P_A P_B\)</span> (on <span class="arithmatex">\(Q_A Q_B\)</span>) commutes with <span class="arithmatex">\(X_A X_B\)</span> if it anti-commutes an even number of times (0 or 2 times).
An error <span class="arithmatex">\(P_1P_2\)</span> on <span class="arithmatex">\(Q_1Q_2\)</span> commutes with <span class="arithmatex">\(X_1X_2\)</span> if <span class="arithmatex">\(A(P_1,X_1)+A(P_2,X_2)\)</span> is even.
Similarly, <span class="arithmatex">\(P_1P_2\)</span> commutes with <span class="arithmatex">\(Z_1Z_2\)</span> if <span class="arithmatex">\(A(P_1,Z_1)+A(P_2,Z_2)\)</span> is even.
By examining all 16 2-qubit Pauli operators <span class="arithmatex">\(P_1P_2\)</span>:
- <span class="arithmatex">\(A(P,X)=0\)</span> for <span class="arithmatex">\(P \in \{I,X\}\)</span>, <span class="arithmatex">\(A(P,X)=1\)</span> for <span class="arithmatex">\(P \in \{Y,Z\}\)</span>.
- <span class="arithmatex">\(A(P,Z)=0\)</span> for <span class="arithmatex">\(P \in \{I,Z\}\)</span>, <span class="arithmatex">\(A(P,Z)=1\)</span> for <span class="arithmatex">\(P \in \{X,Y\}\)</span>.
The errors <span class="arithmatex">\(E_1\)</span> (on <span class="arithmatex">\(Q_1Q_2\)</span>) that commute with <span class="arithmatex">\(X_1X_2\)</span> and <span class="arithmatex">\(Z_1Z_2\)</span> are <span class="arithmatex">\(E_1 \in \{I_{12}, X_1X_2, Z_1Z_2, Y_1Y_2\}\)</span>. Let&rsquo;s call this set <span class="arithmatex">\(K_1\)</span>.
Similarly, the errors <span class="arithmatex">\(E_2\)</span> (on <span class="arithmatex">\(Q_0Q_3\)</span>) that commute with <span class="arithmatex">\(X_0X_3\)</span> and <span class="arithmatex">\(Z_0Z_3\)</span> are <span class="arithmatex">\(E_2 \in \{I_{03}, X_0X_3, Z_0Z_3, Y_0Y_3\}\)</span>. Let&rsquo;s call this set <span class="arithmatex">\(K_2\)</span>.
The combined error <span class="arithmatex">\(E=E_2 E_1\)</span> (since <span class="arithmatex">\(E_1\)</span> and <span class="arithmatex">\(E_2\)</span> act on disjoint qubits, they commute) commutes with <span class="arithmatex">\(S_1\)</span> if <span class="arithmatex">\(S_1 E_2 E_1 S_1 = (S_1 E_2 S_1) (S_1 E_1 S_1)\)</span> (incorrect step for <span class="arithmatex">\(S_1\)</span>).
<span class="arithmatex">\(S_1 E_2 E_1 S_1 = S_1 E_2 S_1 E_1 S_1\)</span> this step is incorrect because <span class="arithmatex">\(E_1\)</span> doesn&rsquo;t commute with <span class="arithmatex">\(S_1\)</span>.
A simpler way: <span class="arithmatex">\(E=E_2 E_1\)</span> commutes with <span class="arithmatex">\(S_1\)</span> if <span class="arithmatex">\(A(P_0,X_0)+A(P_1,X_1)+A(P_2,X_2)+A(P_3,X_3)\)</span> is even.
And it commutes with <span class="arithmatex">\(S_2\)</span> if <span class="arithmatex">\(A(P_0,Z_0)+A(P_1,Z_1)+A(P_2,Z_2)+A(P_3,Z_3)\)</span> is even.</p>
<p>Let <span class="arithmatex">\(E_1=P_1P_2\)</span> (on <span class="arithmatex">\(Q_1Q_2\)</span>) and <span class="arithmatex">\(E_2=P_0P_3\)</span> (on <span class="arithmatex">\(Q_0Q_3\)</span>).
The undetectable errors <span class="arithmatex">\(E=E_2E_1\)</span> are those where <span class="arithmatex">\(P_0P_1P_2P_3\)</span> commutes with <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>.
This implies <span class="arithmatex">\(E_1\)</span> must be in <span class="arithmatex">\(K_1\)</span> and <span class="arithmatex">\(E_2\)</span> must be in <span class="arithmatex">\(K_2\)</span>.
There are <span class="arithmatex">\(4 \times 4 = 16\)</span> such undetectable combined errors <span class="arithmatex">\(E_2 E_1\)</span>.
Any other error is detectable.</p>
<p><strong>2. Calculate the probability of not detecting an error (<span class="arithmatex">\(P_{undetect}\)</span>):</strong>
This is the sum of probabilities of all <span class="arithmatex">\(16\)</span> undetectable errors.
- Case 1: <span class="arithmatex">\(E_1=I, E_2=I\)</span>. Error is <span class="arithmatex">\(I\)</span>. Prob: <span class="arithmatex">\((1-p)^2\)</span>.
- Case 2: <span class="arithmatex">\(E_1 \in K_1 \setminus \{I\}\)</span> (3 errors), <span class="arithmatex">\(E_2=I\)</span>. Error is <span class="arithmatex">\(E_1\)</span>. Prob: <span class="arithmatex">\(3 \times \frac{p}{15}(1-p)\)</span>.
- Case 3: <span class="arithmatex">\(E_1=I, E_2 \in K_2 \setminus \{I\}\)</span> (3 errors). Error is <span class="arithmatex">\(E_2\)</span>. Prob: <span class="arithmatex">\(3 \times (1-p)\frac{p}{15}\)</span>.
- Case 4: <span class="arithmatex">\(E_1 \in K_1 \setminus \{I\}\)</span> (3 errors), <span class="arithmatex">\(E_2 \in K_2 \setminus \{I\}\)</span> (3 errors). Error is <span class="arithmatex">\(E_2E_1\)</span>. Prob: <span class="arithmatex">\(3 \times 3 \times (\frac{p}{15})^2 = 9 \times (\frac{p}{15})^2\)</span>.</p>
<p>Summing these probabilities:</p>
<div class="arithmatex">\[
P_{undetect} = (1-p)^2 + 6 \frac{p}{15}(1-p) + 9 \left(\frac{p}{15}\right)^2
\]</div>
<div class="arithmatex">\[
P_{undetect} = (1-p)^2 + \frac{2p}{5}(1-p) + \frac{9p^2}{225}
\]</div>
<div class="arithmatex">\[
P_{undetect} = 1 - 2p + p^2 + \frac{2p}{5} - \frac{2p^2}{5} + \frac{p^2}{25}
\]</div>
<div class="arithmatex">\[
P_{undetect} = 1 - \frac{8p}{5} + p^2 \left(1 - \frac{2}{5} + \frac{1}{25}\right) = 1 - \frac{8p}{5} + p^2 \left(\frac{25-10+1}{25}\right)
\]</div>
<div class="arithmatex">\[
P_{undetect} = 1 - \frac{8p}{5} + \frac{16p^2}{25}
\]</div>
<p><strong>3. Calculate the probability of no logical error, given no detection:</strong>
The logical fidelity <span class="arithmatex">\(F_L\)</span> is the probability that the final logical state is <span class="arithmatex">\(|\psi_F\rangle\)</span>, given that no error was detected. This means the total error <span class="arithmatex">\(E=E_2E_1\)</span> must belong to the stabilizer group <span class="arithmatex">\(G_S = \{I, XXXX, ZZZZ, YYYY\}\)</span>.
We need to evaluate <span class="arithmatex">\(|\langle\psi_F|E|\psi_F\rangle|^2\)</span> for <span class="arithmatex">\(E \in G_S\)</span>.
For <span class="arithmatex">\(E \in G_S\)</span>, <span class="arithmatex">\(E|\psi_F\rangle = |\psi_F\rangle\)</span> (since <span class="arithmatex">\(S_1|\psi_F\rangle = |\psi_F\rangle\)</span>, <span class="arithmatex">\(S_2|\psi_F\rangle = |\psi_F\rangle\)</span>, and <span class="arithmatex">\(YYYY|\psi_F\rangle = S_1 S_2 |\psi_F\rangle = |\psi_F\rangle\)</span>).
So, for <span class="arithmatex">\(E \in G_S\)</span>, <span class="arithmatex">\(|\langle\psi_F|E|\psi_F\rangle|^2 = 1\)</span>.</p>
<p>We list the <span class="arithmatex">\(E_2E_1\)</span> combinations that fall into <span class="arithmatex">\(G_S\)</span>:
- Case 1: <span class="arithmatex">\(E_1=I, E_2=I\)</span>. <span class="arithmatex">\(E=I\)</span>. Prob: <span class="arithmatex">\((1-p)^2\)</span>. This is in <span class="arithmatex">\(G_S\)</span>. Contribution to numerator: <span class="arithmatex">\((1-p)^2 \times 1\)</span>.
- Case 2: <span class="arithmatex">\(E_1 \in K_1 \setminus \{I\}\)</span>, <span class="arithmatex">\(E_2=I\)</span>. Error is <span class="arithmatex">\(E_1 \in \{X_1X_2, Z_1Z_2, Y_1Y_2\}\)</span>. These are NOT in <span class="arithmatex">\(G_S\)</span>. No contribution.
- Case 3: <span class="arithmatex">\(E_1=I, E_2 \in K_2 \setminus \{I\}\)</span>. Error is <span class="arithmatex">\(E_2 \in \{X_0X_3, Z_0Z_3, Y_0Y_3\}\)</span>. These are NOT in <span class="arithmatex">\(G_S\)</span>. No contribution.
- Case 4: <span class="arithmatex">\(E_1 \in K_1 \setminus \{I\}\)</span>, <span class="arithmatex">\(E_2 \in K_2 \setminus \{I\}\)</span>. These are <span class="arithmatex">\(3 \times 3=9\)</span> errors:
    - <span class="arithmatex">\(E_2E_1 = X_0X_3 X_1X_2 = X_0X_1X_2X_3 = XXXX = S_1\)</span>. Prob: <span class="arithmatex">\((p/15)^2\)</span>. This is in <span class="arithmatex">\(G_S\)</span>. Contributes <span class="arithmatex">\(1 \times (\frac{p}{15})^2\)</span>.
    - <span class="arithmatex">\(E_2E_1 = Z_0Z_3 Z_1Z_2 = Z_0Z_1Z_2Z_3 = ZZZZ = S_2\)</span>. Prob: <span class="arithmatex">\((p/15)^2\)</span>. This is in <span class="arithmatex">\(G_S\)</span>. Contributes <span class="arithmatex">\(1 \times (\frac{p}{15})^2\)</span>.
    - <span class="arithmatex">\(E_2E_1 = Y_0Y_3 Y_1Y_2 = Y_0Y_1Y_2Y_3 = YYYY = S_1S_2\)</span>. Prob: <span class="arithmatex">\((p/15)^2\)</span>. This is in <span class="arithmatex">\(G_S\)</span>. Contributes <span class="arithmatex">\(1 \times (\frac{p}{15})^2\)</span>.
    - The other 6 combinations (e.g., <span class="arithmatex">\(X_0X_3 Z_1Z_2\)</span>) are in <span class="arithmatex">\(N(G_S)\)</span> but not in <span class="arithmatex">\(G_S\)</span>. They represent logical errors. No contribution to <span class="arithmatex">\(F_L\)</span>.</p>
<p>The numerator for <span class="arithmatex">\(F_L\)</span> (probability of an undetected physical error that results in the ideal logical state) is:</p>
<div class="arithmatex">\[
N_{correct\_logical} = (1-p)^2 + 3 \left(\frac{p}{15}\right)^2
\]</div>
<div class="arithmatex">\[
N_{correct\_logical} = 1 - 2p + p^2 + \frac{3p^2}{225} = 1 - 2p + p^2 + \frac{p^2}{75} = 1 - 2p + \frac{76p^2}{75}
\]</div>
<p><strong>4. Calculate Logical Fidelity:</strong>
The logical fidelity is the ratio of <span class="arithmatex">\(N_{correct\_logical}\)</span> to <span class="arithmatex">\(P_{undetect}\)</span>:</p>
<div class="arithmatex">\[
F_L = \frac{N_{correct\_logical}}{P_{undetect}} = \frac{1 - 2p + \frac{76p^2}{75}}{1 - \frac{8p}{5} + \frac{16p^2}{25}}
\]</div>
<p>To write this with a common denominator of 75 for the <span class="arithmatex">\(p^2\)</span> terms:</p>
<div class="arithmatex">\[
F_L = \frac{1 - 2p + \frac{76p^2}{75}}{1 - \frac{24p}{15} + \frac{48p^2}{75}}
\]</div>
<p>The final answer is <span class="arithmatex">\(\boxed{\frac{1 - 2p + \frac{76p^2}{75}}{1 - \frac{8p}{5} + \frac{16p^2}{25}}}\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="mi">76</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">75</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span> <span class="o">+</span> <span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">25</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.847188
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>