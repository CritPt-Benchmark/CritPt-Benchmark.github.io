<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Deconstructing and Analyzing the Circuit</strong></p>
<p>Okay, here&rsquo;s my thought process. The core problem is to calculate the fidelity of a prepared logical <span class="arithmatex">\(|00\rangle\)</span> state, considering errors in the two-qubit gates. We&rsquo;re dealing with a [[4,2,2]] code, which means four physical qubits encode two logical qubits, and it can detect single-qubit errors. Key features are the stabilizers (<span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>) and logical operators (<span class="arithmatex">\(X_A\)</span>, <span class="arithmatex">\(X_B\)</span>, <span class="arithmatex">\(Z_A\)</span>, <span class="arithmatex">\(Z_B\)</span>). The circuit itself prepares the logical state and has an ancilla qubit that helps detect errors. It uses CNOTs and a Hadamard, and the crucial element is post-selection: we only accept outcomes where the ancilla measures <span class="arithmatex">\(|0\rangle\)</span>, and the state is in the code space (eigenvalues +1 for the stabilizers).</p>
<p><strong>Ideal Circuit (No Errors, p=0)</strong></p>
<p>Let&rsquo;s start by imagining a perfect world where there are no errors. The ideal circuit should reliably prepare the <span class="arithmatex">\(|00\rangle\)</span> state. Tracing the circuit step-by-step, starting from the initial state <span class="arithmatex">\(|0000\rangle|0\rangle_4\)</span>, and applying the operations, including H, CNOTs and measurement, I can confirm that the correct final state <em>should</em> be <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle) \otimes |0\rangle_4\)</span> which represents the correct logical <span class="arithmatex">\(|00\rangle\)</span>. Checking against the stabilizers and logical operators, I confirm that the prepared state is correct.</p>
<p><strong>The Impact of Errors</strong></p>
<p>Now, the messy part. I need to figure out what happens when there are errors, specifically two-qubit depolarizing errors after each CNOT gate. The central strategy is to identify the errors that are <em>not</em> detected by the post-selection, thus creating logical errors. An undetectable error is one that, after propagation, doesn&rsquo;t flip the ancilla to <span class="arithmatex">\(|1\rangle\)</span> (since it measures <span class="arithmatex">\(|0\rangle\)</span>) <em>and</em> keeps the final state within the codespace. That means that the error&rsquo;s logical result has to be a stabilizer or a logical.</p>
<p>To find these bad errors, I need to propagate each of the 15 possible two-qubit Pauli errors through the circuit and check how they act on the final state. I have identified that those that will lead to fidelity degradation are logical X or Y errors.</p>
<p><strong>Error Propagation and Undetectable Errors</strong></p>
<p>I&rsquo;ll proceed to analyze each CNOT gate in reverse order, finding what each of the 15 two-qubit Pauli errors do as they get propagated through the circuit. Each error will propagate through the remaining circuit, with a final &ldquo;effective&rdquo; state with the multiplied Pauli error acting on the data state with the ancilla, and the remaining probability of that event happening. I need to make a good table.</p>
<p><strong>Using Stabilizer Formalism and Logic</strong></p>
<p>Let&rsquo;s see. This circuit is a stabilizer circuit, which makes the stabilizer formalism useful. Tracking the evolution of stabilizers through gates might be an easier way to find the undetectable errors. The initial stabilizers are <span class="arithmatex">\(Z_0, Z_1, Z_2, Z_3, Z_4\)</span>. After each gate, I must see how the stabilizers evolve.</p>
<p><strong>Detailed Calculations and Analysis</strong></p>
<p>Then, I have to go through each gate and consider each of the 15 errors for each. It&rsquo;s time to be systematic. I must analyze them case by case:
-   After CNOT04: The error must be <span class="arithmatex">\(I_0 \otimes Z_4\)</span>.
-   After CNOT34: I get <span class="arithmatex">\(Z_3 Z_4\)</span>.
-   After CNOT23: I will get a list of states.
-   After CNOT10: I will get a list of states.
-   After CNOT12: I will get a list of states.
This is where I must carefully apply the criteria for an undetectable logical error, which is commuting with all stabilizers. Any non-trivial result will affect fidelity. After that, I will need to count the errors per gate, and I must not forget that these errors will happen with a probability p/15.</p>
<p><strong>Fidelity Calculation</strong></p>
<p>Once the lists are ready, I have the full list of errors. I can get the infidelty by simply adding up probabilities to get the final result.</p>
<p>The goal is achieved, and I hope I find the correct result.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<h4 id="1-ideal-state-preparation-error-free-case-p0">1. Ideal State Preparation (Error-free case, <span class="arithmatex">\(p=0\)</span>)</h4>
<p>First, let&rsquo;s trace the state of the system through the circuit in the absence of errors. The circuit operations are applied from right to left as written in the problem statement.</p>
<ol>
<li>
<p><strong>Initial State</strong>: The system starts in the state <span class="arithmatex">\(|\psi_0\rangle = |0000\rangle_{0123} |0\rangle_4\)</span>.</p>
</li>
<li>
<p><strong>Hadamard Gate <span class="arithmatex">\(H_1\)</span></strong>: A Hadamard gate is applied to qubit 1.</p>
</li>
</ol>
<div class="arithmatex">\[
|\psi_1\rangle = H_1 |\psi_0\rangle = |0\rangle_0 \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)_1 |00\rangle_{23} |0\rangle_4 = \frac{1}{\sqrt{2}}(|00000\rangle + |01000\rangle)
\]</div>
<ol start="3">
<li><strong><span class="arithmatex">\(CNOT_{12}\)</span></strong>: Control on qubit 1, target on qubit 2.</li>
</ol>
<div class="arithmatex">\[
|\psi_2\rangle = CNOT_{12} |\psi_1\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |01100\rangle)
\]</div>
<ol start="4">
<li><strong><span class="arithmatex">\(CNOT_{10}\)</span></strong>: Control on qubit 1, target on qubit 0.</li>
</ol>
<div class="arithmatex">\[
|\psi_3\rangle = CNOT_{10} |\psi_2\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |11100\rangle)
\]</div>
<ol start="5">
<li><strong><span class="arithmatex">\(CNOT_{23}\)</span></strong>: Control on qubit 2, target on qubit 3.</li>
</ol>
<div class="arithmatex">\[
|\psi_4\rangle = CNOT_{23} |\psi_3\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |11110\rangle)
\]</div>
<ol start="6">
<li><strong><span class="arithmatex">\(CNOT_{34}\)</span></strong>: Control on qubit 3, target on qubit 4 (ancilla).</li>
</ol>
<div class="arithmatex">\[
|\psi_5\rangle = CNOT_{34} |\psi_4\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |11111\rangle)
\]</div>
<ol start="7">
<li><strong><span class="arithmatex">\(CNOT_{04}\)</span></strong>: Control on qubit 0, target on qubit 4 (ancilla).</li>
</ol>
<div class="arithmatex">\[
|\psi_6\rangle = CNOT_{04} |\psi_5\rangle = \frac{1}{\sqrt{2}}(CNOT_{04}|00000\rangle + CNOT_{04}|11111\rangle)
\]</div>
<div class="arithmatex">\[
|\psi_6\rangle = \frac{1}{\sqrt{2}}(|0000\rangle|0\rangle_4 + |1111\rangle|0\rangle_4) = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle) \otimes |0\rangle_4
\]</div>
<ol start="8">
<li><strong>Measurement <span class="arithmatex">\(M_4\)</span></strong>: The ancilla qubit 4 is measured in the Z-basis. The state is already entirely in the <span class="arithmatex">\(|0\rangle_4\)</span> subspace, so the measurement outcome is deterministically <span class="arithmatex">\(|0\rangle\)</span>. The post-measurement state of the four data qubits is:</li>
</ol>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)
\]</div>
<p>This state is the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state, as it is a simultaneous (+1)-eigenstate of the stabilizers <span class="arithmatex">\(S_1=XXXX, S_2=ZZZZ\)</span> and the logical Z-operators <span class="arithmatex">\(Z_A=ZZII, Z_B=ZIZI\)</span>.</p>
<h4 id="2-analysis-of-errors">2. Analysis of Errors</h4>
<p>We consider a single error occurring after one of the five CNOT gates. The error model is a two-qubit depolarizing channel, where one of the 15 non-identity two-qubit Pauli operators <span class="arithmatex">\(E\)</span> occurs with probability <span class="arithmatex">\(p/15\)</span>.</p>
<p>The final state is post-selected on two conditions:</p>
<ol>
<li><strong>Ancilla measures <span class="arithmatex">\(|0\rangle\)</span></strong>: The propagated error must not flip the ancilla from <span class="arithmatex">\(|0\rangle\)</span> to <span class="arithmatex">\(|1\rangle\)</span>. An error <span class="arithmatex">\(E_{final}\)</span> acting just before measurement will flip the ancilla if it contains a Pauli <span class="arithmatex">\(X_4\)</span> or <span class="arithmatex">\(Y_4\)</span> term, because <span class="arithmatex">\(X_4|0\rangle = |1\rangle\)</span> and <span class="arithmatex">\(Y_4|0\rangle = -i|1\rangle\)</span>. Thus, for an error to be undetected by the ancilla, its final propagated form must only have <span class="arithmatex">\(I_4\)</span> or <span class="arithmatex">\(Z_4\)</span> on the ancilla qubit.</li>
<li><strong>State is in the codespace</strong>: The propagated error, when acting on the data qubits, must commute with the code stabilizers <span class="arithmatex">\(S_1=XXXX\)</span> and <span class="arithmatex">\(S_2=ZZZZ\)</span>. An error that anticommutes with a stabilizer would be detected. An error commuting with all stabilizers is either a stabilizer itself or a logical operator.</li>
</ol>
<p>The logical fidelity is the overlap of the final state with the ideal state. We are preparing the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state. Undetectable errors that are logical <span class="arithmatex">\(Z\)</span> operators (or products thereof, like <span class="arithmatex">\(Z_A\)</span>, <span class="arithmatex">\(Z_B\)</span>, <span class="arithmatex">\(Z_A Z_B\)</span>) preserve this state, so they do not decrease fidelity. Undetectable errors that are logical <span class="arithmatex">\(X\)</span> or <span class="arithmatex">\(Y\)</span> operators will change the state to an orthogonal logical state (e.g., <span class="arithmatex">\(|10\rangle_{AB}\)</span>), decreasing the fidelity to zero for that component of the final mixed state.</p>
<p>Therefore, to calculate the logical infidelity (<span class="arithmatex">\(1-F\)</span>), we must sum the probabilities of all single-error events that propagate to a non-trivial logical <span class="arithmatex">\(X\)</span> or <span class="arithmatex">\(Y\)</span> operator on the data qubits and do not flip the ancilla measurement outcome. To first order in <span class="arithmatex">\(p\)</span>, the fidelity is <span class="arithmatex">\(F \approx 1 - P(\text{infidelity-causing error})\)</span>.</p>
<p>We analyze the propagation of each of the 15 possible errors for each of the 5 CNOT gates. Let <span class="arithmatex">\(E_{ij}\)</span> be an error on qubits <span class="arithmatex">\(i,j\)</span> occurring after <span class="arithmatex">\(CNOT_{ij}\)</span>. Let <span class="arithmatex">\(U_{rest}\)</span> be the unitary for the remainder of the circuit. The final error is <span class="arithmatex">\(E_{final} = U_{rest} E_{ij} U_{rest}^{\dagger}\)</span>.</p>
<p>The CNOT propagation rules for Paulis are:
*   <span class="arithmatex">\(CNOT_{ct}(X_c \otimes I_t)CNOT_{ct}^\dagger = X_c \otimes X_t\)</span>
*   <span class="arithmatex">\(CNOT_{ct}(I_c \otimes Z_t)CNOT_{ct}^\dagger = Z_c \otimes Z_t\)</span>
*   Other basis Paulis on one of the qubits are unchanged.</p>
<p><strong>Location 5: After <span class="arithmatex">\(CNOT_{04}\)</span></strong>
The error <span class="arithmatex">\(E_{04}\)</span> does not propagate. For the error to be undetected, it must have <span class="arithmatex">\(I_4\)</span> or <span class="arithmatex">\(Z_4\)</span> on the ancilla. The data-qubit part must be a logical operator. Errors like <span class="arithmatex">\(X_0 \otimes I_4\)</span> have a weight-1 data-qubit part, which is detectable by the distance-2 code. The only undetectable error is <span class="arithmatex">\(I_0 \otimes Z_4\)</span>, which acts as the identity on the data qubits and thus does not cause a logical error.
*   Infidelity-causing errors: 0.</p>
<p><strong>Location 4: After <span class="arithmatex">\(CNOT_{34}\)</span></strong>
Error <span class="arithmatex">\(E_{34}\)</span> is propagated by <span class="arithmatex">\(CNOT_{04}\)</span>. <span class="arithmatex">\(E_{final} = CNOT_{04} E_{34} CNOT_{04}^\dagger\)</span>.
*   Errors with <span class="arithmatex">\(X_4\)</span> or <span class="arithmatex">\(Y_4\)</span> on the ancilla are detected.
*   Consider errors with <span class="arithmatex">\(I_4\)</span> or <span class="arithmatex">\(Z_4\)</span>:
    *   <span class="arithmatex">\(E = Z_3 \otimes Z_4 \rightarrow E_{final} = CNOT_{04}(Z_3 \otimes Z_4)CNOT_{04}^\dagger = Z_3 \otimes (Z_0 Z_4) = (Z_0 Z_3) \otimes Z_4\)</span>. The data part <span class="arithmatex">\(Z_0 Z_3\)</span> is a logical operator (<span class="arithmatex">\(Z_A Z_B S_2\)</span>). This is a Z-type logical error, which does not cause infidelity for the <span class="arithmatex">\(|00\rangle_{AB}\)</span> state.
    *   No other error on qubits (3,4) propagates to a non-trivial undetectable error. For instance, <span class="arithmatex">\(X_3 \otimes I_4\)</span> remains <span class="arithmatex">\(X_3 \otimes I_4\)</span>, which is detectable.
*   Infidelity-causing errors: 0.</p>
<p><strong>Location 3: After <span class="arithmatex">\(CNOT_{23}\)</span></strong>
Error <span class="arithmatex">\(E_{23}\)</span> is propagated by <span class="arithmatex">\(U_{rest} = CNOT_{04}CNOT_{34}\)</span>.
*   <span class="arithmatex">\(E = X_2 \otimes X_3\)</span>: This error is not affected by the subsequent CNOTs as they act on different qubits. The data part is <span class="arithmatex">\(X_2 X_3\)</span>, which is a valid logical operator (<span class="arithmatex">\(X_B S_1\)</span>). This is an X-type error, causing infidelity.
*   <span class="arithmatex">\(E = Y_2 \otimes Y_3\)</span>: Propagates to <span class="arithmatex">\(Y_2 Y_3\)</span> on the data qubits, which is also a logical operator (<span class="arithmatex">\(Y_A Y_B S_1 S_2\)</span>). This is a Y-type error, causing infidelity.
*   <span class="arithmatex">\(E = I_2 \otimes Z_3\)</span>: Propagates as <span class="arithmatex">\(I_2 \otimes Z_3 \xrightarrow{CNOT_{34}} I_2 \otimes Z_3Z_4 \xrightarrow{CNOT_{04}} Z_0 \otimes I_2 \otimes Z_3 \otimes Z_4\)</span>. The data part is <span class="arithmatex">\(Z_0Z_3\)</span>, a Z-type logical error. No infidelity.
*   Other errors are detectable.
*   Infidelity-causing errors: 2 (<span class="arithmatex">\(X_2 \otimes X_3, Y_2 \otimes Y_3\)</span>).</p>
<p><strong>Location 2: After <span class="arithmatex">\(CNOT_{10}\)</span></strong>
Error <span class="arithmatex">\(E_{10}\)</span> is propagated by <span class="arithmatex">\(U_{rest} = CNOT_{04}CNOT_{34}CNOT_{23}\)</span>. None of these gates act on qubits 0 or 1, except <span class="arithmatex">\(CNOT_{04}\)</span> which can pick up a <span class="arithmatex">\(Z_0\)</span> error.
*   <span class="arithmatex">\(E = X_0 \otimes X_1\)</span>: Propagates untouched to data qubits. <span class="arithmatex">\(X_0X_1\)</span> is the logical operator <span class="arithmatex">\(X_B\)</span>. X-type, causes infidelity.
*   <span class="arithmatex">\(E = Y_0 \otimes Y_1\)</span>: Propagates untouched to data qubits. <span class="arithmatex">\(Y_0Y_1\)</span> is equivalent to a logical operator (<span class="arithmatex">\(Z_A X_B S_2\)</span>). Y-type, causes infidelity.
*   <span class="arithmatex">\(E = Z_0 \otimes Z_1\)</span>: Propagates to <span class="arithmatex">\((Z_0Z_1) \otimes Z_4\)</span>. The data part is <span class="arithmatex">\(Z_0Z_1\)</span>, which is the logical <span class="arithmatex">\(Z_A\)</span>. Z-type, no infidelity.
*   Other errors are detectable.
*   Infidelity-causing errors: 2 (<span class="arithmatex">\(X_0 \otimes X_1, Y_0 \otimes Y_1\)</span>). Note that <span class="arithmatex">\(X_1 \otimes X_0\)</span> and <span class="arithmatex">\(Y_1 \otimes Y_0\)</span> are the same operators up to a phase.</p>
<p><strong>Location 1: After <span class="arithmatex">\(CNOT_{12}\)</span></strong>
Error <span class="arithmatex">\(E_{12}\)</span> propagates through <span class="arithmatex">\(U_{rest} = CNOT_{04}CNOT_{34}CNOT_{23}CNOT_{10}\)</span>.
*   <span class="arithmatex">\(E = X_1 \otimes I_2\)</span>: Propagates through <span class="arithmatex">\(CNOT_{10}\)</span> to become <span class="arithmatex">\((X_1 X_0) \otimes I_2\)</span>. The rest of the circuit does not affect it. The final data-qubit error is <span class="arithmatex">\(X_0X_1\)</span>, which is logical <span class="arithmatex">\(X_B\)</span>. X-type, causes infidelity.
*   <span class="arithmatex">\(E = Y_1 \otimes I_2 = i(X_1Z_1)\otimes I_2\)</span>: Propagates through <span class="arithmatex">\(CNOT_{10}\)</span> to become <span class="arithmatex">\(i(X_0X_1)(Z_0Z_1)\otimes I_2 = -Y_0Y_1 \otimes I_2\)</span>. The final data-qubit error is <span class="arithmatex">\(-Y_0Y_1\)</span>, a logical operator. Y-type, causes infidelity.
*   <span class="arithmatex">\(E = Z_1 \otimes I_2\)</span>: Propagates through <span class="arithmatex">\(CNOT_{10}\)</span> to become <span class="arithmatex">\((Z_0Z_1)\otimes I_2\)</span>. This is logical <span class="arithmatex">\(Z_A\)</span>. It then propagates through <span class="arithmatex">\(CNOT_{04}\)</span> to pick up a <span class="arithmatex">\(Z_4\)</span> component, but the data part remains <span class="arithmatex">\(Z_A\)</span>. Z-type, no infidelity.
*   Other errors are detectable.
*   Infidelity-causing errors: 2 (<span class="arithmatex">\(X_1 \otimes I_2, Y_1 \otimes I_2\)</span>).</p>
<h4 id="3-calculating-the-fidelity">3. Calculating the Fidelity</h4>
<p>We sum the number of single-error events that cause a logical X or Y fault.
*   From <span class="arithmatex">\(CNOT_{12}\)</span>: 2 errors.
*   From <span class="arithmatex">\(CNOT_{10}\)</span>: 2 errors.
*   From <span class="arithmatex">\(CNOT_{23}\)</span>: 2 errors.
*   From <span class="arithmatex">\(CNOT_{34}\)</span>: 0 errors.
*   From <span class="arithmatex">\(CNOT_{04}\)</span>: 0 errors.</p>
<p>Total number of infidelity-causing errors, <span class="arithmatex">\(N_{infidelity} = 2 + 2 + 2 + 0 + 0 = 6\)</span>.</p>
<p>Each of these 15 Pauli errors occurs with probability <span class="arithmatex">\(p/15\)</span>. The total probability of an infidelity-causing error, to first order in <span class="arithmatex">\(p\)</span>, is the sum of the probabilities of these individual error events.</p>
<div class="arithmatex">\[
P_{infidelity} = N_{infidelity} \times \frac{p}{15} = 6 \times \frac{p}{15} = \frac{2}{5}p
\]</div>
<p>The logical state fidelity <span class="arithmatex">\(F\)</span> is the probability that the final state is the ideal state <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span>. To first order, this is one minus the probability of any error that changes the state to an orthogonal one.</p>
<div class="arithmatex">\[
F = 1 - P_{infidelity}
\]</div>
<div class="arithmatex">\[
F(p) = 1 - \frac{2}{5}p
\]</div>
<p>This result is valid to first order in <span class="arithmatex">\(p\)</span>. The problem asks for the fidelity as a function of <span class="arithmatex">\(p\)</span>, and for small <span class="arithmatex">\(p\)</span>, this linear approximation is the dominant term.</p>
<p><strong>Final Answer:</strong>
The logical state fidelity of the final 2-qubit logical state is:</p>
<div class="arithmatex">\[
F(p) = 1 - \frac{2}{5}p
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:08.787260
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>