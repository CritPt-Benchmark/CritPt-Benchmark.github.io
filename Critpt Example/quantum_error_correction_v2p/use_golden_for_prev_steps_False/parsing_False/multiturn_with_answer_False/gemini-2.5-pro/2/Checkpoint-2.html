<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><p>Answering the user&rsquo;s request.</p>
<h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p><strong>1. Determine the Ideal Final State</strong></p>
<p>The quantum circuit prepares a 4-qubit state from the initial state <span class="arithmatex">\(|0000\rangle\)</span>. The unitary operations are applied from right to left as given in the expression <span class="arithmatex">\(U = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span>. Let&rsquo;s track the state vector <span class="arithmatex">\(|\psi\rangle\)</span> through the circuit.</p>
<ol>
<li>
<p><strong>Initial state:</strong>
    <span class="arithmatex">\(|\psi_0\rangle = |0000\rangle\)</span></p>
</li>
<li>
<p><strong>Apply <span class="arithmatex">\(H_2\)</span> (Hadamard on qubit 2):</strong>
    <span class="arithmatex">\(|\psi_1\rangle = H_2 |\psi_0\rangle = |00\rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \otimes |0\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)\)</span></p>
</li>
<li>
<p><strong>Apply <span class="arithmatex">\(CNOT_{21}\)</span> (Control on qubit 2, Target on qubit 1):</strong>
    <span class="arithmatex">\(|\psi_2\rangle = CNOT_{21} |\psi_1\rangle = \frac{1}{\sqrt{2}}(CNOT_{21}|0000\rangle + CNOT_{21}|0010\rangle)\)</span>
    The control qubit (2) is <span class="arithmatex">\(|0\rangle\)</span> for the first term, so the target (1) is unchanged. The control is <span class="arithmatex">\(|1\rangle\)</span> for the second term, so the target is flipped.
    <span class="arithmatex">\(|\psi_2\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)\)</span></p>
</li>
<li>
<p><strong>Apply <span class="arithmatex">\(H_0\)</span> (Hadamard on qubit 0):</strong>
    <span class="arithmatex">\(|\psi_3\rangle = H_0 |\psi_2\rangle = \frac{1}{\sqrt{2}}(H_0|0000\rangle + H_0|0110\rangle)\)</span>
    <span class="arithmatex">\(|\psi_3\rangle = \frac{1}{\sqrt{2}} \left( \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)|000\rangle + \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)|110\rangle \right)\)</span>
    <span class="arithmatex">\(|\psi_3\rangle = \frac{1}{2}(|0000\rangle + |1000\rangle + |0110\rangle + |1110\rangle)\)</span></p>
</li>
<li>
<p><strong>Apply <span class="arithmatex">\(CNOT_{03}\)</span> (Control on qubit 0, Target on qubit 3):</strong>
    <span class="arithmatex">\(|\Psi_{ideal}\rangle = CNOT_{03} |\psi_3\rangle = \frac{1}{2}(CNOT_{03}|0000\rangle + CNOT_{03}|1000\rangle + CNOT_{03}|0110\rangle + CNOT_{03}|1110\rangle)\)</span>
    The control qubit (0) is <span class="arithmatex">\(|0\rangle\)</span> for the first and third terms, leaving the target (3) unchanged. The control is <span class="arithmatex">\(|1\rangle\)</span> for the second and fourth terms, flipping the target.</p>
</li>
</ol>
<div class="arithmatex">\[
|\Psi_{ideal}\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)
\]</div>
<p><strong>2. Analyze the Structure of the Ideal Final State</strong></p>
<p>The ideal final state <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span> has a special structure. Let&rsquo;s group the terms by the states of qubit pairs (0,3) and (1,2).</p>
<p><span class="arithmatex">\(|0000\rangle = |00\rangle_{03} \otimes |00\rangle_{12}\)</span>
<span class="arithmatex">\(|1001\rangle = |11\rangle_{03} \otimes |00\rangle_{12}\)</span>
<span class="arithmatex">\(|0110\rangle = |00\rangle_{03} \otimes |11\rangle_{12}\)</span>
<span class="arithmatex">\(|1111\rangle = |11\rangle_{03} \otimes |11\rangle_{12}\)</span></p>
<p>Substituting these into the expression for <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span>:</p>
<div class="arithmatex">\[
|\Psi_{ideal}\rangle = \frac{1}{2} \left( |00\rangle_{03}|00\rangle_{12} + |11\rangle_{03}|00\rangle_{12} + |00\rangle_{03}|11\rangle_{12} + |11\rangle_{03}|11\rangle_{12} \right)
\]</div>
<p>Factoring the expression:</p>
<div class="arithmatex">\[
|\Psi_{ideal}\rangle = \frac{1}{2} \left( (|00\rangle_{03} + |11\rangle_{03}) \otimes |00\rangle_{12} + (|00\rangle_{03} + |11\rangle_{03}) \otimes |11\rangle_{12} \right)
\]</div>
<div class="arithmatex">\[
|\Psi_{ideal}\rangle = \left( \frac{1}{\sqrt{2}}(|00\rangle_{03} + |11\rangle_{03}) \right) \otimes \left( \frac{1}{\sqrt{2}}(|00\rangle_{12} + |11\rangle_{12}) \right)
\]</div>
<p>This shows that the ideal final state is a product of two Bell states, <span class="arithmatex">\(|\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}\)</span>. Let <span class="arithmatex">\(\rho_{ideal} = |\Psi_{ideal}\rangle\langle\Psi_{ideal}|\)</span>.</p>
<p><strong>3. Model the Noisy Circuit Evolution</strong></p>
<p>The circuit consists of two noisy CNOT gates, <span class="arithmatex">\(CNOT_{21}\)</span> and <span class="arithmatex">\(CNOT_{03}\)</span>. Let <span class="arithmatex">\(\mathcal{U}_G\)</span> denote the unitary channel for a gate <span class="arithmatex">\(G\)</span>, and <span class="arithmatex">\(\mathcal{E}_{ij}\)</span> denote the two-qubit depolarizing error channel on qubits <span class="arithmatex">\(i,j\)</span>. The circuit applies the following sequence of operations to the initial state <span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>:</p>
<div class="arithmatex">\[
\rho_{final} = \mathcal{E}_{03} \circ \mathcal{U}_{CNOT_{03}} \circ \mathcal{U}_{H_0} \circ \mathcal{E}_{21} \circ \mathcal{U}_{CNOT_{21}} \circ \mathcal{U}_{H_2} (\rho_0)
\]</div>
<p>Let&rsquo;s analyze the evolution. The state after the first noisy gate, <span class="arithmatex">\(CNOT_{21}\)</span>, is <span class="arithmatex">\(\rho_A = \mathcal{E}_{21} \circ \mathcal{U}_{CNOT_{21}} \circ \mathcal{U}_{H_2} (\rho_0)\)</span>. The subsequent operations are <span class="arithmatex">\(U_{H_0}\)</span> and <span class="arithmatex">\(U_{CNOT_{03}}\)</span>. The error channel <span class="arithmatex">\(\mathcal{E}_{21}\)</span> acts on qubits 1 and 2, while <span class="arithmatex">\(U_{H_0}\)</span> acts on qubit 0 and <span class="arithmatex">\(U_{CNOT_{03}}\)</span> acts on qubits 0 and 3. Since these unitaries act on disjoint sets of qubits from the error channel, they commute:</p>
<div class="arithmatex">\[
\mathcal{U}_{H_0} \circ \mathcal{E}_{21} = \mathcal{E}_{21} \circ \mathcal{U}_{H_0}
\]</div>
<div class="arithmatex">\[
\mathcal{U}_{CNOT_{03}} \circ \mathcal{E}_{21} = \mathcal{E}_{21} \circ \mathcal{U}_{CNOT_{03}}
\]</div>
<p>Using this, we can reorder the operations in the full circuit:</p>
<div class="arithmatex">\[
\rho_{final} = \mathcal{E}_{03} \circ \mathcal{E}_{21} \circ \mathcal{U}_{CNOT_{03}} \circ \mathcal{U}_{H_0} \circ \mathcal{U}_{CNOT_{21}} \circ \mathcal{U}_{H_2} (\rho_0)
\]</div>
<p>The combined unitary part is precisely the ideal circuit, <span class="arithmatex">\(U_{ideal} = U_{CNOT_{03}} U_{H_0} U_{CNOT_{21}} U_{H_2}\)</span>. Thus, the evolution can be written as:</p>
<div class="arithmatex">\[
\rho_{final} = \mathcal{E}_{03} \circ \mathcal{E}_{21} (\rho_{ideal})
\]</div>
<p>Since <span class="arithmatex">\(\rho_{ideal} = |\Phi^+\rangle_{03}\langle\Phi^+|_{03} \otimes |\Phi^+\rangle_{12}\langle\Phi^+|_{12}\)</span>, and the error channels act on separate subsystems:</p>
<div class="arithmatex">\[
\mathcal{E}_{21}(\rho_{ideal}) = |\Phi^+\rangle_{03}\langle\Phi^+|_{03} \otimes \mathcal{E}_{21}(|\Phi^+\rangle_{12}\langle\Phi^+|_{12})
\]</div>
<div class="arithmatex">\[
\rho_{final} = \mathcal{E}_{03}(|\Phi^+\rangle_{03}\langle\Phi^+|_{03}) \otimes \mathcal{E}_{21}(|\Phi^+\rangle_{12}\langle\Phi^+|_{12})
\]</div>
<p><strong>4. Calculate the Fidelity</strong></p>
<p>The physical state fidelity is <span class="arithmatex">\(F = \langle\Psi_{ideal}|\rho_{final}|\Psi_{ideal}\rangle = \text{Tr}(\rho_{ideal} \rho_{final})\)</span>.
Let <span class="arithmatex">\(\rho_{03}^{ideal} = |\Phi^+\rangle_{03}\langle\Phi^+|_{03}\)</span> and <span class="arithmatex">\(\rho_{12}^{ideal} = |\Phi^+\rangle_{12}\langle\Phi^+|_{12}\)</span>.
Let <span class="arithmatex">\(\rho_{03}^{final} = \mathcal{E}_{03}(\rho_{03}^{ideal})\)</span> and <span class="arithmatex">\(\rho_{12}^{final} = \mathcal{E}_{21}(\rho_{12}^{ideal})\)</span>.
Then <span class="arithmatex">\(\rho_{ideal} = \rho_{03}^{ideal} \otimes \rho_{12}^{ideal}\)</span> and <span class="arithmatex">\(\rho_{final} = \rho_{03}^{final} \otimes \rho_{12}^{final}\)</span>.</p>
<div class="arithmatex">\[
F = \text{Tr}((\rho_{03}^{ideal} \otimes \rho_{12}^{ideal}) (\rho_{03}^{final} \otimes \rho_{12}^{final}))
\]</div>
<div class="arithmatex">\[
F = \text{Tr}(\rho_{03}^{ideal} \rho_{03}^{final}) \times \text{Tr}(\rho_{12}^{ideal} \rho_{12}^{final})
\]</div>
<p>This means the total fidelity is the product of the fidelities for each Bell pair subsystem. Let <span class="arithmatex">\(F_{03} = \text{Tr}(\rho_{03}^{ideal} \rho_{03}^{final})\)</span> and <span class="arithmatex">\(F_{12} = \text{Tr}(\rho_{12}^{ideal} \rho_{12}^{final})\)</span>.</p>
<p><strong>5. Fidelity of a Bell State under Depolarizing Noise</strong></p>
<p>Let&rsquo;s calculate the fidelity for one subsystem, say (0,3).
<span class="arithmatex">\(F_{03} = \langle\Phi^+|_{03} \rho_{03}^{final} |\Phi^+\rangle_{03} = \langle\Phi^+|_{03} \mathcal{E}_{03}(|\Phi^+\rangle_{03}\langle\Phi^+|_{03}) |\Phi^+\rangle_{03}\)</span>.
The error channel is <span class="arithmatex">\(\mathcal{E}(\rho) = (1-p) \rho + \frac{p}{15} \sum_{P \neq I} P \rho P^\dagger\)</span>, where <span class="arithmatex">\(P\)</span> are the 15 non-identity two-qubit Pauli operators.</p>
<div class="arithmatex">\[
F_{03} = (1-p) \langle\Phi^+|\Phi^+\rangle\langle\Phi^+|\Phi^+\rangle + \frac{p}{15} \sum_{P_{03} \neq I} \langle\Phi^+| P_{03} |\Phi^+\rangle\langle\Phi^+| P_{03}^\dagger |\Phi^+\rangle
\]</div>
<div class="arithmatex">\[
F_{03} = (1-p) + \frac{p}{15} \sum_{P_{03} \neq I} |\langle\Phi^+| P_{03} |\Phi^+\rangle|^2
\]</div>
<p>We need to find the expectation values of Pauli operators for a Bell state <span class="arithmatex">\(|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\)</span>. The state <span class="arithmatex">\(|\Phi^+\rangle\)</span> is a <span class="arithmatex">\(+1\)</span> eigenstate of the stabilizer operators <span class="arithmatex">\(X\otimes X\)</span> and <span class="arithmatex">\(Z\otimes Z\)</span>. It is also a <span class="arithmatex">\(-1\)</span> eigenstate of <span class="arithmatex">\(Y\otimes Y = (iXZ)(iXZ) = - (X\otimes X)(Z\otimes Z)\)</span>. All other 12 non-identity Pauli operators have an expectation value of 0 for this state.
The non-zero expectation values are:
<span class="arithmatex">\(\langle\Phi^+| X\otimes X |\Phi^+\rangle = 1\)</span>
<span class="arithmatex">\(\langle\Phi^+| Z\otimes Z |\Phi^+\rangle = 1\)</span>
<span class="arithmatex">\(\langle\Phi^+| Y\otimes Y |\Phi^+\rangle = -1\)</span></p>
<p>The sum of squares of these expectation values is:</p>
<div class="arithmatex">\[
\sum_{P_{03} \neq I} |\langle\Phi^+| P_{03} |\Phi^+\rangle|^2 = 1^2 + 1^2 + (-1)^2 = 3
\]</div>
<p>Substituting this into the expression for <span class="arithmatex">\(F_{03}\)</span>:</p>
<div class="arithmatex">\[
F_{03} = (1-p) + \frac{p}{15}(3) = 1-p + \frac{p}{5} = 1 - \frac{4}{5}p
\]</div>
<p>By symmetry, the fidelity for the (1,2) subsystem is the same:</p>
<div class="arithmatex">\[
F_{12} = 1 - \frac{4}{5}p
\]</div>
<p><strong>6. Combine Results for the Final Fidelity</strong></p>
<p>The total physical state fidelity is the product of the fidelities of the two subsystems:</p>
<div class="arithmatex">\[
F = F_{03} \times F_{12} = \left(1 - \frac{4}{5}p\right) \left(1 - \frac{4}{5}p\right) = \left(1 - \frac{4}{5}p\right)^2
\]</div>
<div class="arithmatex">\[
F(p) = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<p><strong>Final Answer:</strong>
The physical state fidelity of the final physical 4-qubit state as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span> is:</p>
<div class="arithmatex">\[
F(p) = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Logical State Fidelity for the [[4,2,2]] Code</strong></p>
<p>My goal is to calculate the logical fidelity, conditioned on no detectable errors.  I&rsquo;m dealing with a [[4,2,2]] quantum code, meaning four physical qubits encode two logical qubits.  First, I needed to understand the code: how the qubits, stabilizers (<span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>), logical operators (<span class="arithmatex">\(X_A, X_B, Z_A, Z_B\)</span>) and basis states relate.  The target logical state I want to prepare is a Bell state:  <span class="arithmatex">\(|\Psi_L\rangle = \frac{1}{\sqrt{2}}(|00\rangle_{AB} + |11\rangle_{AB})\)</span>.</p>
<p>To begin, I had to ensure the circuit actually creates the desired logical state. By working through the circuit operations, I determined the expected ideal physical state is  <span class="arithmatex">\(|\Psi_{ideal}\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)\)</span>.  I then confirmed this state lies within the code space (the +1 eigenspace of the stabilizers) by checking that the state is indeed stabilized by <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>. Further, I had to verify that the  <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span>  state does encode the correct logical Bell state,  <span class="arithmatex">\(|\Psi_L\rangle\)</span>. I constructed the logical basis states using the properties of the stabilizers and logical operators, and carefully checked the action of the logical operators on each logical basis state to make sure I constructed the basis correctly. Ultimately, I confirmed that the ideal circuit indeed creates the correct encoded Bell state.</p>
<p>Next, I introduced an error model: independent depolarizing channels on two qubit pairs, (0,3) and (2,1) after the circuit. My focus is on post-selecting on the absence of detectable errors. I set up the relevant notation and then expressed the final state as the product of the effects of each channel on the ideal Bell pairs. I focused on error channels that act independently on the subsystems to determine the probability of success,  <span class="arithmatex">\(P_{succ}\)</span>, and the physical fidelity. The projector <span class="arithmatex">\(\Pi_C\)</span> allows me to focus on the encoded code subspace for computing <span class="arithmatex">\(P_{succ}\)</span> and logical fidelity,  <span class="arithmatex">\(F_L = F_{phys} / P_{succ}\)</span>.</p>
<p>I then meticulously considered the error channels, noting that the errors can be detectable or undetectable. Detectable errors get post-selected out by measuring the stabilizers, and my goal is the fidelity <em>conditioned</em> on those detectable errors having <em>not</em> occurred.  Undetectable errors can map logical states within the codespace (leaving the logical state unchanged), or they can be true logical errors that <em>change</em> the logical state. So I calculated the fidelity in several ways, and after some struggles, arrived at the result.  I considered all possible combinations of undetectable errors that could have occurred, which led me to the correct expression.
In the end, I confirmed that the logical infidelity indeed scales quadratically with the physical error rate, as expected for a distance-2 code, because the linear decrease in physical fidelity caused by the detectable errors exactly cancels with the decreases in the probability of success, due to those same errors.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p><strong>1. Ideal State and Error Model</strong></p>
<p>From Subproblem 1, the ideal physical state prepared by the circuit is <span class="arithmatex">\(|\Psi_{ideal}\rangle = \frac{1}{2}(|0000\rangle + |1001\rangle + |0110\rangle + |1111\rangle)\)</span>. This state is in the codespace of the [[4,2,2]] code (the +1 eigenspace of stabilizers <span class="arithmatex">\(S_1=XXXX\)</span> and <span class="arithmatex">\(S_2=ZZZZ\)</span>) and corresponds to the logical GHZ state <span class="arithmatex">\(|\Psi_L\rangle = \frac{1}{\sqrt{2}}(|00\rangle_{AB} + |11\rangle_{AB})\)</span>. Let <span class="arithmatex">\(\rho_{ideal} = |\Psi_{ideal}\rangle\langle\Psi_{ideal}|\)</span>.</p>
<p>The circuit has two noisy CNOT gates. The final state of the 4 physical qubits, <span class="arithmatex">\(\rho_{final}\)</span>, after passing through the two independent depolarizing channels is given by:</p>
<div class="arithmatex">\[
\rho_{final} = (\mathcal{E}_{03} \circ \mathcal{E}_{21}) (\rho_{ideal})
\]</div>
<p>where <span class="arithmatex">\(\mathcal{E}_{ij}\)</span> is the two-qubit depolarizing channel on qubits <span class="arithmatex">\(i\)</span> and <span class="arithmatex">\(j\)</span>.</p>
<p><strong>2. Post-selection and Logical Fidelity</strong></p>
<p>We post-select on the absence of detectable errors. This corresponds to projecting the final state into the codespace. The projector onto the codespace is <span class="arithmatex">\(\Pi_C = \frac{1}{4}(I + S_1 + S_2 + S_1S_2)\)</span>. The post-selected state is:</p>
<div class="arithmatex">\[
\rho_{ps} = \frac{\Pi_C \rho_{final} \Pi_C}{\text{Tr}(\Pi_C \rho_{final})}
\]</div>
<p>The denominator, <span class="arithmatex">\(P_{succ} = \text{Tr}(\Pi_C \rho_{final})\)</span>, is the probability of success (i.e., of measuring both stabilizers and getting +1).</p>
<p>The logical state fidelity is defined with respect to the ideal logical state <span class="arithmatex">\(|\Psi_L\rangle\)</span>. The corresponding physical state is <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span>. The fidelity of the post-selected state <span class="arithmatex">\(\rho_{ps}\)</span> with the ideal pure state <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span> is:</p>
<div class="arithmatex">\[
F_L = \langle\Psi_{ideal}| \rho_{ps} |\Psi_{ideal}\rangle
\]</div>
<p>Substituting the expression for <span class="arithmatex">\(\rho_{ps}\)</span>:</p>
<div class="arithmatex">\[
F_L = \frac{\langle\Psi_{ideal}| \Pi_C \rho_{final} \Pi_C |\Psi_{ideal}\rangle}{P_{succ}}
\]</div>
<p>Since <span class="arithmatex">\(|\Psi_{ideal}\rangle\)</span> is in the codespace, it is an eigenvector of <span class="arithmatex">\(\Pi_C\)</span> with eigenvalue 1, i.e., <span class="arithmatex">\(\Pi_C |\Psi_{ideal}\rangle = |\Psi_{ideal}\rangle\)</span> and <span class="arithmatex">\(\langle\Psi_{ideal}| \Pi_C = \langle\Psi_{ideal}|\)</span>. Therefore, the numerator simplifies:</p>
<div class="arithmatex">\[
\langle\Psi_{ideal}| \Pi_C \rho_{final} \Pi_C |\Psi_{ideal}\rangle = \langle\Psi_{ideal}| \rho_{final} |\Psi_{ideal}\rangle = F_{phys}
\]</div>
<p>where <span class="arithmatex">\(F_{phys}\)</span> is the physical state fidelity calculated in Subproblem 1.
Thus, the logical fidelity is the ratio of the physical fidelity to the success probability:</p>
<div class="arithmatex">\[
F_L(p) = \frac{F_{phys}(p)}{P_{succ}(p)}
\]</div>
<p><strong>3. Calculation of the Success Probability (<span class="arithmatex">\(P_{succ}\)</span>)</strong></p>
<p>From Subproblem 1, we know the ideal state factorizes as <span class="arithmatex">\(|\Psi_{ideal}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}\)</span>, where <span class="arithmatex">\(|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\)</span>. The final state is <span class="arithmatex">\(\rho_{final} = \rho_{03} \otimes \rho_{12}\)</span>, where <span class="arithmatex">\(\rho_{03} = \mathcal{E}_{03}(|\Phi^+\rangle_{03}\langle\Phi^+|_{03})\)</span> and <span class="arithmatex">\(\rho_{12} = \mathcal{E}_{21}(|\Phi^+\rangle_{12}\langle\Phi^+|_{12})\)</span>.</p>
<p>The success probability is <span class="arithmatex">\(P_{succ} = \text{Tr}(\Pi_C \rho_{final})\)</span>. Let&rsquo;s write the projector in terms of operators on the subsystems (0,3) and (1,2):</p>
<div class="arithmatex">\[
\Pi_C = \frac{1}{4}(I \otimes I + (X_0X_3 \otimes X_1X_2) + (Z_0Z_3 \otimes Z_1Z_2) + (Y_0Y_3 \otimes Y_1Y_2))
\]</div>
<p>The trace becomes:
\begin{align<em>} P_{succ} &amp;= \frac{1}{4} \text{Tr} \left[ (I \otimes I + X_0X_3 \otimes X_1X_2 + \dots) (\rho_{03} \otimes \rho_{12}) \right] \ &amp;= \frac{1}{4} \left[ \text{Tr}(I\rho_{03})\text{Tr}(I\rho_{12}) + \text{Tr}(X_0X_3\rho_{03})\text{Tr}(X_1X_2\rho_{12}) + \dots \right] \ &amp;= \frac{1}{4} \left[ 1 + \langle X_0X_3 \rangle_{\rho_{03}} \langle X_1X_2 \rangle_{\rho_{12}} + \langle Z_0Z_3 \rangle_{\rho_{03}} \langle Z_1Z_2 \rangle_{\rho_{12}} + \langle Y_0Y_3 \rangle_{\rho_{03}} \langle Y_1Y_2 \rangle_{\rho_{12}} \right] \end{align</em>}
We need to calculate the expectation value of a two-qubit Pauli operator <span class="arithmatex">\(Q\)</span> for a Bell state that has passed through a depolarizing channel. Let <span class="arithmatex">\(\rho' = \mathcal{E}(|\Phi^+\rangle\langle\Phi^+|)\)</span>.</p>
<div class="arithmatex">\[
\langle Q \rangle_{\rho'} = \text{Tr}(Q \rho') = (1-p)\text{Tr}(Q\rho_{ideal}) + \frac{p}{15}\sum_{P \neq I} \text{Tr}(Q P \rho_{ideal} P)
\]</div>
<p>Using the identity <span class="arithmatex">\(\text{Tr}(QP\rho P) = \text{sgn}(P,Q)\text{Tr}(Q\rho)\)</span>, where <span class="arithmatex">\(\text{sgn}(P,Q) = \pm 1\)</span> depending on whether <span class="arithmatex">\(P,Q\)</span> commute or anticommute:</p>
<div class="arithmatex">\[
\langle Q \rangle_{\rho'} = \left( (1-p) + \frac{p}{15}\sum_{P \neq I} \text{sgn}(P,Q) \right) \langle Q \rangle_{ideal}
\]</div>
<p>For any two-qubit Pauli <span class="arithmatex">\(Q \neq I\)</span>, the sum over the 15 non-identity Paulis is <span class="arithmatex">\(\sum_{P \neq I} \text{sgn}(P,Q) = -1\)</span>. So:</p>
<div class="arithmatex">\[
\langle Q \rangle_{\rho'} = \left( 1-p - \frac{p}{15} \right) \langle Q \rangle_{ideal} = \left( 1 - \frac{16}{15}p \right) \langle Q \rangle_{ideal}
\]</div>
<p>The ideal expectation values for <span class="arithmatex">\(|\Phi^+\rangle\)</span> are <span class="arithmatex">\(\langle XX \rangle = 1\)</span>, <span class="arithmatex">\(\langle ZZ \rangle = 1\)</span>, and <span class="arithmatex">\(\langle YY \rangle = -1\)</span>.
So for each subsystem, we have:
<span class="arithmatex">\(\langle XX \rangle_{\rho'} = 1 - \frac{16}{15}p\)</span>
<span class="arithmatex">\(\langle ZZ \rangle_{\rho'} = 1 - \frac{16}{15}p\)</span>
<span class="arithmatex">\(\langle YY \rangle_{\rho'} = -(1 - \frac{16}{15}p)\)</span></p>
<p>Substituting these into the expression for <span class="arithmatex">\(P_{succ}\)</span>:</p>
<div class="arithmatex">\[
P_{succ}(p) = \frac{1}{4} \left[ 1 + \left(1-\frac{16}{15}p\right)^2 + \left(1-\frac{16}{15}p\right)^2 + \left(-\left(1-\frac{16}{15}p\right)\right)\left(-\left(1-\frac{16}{15}p\right)\right) \right]
\]</div>
<div class="arithmatex">\[
P_{succ}(p) = \frac{1}{4} \left[ 1 + 3\left(1 - \frac{16}{15}p\right)^2 \right]
\]</div>
<p>Expanding this expression:</p>
<div class="arithmatex">\[
P_{succ}(p) = \frac{1}{4} \left[ 1 + 3\left(1 - \frac{32}{15}p + \frac{256}{225}p^2\right) \right] = \frac{1}{4} \left[ 4 - \frac{32}{5}p + \frac{256}{75}p^2 \right]
\]</div>
<div class="arithmatex">\[
P_{succ}(p) = 1 - \frac{8}{5}p + \frac{64}{75}p^2
\]</div>
<p><strong>4. Final Calculation of Logical Fidelity</strong></p>
<p>We now combine our results. From Subproblem 1, the physical fidelity is:</p>
<div class="arithmatex">\[
F_{phys}(p) = \left(1 - \frac{4}{5}p\right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2 = 1 - \frac{8}{5}p + \frac{48}{75}p^2
\]</div>
<p>The logical fidelity is the ratio:</p>
<div class="arithmatex">\[
F_L(p) = \frac{F_{phys}(p)}{P_{succ}(p)} = \frac{1 - \frac{8}{5}p + \frac{16}{25}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2}
\]</div>
<p>The linear terms in <span class="arithmatex">\(p\)</span> in the numerator and denominator are identical. This implies that the logical infidelity, <span class="arithmatex">\(1 - F_L(p)\)</span>, is of order <span class="arithmatex">\(p^2\)</span>, which is expected for a distance-2 code.</p>
<div class="arithmatex">\[
1 - F_L(p) = \frac{P_{succ}(p) - F_{phys}(p)}{P_{succ}(p)} = \frac{(1 - \frac{8}{5}p + \frac{64}{75}p^2) - (1 - \frac{8}{5}p + \frac{48}{75}p^2)}{1 - \frac{8}{5}p + \frac{64}{75}p^2} = \frac{\frac{16}{75}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2}
\]</div>
<p><strong>Final Answer:</strong>
The logical state fidelity of the final 2-qubit logical state as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span> is:</p>
<div class="arithmatex">\[
F_L(p) = \frac{1 - \frac{8}{5}p + \frac{16}{25}p^2}{1 - \frac{8}{5}p + \frac{64}{75}p^2}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">/</span><span class="mi">25</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.944862
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>