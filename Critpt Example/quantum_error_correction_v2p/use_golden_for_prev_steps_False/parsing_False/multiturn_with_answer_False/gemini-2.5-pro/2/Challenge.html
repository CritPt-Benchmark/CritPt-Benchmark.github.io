<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Summary of Fault-Tolerant State Preparation and Fidelity Analysis</strong></p>
<p>My objective is to determine the logical state fidelity of the prepared  <span class="arithmatex">\(|00\rangle_{AB}\)</span>  state using a specific quantum circuit and error model within the context of quantum error correction. The key is understanding how single-qubit errors propagate and how the chosen [[4,2,2]] code (a.k.a. the Shor code with two logical qubits) mitigates them.</p>
<p>First, I clarified the role of the stabilizers  <span class="arithmatex">\(S_1 = XXXX\)</span>  and  <span class="arithmatex">\(S_2 = ZZZZ\)</span>, along with the logical operators  <span class="arithmatex">\(X_A = X_0 I_1 X_2 I_3\)</span>, <span class="arithmatex">\(Z_A = Z_0 Z_1 I_2 I_3\)</span>, <span class="arithmatex">\(X_B = X_0 X_1 I_2 I_3\)</span>, and  <span class="arithmatex">\(Z_B = Z_0 I_1 Z_2 I_3\)</span> within this code. While I needed to make sure they commute with stabilizers, I noticed that the commutators for a logical qubit aren&rsquo;t matching with each other. This led me to re-examine commutation relationships, eventually realizing that the logical operators provided in the problem statement are valid.</p>
<p>Then, I meticulously analyzed the circuit  (H1, CNOTs, and measurement) to see how the logical state preparation happens in the ideal scenario and derived the logical  <span class="arithmatex">\(|00\rangle\)</span> state by tracing the circuit&rsquo;s action. This circuit prepares the logical state  <span class="arithmatex">\(|\overline{00}\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span>.</p>
<p>The core of the problem lies in the error model and post-selection: the effect of two-qubit depolarizing noise on each CNOT gate, followed by post-selection on two conditions, the ancilla qubit measurement, and a non-detection of code errors. Using this, I could see that I would have to calculate error probabilities and fidelity.</p>
<p>Given the error model, I meticulously tracked how single Pauli errors propagate through the circuit, especially focusing on how they affect the ancilla qubit&rsquo;s measurement outcome and whether they create any code errors which were not post-selected in the ideal case. This was an arduous process, which meant I had to think of a high-level picture.</p>
<p>I realized that the fidelity is approximately  <span class="arithmatex">\(1 - \frac{N_X p}{15}\)</span>, where  <span class="arithmatex">\(N_X\)</span>  is the number of propagated X-type logical errors and  <span class="arithmatex">\(p/15\)</span>  is the probability of a single error happening.</p>
<p>I systematically classified the errors, identifying those that lead to ancilla detection and those that are undetectable (but still may cause logical errors). After going through all these processes, I determined that the single X-logical errors are equivalent to the X-type operators (<span class="arithmatex">\(X_A X_B\)</span> ) which reduces the fidelity by a small amount. This leads me to arrive at the final fidelity as <span class="arithmatex">\(F = 1 - 2p/15\)</span>.</p>
                      </div>
                    </details>
<div class="content markdown-body"><p>This problem asks for the logical state fidelity of a prepared <span class="arithmatex">\(|00\rangle_{AB}\)</span> state using a specific circuit, considering a two-qubit depolarizing error model for each CNOT gate. The fidelity is to be calculated to first order in the physical error rate <span class="arithmatex">\(p\)</span>, post-selecting on no detectable errors.</p>
<h3 id="1-ideal-state-preparation">1. Ideal State Preparation</h3>
<p>First, let&rsquo;s analyze the circuit in the absence of errors. The initial state is <span class="arithmatex">\(|0000\rangle_D |0\rangle_A\)</span>, where D denotes the four data qubits (0, 1, 2, 3) and A is the ancilla qubit (4).
The circuit operations are applied from right to left as given in the problem statement:
<span class="arithmatex">\(U = (M_4) (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)\)</span>.</p>
<ol>
<li><strong>Initial state</strong>: <span class="arithmatex">\(|\psi_0\rangle = |00000\rangle\)</span>.</li>
<li><strong><span class="arithmatex">\(H_1\)</span></strong>: Applies Hadamard to qubit 1.
    <span class="arithmatex">\(|\psi_1\rangle = |0\rangle_0 |+\rangle_1 |000\rangle_{234} = \frac{1}{\sqrt{2}}(|00000\rangle + |01000\rangle)\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{12}\)</span></strong>: Control 1, target 2.
    <span class="arithmatex">\(|\psi_2\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |01100\rangle)\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{10}\)</span></strong>: Control 1, target 0.
    <span class="arithmatex">\(|\psi_3\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |11100\rangle)\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{23}\)</span></strong>: Control 2, target 3.
    <span class="arithmatex">\(|\psi_4\rangle = \frac{1}{\sqrt{2}}(|00000\rangle + |11110\rangle)\)</span>. This state is <span class="arithmatex">\(|\overline{00}\rangle |0\rangle_4\)</span>, where <span class="arithmatex">\(|\overline{00}\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span> is the desired logical state.</li>
<li><strong><span class="arithmatex">\(CNOT_{34}\)</span></strong>: Control 3, target 4. This begins the verification part.
    <span class="arithmatex">\(|\psi_5\rangle = \frac{1}{\sqrt{2}}(|0000\rangle|0\rangle_4 + |1111\rangle|1\rangle_4)\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{04}\)</span></strong>: Control 0, target 4.
    <span class="arithmatex">\(|\psi_6\rangle = \frac{1}{\sqrt{2}}(CNOT_{04}|00000\rangle + CNOT_{04}|11111\rangle) = \frac{1}{\sqrt{2}}(|00000\rangle + |11110\rangle) = |\overline{00}\rangle|0\rangle_4\)</span>.</li>
<li><strong><span class="arithmatex">\(M_4\)</span></strong>: Measure qubit 4. The state is separable, so the measurement outcome is <span class="arithmatex">\(|0\rangle\)</span> with probability 1. The data qubits are left in the state <span class="arithmatex">\(|\overline{00}\rangle\)</span>.</li>
</ol>
<p>We have verified that the ideal circuit prepares the logical state <span class="arithmatex">\(|\overline{00}\rangle = \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle)\)</span>. This state is stabilized by <span class="arithmatex">\(S_1=XXXX\)</span> and <span class="arithmatex">\(S_2=ZZZZ\)</span>, and is a simultaneous +1 eigenstate of <span class="arithmatex">\(Z_A=ZZII\)</span> and <span class="arithmatex">\(Z_B=ZIZI\)</span>.</p>
<h3 id="2-error-analysis-framework">2. Error Analysis Framework</h3>
<p>The error model states that each of the 5 CNOT gates is followed by a two-qubit depolarizing channel. This is equivalent to saying that after each CNOT, with probability <span class="arithmatex">\(p/15\)</span>, one of the 15 non-identity two-qubit Pauli operators is applied. We work to first order in <span class="arithmatex">\(p\)</span>, meaning we consider at most one such error occurring throughout the circuit.</p>
<p>The final state is post-selected on two conditions:</p>
<ol>
<li>The ancilla qubit (4) is measured to be <span class="arithmatex">\(|0\rangle\)</span>.</li>
<li>The final state of the data qubits is in the codespace (i.e., it is a +1 eigenstate of the stabilizers <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>).</li>
</ol>
<p>An error <span class="arithmatex">\(E\)</span> occurring after a gate <span class="arithmatex">\(U_k\)</span> is propagated by the subsequent gates <span class="arithmatex">\(U_{prop} = U_{final} \dots U_{k+1}\)</span>. The effective error on the final state is <span class="arithmatex">\(E_{eff} = U_{prop} E U_{prop}^\dagger\)</span>.</p>
<p>Our task is to classify each of the <span class="arithmatex">\(5 \times 15 = 75\)</span> possible error events (one for each gate and each of the 15 Paulis) into one of four categories:
a. <strong>Ancilla-detected</strong>: The propagated error <span class="arithmatex">\(E_{eff}\)</span> contains an <span class="arithmatex">\(X_4\)</span> or <span class="arithmatex">\(Y_4\)</span> component, causing the ancilla measurement to fail.
b. <strong>Code-detected</strong>: The error is not ancilla-detected, but the data-qubit part of the error, <span class="arithmatex">\(E_{data}\)</span>, anti-commutes with at least one stabilizer. This error is detected by the code.
c. <strong>Logical error</strong>: The error is not detected by ancilla or code. <span class="arithmatex">\(E_{data}\)</span> commutes with all stabilizers but is not a stabilizer itself. It changes the logical state.
d. <strong>Trivial error</strong>: <span class="arithmatex">\(E_{data}\)</span> is proportional to the identity or a stabilizer. It does not change the logical state.</p>
<p>The final fidelity is given by <span class="arithmatex">\(F = 1 - \frac{p}{15}N_X\)</span>, where <span class="arithmatex">\(N_X\)</span> is the total count of logical errors that are X-type or Y-type (i.e., they change the state <span class="arithmatex">\(|\overline{00}\rangle\)</span> to an orthogonal state).</p>
<h3 id="3-step-by-step-error-classification">3. Step-by-Step Error Classification</h3>
<p>Let <span class="arithmatex">\(C_1 = CNOT_{12}, C_2 = CNOT_{10}, C_3 = CNOT_{23}, C_4 = CNOT_{34}, C_5 = CNOT_{04}\)</span>.</p>
<p><strong>Location 1: After <span class="arithmatex">\(C_1=CNOT_{12}\)</span></strong>
- Propagator: <span class="arithmatex">\(U_{prop} = C_5 C_4 C_3 C_2\)</span>.
- An error <span class="arithmatex">\(E_{12}\)</span> on qubits (1,2) with an <span class="arithmatex">\(X_1\)</span> or <span class="arithmatex">\(Y_1\)</span> component will propagate to have an <span class="arithmatex">\(X_0\)</span> component before <span class="arithmatex">\(C_5\)</span>, which then flips the ancilla (e.g., <span class="arithmatex">\(X_1 \xrightarrow{C_2} X_0X_1\)</span>). There are 8 such errors. These are <strong>ancilla-detected</strong>.
- The 7 remaining ancilla-undetected errors are those with <span class="arithmatex">\(I_1\)</span> or <span class="arithmatex">\(Z_1\)</span> on qubit 1. A detailed analysis shows:
    - <span class="arithmatex">\(I_1 Z_2 \to E_{data} = Z_2 Z_3\)</span>. This is equivalent to the logical operator <span class="arithmatex">\(Z_A\)</span> since <span class="arithmatex">\(Z_A S_2 = (Z_0 Z_1)(ZZZZ) = Z_2 Z_3\)</span>. This is one <strong>logical Z-error</strong>.
    - The other 6 errors are <strong>code-detected</strong>.
- Summary: <span class="arithmatex">\(N_{anc\_det}=8, N_{log,Z}=1, N_{log,X}=0, N_{code\_det}=6\)</span>.</p>
<p><strong>Location 2: After <span class="arithmatex">\(C_2=CNOT_{10}\)</span></strong>
- Propagator: <span class="arithmatex">\(U_{prop} = C_5 C_4 C_3\)</span>.
- An error <span class="arithmatex">\(E_{10}\)</span> on qubits (1,0) with an <span class="arithmatex">\(X_0\)</span> or <span class="arithmatex">\(Y_0\)</span> component will flip the ancilla via <span class="arithmatex">\(C_5\)</span>. There are 8 such errors. These are <strong>ancilla-detected</strong>.
- The 7 remaining ancilla-undetected errors are considered:
    - <span class="arithmatex">\(Z_0 Z_1 \to E_{data} = Z_0 Z_1 = Z_A\)</span>. This is one <strong>logical Z-error</strong>.
    - The other 6 errors are <strong>code-detected</strong>.
- Summary: <span class="arithmatex">\(N_{anc\_det}=8, N_{log,Z}=1, N_{log,X}=0, N_{code\_det}=6\)</span>.</p>
<p><strong>Location 3: After <span class="arithmatex">\(C_3=CNOT_{23}\)</span></strong>
- Propagator: <span class="arithmatex">\(U_{prop} = C_5 C_4\)</span>.
- An error <span class="arithmatex">\(E_{23}\)</span> on qubits (2,3) with an <span class="arithmatex">\(X_3\)</span> or <span class="arithmatex">\(Y_3\)</span> component will flip the ancilla via <span class="arithmatex">\(C_4\)</span>. There are 8 such errors. These are <strong>ancilla-detected</strong>.
- The 7 remaining ancilla-undetected errors are considered:
    - <span class="arithmatex">\(Z_3 X_2 \to E_{data} = X_2 Z_3\)</span>. This operator commutes with the stabilizers. It anti-commutes with <span class="arithmatex">\(Z_B\)</span> but commutes with <span class="arithmatex">\(Z_A, X_A, X_B\)</span>. It is therefore an <strong>X-type logical error</strong> (equivalent to <span class="arithmatex">\(X_B\)</span> up to stabilizers).
    - <span class="arithmatex">\(Z_3 Z_2 \to E_{data} = Z_2 Z_3\)</span>. As seen for Location 1, this is equivalent to <span class="arithmatex">\(Z_A\)</span>. This is one <strong>logical Z-error</strong>.
    - The other 5 errors are <strong>code-detected</strong>.
- Summary: <span class="arithmatex">\(N_{anc\_det}=8, N_{log,Z}=1, N_{log,X}=1, N_{code\_det}=5\)</span>.</p>
<p><strong>Location 4: After <span class="arithmatex">\(C_4=CNOT_{34}\)</span></strong>
- Propagator: <span class="arithmatex">\(U_{prop} = C_5\)</span>.
- An error <span class="arithmatex">\(E_{34}\)</span> on qubits (3,4) with an <span class="arithmatex">\(X_4\)</span> or <span class="arithmatex">\(Y_4\)</span> component is <strong>ancilla-detected</strong> (8 errors).
- The 7 remaining ancilla-undetected errors are considered:
    - <span class="arithmatex">\(X_3 Z_4 \to E_{data} = X_0 X_3\)</span>. This is equivalent to <span class="arithmatex">\(X_A X_B\)</span> (<span class="arithmatex">\(X_A X_B S_1 = (X_1 X_2)(XXXX) = X_0 X_3\)</span>). This is an <strong>X-type logical error</strong>.
    - <span class="arithmatex">\(Z_3 Z_4 \to E_{data} = Z_0 Z_3\)</span>. This is equivalent to <span class="arithmatex">\(Z_A Z_B\)</span> (<span class="arithmatex">\(Z_A Z_B S_2 = (Z_1 Z_2)(ZZZZ) = Z_0 Z_3\)</span>). This is a <strong>Z-type logical error</strong>.
    - The other 5 errors are <strong>code-detected</strong>.
- Summary: <span class="arithmatex">\(N_{anc\_det}=8, N_{log,Z}=1, N_{log,X}=1, N_{code\_det}=5\)</span>.</p>
<p><strong>Location 5: After <span class="arithmatex">\(C_5=CNOT_{04}\)</span></strong>
- Propagator: <span class="arithmatex">\(U_{prop} = I\)</span>.
- An error <span class="arithmatex">\(E_{04}\)</span> on qubits (0,4) with an <span class="arithmatex">\(X_4\)</span> or <span class="arithmatex">\(Y_4\)</span> component is <strong>ancilla-detected</strong> (8 errors).
- The 7 remaining ancilla-undetected errors have data parts that are single-qubit Paulis on qubit 0, or the Identity.
    - <span class="arithmatex">\(I_0 Z_4 \to E_{data} = I_0\)</span>. This is a <strong>trivial error</strong>.
    - The other 6 errors (<span class="arithmatex">\(X_0, Y_0, Z_0\)</span> each appearing twice) are single-qubit errors on data qubit 0, which are all <strong>code-detected</strong>.
- Summary: <span class="arithmatex">\(N_{anc\_det}=8, N_{triv}=1, N_{code\_det}=6\)</span>.</p>
<h3 id="4-fidelity-calculation">4. Fidelity Calculation</h3>
<p>We sum the counts of each error type across all 5 locations.
- Total X-type logical errors: <span class="arithmatex">\(N_X = 0 + 0 + 1 + 1 + 0 = 2\)</span>. These errors change <span class="arithmatex">\(|\overline{00}\rangle\)</span> to an orthogonal state.
- Total Z-type logical errors: <span class="arithmatex">\(N_Z = 1 + 1 + 1 + 1 + 0 = 4\)</span>. These errors leave <span class="arithmatex">\(|\overline{00}\rangle\)</span> unchanged (up to a phase).
- Total trivial errors: <span class="arithmatex">\(N_{triv} = 0 + 0 + 0 + 0 + 1 = 1\)</span>. These leave the state unchanged.</p>
<p>To first order in <span class="arithmatex">\(p\)</span>, the state after post-selection is a mixture. The probability of success (passing post-selection) is <span class="arithmatex">\(P_{succ} \approx 1 - p \frac{N_{det}}{15}\)</span>, where <span class="arithmatex">\(N_{det} = N_{anc\_det\_tot} + N_{code\_det\_tot}\)</span>.
The final state is approximately:</p>
<div class="arithmatex">\[
\rho_{final} \approx \frac{(1-5p) + (N_Z+N_{triv})\frac{p}{15}}{P_{succ}} |\overline{00}\rangle\langle\overline{00}| + \frac{N_X \frac{p}{15}}{P_{succ}} \rho_{err}
\]</div>
<p>where <span class="arithmatex">\(\rho_{err}\)</span> is a state orthogonal to <span class="arithmatex">\(|\overline{00}\rangle\)</span>.</p>
<p>The fidelity is <span class="arithmatex">\(F = \langle\overline{00}| \rho_{final} |\overline{00}\rangle\)</span>.
To first order in <span class="arithmatex">\(p\)</span>:</p>
<div class="arithmatex">\[
F \approx \frac{1-5p + (N_Z+N_{triv})\frac{p}{15}}{1 - (N_{anc\_det\_tot}+N_{code\_det\_tot})\frac{p}{15}}
\]</div>
<p>The total number of errors is <span class="arithmatex">\(75\)</span>. The total number of undetectable errors is <span class="arithmatex">\(N_X+N_Z+N_{triv} = 2+4+1=7\)</span>. So the total number of detectable errors is <span class="arithmatex">\(75-7=68\)</span>.
<span class="arithmatex">\(P_{succ} \approx 1 - 68p/15\)</span>.
The numerator of the fidelity is the probability of being in the correct state, given success.
<span class="arithmatex">\(P(\text{correct state}) = (1-5p) + (N_Z+N_{triv})\frac{p}{15} = 1 - 5p + (4+1)\frac{p}{15} = 1 - 5p + \frac{5p}{15} = 1 - \frac{15p-p}{3} = 1 - \frac{14p}{3} = 1 - \frac{70p}{15}\)</span>.</p>
<div class="arithmatex">\[
F = \frac{1 - 70p/15}{1-68p/15} \approx \left(1-\frac{70p}{15}\right)\left(1+\frac{68p}{15}\right) \approx 1 - \frac{70p}{15} + \frac{68p}{15} = 1 - \frac{2p}{15}
\]</div>
<p>A simpler way to see this is that the infidelity <span class="arithmatex">\(1-F\)</span> is the probability of an X- or Y-type error, conditioned on success.
<span class="arithmatex">\(P(\text{X-err}) = N_X p/15 = 2p/15\)</span>.
<span class="arithmatex">\(1-F \approx \frac{P(\text{X-err})}{P_{succ}} \approx \frac{2p/15}{1} = \frac{2p}{15}\)</span>.
So, <span class="arithmatex">\(F \approx 1 - \frac{2p}{15}\)</span>.</p>
<p>Final Answer:
The logical state fidelity is <span class="arithmatex">\(F(p) = 1 - \frac{2p}{15}\)</span>.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Logical Fidelity Derivation Summary</strong></p>
<p>Okay, so I&rsquo;m tasked with creating a Python function to calculate the logical fidelity of a two-qubit code. The goal is to express the fidelity, <em>F</em>, as a function of the two-qubit gate error rate, <em>p</em>. After a thorough analysis of the quantum circuit and the error model, I&rsquo;ve arrived at the conclusion that <em>F(p) = 1 - 2p/15</em>.</p>
<p>Here&rsquo;s my thought process. I start with the ideal circuit, which prepares the state |00âŸ©. Then I factor in the two-qubit depolarizing noise after each of the five CNOT gates, with an error probability of p/15 for each of the fifteen Pauli errors. The fidelity is the overlap of the ideal state and the post-selected final mixed state. Since it&rsquo;s post-selected, there&rsquo;s a filtering aspect, conditioned on a certain ancilla outcome.</p>
<p>I&rsquo;ve analyzed error propagation through the CNOT gates to track each potential error. Using error propagation rules, I find the logical X and Z errors. I determine the relevant logic errors and ensure they are undetectable by the stabilizer measurement. The key is analyzing which single Pauli errors are undetectable by ancilla, not detected by the code stabilizers, and result in an X or Y logical error.</p>
<p>The important calculation is the effective error due to each Pauli acting at each gate location. After careful calculations and error checking, I&rsquo;ve determined that two logical X errors and four logical Z errors happen within the circuit. These errors are not picked up by code stabilizers.</p>
<p>By counting these specific errors and considering a trivial error, I&rsquo;ve calculated the final infidelity in terms of p, leading me to the final expression, F(p) = 1 - 2p/15. Now, I will put it into a Python function.</p>
                      </div>
                    </details>
<div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:08.786562
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>