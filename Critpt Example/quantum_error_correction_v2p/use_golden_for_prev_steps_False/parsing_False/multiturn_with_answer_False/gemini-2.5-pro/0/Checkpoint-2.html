<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Solution Summary for Quantum Error Correction</strong></p>
<p>My goal is to figure out the fidelity of a quantum state preparation circuit, considering the effects of two-qubit depolarizing noise that occurs during each CNOT gate. The circuit aims to create a logical GHZ state using a [[4,2,2]] code, which has four physical qubits, encodes two logical qubits, and can detect a single-qubit error. I&rsquo;ll summarize my thought process for determining the final fidelity.</p>
<p>First, I need to understand the ideal state. Starting with the initial state |0000&gt;, I apply a sequence of gates: H2, CNOT(2,1), H0, and CNOT(0,3). Although the problem states that this prepares a logical GHZ state, I want to verify it directly by applying these gates and confirming the result aligns with my understanding of logical states. Through direct calculation, I&rsquo;ve confirmed that the circuit does, in fact, produce the target logical GHZ state. The ideal state turns out to be a product of two Bell states.</p>
<p>Next, I need to account for noise. The circuit has two CNOT gates, and each one is followed by a two-qubit depolarizing error channel, introducing both Pauli errors to the state. I carefully analyze the effect of each error channel on a general state, including the ideal state. By working backwards and applying the error channels, and taking advantage of the properties of the depolarizing channel, I break the problem down into manageable chunks. Crucially, I notice that the circuit structure causes the noisy state to factorize in a particular way. This means that I can calculate the fidelity using the product of fidelities of two qubits.</p>
<p>Based on this, I realize the fidelity is a product of fidelities from 0-3 and 1-2 qubits. For each pair of qubits the fidelity is <span class="arithmatex">\(1 - 4p/5\)</span>. This results in a final physical fidelity of <span class="arithmatex">\((1 - 4p/5)^2 = 1 - 8p/5 + 16p^2/25\)</span>.</p>
<p>My calculation approach leverages the structure of the circuits, the factorization of the state, and the properties of the error channels to arrive at a much cleaner solution. The solution expresses the fidelity as a function of the two-qubit depolarization probability. This shows the error rate increases quadratically.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p><strong>1. Determine the ideal final state</strong></p>
<p>The quantum circuit acts on the initial state <span class="arithmatex">\(|\psi_0\rangle = |0000\rangle\)</span>. The circuit is given by the unitary operator <span class="arithmatex">\(U = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span>. We apply the gates sequentially to the initial state.</p>
<ol>
<li><strong>Apply <span class="arithmatex">\(H_2\)</span>:</strong> The Hadamard gate on qubit 2 transforms <span class="arithmatex">\(|0\rangle_2\)</span> to <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|0\rangle_2+|1\rangle_2)\)</span>.</li>
</ol>
<div class="arithmatex">\[
|\psi_1\rangle = H_2 |\psi_0\rangle = |00\rangle \otimes \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle) \otimes |0\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)
\]</div>
<ol start="2">
<li><strong>Apply <span class="arithmatex">\(CNOT_{21}\)</span>:</strong> This gate has control qubit 2 and target qubit 1. It flips qubit 1 if qubit 2 is <span class="arithmatex">\(|1\rangle\)</span>.</li>
</ol>
<div class="arithmatex">\[
|\psi_2\rangle = CNOT_{21} |\psi_1\rangle = \frac{1}{\sqrt{2}}(CNOT_{21}|0000\rangle + CNOT_{21}|0010\rangle)
\]</div>
<div class="codehilite"><pre><span></span><code>Since the control qubit 2 is $|0\rangle$ in the first term and $|1\rangle$ in the second term:
</code></pre></div>

<div class="arithmatex">\[
|\psi_2\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)
\]</div>
<ol start="3">
<li><strong>Apply <span class="arithmatex">\(H_0\)</span>:</strong> The Hadamard gate on qubit 0 acts on the state <span class="arithmatex">\(|\psi_2\rangle\)</span>.</li>
</ol>
<div class="arithmatex">\[
|\psi_3\rangle = H_0 |\psi_2\rangle = \frac{1}{\sqrt{2}}(H_0|0000\rangle + H_0|0110\rangle)
\]</div>
<div class="arithmatex">\[
|\psi_3\rangle = \frac{1}{\sqrt{2}}\left(\frac{1}{\sqrt{2}}(|0000\rangle+|1000\rangle) + \frac{1}{\sqrt{2}}(|0110\rangle+|1110\rangle)\right) = \frac{1}{2}(|0000\rangle+|1000\rangle+|0110\rangle+|1110\rangle)
\]</div>
<ol start="4">
<li><strong>Apply <span class="arithmatex">\(CNOT_{03}\)</span>:</strong> This gate has control qubit 0 and target qubit 3.</li>
</ol>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = CNOT_{03} |\psi_3\rangle = \frac{1}{2}(CNOT_{03}|0000\rangle+CNOT_{03}|1000\rangle+CNOT_{03}|0110\rangle+CNOT_{03}|1110\rangle)
\]</div>
<div class="codehilite"><pre><span></span><code><span class="nv">The</span><span class="w"> </span><span class="nv">control</span><span class="w"> </span><span class="nv">qubit</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span>$<span class="o">|</span><span class="mi">0</span>\<span class="nv">rangle</span>$<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">first</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">third</span><span class="w"> </span><span class="nv">terms</span>,<span class="w"> </span><span class="nv">and</span><span class="w"> </span>$<span class="o">|</span><span class="mi">1</span>\<span class="nv">rangle</span>$<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">second</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">fourth</span><span class="w"> </span><span class="nv">terms</span>:
</code></pre></div>

<div class="arithmatex">\[
|\psi_{ideal}\rangle = \frac{1}{2}(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle)
\]</div>
<p>This is the ideal final physical state. We can recognize this state as a product of two Bell states by grouping qubits (0,3) and (1,2):</p>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = \frac{1}{2}(|00\rangle_{03}|00\rangle_{12} + |11\rangle_{03}|00\rangle_{12} + |00\rangle_{03}|11\rangle_{12} + |11\rangle_{03}|11\rangle_{12})
\]</div>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = \frac{1}{2}(|00\rangle_{03}+|11\rangle_{03}) \otimes (|00\rangle_{12}+|11\rangle_{12})
\]</div>
<p>Let <span class="arithmatex">\(|\Phi^+\rangle_{ij} = \frac{1}{\sqrt{2}}(|00\rangle_{ij} + |11\rangle_{ij})\)</span> be the Bell state on qubits <span class="arithmatex">\(i\)</span> and <span class="arithmatex">\(j\)</span>. Then:</p>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}
\]</div>
<p><strong>2. Analyze the evolution of the density matrix with errors</strong></p>
<p>We trace the evolution of the system&rsquo;s density matrix <span class="arithmatex">\(\rho\)</span>, starting from <span class="arithmatex">\(\rho_0 = |\psi_0\rangle\langle\psi_0|\)</span>.</p>
<ol>
<li>The initial state can be written as a product state over the (0,3) and (1,2) bipartition:</li>
</ol>
<div class="arithmatex">\[
\rho_0 = |0000\rangle\langle 0000| = (|00\rangle_{03}\langle 00|_{03}) \otimes (|00\rangle_{12}\langle 00|_{12})
\]</div>
<ol start="2">
<li>The first two gates, <span class="arithmatex">\(U_{BA} = CNOT_{21} H_2\)</span>, act only on qubits 1 and 2.</li>
</ol>
<div class="arithmatex">\[
\rho_2 = U_{BA} \rho_0 U_{BA}^\dagger = (|00\rangle_{03}\langle 00|_{03}) \otimes (U_{BA}' |00\rangle_{12}\langle 00|_{12} U_{BA}'^\dagger)
\]</div>
<div class="codehilite"><pre><span></span><code>where $U_{BA}&#39;$ is the action of $CNOT_{21} H_2$ on the 2-qubit space (1,2). From step 1, we know $U_{BA}&#39;|00\rangle_{12} = |\Phi^+\rangle_{12}$.
</code></pre></div>

<div class="arithmatex">\[
\rho_2 = (|00\rangle_{03}\langle 00|_{03}) \otimes (|\Phi^+\rangle_{12}\langle\Phi^+|_{12})
\]</div>
<ol start="3">
<li>The first error channel, <span class="arithmatex">\(\mathcal{E}_{21}\)</span>, is a two-qubit depolarizing channel on qubits 1 and 2. It acts on <span class="arithmatex">\(\rho_2\)</span>.</li>
</ol>
<div class="arithmatex">\[
\rho_3 = \mathcal{E}_{21}(\rho_2) = (|00\rangle_{03}\langle 00|_{03}) \otimes \mathcal{E}_{21}(|\Phi^+\rangle_{12}\langle\Phi^+|_{12})
\]</div>
<ol start="4">
<li>The next two gates, <span class="arithmatex">\(U_{DC} = CNOT_{03} H_0\)</span>, act only on qubits 0 and 3.</li>
</ol>
<div class="arithmatex">\[
\rho_5 = U_{DC} \rho_3 U_{DC}^\dagger = (U_{DC}'|00\rangle_{03}\langle 00|_{03}U_{DC}'^\dagger) \otimes \mathcal{E}_{21}(|\Phi^+\rangle_{12}\langle\Phi^+|_{12})
\]</div>
<div class="codehilite"><pre><span></span><code>where $U_{DC}&#39;$ is the action of $CNOT_{03}H_0$ on the 2-qubit space (0,3). We can see from the calculation of the ideal state that $U_{DC}&#39;|00\rangle_{03}=|\Phi^+\rangle_{03}$.
</code></pre></div>

<div class="arithmatex">\[
\rho_5 = (|\Phi^+\rangle_{03}\langle\Phi^+|_{03}) \otimes \mathcal{E}_{21}(|\Phi^+\rangle_{12}\langle\Phi^+|_{12})
\]</div>
<ol start="5">
<li>The final error channel, <span class="arithmatex">\(\mathcal{E}_{03}\)</span>, acts on qubits 0 and 3.</li>
</ol>
<div class="arithmatex">\[
\rho_{final} = \mathcal{E}_{03}(\rho_5) = \mathcal{E}_{03}(|\Phi^+\rangle_{03}\langle\Phi^+|_{03}) \otimes \mathcal{E}_{21}(|\Phi^+\rangle_{12}\langle\Phi^+|_{12})
\]</div>
<p><strong>3. Calculate the final state fidelity</strong></p>
<p>The physical fidelity is given by <span class="arithmatex">\(F_{phys} = \langle\psi_{ideal}|\rho_{final}|\psi_{ideal}\rangle\)</span>. Since both the ideal state <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span> and the final state <span class="arithmatex">\(\rho_{final}\)</span> factorize over the (0,3) and (1,2) bipartition, the fidelity also factorizes:</p>
<div class="arithmatex">\[
F_{phys} = \left( \langle\Phi^+_{03}| \mathcal{E}_{03}(|\Phi^+\rangle_{03}\langle\Phi^+|_{03}) |\Phi^+_{03}\rangle \right) \times \left( \langle\Phi^+_{12}| \mathcal{E}_{21}(|\Phi^+\rangle_{12}\langle\Phi^+|_{12}) |\Phi^+_{12}\rangle \right)
\]</div>
<div class="arithmatex">\[
F_{phys} = F_{03} \times F_{12}
\]</div>
<p>The two factors <span class="arithmatex">\(F_{03}\)</span> and <span class="arithmatex">\(F_{12}\)</span> are identical in form. Let&rsquo;s calculate one of them, for a generic pair of qubits <span class="arithmatex">\((i,j)\)</span>:</p>
<div class="arithmatex">\[
F_{ij} = \langle\Phi^+_{ij}| \mathcal{E}_{ij}(|\Phi^+\rangle_{ij}\langle\Phi^+|_{ij}) |\Phi^+_{ij}\rangle
\]</div>
<p>The error channel is <span class="arithmatex">\(\mathcal{E}_{ij}(\rho) = (1-p)\rho + \frac{p}{15}\sum_{P \in \{I,X,Y,Z\}^{\otimes 2} \setminus \{II\}} P\rho P\)</span>.</p>
<div class="arithmatex">\[
F_{ij} = (1-p)\langle\Phi^+_{ij}|(|\Phi^+\rangle_{ij}\langle\Phi^+|_{ij})|\Phi^+_{ij}\rangle + \frac{p}{15}\sum_{P \neq II} \langle\Phi^+_{ij}| P (|\Phi^+\rangle_{ij}\langle\Phi^+|_{ij}) P |\Phi^+_{ij}\rangle
\]</div>
<div class="arithmatex">\[
F_{ij} = (1-p) + \frac{p}{15}\sum_{P \neq II} |\langle\Phi^+_{ij}| P |\Phi^+_{ij}\rangle|^2
\]</div>
<p>We need to compute the expectation values of the 15 non-identity two-qubit Pauli operators for the Bell state <span class="arithmatex">\(|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\)</span>. The only Pauli operators with non-zero expectation values for <span class="arithmatex">\(|\Phi^+\rangle\)</span> are those that stabilize it (up to a phase). The stabilizers of <span class="arithmatex">\(|\Phi^+\rangle\)</span> are <span class="arithmatex">\(X\otimes X\)</span> and <span class="arithmatex">\(Z\otimes Z\)</span>.
*   <span class="arithmatex">\(\langle\Phi^+| X\otimes X |\Phi^+\rangle = \frac{1}{2}(\langle 00|+\langle 11|)(|11\rangle+|00\rangle) = 1\)</span>
*   <span class="arithmatex">\(\langle\Phi^+| Z\otimes Z |\Phi^+\rangle = \frac{1}{2}(\langle 00|+\langle 11|)(|00\rangle+|11\rangle) = 1\)</span>
*   The operator <span class="arithmatex">\(Y\otimes Y = (iXZ)(iXZ) = - (XX)(ZZ)\)</span>. So, <span class="arithmatex">\(\langle\Phi^+| Y\otimes Y |\Phi^+\rangle = \langle\Phi^+|-(XX)(ZZ)|\Phi^+\rangle = -1 \cdot \langle\Phi^+|XX|\Phi^+\rangle \cdot \langle\Phi^+|ZZ|\Phi^+\rangle = -1\)</span>.
All other 12 non-identity Pauli operators have zero expectation value. For example, <span class="arithmatex">\(\langle\Phi^+| X\otimes I |\Phi^+\rangle = \frac{1}{2}(\langle 00|+\langle 11|)(|10\rangle+|01\rangle)=0\)</span>.
The sum of the squared expectation values is:</p>
<div class="arithmatex">\[
\sum_{P \neq II} |\langle\Phi^+_{ij}| P |\Phi^+_{ij}\rangle|^2 = (1)^2 + (1)^2 + (-1)^2 = 3
\]</div>
<p>Substituting this back into the expression for <span class="arithmatex">\(F_{ij}\)</span>:</p>
<div class="arithmatex">\[
F_{ij} = (1-p) + \frac{p}{15}(3) = 1-p + \frac{p}{5} = 1 - \frac{4}{5}p
\]</div>
<p>Since <span class="arithmatex">\(F_{03} = F_{12} = 1 - \frac{4}{5}p\)</span>, the total physical fidelity is:</p>
<div class="arithmatex">\[
F_{phys} = \left(1 - \frac{4}{5}p\right) \left(1 - \frac{4}{5}p\right) = \left(1 - \frac{4}{5}p\right)^2
\]</div>
<p>Expanding this expression gives the final result:</p>
<div class="arithmatex">\[
F_{phys} = 1 - 2\left(\frac{4}{5}p\right) + \left(\frac{4}{5}p\right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div>
<p><strong>Final Answer:</strong>
The physical state fidelity of the final 4-qubit state is given by the function:</p>
<div class="arithmatex">\[
F_{phys}(p) = 1 - \frac{8}{5}p + \frac{16}{25}p^2
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>A Deep Dive into Logical Fidelity in a [[4,2,2]] Code</strong></p>
<p>Okay, here&rsquo;s the plan for Subproblem 2. My goal is to figure out the <em>logical</em> fidelity, not just the physical one, after running the circuit and dealing with some noise. The circuit&rsquo;s the same, starting with <code>|0000&gt;</code> and hitting a couple of noisy CNOT gates, with some depolarizing noise after each. The kicker? We&rsquo;re post-selecting on detectable errors in the code. That&rsquo;s the key.</p>
<p>First things first: I&rsquo;m dealing with a [[4,2,2]] code, which is all about error correction. I know its stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>. The encoded &ldquo;good&rdquo; space is where the state keeps these stabilizers the same. Essentially, the post-selection here means we only consider final states which &ldquo;survive&rdquo; the stabilizer measurements - states where measuring <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span> both give a &ldquo;no error&rdquo; outcome. This will be critical for how the &ldquo;logical&rdquo; fidelity works.</p>
<p>Now, let&rsquo;s connect the logical picture to the physical one. The circuit is aiming to make the logical GHZ state (a superposition of <span class="arithmatex">\(|00\rangle_{AB}\)</span> and <span class="arithmatex">\(|11\rangle_{AB}\)</span>). I&rsquo;ve got that ideal physical state <span class="arithmatex">\(|\psi_{phys, ideal}\rangle\)</span> from the previous problem. It&rsquo;s the entangled state generated by the circuit. I need to make sure this physical state <em>actually</em> represents the desired logical state.  I&rsquo;ve got the logical operators, <span class="arithmatex">\(Z_A\)</span> and <span class="arithmatex">\(Z_B\)</span>, defined in the problem.  I have to check that my ideal physical state is in the right space by comparing the physical and logical operators. This is where I almost got tripped up. The important note is that these logical operators are only defined <em>up to stabilizers</em>. I need to construct the logical basis, and show this ideal physical state really is what it says it is.</p>
<p>The real challenge is figuring out what these noise errors do to the situation <em>after</em> that post-selection. From subproblem 1, I have a physical density matrix <span class="arithmatex">\(\rho_{final}\)</span> to work with. So, post-selecting means taking only the part of <span class="arithmatex">\(\rho_{final}\)</span> that&rsquo;s in that codespace (states that give <span class="arithmatex">\(XXXX = +1\)</span> and <span class="arithmatex">\(ZZZZ = +1\)</span>) and normalizing it.  The idea is that I am projecting the noisey state into the stabilizer&rsquo;s +1 space. The logical fidelity is the <em>overlap</em> of the post-selected state with that perfect GHZ physical state <span class="arithmatex">\(|\psi_{phys,ideal}\rangle\)</span>.  Mathematically it&rsquo;s: <span class="arithmatex">\(F_{log} = \langle\psi_{phys, ideal}| P_{code} \rho_{final} P_{code} |\psi_{phys, ideal}\rangle / \text{Tr}(P_{code} \rho_{final})\)</span>, where <span class="arithmatex">\(P_{code}\)</span> is the code projector.</p>
<p>This breaks down really nicely:  <span class="arithmatex">\(F_{log} = \frac{\langle\psi_{phys, ideal}| \rho_{final} |\psi_{phys, ideal}\rangle}{\text{Tr}(P_{code} \rho_{final})}\)</span> because <span class="arithmatex">\(|\psi_{phys,ideal}\rangle\)</span> is already in the codespace. So, it simplifies to <span class="arithmatex">\(F_{log} = F_{phys} / P_{success}\)</span>, where <span class="arithmatex">\(F_{phys}\)</span> is the physical fidelity I got from part 1, and <span class="arithmatex">\(P_{success}\)</span> is the probability of actually having no <em>detectable</em> errors that would kick us out of that subspace during post-selection.</p>
<p>To find <span class="arithmatex">\(P_{success}\)</span>, I need to understand what happens to <span class="arithmatex">\(\rho_{final}\)</span> through the noise, before the post-selection. This is about working out what errors are <em>undetectable</em> (meaning they commute with both stabilizers) and what errors are <em>detectable</em>. If an error&rsquo;s detectable, it gets projected out by post-selection. If not, it can stay around.</p>
<p>My plan here is to <em>exactly</em> write <span class="arithmatex">\(\rho_{final}\)</span>, and break it down into all possible Pauli errors. The noise affects the state after each of the CNOT gates (0,3) and (2,1).  I can see the final state being built by the effect of the noisy CNOT gates on (0,3) and then on (1,2). The probability of an error on one CNOT is <span class="arithmatex">\(p\)</span>, meaning that probability of error free is <span class="arithmatex">\((1-p)\)</span>.</p>
<p>The key here is that, for the state I am trying to prepare, the <em>undetectable errors actually correspond to logical operators that act trivially!</em> Let me break this down for the post-selection.</p>
<p>I broke down that final <span class="arithmatex">\(\rho_{final}\)</span> state into terms, with contributions from each possible Pauli error. And by looking at what physical errors</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p><strong>1. Define Logical Fidelity with Post-selection</strong></p>
<p>The final physical state of the system is described by the density matrix <span class="arithmatex">\(\rho_{final}\)</span>, which we analyzed in Subproblem 1. Post-selection on detectable errors means we project the final state into the codespace and renormalize. The projector onto the codespace <span class="arithmatex">\(\mathcal{C}\)</span> is given by <span class="arithmatex">\(P_{\mathcal{C}} = \frac{1}{4}(I+S_1)(I+S_2)\)</span>, where <span class="arithmatex">\(S_1=XXXX\)</span> and <span class="arithmatex">\(S_2=ZZZZ\)</span> are the stabilizers.</p>
<p>The post-selected state is:</p>
<div class="arithmatex">\[
\rho_{ps} = \frac{P_{\mathcal{C}} \rho_{final} P_{\mathcal{C}}}{\text{Tr}(P_{\mathcal{C}} \rho_{final})}
\]</div>
<p>The logical fidelity is the fidelity of this post-selected state with respect to the ideal logical state. Since the ideal physical state <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span> is already in the codespace, <span class="arithmatex">\(P_{\mathcal{C}}|\psi_{ideal}\rangle = |\psi_{ideal}\rangle\)</span>. The logical fidelity is thus:</p>
<div class="arithmatex">\[
F_{log} = \langle\psi_{ideal}| \rho_{ps} |\psi_{ideal}\rangle = \frac{\langle\psi_{ideal}| P_{\mathcal{C}} \rho_{final} P_{\mathcal{C}} |\psi_{ideal}\rangle}{\text{Tr}(P_{\mathcal{C}} \rho_{final})} = \frac{\langle\psi_{ideal}| \rho_{final} |\psi_{ideal}\rangle}{\text{Tr}(P_{\mathcal{C}} \rho_{final})}
\]</div>
<p>The numerator is the physical fidelity <span class="arithmatex">\(F_{phys}\)</span> calculated in Subproblem 1. The denominator is the probability of the post-selection succeeding (i.e., not detecting an error), which we denote <span class="arithmatex">\(P_{success}\)</span>.</p>
<div class="arithmatex">\[
F_{log} = \frac{F_{phys}}{P_{success}}
\]</div>
<p><strong>2. Analyze Undetectable Errors</strong></p>
<p>An error is undetectable if it commutes with all stabilizers of the code. The errors in our model occur on qubits (2,1) and (0,3).</p>
<ul>
<li>
<p><strong>Errors on qubits (1,2):</strong> An error operator <span class="arithmatex">\(E_{12}\)</span> is undetectable if it commutes with <span class="arithmatex">\(S_1 = X_0X_1X_2X_3\)</span> and <span class="arithmatex">\(S_2 = Z_0Z_1Z_2Z_3\)</span>. Since <span class="arithmatex">\(E_{12}\)</span> acts as identity on qubits 0 and 3, this condition simplifies to <span class="arithmatex">\(E_{12}\)</span> commuting with <span class="arithmatex">\(X_1X_2\)</span> and <span class="arithmatex">\(Z_1Z_2\)</span>. The two-qubit Pauli operators that commute with both <span class="arithmatex">\(X_1X_2\)</span> and <span class="arithmatex">\(Z_1Z_2\)</span> are, up to phase, <span class="arithmatex">\(\{I_1I_2, X_1X_2, Y_1Y_2, Z_1Z_2\}\)</span>. These are the 3 non-trivial undetectable errors on this pair.</p>
</li>
<li>
<p><strong>Errors on qubits (0,3):</strong> Similarly, an error <span class="arithmatex">\(E_{03}\)</span> is undetectable if it commutes with <span class="arithmatex">\(X_0X_3\)</span> and <span class="arithmatex">\(Z_0Z_3\)</span>. The non-trivial undetectable errors are <span class="arithmatex">\(\{X_0X_3, Y_0Y_3, Z_0Z_3\}\)</span>.</p>
</li>
</ul>
<p>Any error that is not in these sets is detectable. For each CNOT gate, there are 15 possible non-identity Pauli errors, each with probability <span class="arithmatex">\(p/15\)</span>. Thus, the probability of an undetectable error occurring is <span class="arithmatex">\(3 \times (p/15) = p/5\)</span>. The probability of a detectable error is <span class="arithmatex">\(12 \times (p/15) = 4p/5\)</span>.</p>
<p><strong>3. Calculate the Success Probability <span class="arithmatex">\(P_{success}\)</span></strong></p>
<p>The post-selection succeeds if no detectable errors occur during the circuit.
For the first CNOT gate (<span class="arithmatex">\(CNOT_{21}\)</span>), the probability of either no error or an undetectable error is <span class="arithmatex">\((1-p) + \frac{3p}{15} = 1 - p + \frac{p}{5} = 1 - \frac{4}{5}p\)</span>.
For the second CNOT gate (<span class="arithmatex">\(CNOT_{03}\)</span>), the probability of either no error or an undetectable error is also <span class="arithmatex">\(1 - \frac{4}{5}p\)</span>.
Since the error channels are independent, the total probability of success is the product:</p>
<div class="arithmatex">\[
P_{success} = \left(1 - \frac{4}{5}p\right) \left(1 - \frac{4}{5}p\right) = \left(1 - \frac{4}{5}p\right)^2
\]</div>
<p><strong>4. Analyze the Effect of Undetectable Errors on the Ideal State</strong></p>
<p>The ideal physical state is <span class="arithmatex">\(|\psi_{ideal}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}\)</span>, where <span class="arithmatex">\(|\Phi^+\rangle_{ij} = \frac{1}{\sqrt{2}}(|00\rangle_{ij} + |11\rangle_{ij})\)</span>. This state encodes the logical GHZ state <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>.</p>
<p>Let&rsquo;s examine the effect of the undetectable errors on the components of the ideal state.
The state <span class="arithmatex">\(|\Phi^+\rangle_{ij}\)</span> is a Bell state. Its stabilizers are <span class="arithmatex">\(X_iX_j\)</span> and <span class="arithmatex">\(Z_iZ_j\)</span>.
*   <span class="arithmatex">\(X_iX_j |\Phi^+\rangle_{ij} = |\Phi^+\rangle_{ij}\)</span>
*   <span class="arithmatex">\(Z_iZ_j |\Phi^+\rangle_{ij} = |\Phi^+\rangle_{ij}\)</span>
*   <span class="arithmatex">\(Y_iY_j |\Phi^+\rangle_{ij} = (iX_iZ_i)(iX_jZ_j) |\Phi^+\rangle_{ij} = -(X_iX_j)(Z_iZ_j) |\Phi^+\rangle_{ij} = -|\Phi^+\rangle_{ij}\)</span></p>
<p>Crucially, the set of undetectable physical errors for each noisy gate location is precisely the set of stabilizers for the corresponding part of the ideal physical state.
When an undetectable error <span class="arithmatex">\(E_{12} \in \{X_1X_2, Y_1Y_2, Z_1Z_2\}\)</span> occurs on qubits (1,2), the state <span class="arithmatex">\(|\Phi^+\rangle_{12}\)</span> is mapped to <span class="arithmatex">\(\pm |\Phi^+\rangle_{12}\)</span>. The corresponding density matrix <span class="arithmatex">\(|\Phi^+\rangle_{12}\langle\Phi^+|_{12}\)</span> is left invariant. The same holds for undetectable errors on qubits (0,3) acting on <span class="arithmatex">\(|\Phi^+\rangle_{03}\)</span>.</p>
<p>This means that any undetectable error leaves the ideal density matrix <span class="arithmatex">\(|\psi_{ideal}\rangle\langle\psi_{ideal}|\)</span> unchanged.</p>
<p><strong>5. Calculate the Logical Fidelity</strong></p>
<p>Let&rsquo;s trace the state. The final state is <span class="arithmatex">\(\rho_{final} = \rho_{03} \otimes \rho_{12}\)</span>, where <span class="arithmatex">\(\rho_{ij} = \mathcal{E}_{ij}(|\Phi^+\rangle_{ij}\langle\Phi^+|_{ij})\)</span>.
We can split the error channel&rsquo;s action into three parts: no error, undetectable error, and detectable error.</p>
<div class="arithmatex">\[
\mathcal{E}_{ij}(|\Phi^+\rangle\langle\Phi^+|) = (1-p)|\Phi^+\rangle\langle\Phi^+| + \frac{p}{15}\sum_{E \in \mathcal{U}_{ij}} E|\Phi^+\rangle\langle\Phi^+|E^\dagger + \frac{p}{15}\sum_{E \in \mathcal{D}_{ij}} E|\Phi^+\rangle\langle\Phi^+|E^\dagger
\]</div>
<p>where <span class="arithmatex">\(\mathcal{U}_{ij}\)</span> is the set of 3 non-identity undetectable errors and <span class="arithmatex">\(\mathcal{D}_{ij}\)</span> is the set of 12 detectable errors.
As shown above, for any <span class="arithmatex">\(E \in \mathcal{U}_{ij}\)</span>, <span class="arithmatex">\(E|\Phi^+\rangle\langle\Phi^+|E^\dagger = |\Phi^+\rangle\langle\Phi^+|\)</span>.
So the part of the state corresponding to no error or an undetectable error is:</p>
<div class="arithmatex">\[
(1-p)|\Phi^+\rangle\langle\Phi^+| + \frac{3p}{15}|\Phi^+\rangle\langle\Phi^+| = \left(1-\frac{4}{5}p\right)|\Phi^+\rangle\langle\Phi^+|
\]</div>
<p>This component lies in the codespace. The remaining part, caused by detectable errors, lies in error subspaces orthogonal to the codespace.</p>
<p>The component of <span class="arithmatex">\(\rho_{final}\)</span> that survives post-selection (i.e., lies in the codespace) is:</p>
<div class="arithmatex">\[
P_{\mathcal{C}}\rho_{final}P_{\mathcal{C}} = \left( \left(1-\frac{4}{5}p\right)|\Phi^+_{03}\rangle\langle\Phi^+_{03}| \right) \otimes \left( \left(1-\frac{4}{5}p\right)|\Phi^+_{12}\rangle\langle\Phi^+_{12}| \right)
\]</div>
<div class="arithmatex">\[
P_{\mathcal{C}}\rho_{final}P_{\mathcal{C}} = \left(1-\frac{4}{5}p\right)^2 |\psi_{ideal}\rangle\langle\psi_{ideal}|
\]</div>
<p>Now we can compute the numerator and denominator for the logical fidelity.
*   <strong>Numerator:</strong> <span class="arithmatex">\(F_{phys} = \langle\psi_{ideal}| \rho_{final} |\psi_{ideal}\rangle\)</span>. The ideal state projects out only the component of <span class="arithmatex">\(\rho_{final}\)</span> proportional to itself.</p>
<div class="arithmatex">\[
F_{phys} = \left(1-\frac{4}{5}p\right)^2 \langle\psi_{ideal}| \left( |\psi_{ideal}\rangle\langle\psi_{ideal}| \right) |\psi_{ideal}\rangle = \left(1-\frac{4}{5}p\right)^2
\]</div>
<div class="codehilite"><pre><span></span><code>This matches the result from Subproblem 1.
</code></pre></div>

<ul>
<li><strong>Denominator:</strong> <span class="arithmatex">\(P_{success} = \text{Tr}(P_{\mathcal{C}}\rho_{final})\)</span>. Using the property <span class="arithmatex">\(\text{Tr}(AB)=\text{Tr}(BA)\)</span> and <span class="arithmatex">\(P_{\mathcal{C}}^2=P_{\mathcal{C}}\)</span>:</li>
</ul>
<div class="arithmatex">\[
P_{success} = \text{Tr}(P_{\mathcal{C}}\rho_{final}P_{\mathcal{C}}) = \text{Tr}\left(\left(1-\frac{4}{5}p\right)^2 |\psi_{ideal}\rangle\langle\psi_{ideal}|\right) = \left(1-\frac{4}{5}p\right)^2
\]</div>
<p>Finally, the logical fidelity is:</p>
<div class="arithmatex">\[
F_{log} = \frac{F_{phys}}{P_{success}} = \frac{\left(1 - \frac{4}{5}p\right)^2}{\left(1 - \frac{4}{5}p\right)^2} = 1
\]</div>
<p>The logical fidelity is 1 because for this specific logical state, the only errors that can occur without being detected are those that act as stabilizers on the physical state, leaving the logical state invariant.</p>
<p><strong>Final Answer:</strong>
The logical state fidelity of the final 2-qubit logical state, after post-selection, is:</p>
<div class="arithmatex">\[
F_{log}(p) = 1
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.039569
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>