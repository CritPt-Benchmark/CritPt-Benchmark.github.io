<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-1</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-1</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>Decomposing and Solving the 4-Qubit Fidelity Problem</strong></p>
<p>Alright, let&rsquo;s break down this problem. My goal is to figure out how well a specific quantum state, prepared by a particular circuit, holds up under the influence of noise. This circuit prepares a 4-qubit state, and the &ldquo;noise&rdquo; comes in the form of a depolarizing channel, acting on pairs of qubits after each CNOT gate. The end goal is to express the fidelity, how similar the actual noisy state is to the perfect one, as a function of the error rate <code>p</code>.</p>
<p>The key to unlocking this problem is understanding the circuit&rsquo;s building blocks and the error model. The circuit, in reverse order, goes: <span class="arithmatex">\(H_2\)</span>, <span class="arithmatex">\(CNOT_{21}\)</span>, <span class="arithmatex">\(H_0\)</span>, <span class="arithmatex">\(CNOT_{03}\)</span>.  The errors pop up after those CNOT gates.  I can treat the initial state as all <span class="arithmatex">\(|0\rangle\)</span>s, or <span class="arithmatex">\(|0000\rangle\)</span>. After the noisy CNOT gates, the two-qubit depolarizing channel has a chance of leaving the quantum state alone or, otherwise, applying a random Pauli operator to it, as I know. It&rsquo;s essentially a mixed bag of potential Pauli operators.</p>
<p>First, I need to figure out what the &ldquo;ideal&rdquo; state should look like without any errors. Tracing through the circuit, the first two gates, <span class="arithmatex">\(H_2\)</span> and <span class="arithmatex">\(CNOT_{21}\)</span>, create a Bell pair on qubits 1 and 2.  Then, the second set of gates, <span class="arithmatex">\(H_0\)</span> and <span class="arithmatex">\(CNOT_{03}\)</span>, makes a Bell pair on qubits 0 and 3.  Since these two sets of operations act on separate sets of qubits, the final &ldquo;ideal&rdquo; state turns out to be a tensor product: a Bell pair on qubits 0,3 tensor a Bell pair on qubits 1,2. I can write this as <span class="arithmatex">\(|\psi_{ideal}\rangle = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}\)</span> where <span class="arithmatex">\(|\Phi^+\rangle\)</span> means a standard Bell state.</p>
<p>With the ideal state in hand, I can focus on modelling how the circuit gets ruined by errors. The state starts as all <span class="arithmatex">\(|0\rangle\)</span>, so <span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>.  Then I can step by step apply the circuit and error channels. The steps are, first a block of operations and an error on qubits 1, 2,  and then a second block of operations and an error on qubits 0, 3. The noise is like a filter that distorts the quantum state at each CNOT operation.  The channel, written in my code, is <span class="arithmatex">\(\mathcal{E}(\rho) = (1-p) \rho + p \sum_{P \in \{I,X,Y,Z\}^{\otimes 2} \setminus \{II\}} \frac{P \rho P^\dagger}{15}\)</span>.  The important part is that with probability <span class="arithmatex">\(p\)</span>, one of the 15 Pauli operators (besides the identity) will randomly flip or rotate the states.</p>
<p>Fidelity, <span class="arithmatex">\(F\)</span>, is the inner product of the ideal state with the noisy density matrix <span class="arithmatex">\(\rho_{final}\)</span>:  <span class="arithmatex">\(F = \langle\psi_{ideal}|\rho_{final}|\psi_{ideal}\rangle\)</span>. The key insight is that since the operations and the errors act on different qubit pairs independently (0,3 and 1,2), the whole process factorizes. That means I can calculate the fidelity for one pair, and then square the answer.  This huge simplification comes from the fact that the two error channels act on different qubit spaces:  it&rsquo;s a product of fidelities, and I just have to do it once!</p>
<p>To do this, I break the final state up into smaller steps and solve for the total fidelity. First, I compute what happens if I apply a single noisy CNOT to an initial state <span class="arithmatex">\(\rho_0 = |0000\rangle\langle0000|\)</span>, which can be written in a density matrix.  After doing so, I then calculate the average over all 2-qubit Paulis (apart from the identity). Then, I compute the fidelity. From this, I compute that the fidelity on the bell state after the error is <span class="arithmatex">\(F_{gate} = 1 - \frac{4p}{5}\)</span>.  Finally, since the errors are independent, the total fidelity of the 4-qubit state will be the square of that number!  Therefore, the final answer is <span class="arithmatex">\(F = (1 - \frac{4p}{5})^2\)</span>.</p>
                      </div>
                    </details>
<div class="content markdown-body"><h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p>The goal is to compute the physical state fidelity <span class="arithmatex">\(F = \langle\psi_{ideal}|\rho_{final}|\psi_{ideal}\rangle\)</span>, where <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span> is the state prepared by the noiseless circuit and <span class="arithmatex">\(\rho_{final}\)</span> is the state prepared by the noisy circuit.</p>
<p><strong>1. Determine the ideal final state <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span></strong></p>
<p>The circuit operations are applied from right to left to the initial state <span class="arithmatex">\(|\psi_{in}\rangle = |0000\rangle\)</span>.
The unitary for the circuit is <span class="arithmatex">\(U = (CNOT_{03}) (H_0) (CNOT_{21}) (H_2)\)</span>.</p>
<ol>
<li>Initial state:</li>
</ol>
<div class="arithmatex">\[
|\psi_0\rangle = |0000\rangle = |0\rangle_0 |0\rangle_1 |0\rangle_2 |0\rangle_3
\]</div>
<ol start="2">
<li>Apply the Hadamard gate <span class="arithmatex">\(H_2\)</span> to qubit 2:</li>
</ol>
<div class="arithmatex">\[
|\psi_1\rangle = H_2 |\psi_0\rangle = |0\rangle_0 |0\rangle_1 \frac{1}{\sqrt{2}}(|0\rangle_2+|1\rangle_2) |0\rangle_3 = \frac{1}{\sqrt{2}}(|0000\rangle + |0010\rangle)
\]</div>
<ol start="3">
<li>Apply the <span class="arithmatex">\(CNOT_{21}\)</span> gate (control on qubit 2, target on qubit 1):</li>
</ol>
<div class="arithmatex">\[
|\psi_2\rangle = CNOT_{21} |\psi_1\rangle = \frac{1}{\sqrt{2}}(CNOT_{21}|0000\rangle + CNOT_{21}|0010\rangle) = \frac{1}{\sqrt{2}}(|0000\rangle + |0110\rangle)
\]</div>
<div class="codehilite"><pre><span></span><code>This state can be factored as a tensor product:
</code></pre></div>

<div class="arithmatex">\[
|\psi_2\rangle = |0\rangle_0 |0\rangle_3 \otimes \frac{1}{\sqrt{2}}(|00\rangle_{12} + |11\rangle_{12}) = |00\rangle_{03} \otimes |\Phi^+\rangle_{12}
\]</div>
<div class="codehilite"><pre><span></span><code>where $|\Phi^+\rangle_{12} = \frac{1}{\sqrt{2}}(|00\rangle_{12} + |11\rangle_{12})$ is a Bell state on qubits 1 and 2.
</code></pre></div>

<ol start="4">
<li>Apply the Hadamard gate <span class="arithmatex">\(H_0\)</span> to qubit 0:</li>
</ol>
<div class="arithmatex">\[
|\psi_3\rangle = H_0 |\psi_2\rangle = \left(H_0|00\rangle_{03}\right) \otimes |\Phi^+\rangle_{12} = \frac{1}{\sqrt{2}}(|00\rangle_{03} + |10\rangle_{03}) \otimes |\Phi^+\rangle_{12}
\]</div>
<ol start="5">
<li>Apply the <span class="arithmatex">\(CNOT_{03}\)</span> gate (control on qubit 0, target on qubit 3):</li>
</ol>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = CNOT_{03} |\psi_3\rangle = \left(CNOT_{03} \frac{1}{\sqrt{2}}(|00\rangle_{03} + |10\rangle_{03})\right) \otimes |\Phi^+\rangle_{12}
\]</div>
<div class="arithmatex">\[
|\psi_{ideal}\rangle = \frac{1}{\sqrt{2}}(|00\rangle_{03} + |11\rangle_{03}) \otimes |\Phi^+\rangle_{12} = |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12}
\]</div>
<div class="codehilite"><pre><span></span><code>The ideal final state is a tensor product of two Bell states, one on qubits (0,3) and one on qubits (1,2).
</code></pre></div>

<p><strong>2. Model the evolution of the density matrix with errors</strong></p>
<p>The circuit consists of two blocks of operations separated by an error channel.
*   <strong>Block 1:</strong> <span class="arithmatex">\(U_{12} = CNOT_{21} H_2\)</span> acts on qubits 1 and 2.
*   <strong>Error 1:</strong> A two-qubit depolarizing channel <span class="arithmatex">\(\mathcal{E}_1\)</span> on qubits 1 and 2 follows <span class="arithmatex">\(CNOT_{21}\)</span>.
*   <strong>Block 2:</strong> <span class="arithmatex">\(U_{03} = CNOT_{03} H_0\)</span> acts on qubits 0 and 3.
*   <strong>Error 2:</strong> A two-qubit depolarizing channel <span class="arithmatex">\(\mathcal{E}_2\)</span> on qubits 0 and 3 follows <span class="arithmatex">\(CNOT_{03}\)</span>.</p>
<p>The error channel for a two-qubit gate is given by:</p>
<div class="arithmatex">\[
\mathcal{E}(\rho) = (1-p) \rho + \frac{p}{15} \sum_{P \in \mathcal{P}_2 \setminus \{I_4\}} P \rho P^\dagger
\]</div>
<p>where <span class="arithmatex">\(\mathcal{P}_2 = \{I,X,Y,Z\}^{\otimes 2}\)</span> is the set of 16 two-qubit Pauli operators.</p>
<p>Let&rsquo;s trace the state <span class="arithmatex">\(\rho(t)\)</span> through the circuit:</p>
<ol>
<li>
<p>Initial state: <span class="arithmatex">\(\rho_{in} = |0000\rangle\langle0000| = |00\rangle\langle00|_{03} \otimes |00\rangle\langle00|_{12}\)</span>.</p>
</li>
<li>
<p>After <span class="arithmatex">\(U_{12}\)</span>: The state becomes <span class="arithmatex">\(\rho_1^{ideal} = U_{12}\rho_{in}U_{12}^\dagger\)</span>. Since <span class="arithmatex">\(U_{12}\)</span> only acts on qubits 1,2, this is:</p>
</li>
</ol>
<div class="arithmatex">\[
\rho_1^{ideal} = |00\rangle\langle00|_{03} \otimes \left(U_{12}|00\rangle\langle00|_{12}U_{12}^\dagger\right) = |00\rangle\langle00|_{03} \otimes |\Phi^+\rangle\langle\Phi^+|_{12}
\]</div>
<ol start="3">
<li>After the first error channel <span class="arithmatex">\(\mathcal{E}_1\)</span> on qubits 1,2:</li>
</ol>
<div class="arithmatex">\[
\rho_1 = \mathcal{E}_1(\rho_1^{ideal}) = |00\rangle\langle00|_{03} \otimes \mathcal{E}_1(|\Phi^+\rangle\langle\Phi^+|_{12})
\]</div>
<ol start="4">
<li>After <span class="arithmatex">\(U_{03}\)</span>: The unitary <span class="arithmatex">\(U_{03}\)</span> acts only on qubits 0,3.</li>
</ol>
<div class="arithmatex">\[
\rho_2^{pre-error} = U_{03} \rho_1 U_{03}^\dagger = \left(U_{03}|00\rangle\langle00|_{03}U_{03}^\dagger\right) \otimes \mathcal{E}_1(|\Phi^+\rangle\langle\Phi^+|_{12})
\]</div>
<div class="arithmatex">\[
\rho_2^{pre-error} = |\Phi^+\rangle\langle\Phi^+|_{03} \otimes \mathcal{E}_1(|\Phi^+\rangle\langle\Phi^+|_{12})
\]</div>
<ol start="5">
<li>After the second error channel <span class="arithmatex">\(\mathcal{E}_2\)</span> on qubits 0,3:</li>
</ol>
<div class="arithmatex">\[
\rho_{final} = \mathcal{E}_2(\rho_2^{pre-error}) = \mathcal{E}_2(|\Phi^+\rangle\langle\Phi^+|_{03}) \otimes \mathcal{E}_1(|\Phi^+\rangle\langle\Phi^+|_{12})
\]</div>
<p><strong>3. Calculate the final fidelity</strong></p>
<p>The fidelity is <span class="arithmatex">\(F = \langle\psi_{ideal}|\rho_{final}|\psi_{ideal}\rangle\)</span>. Substituting the expressions for <span class="arithmatex">\(|\psi_{ideal}\rangle\)</span> and <span class="arithmatex">\(\rho_{final}\)</span>:</p>
<div class="arithmatex">\[
F = \left( \langle\Phi^+|_{03} \otimes \langle\Phi^+|_{12} \right) \left( \mathcal{E}_2(|\Phi^+\rangle\langle\Phi^+|_{03}) \otimes \mathcal{E}_1(|\Phi^+\rangle\langle\Phi^+|_{12}) \right) \left( |\Phi^+\rangle_{03} \otimes |\Phi^+\rangle_{12} \right)
\]</div>
<p>Due to the tensor product structure, the fidelity factors into two identical terms:</p>
<div class="arithmatex">\[
F = \left( \langle\Phi^+|_{03}| \mathcal{E}_2(|\Phi^+\rangle\langle\Phi^+|_{03}) |\Phi^+\rangle_{03} \right) \times \left( \langle\Phi^+|_{12}| \mathcal{E}_1(|\Phi^+\rangle\langle\Phi^+|_{12}) |\Phi^+\rangle_{12} \right)
\]</div>
<p>Let&rsquo;s compute one of these factors, which represents the fidelity of a Bell state after passing through the error channel. Let <span class="arithmatex">\(F_{gate} = \langle\Phi^+| \mathcal{E}(|\Phi^+\rangle\langle\Phi^+|) |\Phi^+\rangle\)</span>.</p>
<div class="arithmatex">\[
F_{gate} = \langle\Phi^+| \left( (1-p) |\Phi^+\rangle\langle\Phi^+| + \frac{p}{15} \sum_{P \neq I} P |\Phi^+\rangle\langle\Phi^+| P^\dagger \right) |\Phi^+\rangle
\]</div>
<div class="arithmatex">\[
F_{gate} = (1-p) \langle\Phi^+|\Phi^+\rangle\langle\Phi^+|\Phi^+\rangle + \frac{p}{15} \sum_{P \neq I} \langle\Phi^+|P|\Phi^+\rangle\langle\Phi^+|P^\dagger|\Phi^+\rangle
\]</div>
<p>Since <span class="arithmatex">\(\langle\Phi^+|\Phi^+\rangle = 1\)</span> and <span class="arithmatex">\(\langle\Phi^+|P^\dagger|\Phi^+\rangle = (\langle\Phi^+|P|\Phi^+\rangle)^*\)</span>:</p>
<div class="arithmatex">\[
F_{gate} = (1-p) + \frac{p}{15} \sum_{P \neq I} |\langle\Phi^+|P|\Phi^+\rangle|^2
\]</div>
<p>We need to calculate the expectation value of the 15 non-identity two-qubit Pauli operators for the Bell state <span class="arithmatex">\(|\Phi^+\rangle\)</span>. The state <span class="arithmatex">\(|\Phi^+\rangle\)</span> is a <span class="arithmatex">\(+1\)</span> eigenstate of the Pauli operators <span class="arithmatex">\(X \otimes X\)</span> and <span class="arithmatex">\(Z \otimes Z\)</span>.
*   <span class="arithmatex">\(\langle\Phi^+|X \otimes X|\Phi^+\rangle = 1\)</span>
*   <span class="arithmatex">\(\langle\Phi^+|Z \otimes Z|\Phi^+\rangle = 1\)</span>
*   Also, <span class="arithmatex">\(Y \otimes Y = (iZX)(iZX) = - (Z \otimes Z)(X \otimes X)\)</span>. Thus, <span class="arithmatex">\(\langle\Phi^+|Y \otimes Y|\Phi^+\rangle = -1\)</span>.</p>
<p>For any other two-qubit Pauli operator <span class="arithmatex">\(P\)</span> (not in the set <span class="arithmatex">\(\{I\otimes I, X\otimes X, Y\otimes Y, Z\otimes Z\}\)</span>), it can be shown that <span class="arithmatex">\(\langle\Phi^+|P|\Phi^+\rangle = 0\)</span>. This is because any such <span class="arithmatex">\(P\)</span> will anti-commute with at least one of the stabilizers (<span class="arithmatex">\(X \otimes X\)</span> or <span class="arithmatex">\(Z \otimes Z\)</span>) of <span class="arithmatex">\(|\Phi^+\rangle\)</span>. If <span class="arithmatex">\(\{P, S\}=0\)</span> and <span class="arithmatex">\(S|\Phi^+\rangle = |\Phi^+\rangle\)</span>, then <span class="arithmatex">\(\langle\Phi^+|P|\Phi^+\rangle = \langle\Phi^+|PS|\Phi^+\rangle = -\langle\Phi^+|SP|\Phi^+\rangle = -\langle\Phi^+|P|\Phi^+\rangle\)</span>, which implies <span class="arithmatex">\(\langle\Phi^+|P|\Phi^+\rangle = 0\)</span>.</p>
<p>The sum is over the 15 non-identity Paulis. The only non-zero contributions come from <span class="arithmatex">\(P \in \{X \otimes X, Y \otimes Y, Z \otimes Z\}\)</span>.</p>
<div class="arithmatex">\[
\sum_{P \neq I} |\langle\Phi^+|P|\Phi^+\rangle|^2 = |\langle\Phi^+|X \otimes X|\Phi^+\rangle|^2 + |\langle\Phi^+|Y \otimes Y|\Phi^+\rangle|^2 + |\langle\Phi^+|Z \otimes Z|\Phi^+\rangle|^2
\]</div>
<div class="arithmatex">\[
\sum_{P \neq I} |\langle\Phi^+|P|\Phi^+\rangle|^2 = |1|^2 + |-1|^2 + |1|^2 = 1+1+1=3
\]</div>
<p>Now, substitute this back into the expression for <span class="arithmatex">\(F_{gate}\)</span>:</p>
<div class="arithmatex">\[
F_{gate} = (1-p) + \frac{p}{15}(3) = 1 - p + \frac{p}{5} = 1 - \frac{4p}{5}
\]</div>
<p>The total fidelity is the product of the fidelities from the two independent error channels:</p>
<div class="arithmatex">\[
F = F_{gate} \times F_{gate} = \left(1 - \frac{4p}{5}\right)^2
\]</div>
<p>Expanding this expression gives:</p>
<div class="arithmatex">\[
F = 1 - \frac{8p}{5} + \frac{16p^2}{25}
\]</div>
<p><strong>Final Answer:</strong>
The physical state fidelity of the final 4-qubit state is:</p>
<div class="arithmatex">\[
F(p) = \left(1 - \frac{4p}{5}\right)^2 = 1 - \frac{8p}{5} + \frac{16p^2}{25}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_physical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_physical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.550563
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>