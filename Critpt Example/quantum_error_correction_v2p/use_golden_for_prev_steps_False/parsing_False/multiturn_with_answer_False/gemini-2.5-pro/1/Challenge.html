<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><p>An elegant and robust solution requires careful, step-by-step reasoning. Here is the complete derivation of the logical state fidelity.</p>
<h3 id="step-by-step-derivation">Step-by-Step Derivation</h3>
<p><strong>1. Ideal State Preparation</strong></p>
<p>First, let&rsquo;s analyze the error-free state preparation circuit. The circuit is given by <span class="arithmatex">\(U = M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)\)</span>. The operations are applied from right to left.
The initial state is <span class="arithmatex">\(|0000\rangle_C |0\rangle_A = |00000\rangle\)</span>, where C denotes the four code qubits (0,1,2,3) and A is the ancilla qubit (4).</p>
<ol>
<li><strong><span class="arithmatex">\(H_1\)</span> on qubit 1</strong>: The state becomes <span class="arithmatex">\(|0\rangle_0 \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)_1 |000\rangle_{234} = \frac{1}{\sqrt{2}}(|00000\rangle + |01000\rangle)\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{12}\)</span></strong>: <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|00000\rangle + |01100\rangle)\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{10}\)</span></strong>: <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|00000\rangle + |11100\rangle)\)</span>.</li>
<li><strong><span class="arithmatex">\(CNOT_{23}\)</span></strong>: <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|00000\rangle + |11110\rangle) = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle) \otimes |0\rangle_4\)</span>.</li>
</ol>
<p>The state of the code qubits is <span class="arithmatex">\(|\psi_L\rangle = \frac{1}{\sqrt{2}}(|0000\rangle + |1111\rangle)\)</span>. Let&rsquo;s verify this is the logical <span class="arithmatex">\(|00\rangle_{AB}\)</span> state. The logical state <span class="arithmatex">\(|00\rangle_L\)</span> must be a simultaneous +1 eigenstate of the stabilizers <span class="arithmatex">\(S_1=XXXX\)</span>, <span class="arithmatex">\(S_2=ZZZZ\)</span>, and the logical operators <span class="arithmatex">\(Z_A=ZZII\)</span>, <span class="arithmatex">\(Z_B=ZIZI\)</span>.
- <span class="arithmatex">\(S_1 |\psi_L\rangle = XXXX \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) = \frac{1}{\sqrt{2}}(|1111\rangle+|0000\rangle) = |\psi_L\rangle\)</span>.
- <span class="arithmatex">\(S_2 |\psi_L\rangle = ZZZZ \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) = \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) = |\psi_L\rangle\)</span>.
- <span class="arithmatex">\(Z_A |\psi_L\rangle = Z_0 Z_1 \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) = \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) = |\psi_L\rangle\)</span>.
- <span class="arithmatex">\(Z_B |\psi_L\rangle = Z_0 Z_2 \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) = \frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle) = |\psi_L\rangle\)</span>.
The state is indeed the logical <span class="arithmatex">\(|00\rangle_L\)</span>.</p>
<p>The remaining gates, <span class="arithmatex">\(CNOT_{34}\)</span> and <span class="arithmatex">\(CNOT_{04}\)</span>, followed by the measurement <span class="arithmatex">\(M_4\)</span>, constitute a verification step. This sub-circuit measures the parity of qubits 0 and 3, which corresponds to measuring the operator <span class="arithmatex">\(Z_0 Z_3\)</span>. The operator <span class="arithmatex">\(Z_0 Z_3\)</span> is logically equivalent to <span class="arithmatex">\(Z_A Z_B\)</span>, since <span class="arithmatex">\(Z_A Z_B S_2 = (Z_0 Z_1)(Z_0 Z_2)(Z_0 Z_1 Z_2 Z_3) = Z_1 Z_2 (Z_0 Z_1 Z_2 Z_3) = Z_0 Z_3\)</span>.
Since <span class="arithmatex">\(|00\rangle_L\)</span> is a +1 eigenstate of both <span class="arithmatex">\(Z_A\)</span> and <span class="arithmatex">\(Z_B\)</span>, it is also a +1 eigenstate of <span class="arithmatex">\(Z_A Z_B \equiv Z_0 Z_3\)</span>. Thus, in the error-free case, the ancilla measurement always yields <span class="arithmatex">\(|0\rangle\)</span>.</p>
<p><strong>2. Error Analysis Framework</strong></p>
<p>Each of the 5 CNOT gates is followed by a two-qubit depolarizing channel, which applies one of the 15 non-identity Paulis <span class="arithmatex">\(E\)</span> with probability <span class="arithmatex">\(p/15\)</span>. We work to first order in <span class="arithmatex">\(p\)</span>. The logical fidelity is <span class="arithmatex">\(F = \langle 00_L | \rho_{final} | 00_L \rangle\)</span>. An error leads to infidelity if it transforms the state <span class="arithmatex">\(|00\rangle_L\)</span> into an orthogonal logical state (i.e., applies a logical X- or Y-type operator) and is not detected.</p>
<p>An error is detected if:</p>
<ol>
<li>The final state of the four code qubits is not in the codespace (i.e., it is not a +1 eigenstate of <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>). This is what &ldquo;post-selected on all detectable errors&rdquo; means. An error operator <span class="arithmatex">\(\tilde{E}\)</span> acting on the code qubits is detected if it anticommutes with either <span class="arithmatex">\(S_1\)</span> or <span class="arithmatex">\(S_2\)</span>.</li>
<li>The ancilla measurement yields <span class="arithmatex">\(|1\rangle\)</span>.</li>
</ol>
<p>An error causes infidelity if it is not detected and corresponds to a logical operator that flips the <span class="arithmatex">\(|00\rangle_L\)</span> state, i.e., an operator containing an odd power of logical <span class="arithmatex">\(X_A, X_B, Y_A,\)</span> or <span class="arithmatex">\(Y_B\)</span>.</p>
<p>Let&rsquo;s denote the CNOT gates by <span class="arithmatex">\(G_1, ..., G_5\)</span> in the order they appear in the circuit:
<span class="arithmatex">\(G_1 = CNOT_{12}\)</span>, <span class="arithmatex">\(G_2 = CNOT_{10}\)</span>, <span class="arithmatex">\(G_3 = CNOT_{23}\)</span>, <span class="arithmatex">\(G_4 = CNOT_{34}\)</span>, <span class="arithmatex">\(G_5 = CNOT_{04}\)</span>.
An error <span class="arithmatex">\(E_k\)</span> on the qubits of gate <span class="arithmatex">\(G_k\)</span> propagates through the remaining gates <span class="arithmatex">\(U_{&gt;k}\)</span>. The effective error at the end of the circuit is <span class="arithmatex">\(\tilde{E}_k = U_{&gt;k} E_k U_{&gt;k}^\dagger\)</span>, which acts on the ideal final state <span class="arithmatex">\(|00\rangle_L|0\rangle_4\)</span>.</p>
<p><strong>3. Errors during State Preparation (<span class="arithmatex">\(G_1, G_2, G_3\)</span>)</strong></p>
<p>An error <span class="arithmatex">\(E_k\)</span> occurring after gates <span class="arithmatex">\(G_1, G_2,\)</span> or <span class="arithmatex">\(G_3\)</span> propagates to an error <span class="arithmatex">\(\hat{E}_k\)</span> on the code qubits at the end of the state preparation phase (before the verification gates <span class="arithmatex">\(G_4, G_5\)</span>). The state of the system becomes <span class="arithmatex">\(\hat{E}_k |00\rangle_L |0\rangle_4\)</span>. The subsequent verification circuit measures the logical operator <span class="arithmatex">\(Z_A Z_B\)</span>.
- If <span class="arithmatex">\(\hat{E}_k\)</span> commutes with <span class="arithmatex">\(Z_A Z_B\)</span>, the state remains a +1 eigenstate, and the ancilla measures <span class="arithmatex">\(|0\rangle\)</span>. The error is not detected by the ancilla.
- If <span class="arithmatex">\(\hat{E}_k\)</span> anticommutes with <span class="arithmatex">\(Z_A Z_B\)</span>, the state becomes a -1 eigenstate. The ancilla measures <span class="arithmatex">\(|1\rangle\)</span>, and the error is detected.</p>
<p>For an error to cause infidelity, it must be an X- or Y-type logical operator. Let&rsquo;s check their commutation with the check operator <span class="arithmatex">\(Z_A Z_B = (Z_0 Z_1)(Z_0 Z_2) = Z_1 Z_2\)</span>.
-   <span class="arithmatex">\([X_A, Z_A Z_B] = [X_1 X_3, Z_1 Z_2] \neq 0\)</span>. They anticommute.
-   <span class="arithmatex">\([X_B, Z_A Z_B] = [X_0 X_1, Z_1 Z_2] \neq 0\)</span>. They anticommute.
-   Logical <span class="arithmatex">\(Y_A=iX_AZ_A\)</span> and <span class="arithmatex">\(Y_B=iX_BZ_B\)</span> also anticommute with <span class="arithmatex">\(Z_A Z_B\)</span>.</p>
<p>Any logical X- or Y-type error anticommutes with the check operator <span class="arithmatex">\(Z_A Z_B\)</span>. Therefore, any such error occurring during the state preparation phase (<span class="arithmatex">\(G_1, G_2, G_3\)</span>) will be detected by the ancilla measurement. These errors do not contribute to the logical infidelity.</p>
<p><strong>4. Errors during Verification (<span class="arithmatex">\(G_4, G_5\)</span>)</strong></p>
<p>Errors occurring during the verification circuit must be analyzed by tracing the state evolution.</p>
<ul>
<li>
<p><strong>Errors on <span class="arithmatex">\(G_5 = CNOT_{04}\)</span></strong>: Let an error <span class="arithmatex">\(E_5=P_0 P_4\)</span> occur after <span class="arithmatex">\(G_5\)</span>. The error <span class="arithmatex">\(\tilde{E}_5=E_5\)</span> acts on the final state <span class="arithmatex">\(|00\rangle_L|0\rangle_4\)</span>.</p>
<ul>
<li>To pass the stabilizer checks, <span class="arithmatex">\(E_5\)</span> must commute with <span class="arithmatex">\(S_1\)</span> and <span class="arithmatex">\(S_2\)</span>. This requires the part on the code qubits, <span class="arithmatex">\(P_0\)</span>, to commute with <span class="arithmatex">\(X_0\)</span> and <span class="arithmatex">\(Z_0\)</span>, forcing <span class="arithmatex">\(P_0=I_0\)</span>. So only errors of the form <span class="arithmatex">\(I_0 P_4\)</span> survive stabilizer checks.</li>
<li>The state with error is <span class="arithmatex">\((I_0 P_4)|00\rangle_L|0\rangle_4\)</span>.<ul>
<li>If <span class="arithmatex">\(P_4=X_4\)</span> or <span class="arithmatex">\(Y_4\)</span>, the ancilla becomes <span class="arithmatex">\(|1\rangle_4\)</span>, so the error is detected.</li>
<li>If <span class="arithmatex">\(P_4=Z_4\)</span>, the state becomes <span class="arithmatex">\(-|00\rangle_L|0\rangle_4\)</span>. The ancilla measures <span class="arithmatex">\(|0\rangle\)</span>. The code state is unchanged up to a global phase. This does not affect fidelity.</li>
</ul>
</li>
<li>Therefore, no error on <span class="arithmatex">\(G_5\)</span> causes logical infidelity.</li>
</ul>
</li>
<li>
<p><strong>Errors on <span class="arithmatex">\(G_4 = CNOT_{34}\)</span></strong>: Let an error <span class="arithmatex">\(E_4=P_3 P_4\)</span> occur after <span class="arithmatex">\(G_4\)</span>. The state before the error is <span class="arithmatex">\(\frac{1}{\sqrt{2}}(|00000\rangle+|11111\rangle)\)</span>. The error <span class="arithmatex">\(E_4\)</span> acts, then <span class="arithmatex">\(G_5=CNOT_{04}\)</span>, then the measurement <span class="arithmatex">\(M_4\)</span>.
    We must find errors <span class="arithmatex">\(E_4=P_3 P_4\)</span> which result in a final state <span class="arithmatex">\((L|00\rangle_L)|0\rangle_4\)</span>, where <span class="arithmatex">\(L\)</span> is an X/Y-type logical operator.
    An equivalent method is to calculate the propagated error <span class="arithmatex">\(\tilde{E}_4 = CNOT_{04} E_4 CNOT_{04}^\dagger\)</span> and check its properties.
    The error <span class="arithmatex">\(E_4=P_3 P_4\)</span> propagates to <span class="arithmatex">\(\tilde{E}_4\)</span>. We need <span class="arithmatex">\(\tilde{E}_4\)</span> to be an operator that, when acting on <span class="arithmatex">\(|00\rangle_L|0\rangle_4\)</span>, yields a state that passes all checks and has a logical X/Y error.
    The final state with the error is <span class="arithmatex">\(\tilde{E}_4|00\rangle_L|0\rangle_4\)</span>.</p>
<ul>
<li>Ancilla check: The state must be in the <span class="arithmatex">\(|0\rangle_4\)</span> subspace. This means <span class="arithmatex">\(\tilde{E}_4\)</span> cannot have an <span class="arithmatex">\(X_4\)</span> or <span class="arithmatex">\(Y_4\)</span> component that acts on <span class="arithmatex">\(|0\rangle_4\)</span>. So <span class="arithmatex">\(\tilde{E}_4\)</span> must be of the form <span class="arithmatex">\(L_{0123} \otimes I_4\)</span> or <span class="arithmatex">\(L_{0123} \otimes Z_4\)</span>.</li>
<li>Stabilizer check: <span class="arithmatex">\(L_{0123}\)</span> must be a logical operator.</li>
<li>Infidelity condition: <span class="arithmatex">\(L_{0123}\)</span> must be an X/Y-type logical operator.</li>
</ul>
<p>Let&rsquo;s test which errors <span class="arithmatex">\(E_4=P_3 P_4\)</span> propagate to such an <span class="arithmatex">\(\tilde{E}_4\)</span>.
The propagation rule is <span class="arithmatex">\(\tilde{E}_4 = CNOT_{04} (P_3 P_4) CNOT_{04} = P_3 (CNOT_{04} P_4 CNOT_{04})\)</span>.
-   If <span class="arithmatex">\(P_4=I_4\)</span>, <span class="arithmatex">\(\tilde{E}_4 = P_3 \otimes I_4\)</span>. For this to be a logical operator, <span class="arithmatex">\(P_3\)</span> must be at least a weight-2 Pauli operator, which is not possible.
-   If <span class="arithmatex">\(P_4=X_4\)</span>, <span class="arithmatex">\(\tilde{E}_4 = P_3 \otimes X_4\)</span>. This is detected by the ancilla check.
-   If <span class="arithmatex">\(P_4=Y_4\)</span>, <span class="arithmatex">\(\tilde{E}_4 = P_3 \otimes (Y_4 Z_0)\)</span>. This has a <span class="arithmatex">\(Y_4\)</span> component and is detected by the ancilla check.
-   If <span class="arithmatex">\(P_4=Z_4\)</span>, <span class="arithmatex">\(\tilde{E}_4 = P_3 \otimes (Z_0 Z_4) = (P_3 Z_0) \otimes Z_4\)</span>.
    This form survives the ancilla check. The effective error on the code qubits is <span class="arithmatex">\(L=P_3 Z_0\)</span>. We need to check when <span class="arithmatex">\(L\)</span> is an infidelity-causing logical error.
    1.  <span class="arithmatex">\(L\)</span> must be a logical operator (commute with <span class="arithmatex">\(S_1, S_2\)</span>).
        -   <span class="arithmatex">\([P_3 Z_0, S_1=XXXX]\)</span>: Commutes if <span class="arithmatex">\(P_3\)</span> commutes with <span class="arithmatex">\(X_3\)</span>. <span class="arithmatex">\(P_3 \in \{I_3, X_3\}\)</span>.
        -   <span class="arithmatex">\([P_3 Z_0, S_2=ZZZZ]\)</span>: Commutes if <span class="arithmatex">\(P_3\)</span> anticommutes with <span class="arithmatex">\(Z_3\)</span>. <span class="arithmatex">\(P_3 \in \{X_3, Y_3\}\)</span>.
        -   Combining these, <span class="arithmatex">\(P_3\)</span> must be <span class="arithmatex">\(X_3\)</span>.
        However, this check is flawed. For example, for <span class="arithmatex">\(P_3=Y_3\)</span>, <span class="arithmatex">\([Y_3Z_0, S_1]\)</span> requires an even number of anticommuting pairs. <span class="arithmatex">\(Y_3\)</span> with <span class="arithmatex">\(X_3\)</span>, and <span class="arithmatex">\(Z_0\)</span> with <span class="arithmatex">\(X_0\)</span>. Two anticommutations lead to commutation. So <span class="arithmatex">\(P_3 Z_0\)</span> commutes with <span class="arithmatex">\(S_1\)</span> for any <span class="arithmatex">\(P_3\)</span>. Similarly, <span class="arithmatex">\(P_3 Z_0\)</span> commutes with <span class="arithmatex">\(S_2\)</span> for any <span class="arithmatex">\(P_3\)</span>. So <span class="arithmatex">\(P_3 Z_0\)</span> is a logical operator for <span class="arithmatex">\(P_3 \in \{X,Y,Z\}\)</span>. (For <span class="arithmatex">\(P_3=I_3\)</span>, <span class="arithmatex">\(Z_0\)</span> is not a logical operator).
    2.  <span class="arithmatex">\(L\)</span> must cause infidelity. We check if <span class="arithmatex">\(L|00\rangle_L\)</span> is orthogonal to <span class="arithmatex">\(|00\rangle_L\)</span>.
        -   <span class="arithmatex">\(L=X_3 Z_0\)</span>: <span class="arithmatex">\(\langle 00_L|X_3 Z_0|00_L\rangle = 0\)</span>. This is an infidelity-causing error.
        -   <span class="arithmatex">\(L=Y_3 Z_0\)</span>: <span class="arithmatex">\(\langle 00_L|Y_3 Z_0|00_L\rangle = 0\)</span>. This is an infidelity-causing error.
        -   <span class="arithmatex">\(L=Z_3 Z_0\)</span>: This is a Z-type logical error. It preserves <span class="arithmatex">\(|00\rangle_L\)</span>. No infidelity.</p>
<p>So, the errors <span class="arithmatex">\(E_4 = X_3 Z_4\)</span> and <span class="arithmatex">\(E_4 = Y_3 Z_4\)</span> on gate <span class="arithmatex">\(G_4\)</span> both lead to infidelity. This gives a total of 2 infidelity-causing error events for gate <span class="arithmatex">\(G_4\)</span>.</p>
</li>
</ul>
<p><strong>5. Final Calculation</strong></p>
<p>We have found that there are no first-order infidelity-causing errors from gates <span class="arithmatex">\(G_1, G_2, G_3, G_5\)</span>. There are 2 such errors from gate <span class="arithmatex">\(G_4\)</span>.
The total number of infidelity-causing single-error events is <span class="arithmatex">\(N_{XY} = 2\)</span>.
Each of the 15 non-identity Pauli errors occurs with probability <span class="arithmatex">\(p/15\)</span>.
The total probability of an infidelity-causing logical error is <span class="arithmatex">\(p_{logical} = N_{XY} \times \frac{p}{15} = \frac{2p}{15}\)</span>.</p>
<p>The logical fidelity <span class="arithmatex">\(F\)</span> is the probability that the final state is the ideal state <span class="arithmatex">\(|00\rangle_L\)</span>. To first order in <span class="arithmatex">\(p\)</span>, this is 1 minus the probability of any infidelity-causing error.</p>
<div class="arithmatex">\[
F = 1 - p_{logical} = 1 - \frac{2p}{15}
\]</div>
<p>The logical infidelity is <span class="arithmatex">\(1-F = \frac{2p}{15}\)</span>. The problem asks for the logical state fidelity.</p>
<p><strong>Final Answer:</strong>
The logical state fidelity of the final 2-qubit logical state is:</p>
<div class="arithmatex">\[
F(p) = 1 - \frac{2p}{15}
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="reasoning">
                      <summary>Reasoning <span class="tag">(model)</span></summary>
                      <div class="markdown-body reasoning-body">
                        <p><strong>My Approach to Filling the Code Template</strong></p>
<p>Okay, so I need to provide the expression for the logical state fidelity, <span class="arithmatex">\(F(p)\)</span>, and put it into the provided Python function.  The final result I calculated is <span class="arithmatex">\(F(p) = 1 - \frac{2p}{15}\)</span>.  Now I just need to translate this into the <code>sympy</code> syntax required for the code.  Since the problem already sets <code>p = sp.symbols('p')</code>, all I have to do is rewrite the expression using <code>sympy</code> operators. The template uses <code>F_logical</code> to store the output.</p>
<p>So, in <code>sympy</code>,  <span class="arithmatex">\(1 - \frac{2p}{15}\)</span> becomes <code>1 - 2*p/15</code>.  This is a valid <code>sympy</code> expression, which is what the <code>answer(p)</code> function needs to return. The input is p, and the expression is a function of that value.</p>
<p>I am confident that this is correct; all I need to do is substitute the <code>...</code> in the template with this expression. Let me just double-check that the function takes the single parameter <code>p</code> and outputs a <code>sympy.Expr</code>, which is indeed the case. Everything looks good.</p>
                      </div>
                    </details>
<div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:08.787271
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>