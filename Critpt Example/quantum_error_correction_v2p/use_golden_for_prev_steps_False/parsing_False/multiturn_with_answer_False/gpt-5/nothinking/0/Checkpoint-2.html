<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">üåì</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Error model</li>
<li>After each two-qubit CNOT gate, a two-qubit depolarizing channel acts:<ul>
<li>With probability 1‚àíp: no error (identity).</li>
<li>With probability p: one of the 15 non-identity two-qubit Paulis is applied uniformly at random (each with probability p/15).</li>
</ul>
</li>
<li>Single-qubit gates (H) are assumed ideal.</li>
<li>
<p>There are two CNOT gates in the circuit: CNOT21 and CNOT03, so there are two independent error locations.</p>
</li>
<li>
<p>Circuit and target state</p>
</li>
<li>Circuit (right-to-left): H2 ‚Üí CNOT21 ‚Üí H0 ‚Üí CNOT03.</li>
<li>
<p>The physical output state in the ideal (p=0) case is a pure 4-qubit state |œà‚ü© determined by the circuit. The question asks for the physical fidelity of the final 4-qubit state with respect to the ideal output, as a function of p:
    F(p) = ‚ü®œà| œÅ_out(p) |œà‚ü©.</p>
</li>
<li>
<p>Fidelity under Pauli depolarizing noise after Clifford circuit</p>
</li>
<li>Because the circuit is Clifford and the noise is Pauli, the overall channel maps the pure |œà‚ü© to a classical mixture over Pauli errors applied to |œà‚ü©.</li>
<li>
<p>For any error pattern E (a tensor product of Paulis on the qubits where noise acts), the state becomes E|œà‚ü© up to the unitary propagation through later gates. Fidelity with |œà‚ü© is:</p>
<ul>
<li>1 if the net error equals the identity (i.e., no error at either location, or errors that cancel to identity).</li>
<li>0 otherwise, since E|œà‚ü© is orthogonal to |œà‚ü© for any nontrivial Pauli E on a pure stabilizer state unless E ‚àà Stabilizer(|œà‚ü©); but |œà‚ü© here is a non-degenerate pure state and the only Pauli mapping it to itself is ¬±I (global phase irrelevant). Hence only the identity contributes to fidelity.</li>
</ul>
</li>
<li>
<p>Compute the probability that the net error is identity</p>
</li>
<li>Let the two error locations be L1 (after CNOT21) and L2 (after CNOT03).</li>
<li>Each location independently applies:<ul>
<li>I with probability 1‚àíp,</li>
<li>a non-identity two-qubit Pauli with probability p.</li>
</ul>
</li>
<li>
<p>The net error after both locations equals identity in exactly two disjoint cases:
    1) No error at either location: probability (1‚àíp)^2.
    2) A non-identity Pauli at L1 and a (possibly different) non-identity Pauli at L2 that, after conjugation by the intervening unitary between locations, multiply to identity.</p>
<ul>
<li>Let U be the Clifford between L1 and L2 (here U = H0 ‚àò CNOT03; note L2‚Äôs error is applied after CNOT03, while L1‚Äôs error is before H0 and CNOT03). The net error is E2 ¬∑ U E1 U‚Ä†.</li>
<li>For the product to be identity, we must have E2 = U E1‚Ä† U‚Ä†. Since all non-identity Paulis square to identity up to phase, E1‚Ä† = E1 (phase irrelevant). Thus for each E1 there is exactly one E2 that cancels it.</li>
<li>Given that L1 picked any of the 15 non-identity Paulis (probability p), the probability that L2 picks exactly that one required Pauli is p/15.</li>
<li>Summing over the 15 choices for E1 is already accounted for by the marginal probability p at L1; there is no extra combinatorial factor because the conditional probability at L2 to match is 1/15.</li>
<li>Therefore, the probability of the canceling two-error event is p ¬∑ (p/15) = p^2/15.</li>
</ul>
</li>
<li>
<p>Any case with exactly one error produces a non-identity net Pauli, giving zero fidelity contribution. Any case with two errors that do not cancel also gives zero fidelity contribution.</p>
</li>
<li>
<p>Therefore, the output state fidelity equals the probability that the net error is identity:
  F(p) = (1 ‚àí p)^2 + p^2/15.</p>
</li>
<li>
<p>Simplified polynomial form:
  F(p) = 1 ‚àí 2p + p^2 + p^2/15 = 1 ‚àí 2p + (16/15) p^2.</p>
</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Fidelity:</li>
</ul>
<div class="arithmatex">\[
F(p) = (1-p)^2 + \frac{p^2}{15} = 1 - 2p + \frac{16}{15}p^2.
\]</div>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Dimensionless error probability p per two-qubit gate.</li>
<li>Two CNOTs in the circuit; single-qubit gates are ideal.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = (1 ‚àí p)^2 + p^2/15 = 1 ‚àí 2p + (16/15) p^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Setup and noise model</li>
<li>Circuit (right-to-left): H2 ‚Üí CNOT21 ‚Üí H0 ‚Üí CNOT03.</li>
<li>Two error locations: immediately after CNOT21 (L1) and immediately after CNOT03 (L2).</li>
<li>At each location, with probability 1‚àíp no error; with probability p a uniformly random non-identity two-qubit Pauli (one of the 15) acts.</li>
<li>
<p>H gates are ideal. Clifford + Pauli noise lets us track Pauli errors through via conjugation.</p>
</li>
<li>
<p>Post-selection on the [[4,2,2]] code</p>
</li>
<li>Stabilizers: S = ‚ü®XXXX, ZZZZ‚ü©.</li>
<li>Post-select on ‚Äúno-detect‚Äù events: only error patterns whose final Pauli error Eout commutes with both stabilizers (i.e., lies in the normalizer N(S)) survive. Syndromes with ‚àí1 for either stabilizer are discarded.</li>
<li>
<p>The logical fidelity conditioned on survival equals the probability that the net error is a stabilizer (acts trivially on the codespace) divided by the total survival probability (probability that net error is in the normalizer):
    F_log(p) = P(Eout ‚àà S) / P(Eout ‚àà N(S)).</p>
</li>
<li>
<p>Characterize the normalizer for this code</p>
</li>
<li>N(S) consists of Paulis that commute with XXXX and ZZZZ. On 4 qubits, these are exactly tensor products with an even number of X/Y and an even number of Z/Y, equivalently the set generated by:<ul>
<li>Stabilizers: XXXX, ZZZZ, and their product YYYY.</li>
<li>Logical Paulis: X_A = X I X I, X_B = X X I I, Z_A = Z Z I I, Z_B = Z I Z I and their products.</li>
</ul>
</li>
<li>Counting on 4 qubits: |N(S)| = 32 (including identity). The stabilizer group S has size 4 = {I, XXXX, ZZZZ, YYYY}.</li>
<li>
<p>Hence among the 15 non-identity 4-qubit Paulis, 3 are stabilizers, 28 are other normalizer elements (logical Paulis), and the remaining 48 are detectable (outside the normalizer). We will only need the distinction ‚Äústabilizer vs. non-normalizer‚Äù below for survival, and ‚Äústabilizer vs. logical‚Äù for fidelity within survivors.</p>
</li>
<li>
<p>Propagation of two-qubit error sets through the intervening Cliffords</p>
</li>
<li>Let the error inserted after L1 be E1 (a 2-qubit Pauli on qubits 2,1), and after L2 be E2 (a 2-qubit Pauli on qubits 0,3).</li>
<li>The net error at the end is Eout = E2 ¬∑ U E1 U‚Ä†, where U = H0 ¬∑ CNOT03 ¬∑ H0‚Ä† is the Clifford between L1 and L2 plus the final CNOT; more directly, because H0 is before CNOT03, we use standard conjugation rules to map E1, E2 to a 4-qubit Pauli at the output.</li>
<li>Key structural fact: each location‚Äôs two-qubit Pauli spreads, under conjugation by intervening Cliffords, to a 4-qubit Pauli that has non-identity support only on the same two-qubit subset it started on, possibly moved by the CNOT lightcone:<ul>
<li>E1 acts initially on qubits {2,1}; after H0 (on qubit 0) it is unchanged; after CNOT03 it is still supported on {2,1}. Hence E1 contributes only on {2,1} in Eout.</li>
<li>E2 acts on {0,3} and remains on {0,3}.</li>
</ul>
</li>
<li>
<p>Therefore, at the end, Eout factorizes as a tensor product over the partition {0,3} ‚äó {2,1}:
    Eout = Eout(0,3) ‚äó Eout(2,1),
    where each factor is the corresponding two-qubit Pauli (possibly conjugated by the H on qubit 0 for E2). Conjugation by H on qubit 0 swaps X ‚Üî Z on that qubit, Y ‚Üí ‚àíY.</p>
</li>
<li>
<p>Detectability criterion per pair</p>
</li>
<li>A 4-qubit Pauli P = P03 ‚äó P21 commutes with XXXX iff both P03 and P21 have even X/Y parity; and it commutes with ZZZZ iff both P03 and P21 have even Z/Y parity.</li>
<li>Consequently:<ul>
<li>If a two-qubit Pauli on a pair has odd X/Y parity or odd Z/Y parity, it anticommutes with at least one stabilizer and is detectable.</li>
<li>A two-qubit Pauli on a pair is undetectable within that pair iff it has even X/Y parity and even Z/Y parity; but the only such two-qubit Paulis are II and YY on that pair (since on two qubits, even X/Y and even Z/Y forces either identity or both qubits Y).</li>
</ul>
</li>
<li>
<p>Therefore, for each pair independently:</p>
<ul>
<li>Allowed (survive) two-qubit Paulis on that pair: II or YY (2 possibilities).</li>
<li>Disallowed (detected) on that pair: the other 15‚àí2 = 13 non-identity elements.</li>
</ul>
</li>
<li>
<p>Survival probability</p>
</li>
<li>At each location:<ul>
<li>With probability 1‚àíp: II (survives).</li>
<li>With probability p: a uniformly random non-identity two-qubit Pauli. Among these 15, exactly 1 equals YY (survives), and the remaining 14 are detected.</li>
<li>Thus per location, the ‚Äúsurvival‚Äù probability is (1‚àíp) + p¬∑(1/15) = 1 ‚àí (14/15)p.</li>
</ul>
</li>
<li>
<p>Because the two locations act on disjoint pairs and independence is preserved, the total survival probability is the product:
    P_survive = [1 ‚àí (14/15)p]^2.</p>
</li>
<li>
<p>Within survivors: which are stabilizers vs. logical?</p>
</li>
<li>The surviving possibilities per pair are only II and YY.</li>
<li>Therefore Eout can be one of the four tensor products: II‚äóII, YY‚äóII, II‚äóYY, YY‚äóYY. In 4-qubit notation these are:<ul>
<li>II‚äóII = I I I I = I (stabilizer).</li>
<li>YY‚äóII = I I Y Y up to qubit order {0,3}|{2,1}; mapping back to standard order (0,1,2,3): this is Y_2 Y_1 = I Y Y I after ordering. But using the given stabilizers, the 4-qubit element with Y on all four qubits is YYYY; with Y on only a pair it is not a stabilizer. However, recall our even-parity conditions above were for the whole 4-qubit operator; the pairwise analysis already guaranteed commutation with both stabilizers. The only 4-qubit Paulis commuting with both stabilizers are exactly the normalizer; among the four candidates, we must determine which are in S.</li>
</ul>
</li>
<li>Compute explicitly whether YY on a pair is a logical or a stabilizer element:<ul>
<li>Consider YY on qubits 2 and 1 (I Y Y I). Check commutation with XXXX: X on qubits 1 and 2 anticommutes with Y on those qubits twice, giving overall commute; similarly with ZZZZ. Hence it is in the normalizer. It is not in the stabilizer group S = {I, XXXX, ZZZZ, YYYY}, so it is a nontrivial logical operator.</li>
<li>II‚äóYY similarly yields a two-qubit Y on qubits 0 and 3 (Y I I Y) up to the H on qubit 0 which maps Y0 ‚Üí ‚àíY0, so it stays Y on that qubit; thus it is also a nontrivial logical operator.</li>
<li>YY‚äóYY gives YYYY, which equals the product of XXXX and ZZZZ and is a stabilizer.</li>
</ul>
</li>
<li>
<p>Therefore:</p>
<ul>
<li>Stabilizer outcomes among survivors: I and YYYY (2 of the 4).</li>
<li>Logical (nontrivial) outcomes among survivors: Y on pair {2,1} only, or Y on pair {0,3} only (2 of the 4).</li>
</ul>
</li>
<li>
<p>Conditional probabilities among survivors</p>
</li>
<li>At each location, the distribution over the two surviving choices is:<ul>
<li>II with probability (1‚àíp) / [1 ‚àí (14/15)p],</li>
<li>YY with probability (p/15) / [1 ‚àí (14/15)p].</li>
</ul>
</li>
<li>Since locations are independent, the joint survivor distribution over the four outcomes is the product distribution. The total probability weight on stabilizers equals:
    P_S|survive = Prob[(II,II) or (YY,YY)] given survival
                 = [ (1‚àíp)^2 + (p/15)^2 ] / [ 1 ‚àí (14/15)p ]^2.</li>
<li>
<p>Hence the logical state fidelity conditioned on post-selection is:
    F_log(p) = P_S|survive
             = [ (1‚àíp)^2 + (p^2/225) ] / [ 1 ‚àí (14/15)p ]^2.</p>
</li>
<li>
<p>Small-p expansion (sanity check)</p>
</li>
<li>Expand numerator: 1 ‚àí 2p + p^2 + p^2/225 = 1 ‚àí 2p + (226/225)p^2.</li>
<li>Denominator: [1 ‚àí (14/15)p]^2 = 1 ‚àí (28/15)p + (196/225)p^2.</li>
<li>Series to O(p^2):
    F_log(p) ‚âà 1 ‚àí (2 ‚àí 28/15)p + [226/225 ‚àí 196/225 + (2 ‚àí 28/15)^2] p^2/??? Better to compute directly:
    Using ratio expansion, F ‚âà 1 ‚àí (2 ‚àí 28/15)p + O(p^2) = 1 ‚àí (2/15)p + O(p^2), showing strong suppression of first-order errors by post-selection as expected.</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Survival probability:</li>
</ul>
<div class="arithmatex">\[
P_{\mathrm{survive}}(p) = \left(1 - \frac{14}{15}p\right)^2.
\]</div>
<ul>
<li>Conditional logical fidelity:</li>
</ul>
<div class="arithmatex">\[
F_{\mathrm{log}}(p) = \frac{(1-p)^2 + \left(\frac{p}{15}\right)^2}{\left(1 - \frac{14}{15}p\right)^2}.
\]</div>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>p is the two-qubit depolarizing error probability per CNOT.</li>
<li>Single-qubit gates are noiseless.</li>
<li>Post-selection discards any run with nontrivial stabilizer syndrome.</li>
</ul>
<ol start="4">
<li>Final Answer:
F_log(p) = [ (1 ‚àí p)^2 + (p/15)^2 ] / [ 1 ‚àí (14/15)p ]^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">14</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.843659
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>