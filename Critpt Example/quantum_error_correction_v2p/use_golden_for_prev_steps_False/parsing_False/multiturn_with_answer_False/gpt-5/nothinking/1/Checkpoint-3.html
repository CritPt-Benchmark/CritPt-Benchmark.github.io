<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Circuit and noise model:</li>
<li>Circuit (right-to-left): apply H on qubit 2, then CNOT21, then H on qubit 0, then CNOT03.</li>
<li>
<p>Only the two CNOT gates are followed by noise. Each is followed by an independent two-qubit depolarizing channel:</p>
<ul>
<li>With probability 1−p: no error.</li>
<li>With probability p: one of the 15 non-identity two-qubit Pauli errors is applied uniformly at random (each with probability p/15).</li>
</ul>
</li>
<li>
<p>Target state:</p>
</li>
<li>The circuit (without noise) prepares a specific 4-qubit physical code state |ψideal⟩ that encodes the logical GHZ (|00⟩AB + |11⟩AB)/√2 in the [[4,2,2]] code.</li>
<li>
<p>We denote the final ideal pure state by ρideal = |ψideal⟩⟨ψideal|.</p>
</li>
<li>
<p>Fidelity definition:</p>
</li>
<li>
<p>The physical state fidelity of the final 4-qubit state is F = ⟨ψideal| ρnoisy |ψideal⟩, where ρnoisy is the state after the two noisy CNOTs and the two perfect H gates.</p>
</li>
<li>
<p>Linearity and independence of noise:</p>
</li>
<li>Because the noise channels are Pauli twirls and the circuit between/around them is unitary, the resulting fidelity can be computed by summing the probabilities of all error patterns that map |ψideal⟩ to itself (i.e., that are benign for the final state).</li>
<li>
<p>Let E1 be the Pauli error after CNOT21, and E2 the Pauli error after CNOT03, with each independently equal to I with probability 1−p, or one of the 15 non-identity two-qubit Paulis with probability p/15.</p>
</li>
<li>
<p>Benign-error counting:</p>
</li>
<li>For a fixed final target pure state |ψideal⟩, the fidelity contribution from a Pauli error pattern E = E2 E1 (Heisenberg-propagated to the end) is 1 if E|ψideal⟩ = |ψideal⟩ and 0 otherwise.</li>
<li>
<p>In the depolarizing model, at each noisy CNOT, exactly one pattern (the identity) leaves |ψideal⟩ invariant with certainty; all 15 non-identity two-qubit Paulis, when pushed to the end, will produce an orthogonal state with respect to |ψideal⟩ (since |ψideal⟩ is a non-stabilizer eigenstate of none of those two-qubit Paulis on the involved qubits, and any nontrivial two-qubit Pauli either flips syndrome or changes the final state). Hence, for each noisy CNOT, the only fidelity-preserving “error” is the no-error branch.</p>
</li>
<li>
<p>Consequently, the only overall error pattern that preserves the final state is E1 = I and E2 = I, which occurs with probability (1−p)⋅(1−p).</p>
</li>
<li>
<p>All other combinations (one or both CNOTs suffering a non-identity two-qubit Pauli) yield a final state orthogonal to |ψideal⟩ in expectation under the depolarizing mixture, contributing zero to F.</p>
</li>
<li>
<p>Therefore, the physical fidelity is simply the probability that neither CNOT suffers an error:
  F = (1 − p)^2.</p>
</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Noise per CNOT: Λ(ρ) = (1 − p) ρ + (p/15) ∑P≠I P ρ P.</li>
<li>Fidelity: F = ⟨ψideal| ρnoisy |ψideal⟩ = Prob[E1 = I ∧ E2 = I] = (1 − p)^2.</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Gates are unitary and noiseless except the two CNOTs.</li>
<li>Two-qubit depolarizing noise with error probability p applied after each CNOT.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = (1 − p)^2</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Setup and noise:</li>
<li>Circuit (right-to-left): H2 → CNOT21 → H0 → CNOT03.</li>
<li>Only the two CNOTs are noisy. After each CNOTij, an independent two-qubit depolarizing channel acts on the same pair {i,j}:
    Λ(ρ) = (1 − p) ρ + (p/15) ∑P∈P2{I} P ρ P,
    with P2 the two-qubit Pauli group on those two qubits.</li>
<li>
<p>We post-select on the [[4,2,2]] code’s stabilizers S = {XXXX, ZZZZ}, i.e., we keep runs whose final 4-qubit state lies in the codespace (both stabilizer checks yield +1), and we then decode to the 2-qubit logical state. The target logical state is the logical GHZ (|00⟩AB + |11⟩AB)/√2.</p>
</li>
<li>
<p>Goal:</p>
</li>
<li>
<p>Logical state fidelity Flog = ⟨GHZ| ρlog |GHZ⟩, conditioned on acceptance (no detected error), where ρlog is the decoded logical state of the accepted runs.</p>
</li>
<li>
<p>Key facts about the [[4,2,2]] code for distance-2, post-selected operation:</p>
</li>
<li>Distance d = 2 detects any single-qubit Pauli error but cannot detect all two-qubit Paulis.</li>
<li>Here, only two-qubit Paulis occur, each confined to one of the CNOT pairs: after CNOT21, errors act on qubits {2,1}; after CNOT03, errors act on {0,3}.</li>
<li>
<p>A two-qubit Pauli E on a given pair is:</p>
<ul>
<li>Detected if it anticommutes with at least one stabilizer generator XXXX or ZZZZ, hence flips a syndrome.</li>
<li>Undetected if it commutes with both stabilizers and preserves the codespace. Among those, some are equivalent (up to stabilizers) to nontrivial logical Paulis and thus cause a logical error; others are stabilizers and thus are harmless.</li>
</ul>
</li>
<li>
<p>Commutation conditions with stabilizers:</p>
</li>
<li>For E supported only on qubits {a,b}, its commutation with ZZZZ demands an even number of X/Y on {a,b}; commutation with XXXX demands an even number of Z/Y on {a,b}.</li>
<li>On a two-qubit support, the non-identity Paulis are the 15 elements of {I,X,Y,Z}^{⊗2} \ {II}. The subset commuting with both XXXX and ZZZZ is exactly:
    {II, XX, YY, ZZ} on those two qubits.</li>
<li>
<p>Therefore, per noisy CNOT, exactly 3 of the 15 non-identity errors are undetected (XX, YY, ZZ on that pair). The other 12/15 are detected and post-selected away.</p>
</li>
<li>
<p>Harmless vs logical among undetected errors:</p>
</li>
<li>Among {XX, YY, ZZ} on a given pair:<ul>
<li>One of them equals the weight-2 stabilizer on that pair induced by the code’s global stabilizers. In the [[4,2,2]] code, the product of the two global stabilizers gives identity, so weight-2 operators are not global stabilizers; however, when restricted to a fixed pair, XX and ZZ on that pair act as logical or as part of the logical/stabilizer equivalence depending on the pair and the chosen logical operator representatives.</li>
</ul>
</li>
<li>
<p>We need to determine, for each pair {2,1} and {0,3}, which of {XX, YY, ZZ} induce a logical error on the AB logical qubits and which act trivially on the logical state (up to global phase).</p>
</li>
<li>
<p>Using the given logical operator representatives:</p>
</li>
<li>Stabilizers: Sx = XXXX, Sz = ZZZZ.</li>
<li>Logical Paulis:
    X_A = X I X I, Z_A = Z Z I I,
    X_B = X X I I, Z_B = Z I Z I,
    all up to multiplication by Sx,Sz.</li>
<li>Consider an undetected two-qubit Pauli E on a specific pair and test its action on the logical subspace by commuting with the above logicals.</li>
<li>Pair {2,1} (qubits 2 and 1):<ul>
<li>Map the pair-local operators to logical operators modulo stabilizers:
  • On {2,1}, XX21:
    Multiply by Sx = XXXX to shift supports: XX21 · Sx = (X2 X1)(X0 X1 X2 X3) = X0 X3 (up to ordering). That equals X0 X3, which is equivalent (mod Sx) to X_A X_B (since X_A = X0 X2, X_B = X0 X1, and with stabilizers, weight-2 cross-pair X’s can be reduced to logical X’s). Hence XX21 implements a nontrivial logical X-type on AB; it flips the logical GHZ phase/sign or swaps components, i.e., it causes a logical error.
  • Similarly, ZZ21 maps (mod Sz) to a nontrivial logical Z-type on AB.
  • YY21 = (i XZ)⊗(i ZX) ∝ XX21·ZZ21 (up to phase), thus also a nontrivial logical on AB.</li>
<li>Conclusion: all three undetected errors {XX, YY, ZZ} on {2,1} are logical (harmful).</li>
</ul>
</li>
<li>Pair {0,3} (qubits 0 and 3) is symmetric by permutation of qubits under the code’s stabilizers; the same conclusion holds: undetected {XX, YY, ZZ} on {0,3} are logical errors.</li>
<li>
<p>Therefore, every undetected non-identity two-qubit error on either noisy CNOT pair induces a logical error; there are no harmless undetected errors in this setting.</p>
</li>
<li>
<p>Counting accepted branches and fidelity:</p>
</li>
<li>For each noisy CNOT independently:<ul>
<li>With probability 1−p: identity → accepted and no logical error.</li>
<li>With probability p:
  • 12/15 detected → rejected by post-selection.
  • 3/15 undetected → accepted but induce a logical error on the code space.</li>
</ul>
</li>
<li>Let A be the acceptance probability and G the good (no-logical-error) probability.<ul>
<li>One CNOT contributes:</li>
<li>Acceptance A1 = (1 − p) + p·(3/15) = 1 − p + p/5 = 1 − (4/5) p.</li>
<li>Good G1 = (1 − p) (since all undetected non-identity branches are logical).</li>
<li>Two independent CNOTs:</li>
<li>Acceptance A = A1^2 = [1 − (4/5) p]^2.</li>
<li>Good G = probability no logical error and accepted = (1 − p)^2 (only identity after both CNOTs).</li>
</ul>
</li>
<li>
<p>Logical fidelity conditioned on acceptance:
    F_log(p) = G / A = (1 − p)^2 / [1 − (4/5) p]^2.</p>
</li>
<li>
<p>Small-p expansion (optional check):</p>
</li>
<li>F_log(p) = 1 − (2/5) p + O(p^2).</li>
<li>This shows post-selection improves leading-order sensitivity compared to physical fidelity (which was (1 − p)^2 = 1 − 2p + O(p^2)).</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Per CNOT acceptance: A1 = (1 − p) + (p/15)·3 = 1 − (4/5) p.</li>
<li>Two CNOTs acceptance: A = [1 − (4/5) p]^2.</li>
<li>Good (no logical error) probability: G = (1 − p)^2.</li>
<li>Logical fidelity (post-selected): </li>
</ul>
<div class="arithmatex">\[
F_{\mathrm{log}}(p) = \frac{(1 - p)^2}{\left[1 - \frac{4}{5}p\right]^2}.
\]</div>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Only two-qubit gate depolarizing noise p after each CNOT.</li>
<li>Post-selection on both stabilizers returning +1 (codespace).</li>
</ul>
<ol start="4">
<li>Final Answer:
F_log(p) = (1 − p)^2 / [1 − (4/5) p]^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Circuit and noise model</li>
<li>Operations applied right-to-left: H1 → CNOT12 → CNOT10 → CNOT23 → CNOT34 → CNOT04 → M4.</li>
<li>Only the five CNOTs are noisy. After each CNOTij, an independent two-qubit depolarizing channel acts on that pair:
    Λ(ρ) = (1 − p) ρ + (p/15) ∑P∈P2{I} P ρ P.</li>
<li>
<p>Post-selection:</p>
<ul>
<li>Keep only runs where the ancilla measurement outcome is |0⟩.</li>
<li>Keep only runs whose final data state lies in the [[4,2,2]] codespace (both stabilizers XXXX and ZZZZ have +1).</li>
<li>Decode to the logical 2-qubit state and compare with the target |00⟩AB.</li>
</ul>
</li>
<li>
<p>Target and acceptance/fidelity structure</p>
</li>
<li>Let A be the overall acceptance probability (ancilla=0 and codespace).</li>
<li>Let G be the probability of acceptance with no logical error (i.e., the decoded logical state equals |00⟩AB).</li>
<li>
<p>The logical state fidelity conditioned on acceptance is F_log = G / A.</p>
</li>
<li>
<p>Detectability and benignness analysis (Pauli-frame counting)</p>
</li>
<li>The [[4,2,2]] code detects any weight-1 Pauli on the data. Our noise consists only of two-qubit Paulis at the five CNOT locations; each such error is either:<ul>
<li>Detected by the code’s stabilizers (flips XXXX or ZZZZ) and thus rejected,</li>
<li>Or undetected by the code stabilizers but flagged by the ancilla (ancilla=1) and thus rejected,</li>
<li>Or undetected by both and hence accepted. Among accepted non-identity errors, some could be harmless (stabilizers) and some could enact logical Paulis (harmful).</li>
</ul>
</li>
<li>Fault-tolerant preparation via the ancilla is arranged so that any single two-qubit Pauli error at any one of the five CNOTs is either detected by the stabilizers or by the ancilla, unless it acts as a code stabilizer on the data (benign). Moreover, any accepted non-identity single fault on the data that commutes with both stabilizers is equivalent to a stabilizer (hence does not change the logical state).</li>
<li>
<p>Consequently, to first order in p (single-fault regime), all accepted events have the correct logical state; accepted logical errors require at least two faults.</p>
</li>
<li>
<p>First-order probabilities per CNOT</p>
</li>
<li>For a single noisy CNOT:<ul>
<li>Identity branch with probability 1 − p: always accepted and correct.</li>
<li>Error branch with probability p:</li>
<li>Among the 15 non-identity two-qubit Paulis, the preparation-plus-ancilla circuitry ensures that any such single fault is rejected (either by ancilla=1 or by code syndrome) unless it maps to a data stabilizer. Two-qubit Paulis equal to a data stabilizer on the CNOT’s support do not exist as literal local stabilizers; however, when propagated through the circuit, a subset of single faults lead to a harmless effect (stabilizer) at the end and thus are accepted without logical error. Denote the fraction of such harmless single-fault branches by f_h (per CNOT). All other single-fault branches are rejected.</li>
</ul>
</li>
<li>
<p>Because the ancilla fault-tolerance was designed to detect any single fault affecting the logical content, we have, to first order:</p>
<ul>
<li>Acceptance A = 1 − c p + O(p^2), with c reflecting the rejection of most single-fault branches across the five CNOTs.</li>
<li>Good probability G = 1 − c p + O(p^2), since all accepted single-fault branches are harmless (the same c).</li>
<li>Hence F_log = G/A = 1 − O(p^2); no linear term in p.</li>
</ul>
</li>
<li>
<p>Leading-order result</p>
</li>
<li>
<p>Therefore, the logical fidelity conditioned on acceptance has no O(p) degradation:
    F_log(p) = 1 − α p^2 + O(p^3),
    where α is a positive constant determined by the combinatorics of two-fault patterns that both evade detection (ancilla and stabilizers) and enact a logical on the data.</p>
</li>
<li>
<p>Compact rational form via acceptance/good counting</p>
</li>
<li>Let each CNOT have acceptance probability A1 = 1 − a p + O(p^2) and “good accepted” probability G1 = 1 − a p + O(p^2). For five independent locations,
    A = (1 − a p)^5 + O(p^2), G = (1 − a p)^5 + O(p^2),
    yielding F_log = 1 + O(p^2).</li>
<li>Without a full propagation table of all 15 error generators through the specific circuit and their ancilla/stabilizer outcomes, α cannot be uniquely determined, but the absence of a linear term is fixed by the fault-tolerant design.</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Acceptance and good probabilities:</li>
</ul>
<div class="arithmatex">\[
A(p) = 1 - c\,p + O(p^2), \quad G(p) = 1 - c\,p + O(p^2).
\]</div>
<ul>
<li>Logical fidelity conditioned on acceptance:</li>
</ul>
<div class="arithmatex">\[
F_{\mathrm{log}}(p) = \frac{G(p)}{A(p)} = 1 - \alpha p^2 + O(p^3), \quad \text{with } \alpha &gt; 0.
\]</div>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Two-qubit depolarizing error with rate p after each CNOT.</li>
<li>Post-selection on codespace and ancilla outcome |0⟩.</li>
</ul>
<ol start="4">
<li>Final Answer:
F_log(p) = 1 − α p^2 + O(p^3), i.e., there is no linear-in-p term; the leading logical infidelity is quadratic in p. The constant α depends on the detailed two-fault combinatorics of the circuit (ancilla plus code), but all single-fault events are either rejected or harmless.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.540585
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>