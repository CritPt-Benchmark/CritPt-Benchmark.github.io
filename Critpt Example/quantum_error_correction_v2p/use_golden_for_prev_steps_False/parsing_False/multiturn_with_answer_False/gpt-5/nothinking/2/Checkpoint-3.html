<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>
<p>Noise model:
  After each CNOT gate, a two-qubit depolarizing channel acts:
  E(ρ) = (1 − p) ρ + (p/15) ∑_{P∈{two-qubit non-identity Paulis}} P ρ P.
  Single-qubit H has no noise.</p>
</li>
<li>
<p>Circuit:
  U = CNOT_{03} ⋅ H_0 ⋅ CNOT_{21} ⋅ H_2.
  There are exactly two noisy two-qubit gates: CNOT_{21} and CNOT_{03}, each followed by its own depolarizing channel.</p>
</li>
<li>
<p>Target state:
  Let |ψ_id⟩ be the state output by the ideal (noise-free) circuit. The physical state fidelity is F ≡ ⟨ψ_id| ρ_out |ψ_id⟩, where ρ_out is the actual output state with noise after the two CNOTs.</p>
</li>
<li>
<p>Effect of a two-qubit depolarizing channel on pure-state fidelity:
  Consider a single such channel acting on some two-qubit subsystem of a pure state |φ⟩ of the full system. The output is
  ρ&rsquo; = (1 − p) |φ⟩⟨φ| + (p/15) ∑<em>{P≠I} P |φ⟩⟨φ| P.
  The fidelity with |φ⟩ is
  F&rsquo; = ⟨φ|ρ&rsquo;|φ⟩ = (1 − p) + (p/15) ∑</em>{P≠I} |⟨φ|P|φ⟩|^2.
  For a generic pure state and the full two-qubit Pauli set on those two qubits, at most the identity has perfect overlap; for non-identity Paulis, the average overlap term vanishes. In particular, for a two-qubit depolarizing channel, the channel’s entanglement (or state) fidelity with respect to any pure state equals
  F_2q = 1 − (d − 1)/d ⋅ p = 1 − (15/16) p,
  because the two-qubit Hilbert space has dimension d = 16 for the Pauli transfer on density matrices; equivalently, the depolarizing channel sends ρ → (1 − p)ρ + p I/4 on the acted two-qubit subsystem, which yields state fidelity 1 − 3p/4 if the whole system were only those two qubits. When embedded in a larger system with the Kraus operators being the full 15 two-qubit Paulis, the contribution to ⟨ψ|·|ψ⟩ from non-identity Paulis is zero, so the net fidelity factor per noisy CNOT is precisely (1 − p).</p>
</li>
</ul>
<p>More directly (and sufficient here): since the non-identity Pauli errors are mutually orthogonal to the projector onto the ideal pure state for a generic target state, each depolarizing channel reduces the overlap with the error-free branch by a factor (1 − p), while all error branches are orthogonal and do not contribute to the final overlap.</p>
<p>Therefore, each noisy CNOT contributes a multiplicative factor (1 − p) to the final fidelity with the ideal output state.</p>
<ul>
<li>Independence and composition:
  The two depolarizing channels act after different CNOTs and are independent. The final state is a convex mixture over four cases: no error, error after first CNOT only, error after second CNOT only, errors after both. Only the no-error branch matches the ideal output state; all other branches are orthogonal to the ideal pure state (the two-qubit Paulis applied after their respective CNOTs map |ψ_id⟩ to an orthogonal state). Hence the fidelity equals the weight of the no-error branch:
  F(p) = (1 − p) ⋅ (1 − p) = (1 − p)^2.</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>
<p>The channel after each CNOT:
  E(ρ) = (1 − p) ρ + (p/15) ∑_{P≠I} P ρ P.</p>
</li>
<li>
<p>Final physical state fidelity:
  F(p) = ⟨ψ_id| ρ_out |ψ_id⟩ = (1 − p)^2.</p>
</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Error rate p is per two-qubit gate.</li>
<li>Only the two CNOTs are noisy; H gates are ideal.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = (1 − p)^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Code, target, and circuit</li>
<li>[[4,2,2]] code with stabilizers S = ⟨XXXX, ZZZZ⟩ encodes two logical qubits A,B with logical Paulis:
    X_A = X I X I, X_B = X X I I, Z_A = Z Z I I, Z_B = Z I Z I (up to stabilizers).</li>
<li>
<p>We prepare the logical GHZ state (|00⟩<em>{AB} + |11⟩</em>{AB})/√2 using the circuit
    U = CNOT_{03} ⋅ H_0 ⋅ CNOT_{21} ⋅ H_2,
    where only the two CNOTs are followed by two-qubit depolarizing noise with error rate p; H gates are perfect.</p>
</li>
<li>
<p>Noise model
  After each CNOT_{ij}, a two-qubit depolarizing channel acts on qubits i,j:
  E(ρ) = (1 − p) ρ + (p/15) ∑_{P∈P2{II}} P ρ P,
  where P2 = {I,X,Y,Z}^{⊗2} on that pair.</p>
</li>
<li>
<p>Post-selection on detectable errors
  The [[4,2,2]] code detects any single-qubit Pauli error and any weight-1 error; more generally, it detects any error that anticommutes with at least one stabilizer (i.e., flips the syndrome). We assume we measure the stabilizers at the end and keep only runs with trivial syndrome (“post-select on no detected error”).</p>
</li>
</ul>
<p>The logical state fidelity under post-selection equals
  F_log(p) = ⟨Ψ_L| ρ_L|Ψ_L⟩,
  where ρ_L is the logical two-qubit state obtained by (i) applying the noisy circuit, (ii) projecting onto the code space (trivial syndrome), and (iii) renormalizing. Equivalently, among the error events produced by the two depolarizing channels, we retain only those that commute with both stabilizers (so they are undetected); among these, some may act as nontrivial logical Paulis (logical faults) and thus reduce the logical fidelity, while those equivalent to stabilizers have no effect on the logical state.</p>
<ul>
<li>
<p>Strategy
  1) Enumerate undetected two-qubit Pauli errors from each depolarizing channel location that commute with S = {XXXX, ZZZZ}.
  2) Among those, classify which are stabilizers (harmless) and which implement nontrivial logical operations (harmful).
  3) Compute acceptance probability P_acc(p) (probability that the syndrome is trivial) and, conditioned on acceptance, the probability of a logical fault P_L|acc.
  4) The logical state is a mixture of the ideal logical state and states with a logical Pauli applied. For the GHZ target |Ψ_L⟩, only the branch with no logical fault contributes to the overlap; branches with nontrivial logical Paulis are orthogonal (for this GHZ) or at least yield zero overlap with |Ψ_L⟩ for the Paulis that can occur here. Thus
     F_log(p) = Prob(no logical fault | accepted) = [Prob(accepted and no logical fault)] / P_acc.</p>
</li>
<li>
<p>Commutation condition with stabilizers
  Let an error E act on the two qubits of a CNOT location. For the error to pass post-selection, it must commute with both XXXX and ZZZZ.</p>
</li>
</ul>
<p>For any Pauli P, P commutes with XXXX iff it has even parity of Z/Y over all 4 qubits (i.e., it anticommutes with X on an odd number of positions is forbidden). Since the error acts only on a two-qubit subset, this reduces to: the number of Z or Y on those two acted qubits must be even (0 or 2).
  Similarly, P commutes with ZZZZ iff the number of X or Y on the two acted qubits is even.</p>
<p>On a two-qubit support, the pairs that satisfy both are exactly:
  - II (identity, but excluded from the 15 non-identity set)
  - XX, YY, ZZ on that pair.</p>
<p>Therefore, among the 15 non-identity two-qubit Paulis, exactly 3 commute with both stabilizers; the remaining 12 flip the syndrome and are rejected by post-selection.</p>
<ul>
<li>Classification into stabilizer vs logical on the code
  XX, YY, ZZ on a particular pair of qubits are not, in general, elements of the stabilizer group S = ⟨XXXX, ZZZZ⟩ (whose nontrivial elements are XXXX, ZZZZ, and ±XXXX·ZZZZ = YYYY). On support of the acted pair, we need to see whether these undetected errors are equivalent (up to stabilizers) to the identity or to nontrivial logical Paulis.</li>
</ul>
<p>However, crucial simplification for fidelity:
  - If an undetected error equals a stabilizer element, it has no effect on the logical state.
  - If it equals a nontrivial logical Pauli, for the GHZ target state |Ψ_L⟩ = (|00⟩+|11⟩)/√2 of logical qubits A,B, the overlap ⟨Ψ_L| L |Ψ_L⟩ is:
    ⟨Ψ_L|X_A|Ψ_L⟩ = 0, ⟨Ψ_L|X_B|Ψ_L⟩ = 0, ⟨Ψ_L|Z_A|Ψ_L⟩ = 0, ⟨Ψ_L|Z_B|Ψ_L⟩ = 0,
    ⟨Ψ_L|X_A X_B|Ψ_L⟩ = 1, ⟨Ψ_L|Z_A Z_B|Ψ_L⟩ = 1, ⟨Ψ_L|Y_A Y_B|Ψ_L⟩ = 1.
    Thus only logical operators that are in the stabilizer of |Ψ_L⟩, namely {I, X_A X_B, Z_A Z_B, Y_A Y_B}, preserve the state (up to a phase). Single-qubit logicals flip it to an orthogonal state.</p>
<p>Therefore, we must determine, for each CNOT location, which of the undetected pair-Paulis {XX, YY, ZZ} on that specific pair map to which logical operators. Then we can count how many are harmless (in the GHZ stabilizer) versus harmful (logical faults).</p>
<ul>
<li>Mapping for the two locations
  The two noisy locations act on pairs (2,1) and (0,3), respectively. We need the image of pair-Pauli on those qubit indices modulo the code stabilizer.</li>
</ul>
<p>Use the given logical operators:
  - X_A = X I X I (qubits 0,1,2,3)
  - X_B = X X I I
  - Z_A = Z Z I I
  - Z_B = Z I Z I
  And stabilizers:
  - S_X = X X X X
  - S_Z = Z Z Z Z
  Also S_Y = i^k S_X S_Z = Y Y Y Y (up to phase).</p>
<p>Work modulo S. On qubits (2,1) and (0,3), the undetected errors are:
  - On (2,1): XX_21, YY_21, ZZ_21.
    Express them in the logical basis:
    • ZZ_21: place Z on qubits 2 and 1. But Z_A = Z Z I I is on qubits (0,1). Z_B = Z I Z I is on (0,2). Multiplying Z_A Z_B gives (Z Z I I)(Z I Z I) = (I, Z, Z, I) = Z on (1,2). Hence
      Z_1 Z_2 ≡ Z_A Z_B (up to phase). So ZZ_21 is the logical Z_A Z_B, which stabilizes |Ψ_L⟩.
    • XX_21: use X_A = X I X I (on 0,2) and X_B = X X I I (on 0,1). Multiply: X_A X_B = (X, X, X, I). To get X on (1,2) we can multiply by S_X = XXXX to move X from qubit 0 to qubit 3:
      (X_A X_B) ⋅ S_X = (X,X,X,I) ⋅ (X,X,X,X) = (I, I, I, X) which is not on (1,2). Instead, observe:
      X on (1,2) equals (X_A X_B) times X on qubits (0,3):
      (X_A X_B) = X_0 X_1 X_2. Multiply by X_0 to cancel qubit 0 gives X_1 X_2, but X_0 is not in S. However, we can multiply by S_X to trade X_0 for X_3: S_X ⋅ X_0 = X_1 X_2 X_3. Then
      (X_A X_B) ⋅ S_X = X_3, so multiplying that by X_3 gives identity. A cleaner route: use that the code space modulo S has a basis of two logical qubits; independent representatives are X_A, X_B, Z_A, Z_B. Any weight-2 Pauli commuting with S must correspond to either a logical two-qubit operator (like X_A X_B, Z_A Z_B, Y_A Y_B) or a stabilizer. To test which, compute its action on the four code basis states; but we can infer by pairing:
      Since ZZ_21 maps to Z_A Z_B, by symmetry under the Clifford of the circuit that creates the GHZ, XX_21 maps to X_A X_B, and YY_21 maps to Y_A Y_B, up to stabilizers. Indeed, using Y_A Y_B = (iX_A Z_A)(iX_B Z_B) = − X_A X_B Z_A Z_B, and the same local pairing on qubits (1,2), Y_1 Y_2 = − X_1 X_2 Z_1 Z_2, consistent with the mapping above. Therefore,
      XX_21 ≡ X_A X_B,
      YY_21 ≡ Y_A Y_B,
      ZZ_21 ≡ Z_A Z_B.
    All three are in the stabilizer of |Ψ_L⟩ and thus harmless for fidelity.</p>
<ul>
<li>On (0,3): XX_03, YY_03, ZZ_03.
    Similarly, note that S_X = X0 X1 X2 X3 implies X0 X3 ≡ X1 X2 (mod S_X), and S_Z implies Z0 Z3 ≡ Z1 Z2. Hence the mapping is identical:
      XX_03 ≡ XX_12 ≡ X_A X_B,
      YY_03 ≡ YY_12 ≡ Y_A Y_B,
      ZZ_03 ≡ ZZ_12 ≡ Z_A Z_B.
    Therefore, the undetected weight-2 Paulis on (0,3) are also exactly the GHZ stabilizers.</li>
</ul>
<p>Conclusion: every undetected two-qubit Pauli from either noisy location acts as one of {X_A X_B, Y_A Y_B, Z_A Z_B}, which all stabilize the logical GHZ state. Hence, conditioned on acceptance (trivial syndrome), there is no logical fault; the post-selected logical state equals the target state exactly.</p>
<ul>
<li>Probabilities
  For each noisy CNOT, acceptance probability:</li>
<li>No error with prob (1 − p).</li>
<li>Error occurs with prob p; it is accepted only if it is one of {XX,YY,ZZ} on that pair, i.e., with probability 3/15 = 1/5.
  Thus per gate, P_acc,1 = (1 − p) + p × (1/5) = 1 − (4/5) p.</li>
</ul>
<p>The two gates are independent, so the total acceptance probability is
  P_acc(p) = [1 − (4/5) p]^2.</p>
<p>Conditioned on acceptance, the logical state equals the target (no logical fault) with probability 1.</p>
<p>Therefore the logical state fidelity under post-selection is 1 for all p, while the success probability decreases with p.</p>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>
<p>Accepted set per noisy CNOT:
  {II} ∪ {XX, YY, ZZ} on the acted pair; accepted non-identity fraction = 3/15.</p>
</li>
<li>
<p>Acceptance probability:
  P_acc(p) = [ (1 − p) + (p/15) × 3 ]^2 = [1 − (4/5) p]^2.</p>
</li>
<li>
<p>Logical fidelity conditioned on acceptance:
  F_log(p) = 1.</p>
</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Error rate p is per two-qubit gate; only the two CNOTs are noisy.</li>
<li>Post-selection keeps only trivial stabilizer syndrome outcomes.</li>
</ul>
<ol start="4">
<li>Final Answer:
F_log(p) = 1 for all p ∈ [0,1], with total acceptance probability P_acc(p) = [1 − (4/5) p]^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Setup and noise model</li>
<li>Code: [[4,2,2]] with stabilizers S = ⟨S_X, S_Z⟩ = ⟨XXXX, ZZZZ⟩. Logical Paulis (one convenient choice):
    X_A = X I X I, X_B = X X I I, Z_A = Z Z I I, Z_B = Z I Z I.</li>
<li>Target logical state: |00⟩_{AB}.</li>
<li>Circuit (right-to-left action):
    1) H_1
    2) CNOT_{12}
    3) CNOT_{10}
    4) CNOT_{23}
    5) CNOT_{34}
    6) CNOT_{04}
    7) Measure qubit 4 in Z; accept only outcome |0⟩.</li>
<li>
<p>Noise: after each two-qubit CNOT, apply a two-qubit depolarizing channel on that pair:
    E(ρ) = (1 − p) ρ + (p/15) ∑_{P∈P2{II}} P ρ P.
    Single-qubit H and the final measurement are ideal.</p>
</li>
<li>
<p>Acceptance/post-selection rules</p>
</li>
<li>We post-select on:
    (i) trivial code syndrome (i.e., the final state is in the code space; any error that anticommutes with at least one of S_X, S_Z is detected and rejected),
    (ii) ancilla qubit 4 measured in |0⟩.</li>
<li>
<p>Among the 15 non-identity two-qubit Paulis following a CNOT, only those that commute with both S_X and S_Z and are compatible with ancilla |0⟩ can survive acceptance. All others are rejected.</p>
</li>
<li>
<p>Goal</p>
</li>
<li>
<p>Compute the logical state fidelity conditioned on acceptance:
    F_log(p) = ⟨00| ρ_L |00⟩_L,
    where ρ_L is the two-logical-qubit state obtained after projecting onto the code space and ancilla |0⟩ and renormalizing.</p>
</li>
<li>
<p>Key observation: fault-tolerant state preparation with ancilla verification</p>
</li>
<li>The purpose of the ancilla branch (CNOTs involving qubit 4 and its Z-measurement) is to detect any single fault (single two-qubit Pauli error) that could otherwise map into a nontrivial logical error on the encoded |00⟩_L.</li>
<li>With the [[4,2,2]] code’s distance 2, post-selection on stabilizer syndrome detects any error that anticommutes with a stabilizer; the ancilla verification is chosen so that any single two-qubit Pauli arising after any one CNOT either:
    (a) flips the code syndrome,
    (b) flips the ancilla measurement to |1⟩,
    (c) or, if it passes both, acts trivially (as a stabilizer) or as a logical operator that stabilizes |00⟩_L (i.e., Z-type on both logicals, etc.).</li>
<li>
<p>Consequently, conditioned on acceptance (trivial syndrome and ancilla |0⟩), any single fault does not cause a logical error, and similarly any combination of faults that still passes acceptance must be equivalent to an element that stabilizes |00⟩_L.</p>
</li>
<li>
<p>Stabilizer of |00⟩_L</p>
</li>
<li>
<p>The state |00⟩_{AB} is stabilized by Z_A and Z_B (and their products):
    Z_A |00⟩_L = |00⟩_L, Z_B |00⟩_L = |00⟩_L,
    and by the code stabilizers S_X, S_Z. Any operator equivalent (mod S) to Z_A^a Z_B^b with a,b∈{0,1} stabilizes |00⟩_L; any operator that includes an X on A or B flips |00⟩_L to an orthogonal state.</p>
</li>
<li>
<p>Classification of accepted error patterns</p>
</li>
<li>For each noisy CNOT, the only Pauli errors that can survive both the code-syndrome check and the ancilla |0⟩ check are engineered to act, modulo S, as one of {I, Z_A, Z_B, Z_A Z_B} on the logical sector. These operators stabilize |00⟩_L and thus do not reduce its fidelity.</li>
<li>Any Pauli that would act as X_A, X_B, X_A Z_B, etc., is detected either by the code stabilizer measurement (trivial syndrome post-selection) or by flipping the ancilla to |1⟩ and thus is rejected.</li>
<li>
<p>Therefore, conditioned on acceptance, the logical state equals |00⟩_L exactly.</p>
</li>
<li>
<p>Independence from p for the conditional fidelity</p>
</li>
<li>
<p>While the overall acceptance probability decreases with p (since most error patterns are rejected either by syndrome or ancilla), the logical state fidelity conditioned on acceptance remains unity: all accepted branches are logically correct (possibly with a stabilizer or logical Z-type that leaves |00⟩_L unchanged).</p>
</li>
<li>
<p>Conclusion</p>
</li>
<li>Under the stated post-selections (trivial syndrome and ancilla outcome |0⟩), the procedure is fault-tolerant in the sense that no logical error slips through from any single CNOT fault, and error combinations that pass acceptance are equivalent to stabilizers of |00⟩_L. Hence the conditional logical fidelity is 1 for all p.</li>
</ul>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>
<p>Noise channel after each CNOT:
  E(ρ) = (1 − p) ρ + (p/15) ∑_{P≠II} P ρ P.</p>
</li>
<li>
<p>Logical fidelity conditioned on acceptance:
  F_log(p) = ⟨00| ρ_L |00⟩_L = 1.</p>
</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Error rate p is per two-qubit gate.</li>
<li>Only the two-qubit gates are noisy; single-qubit H and the measurement are ideal.</li>
<li>Post-selection on trivial syndrome and ancilla measurement outcome |0⟩.</li>
</ul>
<ol start="4">
<li>Final Answer:
F_log(p) = 1 for all p ∈ [0,1], conditioned on accepting runs (trivial code syndrome and ancilla outcome |0⟩).</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.343158
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>