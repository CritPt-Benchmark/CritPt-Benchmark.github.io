<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Noise model and effective error:</li>
<li>Only the two CNOTs are noisy. After CNOT21 a two-qubit depolarizing channel acts on qubits (2,1), and after CNOT03 a depolarizing channel acts on qubits (0,3).</li>
<li>Let the Pauli error after CNOT21 be <span class="arithmatex">\(P_{12}\)</span> (acting on qubits 1,2; same as 2,1 up to ordering) and after CNOT03 be <span class="arithmatex">\(P_{03}\)</span> (acting on qubits 0,3). Each takes value<ul>
<li><span class="arithmatex">\(II\)</span> with probability <span class="arithmatex">\(1-p\)</span>,</li>
<li>each of the 15 non-identity two-qubit Paulis with probability <span class="arithmatex">\(p/15\)</span>.</li>
</ul>
</li>
<li>Because the gates following <span class="arithmatex">\(P_{12}\)</span> (namely <span class="arithmatex">\(H_0\)</span> and CNOT03) act only on qubits 0 and 3, they commute with <span class="arithmatex">\(P_{12}\)</span>. Hence the effective Pauli at the end is simply</li>
</ul>
<div class="arithmatex">\[
P_{\text{eff}} = P_{03}\,P_{12} = P_{03} \otimes P_{12},
\]</div>
<div class="codehilite"><pre><span></span><code>acting on disjoint pairs.
</code></pre></div>

<ul>
<li>Target state is a stabilizer state:</li>
<li>The code stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>.</li>
<li>For the logical GHZ state <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>, the logical stabilizers are <span class="arithmatex">\(X_A X_B\)</span> and <span class="arithmatex">\(Z_A Z_B\)</span>.</li>
<li>Using the given logical operators,</li>
</ul>
<div class="arithmatex">\[
X_A X_B = (XIXI)(XXII) = IXXI,
\]</div>
<div class="arithmatex">\[
Z_A Z_B = (ZZII)(ZIZI) = IZZI.
\]</div>
<ul>
<li>Thus the target 4-qubit state is the unique stabilizer state with generators</li>
</ul>
<div class="arithmatex">\[
\langle\, XXXX,\; ZZZZ,\; IXXI,\; IZZI \,\rangle.
\]</div>
<ul>
<li>Stabilizer factorization over the two disjoint pairs (0,3) and (1,2):</li>
<li>Restrict these generators to qubits (0,3):<ul>
<li><span class="arithmatex">\(XXXX \to XX\)</span>, <span class="arithmatex">\(ZZZZ \to ZZ\)</span>, <span class="arithmatex">\(IXXI \to II\)</span>, <span class="arithmatex">\(IZZI \to II\)</span>,</li>
<li>generating the subgroup <span class="arithmatex">\(\{II,\,XX,\,YY,\,ZZ\}\)</span> on qubits (0,3).</li>
</ul>
</li>
<li>Restrict to qubits (1,2):<ul>
<li><span class="arithmatex">\(XXXX \to XX\)</span>, <span class="arithmatex">\(ZZZZ \to ZZ\)</span>, <span class="arithmatex">\(IXXI \to XX\)</span>, <span class="arithmatex">\(IZZI \to ZZ\)</span>,</li>
<li>also generating <span class="arithmatex">\(\{II,\,XX,\,YY,\,ZZ\}\)</span> on qubits (1,2).</li>
</ul>
</li>
<li>Therefore the full stabilizer group is</li>
</ul>
<div class="arithmatex">\[
\mathcal{S}_{\text{target}} = \{P_{03}\otimes P_{12}\;|\;P_{03}\in\{II,XX,YY,ZZ\},\;P_{12}\in\{II,XX,YY,ZZ\}\},
\]</div>
<div class="codehilite"><pre><span></span><code>of size 16.
</code></pre></div>

<ul>
<li>Fidelity with a stabilizer state under Pauli noise:</li>
<li>For a stabilizer state <span class="arithmatex">\(|\psi\rangle\)</span>, and a Pauli error <span class="arithmatex">\(P\)</span>, <span class="arithmatex">\(\langle\psi|P|\psi\rangle=1\)</span> iff <span class="arithmatex">\(P\in\mathcal{S}_{\text{target}}\)</span>, and <span class="arithmatex">\(0\)</span> otherwise.</li>
<li>The physical state fidelity is thus the probability that the effective Pauli lies in the stabilizer:</li>
</ul>
<div class="arithmatex">\[
F(p) = \Pr\big(P_{\text{eff}}\in\mathcal{S}_{\text{target}}\big).
\]</div>
<ul>
<li>Since <span class="arithmatex">\(P_{\text{eff}}=P_{03}\otimes P_{12}\)</span> and <span class="arithmatex">\(\mathcal{S}_{\text{target}}\)</span> factorizes as above, this becomes</li>
</ul>
<div class="arithmatex">\[
F(p) = \Pr\big(P_{03}\in\{II,XX,YY,ZZ\}\big)\cdot \Pr\big(P_{12}\in\{II,XX,YY,ZZ\}\big).
\]</div>
<ul>
<li>Probability for one noisy CNOT to yield a “good” pair:</li>
<li>For a two-qubit depolarizing channel with error rate <span class="arithmatex">\(p\)</span>:</li>
</ul>
<div class="arithmatex">\[
\Pr(P=II) = 1-p,\quad \Pr(P=Q\neq II)=\frac{p}{15}.
\]</div>
<ul>
<li>The “good” set is <span class="arithmatex">\(\{II,XX,YY,ZZ\}\)</span>, which contains <span class="arithmatex">\(II\)</span> and 3 specific non-identity Paulis. Hence for one channel,</li>
</ul>
<div class="arithmatex">\[
\Pr(\text{good}) = (1-p) + 3\frac{p}{15} = 1 - \frac{4}{5}p.
\]</div>
<ul>
<li>Combine the two independent channels:</li>
</ul>
<div class="arithmatex">\[
F(p) = \left(1-\frac{4}{5}p\right)^2 = 1 - \frac{8}{5}p + \frac{16}{25}p^2.
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All equations are presented above using LaTeX.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Qubits labeled 0–3; logical qubits A,B; stabilizers and logical operators as provided.</li>
<li>Only two-qubit CNOT gates are noisy per the stated depolarizing model; single-qubit H gates are ideal.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = (1 - 4p/5)^2 = 1 - (8/5)p + (16/25)p^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Circuit and noise model</li>
<li>The only noisy operations are the two CNOTs. Right after each CNOT, a two-qubit depolarizing channel acts on that CNOT’s two qubits:<ul>
<li>after CNOT21: an error <span class="arithmatex">\(P_{12}\)</span> on qubits <span class="arithmatex">\((1,2)\)</span>,</li>
<li>after CNOT03: an error <span class="arithmatex">\(P_{03}\)</span> on qubits <span class="arithmatex">\((0,3)\)</span>.</li>
</ul>
</li>
<li>Each error is a Pauli on its two qubits: <span class="arithmatex">\(P\in\{II, IX,\dots, ZZ\}\)</span> with</li>
</ul>
<div class="arithmatex">\[
\Pr(P=II)=1-p,\qquad \Pr(P=Q\neq II)=\frac{p}{15}.
\]</div>
<ul>
<li>The subsequent ideal gates act on disjoint qubits, so the effective end-of-circuit error is</li>
</ul>
<div class="arithmatex">\[
E = P_{03}\otimes P_{12},
\]</div>
<div class="codehilite"><pre><span></span><code>with $P_{03}$ and $P_{12}$ independent.
</code></pre></div>

<ul>
<li>Target logical state and its physical stabilizer</li>
<li>The code stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>.</li>
<li>For the logical Bell state <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span>,</li>
</ul>
<div class="arithmatex">\[
X_A X_B = (XIXI)(XXII) = IXXI,\qquad Z_A Z_B = (ZZII)(ZIZI) = IZZI.
\]</div>
<ul>
<li>Hence the physical 4-qubit target state is the unique stabilizer state with generators</li>
</ul>
<div class="arithmatex">\[
\langle\, XXXX,\; ZZZZ,\; IXXI,\; IZZI \,\rangle.
\]</div>
<ul>
<li>Restricted to the disjoint pairs (0,3) and (1,2), this is exactly the product of two Bell pairs:</li>
</ul>
<div class="arithmatex">\[
\{II,XX,YY,ZZ\}_{03}\ \times\ \{II,XX,YY,ZZ\}_{12}.
\]</div>
<ul>
<li>Post-selection condition (detectable vs. undetectable)</li>
<li>We post-select on “no detectable error,” i.e., on errors <span class="arithmatex">\(E\)</span> that commute with both <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>.</li>
<li>For a two-qubit Pauli <span class="arithmatex">\(P\)</span> on a pair, define the commutation signatures</li>
</ul>
<div class="arithmatex">\[
s_X(P)=\pm1 \text{ for } [P,XX]=0\text{ or }\{P,XX\}=0,\qquad s_Z(P)=\pm1 \text{ for } [P,ZZ]=0\text{ or }\{P,ZZ\}=0.
\]</div>
<ul>
<li>For the full error <span class="arithmatex">\(E=P_{03}\otimes P_{12}\)</span>, we have</li>
</ul>
<div class="arithmatex">\[
s_X(E)=s_X(P_{03})\,s_X(P_{12}),\qquad s_Z(E)=s_Z(P_{03})\,s_Z(P_{12}).
\]</div>
<ul>
<li>Post-selection acceptance requires</li>
</ul>
<div class="arithmatex">\[
s_X(E)=+1,\quad s_Z(E)=+1\quad\Longleftrightarrow\quad s_X(P_{03})=s_X(P_{12})\text{ and } s_Z(P_{03})=s_Z(P_{12}).
\]</div>
<div class="codehilite"><pre><span></span><code>Thus $P_{03}$ and $P_{12}$ must lie in the same signature class.
</code></pre></div>

<ul>
<li>Classifying two-qubit Paulis by signature</li>
<li>The 16 two-qubit Paulis on a pair split into four classes by <span class="arithmatex">\((s_X,s_Z)\in\{(+,+),(+,-),(-,+),(-,-)\}\)</span>, with exactly 4 Paulis per class.</li>
<li>The <span class="arithmatex">\((+,+)\)</span> class is <span class="arithmatex">\(\{II,XX,YY,ZZ\}\)</span>; the other three classes each contain 4 non-identity Paulis.</li>
<li>Under the depolarizing model, the per-pair class probabilities are</li>
</ul>
<div class="arithmatex">\[
w_0:=\Pr\big((+,+)\big)=(1-p)+3\frac{p}{15}=1-\frac{4}{5}p,
\]</div>
<div class="arithmatex">\[
      w_2=\Pr\big((-,+)\big)=\frac{4}{15}p,\quad
\]</div>
<ul>
<li>Acceptance probability (yield)</li>
<li>We accept iff the two independent draws <span class="arithmatex">\(P_{03}\)</span> and <span class="arithmatex">\(P_{12}\)</span> fall in the same class:</li>
</ul>
<div class="arithmatex">\[
      = \left(1-\frac{4}{5}p\right)^2 + 3\left(\frac{4}{15}p\right)^2
\]</div>
<ul>
<li>Logical fidelity conditioned on acceptance</li>
<li>Within the accepted set, the final logical 2-qubit state matches the target Bell state iff <span class="arithmatex">\(E\)</span> fixes the target physical state, i.e., <span class="arithmatex">\(E\)</span> lies in its stabilizer. From above, this requires</li>
</ul>
<div class="arithmatex">\[
P_{03}\in\{II,XX,YY,ZZ\},\quad P_{12}\in\{II,XX,YY,ZZ\},
\]</div>
<div class="codehilite"><pre><span></span><code>which occurs with probability $w_0^2 = \left(1-\frac{4}{5}p\right)^2$.
</code></pre></div>

<ul>
<li>Any other accepted error is an undetectable logical Pauli (e.g., <span class="arithmatex">\(X_B\)</span>, <span class="arithmatex">\(Z_A\)</span>, or <span class="arithmatex">\(Y_A Y_B\)</span> up to stabilizers) that maps the target Bell state to an orthogonal Bell state, yielding zero overlap.</li>
<li>Therefore the conditional logical state fidelity is</li>
</ul>
<div class="arithmatex">\[
      = \frac{\Pr(E\in \text{stabilizer of target})}{\Pr(\text{accepted})}
      = \frac{\left(1-\frac{4}{5}p\right)^2}{\left(1-\frac{4}{5}p\right)^2 + 3\left(\frac{4}{15}p\right)^2}
\]</div>
<ul>
<li>Small-<span class="arithmatex">\(p\)</span> expansion:</li>
</ul>
<div class="arithmatex">\[
F_{\text{logical}}(p)=1-\frac{16}{75}p^2+O(p^3),
\]</div>
<div class="codehilite"><pre><span></span><code>i.e., all first-order logical errors are detected and discarded.
</code></pre></div>

<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All expressions are typeset in LaTeX above.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Qubits are labeled 0–3; logical qubits A,B as given.</li>
<li>Depolarizing noise only on the two CNOTs; Hadamards are ideal.</li>
<li>Post-selection keeps only errors commuting with <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>.</li>
</ul>
<ol start="4">
<li>Final Answer:
F_logical(p) = [(1 - 4p/5)^2] / [(1 - 4p/5)^2 + 3(4p/15)^2] = [1 - (8/5)p + (16/25)p^2] / [1 - (8/5)p + (64/75)p^2].</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Circuit, noise model, and acceptance</li>
<li>Data qubits are 0–3; ancilla is 4. The (right-to-left) circuit is</li>
</ul>
<div class="arithmatex">\[
H_1 \;\to\; CNOT_{12} \;\to\; CNOT_{10} \;\to\; CNOT_{23} \;\to\; CNOT_{34}\;\to\; CNOT_{04}\;\to\; M_4,
\]</div>
<div class="codehilite"><pre><span></span><code><span class="nx">with</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">two</span><span class="o">-</span><span class="nx">qubit</span><span class="w"> </span><span class="nx">depolarizing</span><span class="w"> </span><span class="nx">error</span><span class="w"> </span><span class="nx">after</span><span class="w"> </span><span class="nx">each</span><span class="w"> </span><span class="nx">CNOT</span><span class="p">:</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">probability</span><span class="w"> </span><span class="err">$</span><span class="mi">1</span><span class="o">-</span><span class="nx">p</span><span class="err">$</span><span class="w"> </span><span class="nx">no</span><span class="w"> </span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">probability</span><span class="w"> </span><span class="err">$</span><span class="nx">p</span><span class="err">$</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">uniformly</span><span class="w"> </span><span class="nx">random</span><span class="w"> </span><span class="nx">non</span><span class="o">-</span><span class="nx">identity</span><span class="w"> </span><span class="nx">two</span><span class="o">-</span><span class="nx">qubit</span><span class="w"> </span><span class="nx">Pauli</span><span class="w"> </span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="nx">choices</span><span class="p">,</span><span class="w"> </span><span class="nx">each</span><span class="w"> </span><span class="err">$</span><span class="nx">p</span><span class="o">/</span><span class="mi">15</span><span class="err">$</span><span class="p">).</span>
</code></pre></div>

<ul>
<li>
<p>Post-selection/acceptance: keep runs with ancilla outcome 0 and with no code-detectable error on the data (i.e., the final data Pauli error commutes with both stabilizers <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>).</p>
</li>
<li>
<p>Target encoded state and its stabilizer</p>
</li>
<li>The target is the encoded logical two-qubit state <span class="arithmatex">\(\lvert 00\rangle_{AB}\)</span> in the [[4,2,2]] code, whose stabilizer we may take as</li>
</ul>
<div class="arithmatex">\[
\mathcal{S}_{\text{tgt}}=\langle XXXX,\; ZZZZ,\; Z_A:=ZZII,\; Z_B:=ZIZI\rangle.
\]</div>
<ul>
<li>Equivalently, the four commuting checks we will use are</li>
</ul>
<div class="arithmatex">\[
S_X:=XXXX, \quad S_Z:=ZZZZ,\quad Z_A=Z_0Z_1,\quad Z_B=Z_0Z_2.
\]</div>
<ul>
<li>
<p>The ancilla sequence <span class="arithmatex">\(CNOT_{34},CNOT_{04}\)</span> followed by <span class="arithmatex">\(M_4\)</span> in the <span class="arithmatex">\(Z\)</span> basis measures <span class="arithmatex">\(Z_0Z_3\)</span>; for the ideal target state, the outcome is +1 (we keep outcome “0”).</p>
</li>
<li>
<p>Where leading-order logical errors can come from</p>
</li>
<li>Any single two-qubit fault that is accepted (i.e., passes the two code checks and the ancilla parity) must act as an element of the target stabilizer <span class="arithmatex">\(\mathcal{S}_{\text{tgt}}\)</span>, hence does not reduce fidelity (no <span class="arithmatex">\(O(p)\)</span> infidelity). Therefore the first nontrivial contribution to logical infidelity is <span class="arithmatex">\(O(p^2)\)</span>, from two-fault combinations among the three “data-building” CNOTs: <span class="arithmatex">\(CNOT_{12}\)</span>, <span class="arithmatex">\(CNOT_{10}\)</span>, <span class="arithmatex">\(CNOT_{23}\)</span>.</li>
<li>
<p>Faults on the ancilla CNOTs do not affect the data (they cannot propagate back to controls), and while they can flip the ancilla outcome, they cannot by themselves induce data logical errors; mixed pairs (one data, one ancilla fault) cannot produce an undetected logical error after code post-selection.</p>
</li>
<li>
<p>Signature method: how an error transforms the four checks</p>
</li>
<li>For any final data Pauli error <span class="arithmatex">\(E\)</span>, define its commutation signatures with the four checks as</li>
</ul>
<div class="arithmatex">\[
s_X(E)=\pm1\ \text{for } [E,S_X]=0 \text{ or } \{E,S_X\}=0,
\]</div>
<div class="arithmatex">\[
s_Z(E)=\pm1\ \text{for } [E,S_Z]=0 \text{ or } \{E,S_Z\}=0,
\]</div>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Acceptance constraints:<ul>
<li>code post-selection requires s_X(E)=+1 and s_Z(E)=+1,</li>
<li>ancilla parity +1 (outcome 0) requires <span class="arithmatex">\(s_{Z_0Z_3}(E)=+1\)</span>. Noting <span class="arithmatex">\(Z_0Z_3 = S_Z \cdot Z_A \cdot Z_B\)</span>, we have</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
s_{Z_0Z_3}(E)=s_Z(E)\,s_A(E)\,s_B(E).
\]</div>
<div class="codehilite"><pre><span></span><code>  With $s_Z(E)=+1$ from code post-selection, this reduces to $s_A(E)\,s_B(E)=+1$.
</code></pre></div>

<ul>
<li>
<p>Logical correctness vs. logical error:</p>
<ul>
<li>The target state is stabilized by <span class="arithmatex">\(Z_A\)</span> and <span class="arithmatex">\(Z_B\)</span>, so it is preserved iff <span class="arithmatex">\(s_A(E)=+1\)</span> and <span class="arithmatex">\(s_B(E)=+1\)</span>.</li>
<li>Among accepted events (where <span class="arithmatex">\(s_A(E)\,s_B(E)=+1\)</span>), the only way to be wrong is <span class="arithmatex">\(s_A(E)=s_B(E)=-1\)</span> (this corresponds to a logical <span class="arithmatex">\(X_A X_B\)</span>-type error up to stabilizers).</li>
</ul>
</li>
<li>
<p>Per-gate signature distribution for a single fault</p>
</li>
<li>We place a two-qubit Pauli error immediately after a given CNOT and propagate it forward through any later data CNOTs to the end (ancilla CNOTs can be ignored for data signatures). For each of the three data CNOTs we compute the map from the 15 non-identity two-qubit Paulis to the signature vector</li>
</ul>
<div class="arithmatex">\[
v=(s_X, s_Z, s_A, s_B)\in\{\pm1\}^4.
\]</div>
<ul>
<li>Location L1: after <span class="arithmatex">\(CNOT_{12}\)</span> (on qubits 1,2), only later CNOTs are <span class="arithmatex">\(CNOT_{10}\)</span> and <span class="arithmatex">\(CNOT_{23}\)</span>. A two-qubit Pauli <span class="arithmatex">\(P_1\otimes P_2\)</span> on (1,2) with bits</li>
</ul>
<div class="arithmatex">\[
x_k=\mathbf{1}[P_k\in\{X,Y\}],\quad z_k=\mathbf{1}[P_k\in\{Z,Y\}],\quad k=1,2,
\]</div>
<div class="codehilite"><pre><span></span><code>yields the final signatures
</code></pre></div>

<div class="arithmatex">\[
s_X=(-1)^{z_1+z_2},\quad s_Z=+1,\quad s_A=+1,\quad s_B=(-1)^{x_1+x_2}.
\]</div>
<div class="codehilite"><pre><span></span><code>Thus $v$ depends only on the parities $(z_1+z_2)\bmod2$ and $(x_1+x_2)\bmod2$. Counting over the 15 non-identity $P_1\otimes P_2$ gives:
<span class="k">-</span> $(+,+,+,+)$: 3
<span class="k">-</span> $(-,+,+,+)$: 4
<span class="k">-</span> $(+,+,+,-)$: 4
<span class="k">-</span> $(-,+,+,-)$: 4
</code></pre></div>

<ul>
<li>Location L2: after <span class="arithmatex">\(CNOT_{10}\)</span> (on qubits 1,0), with no later data CNOT touching these qubits:</li>
</ul>
<div class="arithmatex">\[
s_X=(-1)^{z_1+z_0},\quad s_Z=(-1)^{x_1+x_0},\quad s_A=(-1)^{x_1+x_0},\quad s_B=(-1)^{x_0}.
\]</div>
<div class="codehilite"><pre><span></span><code>Counting over 15 non-identity pairs yields:
- $(+,-,-,+)$: 2,  $(-,-,-,+)$: 2,  $(-,+,+,+)$: 2,  $(+,+,+,+)$: 1,
- $(+,-,-,-)$: 2,  $(+,+,+,-)$: 2,  $(-,+,+,-)$: 2,  $(-,-,-,-)$: 2.
</code></pre></div>

<ul>
<li>Location L3: after <span class="arithmatex">\(CNOT_{23}\)</span> (on qubits 2,3), with no later data CNOT at all:</li>
</ul>
<div class="arithmatex">\[
s_X=(-1)^{z_2+z_3},\quad s_Z=(-1)^{x_2+x_3},\quad s_A=+1,\quad s_B=(-1)^{x_2}.
\]</div>
<div class="codehilite"><pre><span></span><code>Counting over 15 non-identity pairs yields:
- $(+,-,+,+)$: 1,  $(-,-,+,+)$: 2,  $(-,+,+,+)$: 2,  $(+,+,+,+)$: 2,
- $(+,-,+,-)$: 2,  $(+,+,+,-)$: 2,  $(-,+,+,-)$: 2,  $(-,-,+,-)$: 2.
</code></pre></div>

<ul>
<li>No first-order logical error</li>
<li>
<p>For a single fault to be accepted it must satisfy <span class="arithmatex">\(s_X=+1\)</span>, <span class="arithmatex">\(s_Z=+1\)</span>, and <span class="arithmatex">\(s_A s_B=+1\)</span>. From the above distributions, all such single faults, if any, lie in the target stabilizer (e.g., <span class="arithmatex">\(Z_0Z_1\)</span>, <span class="arithmatex">\(Z_2Z_3\)</span>, or <span class="arithmatex">\(XXXX\)</span>), hence they contribute no <span class="arithmatex">\(O(p)\)</span> loss of fidelity.</p>
</li>
<li>
<p>Counting the <span class="arithmatex">\(O(p^2)\)</span> accepted logical errors</p>
</li>
<li>For two independent faults at locations <span class="arithmatex">\(g\)</span> and <span class="arithmatex">\(h\)</span>, the total signature is the componentwise product of the two signature vectors: <span class="arithmatex">\(v_{gh}=v_g\cdot v_h\)</span>.</li>
<li>An accepted logical error (to second order) requires:</li>
</ul>
<div class="arithmatex">\[
s_X^{(g)}s_X^{(h)}=+1,\quad s_Z^{(g)}s_Z^{(h)}=+1,\quad s_A^{(g)}s_A^{(h)}=-1,\quad s_B^{(g)}s_B^{(h)}=-1.
\]</div>
<div class="codehilite"><pre><span></span><code>That is, the $s_X$ and $s_Z$ signs must match between the two faults, while $s_A$ and $s_B$ must be opposite.
</code></pre></div>

<ul>
<li>Using the per-location distributions above, we count for each unordered pair of data CNOTs:<ul>
<li>Pair (L1,L2): impossible, because L1 has <span class="arithmatex">\(s_A=+1\)</span> always, while acceptance requires <span class="arithmatex">\(s_Z^{(1)}s_Z^{(2)}=+1\)</span>, which with L1’s <span class="arithmatex">\(s_Z=+1\)</span> would force <span class="arithmatex">\(s_Z^{(2)}=+1\)</span>, but then <span class="arithmatex">\(s_A^{(2)}=s_Z^{(2)}=+1\)</span> for L2 (since <span class="arithmatex">\(s_A=s_Z\)</span> at L2), contradicting <span class="arithmatex">\(s_A^{(1)}s_A^{(2)}=-1\)</span>. So 0 combinations.</li>
<li>Pair (L1,L3): impossible, because both L1 and L3 have <span class="arithmatex">\(s_A=+1\)</span>, hence <span class="arithmatex">\(s_A^{(1)}s_A^{(2)}=+1\)</span> cannot equal −1. So 0 combinations.</li>
<li>Pair (L2,L3): feasible. Imposing the four constraints and summing over the tabulated categories gives</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
N_{\text{bad}}(L2,L3)=14.
\]</div>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="o">(</span><span class="nt">Details</span><span class="o">:</span><span class="w"> </span><span class="nt">from</span><span class="w"> </span><span class="nt">L2</span><span class="w"> </span><span class="nt">we</span><span class="w"> </span><span class="nt">must</span><span class="w"> </span><span class="nt">choose</span><span class="w"> </span><span class="nt">categories</span><span class="w"> </span><span class="nt">with</span><span class="w"> </span><span class="o">$</span><span class="nt">s_A</span><span class="o">^</span><span class="p">{</span><span class="err">(2)</span><span class="p">}</span><span class="o">=</span><span class="nt">-1</span><span class="o">$</span><span class="w"> </span><span class="o">(</span><span class="nt">equivalently</span><span class="w"> </span><span class="o">$</span><span class="nt">s_Z</span><span class="o">^</span><span class="p">{</span><span class="err">(2)</span><span class="p">}</span><span class="o">=</span><span class="nt">-1</span><span class="o">$),</span><span class="w"> </span><span class="nt">and</span><span class="w"> </span><span class="nt">from</span><span class="w"> </span><span class="nt">L3</span><span class="w"> </span><span class="nt">we</span><span class="w"> </span><span class="nt">must</span><span class="w"> </span><span class="nt">choose</span><span class="w"> </span><span class="nt">categories</span><span class="w"> </span><span class="nt">with</span><span class="w"> </span><span class="o">$</span><span class="nt">s_Z</span><span class="o">^</span><span class="p">{</span><span class="err">(3)</span><span class="p">}</span><span class="o">=</span><span class="nt">-1</span><span class="o">$;</span><span class="w"> </span><span class="nt">then</span><span class="w"> </span><span class="nt">require</span><span class="w"> </span><span class="nt">equal</span><span class="w"> </span><span class="o">$</span><span class="nt">s_X</span><span class="o">$,</span><span class="w"> </span><span class="nt">and</span><span class="w"> </span><span class="nt">opposite</span><span class="w"> </span><span class="o">$</span><span class="nt">s_B</span><span class="o">$</span><span class="w"> </span><span class="nt">signs</span><span class="o">.</span><span class="w"> </span><span class="nt">The</span><span class="w"> </span><span class="nt">count</span><span class="w"> </span><span class="nt">by</span><span class="w"> </span><span class="nt">matching</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">listed</span><span class="w"> </span><span class="nt">categories</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">14</span><span class="o">.)</span>
</code></pre></div>

<ul>
<li>Therefore, among the <span class="arithmatex">\(15\times15=225\)</span> ordered pairs of non-identity Pauli faults at a given unordered gate pair, only the (L2,L3) pair yields accepted logical errors, with 14 such combinations. There is only one such unordered pair among the three data CNOTs, so the total second-order probability of an accepted logical error is</li>
</ul>
<div class="arithmatex">\[
P_{\text{bad}} = \frac{14}{225}\,p^2 + O(p^3).
\]</div>
<ul>
<li>Logical fidelity to second order</li>
<li>The overall acceptance probability is <span class="arithmatex">\(1-O(p)\)</span>, so normalizing by acceptance affects the <span class="arithmatex">\(p^2\)</span> coefficient only at <span class="arithmatex">\(O(p^3)\)</span>. Hence the logical state fidelity conditioned on acceptance is</li>
</ul>
<div class="arithmatex">\[
F_{\text{logical}}(p) = 1 - \frac{14}{225}\,p^2 + O(p^3).
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<p>All relevant formulas are expressed using LaTeX above.</p>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Only two-qubit CNOTs are noisy with a two-qubit depolarizing channel at rate <span class="arithmatex">\(p\)</span>; <span class="arithmatex">\(H\)</span> and <span class="arithmatex">\(M\)</span> are ideal.</li>
<li>Qubit labels and logical operators follow the problem statement.</li>
</ul>
<ol start="4">
<li>Final Answer:
F_logical(p) = 1 - (14/225) p^2 + O(p^3).</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">225</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.647666
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>