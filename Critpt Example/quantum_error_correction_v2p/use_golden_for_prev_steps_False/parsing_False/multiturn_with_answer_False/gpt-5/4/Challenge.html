<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "â–¶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">ðŸŒ“</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, or mathematical identities.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Code and target state</li>
<li>[[4,2,2]] code on physical qubits 0â€“3 with stabilizers S = âŸ¨XXXX, ZZZZâŸ©.</li>
<li>Logical operators (one convenient choice): X_A = X I X I, X_B = X X I I, Z_A = Z Z I I, Z_B = Z I Z I.</li>
<li>
<p>The prepared target logical state is |00âŸ©_AB, i.e., the joint +1 eigenspace of Z_A, Z_B and of the stabilizers. In the computational basis this is the 4-qubit GHZ state (|0000âŸ©+|1111âŸ©)/âˆš2 on qubits 0â€“3.</p>
</li>
<li>
<p>Circuit and noise model</p>
</li>
<li>Circuit (applied right-to-left): H_1, CNOT_12, CNOT_10, CNOT_23, CNOT_34, CNOT_04, then measure Z on ancilla 4 and post-select the outcome 0.</li>
<li>After each CNOT a two-qubit depolarizing fault acts on that gateâ€™s two qubits: with probability p it applies one of the 15 non-identity 2-qubit Paulis uniformly (p/15 each), and with probability 1âˆ’p the identity. There are 5 such noisy CNOTs.</li>
<li>
<p>Post-selection: accept only if the ancilla measurement is 0 and the final 4-qubit state is in the code space (i.e., it passes both stabilizer checks XXXX=+1 and ZZZZ=+1). Equivalently, we discard all detectable faults.</p>
</li>
<li>
<p>What the ancilla measures</p>
</li>
<li>The last two CNOTs implement a non-destructive measurement of Z_0 Z_3 with an ancilla initially in |0âŸ©:<ul>
<li>Conjugating Z_4 by CNOT_34 then CNOT_04 maps Z_4 â†’ Z_0 Z_3 Z_4. Since the ancilla starts in +1 eigenstate of Z_4, measuring Z_4 at the end is equivalently a measurement of Z_0 Z_3 on the data.</li>
</ul>
</li>
<li>
<p>Thus acceptance additionally enforces Z_0 Z_3 = +1, besides XXXX=+1 and ZZZZ=+1.</p>
</li>
<li>
<p>Pauli propagation and acceptance conditions (parity formulation)</p>
</li>
<li>Work in the Pauli frame. For each error location j (after one of the five CNOTs), propagate any 2-qubit Pauli error to just before the final ancilla measurement. Represent a Pauli by its X- and Z-masks on the five qubits.</li>
<li>For a final Pauli P on qubits 0â€“4 to be accepted:<ul>
<li>It must commute with ZZZZ: the number of X or Y on qubits 0â€“3 is even. Define w = (x_0 âŠ• x_1 âŠ• x_2 âŠ• x_3) = 0.</li>
<li>It must commute with XXXX: the number of Z or Y on qubits 0â€“3 is even. Define y = (z_0 âŠ• z_1 âŠ• z_2 âŠ• z_3) = 0.</li>
<li>It must not flip the ancilla Z outcome: no X_4 or Y_4 is present, i.e., x_4 = 0. Z_4 is allowed.</li>
</ul>
</li>
<li>
<p>Logical bit-flip content is read off from commutation with logical Zâ€™s:</p>
<ul>
<li>Define v_A = x_0 âŠ• x_1 (anticommutes with Z_A iff v_A=1), v_B = x_0 âŠ• x_2 (anticommutes with Z_B iff v_B=1).</li>
<li>A nontrivial logical bit flip (harmful for fidelity to |00âŸ©) occurs iff (v_A, v_B) â‰  (0,0). Logical Zâ€™s alone (any Z_A^a Z_B^b) leave |00âŸ© invariant and do not reduce state fidelity.</li>
</ul>
</li>
<li>
<p>Single-fault analysis</p>
</li>
<li>
<p>For a single two-qubit fault to pass all acceptance checks, it must have w=0, y=0, x_4=0. A direct check (via propagation rules below) shows the only such single-fault images have v_A=v_B=0. Hence no accepted single-fault can cause a logical error. Therefore the logical infidelity is O(p^2).</p>
</li>
<li>
<p>Propagation rules through the tail of the circuit</p>
</li>
<li>We need how X and Z errors transform forward through the subsequent CNOTs:<ul>
<li>For CNOT câ†’t: X_câ†’X_c X_t, Z_câ†’Z_c, X_tâ†’X_t, Z_tâ†’Z_c Z_t; and Y accordingly by linearity.</li>
</ul>
</li>
<li>Let the five error locations be after the gates: CNOT_12, CNOT_10, CNOT_23, CNOT_34, CNOT_04. For each location j and each of the two qubits of that CNOT, propagate X and Z to the end. Denote the X-bit on qubit i by x_i and Z-bit by z_i:<ul>
<li>After CNOT_12:</li>
<li>X_1 â†’ X_1 X_0 X_4, Z_1 â†’ Z_1</li>
<li>X_2 â†’ X_2 X_3 X_4, Z_2 â†’ Z_2</li>
<li>After CNOT_10:</li>
<li>X_1 â†’ X_1, Z_1 â†’ Z_1</li>
<li>X_0 â†’ X_0 X_4, Z_0 â†’ Z_0</li>
<li>After CNOT_23:</li>
<li>X_2 â†’ X_2, Z_2 â†’ Z_2</li>
<li>X_3 â†’ X_3 X_4, Z_3 â†’ Z_3</li>
<li>After CNOT_34:</li>
<li>X_3 â†’ X_3, Z_3 â†’ Z_3</li>
<li>X_4 â†’ X_4, Z_4 â†’ Z_0 Z_4</li>
<li>After CNOT_04:</li>
<li>X_0 â†’ X_0, Z_0 â†’ Z_0</li>
<li>X_4 â†’ X_4, Z_4 â†’ Z_4</li>
</ul>
</li>
<li>
<p>Y maps linearly as XâŠ•Z in the binary vector representation.</p>
</li>
<li>
<p>Categorizing each locationâ€™s 15 faults</p>
</li>
<li>Each two-qubit Pauli error at a location j is the XOR-sum of one of {X,Z,Y} on the control and one of {X,Z,Y} on the target (excluding both identities). Using the above propagation, for each location j we tabulate, over its 15 faults, the resulting tuple<ul>
<li>(w, x_4, y; v_A, v_B) âˆˆ {0,1}^3 Ã— {0,1}^2
  where w = x_0âŠ•x_1âŠ•x_2âŠ•x_3, y = z_0âŠ•z_1âŠ•z_2âŠ•z_3, v_A = x_0âŠ•x_1, v_B = x_0âŠ•x_2.</li>
</ul>
</li>
<li>
<p>The full 15-element distributions per location (counting multiplicities) are:</p>
<ul>
<li>After CNOT_12:</li>
<li>(0,1,0; 0,1): 4, (0,1,1; 0,1): 4, (0,0,1; 0,0): 2, (0,0,0; 0,0): 3.</li>
<li>Note: v â‰  (0,0) only equals (0,1) here.</li>
<li>After CNOT_10:</li>
<li>(1,0,0; 1,0): 2, (1,0,1; 1,0): 2, (0,0,1; 0,0): 2,
    (1,1,0; 1,1): 2, (1,1,1; 1,1): 2, (0,1,0; 0,1): 2, (0,1,1; 0,1): 2, (0,0,0; 0,0): 1.</li>
<li>After CNOT_23:</li>
<li>Same (w,x_4,y) multiplicities as CNOT_10 but with v mapping:</li>
<li>(1,0,0; 0,1): 2, (1,0,1; 0,1): 2, (0,0,1; 0,0): 2,
    (1,1,0; 0,0): 2, (1,1,1; 0,0): 2, (0,1,0; 0,1): 2, (0,1,1; 0,1): 2, (0,0,0; 0,0): 1.</li>
<li>After CNOT_34:</li>
<li>Same (w,x_4,y) multiplicities as CNOT_10, but v always (0,0).</li>
<li>After CNOT_04:</li>
<li>(1,0,0; 1,1): 2, (1,0,1; 1,1): 2, (0,0,1; 0,0): 2,
    (0,1,0; 0,0): 2, (0,0,0; 0,0): 1, (1,1,0; 1,1): 2, (1,1,1; 1,1): 2, (0,1,1; 0,0): 2.</li>
</ul>
</li>
<li>
<p>Accepted and harmful pairs at O(p^2)</p>
</li>
<li>With two faults at distinct locations j&lt;k, the final parity tuple is the XOR-sum of the two locationsâ€™ tuples:<ul>
<li>Acceptance requires matching (w, x_4, y): i.e., (w_j, x_{4,j}, y_j) = (w_k, x_{4,k}, y_k) so that their XOR vanishes.</li>
<li>The output logical bit flip vector is v_total = v_j âŠ• v_k. Harmful iff v_total â‰  (0,0).</li>
</ul>
</li>
<li>Therefore, for a given pair of locations (j,k), the number of accepted harmful pairs equals<ul>
<li>sum over all triples t=(w,x_4,y): N_j(t, v_jâ‰ 0) Ã— N_k(t, v_k=0) + N_j(t, v_j=0) Ã— N_k(t, v_kâ‰ 0)
  plus the pairs where both have nonzero v and give vâŠ•vâ‰ 0 (if that occurs).</li>
</ul>
</li>
<li>Carrying out this counting using the above per-location tables yields, for the 10 unordered pairs of locations (in the order (12,10), (12,23), (12,34), (12,04), (10,23), (10,34), (10,04), (23,34), (23,04), (34,04)):<ul>
<li>Accepted harmful counts: 0, 0, 16, 16, 16, 24, 16, 16, 24, 16 respectively.</li>
</ul>
</li>
<li>
<p>Summing gives a total of 144 accepted harmful two-fault patterns out of 5â‹…4/2 Ã— 15Ã—15 = 10 Ã— 225 possibilities.</p>
</li>
<li>
<p>Logical fidelity to second order in p</p>
</li>
<li>Each specific two-fault pattern has probability (p/15)^2 + O(p^3). By the above, the total probability of an accepted harmful event is</li>
</ul>
<div class="arithmatex">\[
P_{\text{harm, acc}} = 144 \left(\frac{p}{15}\right)^2 + O(p^3) = \frac{144}{225} p^2 + O(p^3) = \frac{16}{25} p^2 + O(p^3).
\]</div>
<ul>
<li>Because all single faults are rejected (or harmless), and acceptance renormalization only changes the result at O(p^3), the conditional logical state fidelity of the post-selected output is</li>
</ul>
<div class="arithmatex">\[
F_{\text{logical}}(p) = 1 - P_{\text{harm, acc}} + O(p^3) = 1 - \frac{16}{25}\,p^2 + O(p^3).
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>Commutation/propagation under CNOT used:</li>
</ul>
<div class="arithmatex">\[
X_c \mapsto X_c X_t,\quad Z_c \mapsto Z_c,\quad X_t \mapsto X_t,\quad Z_t \mapsto Z_c Z_t.
\]</div>
<ul>
<li>Acceptance parities:</li>
</ul>
<div class="arithmatex">\[
w = x_0 \oplus x_1 \oplus x_2 \oplus x_3 = 0,\quad y = z_0 \oplus z_1 \oplus z_2 \oplus z_3 = 0,\quad x_4 = 0.
\]</div>
<ul>
<li>Logical bit-flip indicators:</li>
</ul>
<div class="arithmatex">\[
v_A = x_0 \oplus x_1,\qquad v_B = x_0 \oplus x_2.
\]</div>
<ul>
<li>Leading-order logical infidelity:</li>
</ul>
<div class="arithmatex">\[
1 - F_{\text{logical}}(p) = \frac{16}{25}\,p^2 + O(p^3).
\]</div>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Error rate p is the two-qubit gate error probability per CNOT, with a uniform two-qubit depolarizing channel following each CNOT.</li>
<li>We report the conditional logical state fidelity after post-selecting on the ancilla measuring |0âŸ© and on passing all detectable code checks (XXXX and ZZZZ).</li>
</ul>
<ol start="4">
<li>Final Answer:
F_logical(p) = 1 âˆ’ (16/25) p^2 + O(p^3).</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:08.786766
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>