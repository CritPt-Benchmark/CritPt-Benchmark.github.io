<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="c1"># We&#39;ll implement symplectic representation for Pauli strings on 5 qubits (0..3 data, 4 ancilla)</span>
<span class="c1"># Pauli string represented by two bit arrays x, z of length 5.</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Helper: construct Pauli from per-qubit char list like [&#39;I&#39;,&#39;X&#39;,&#39;Z&#39;,&#39;Y&#39;,&#39;I&#39;]</span>
<span class="n">pauli_char_to_bits</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">pauli_from_chars</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">zi</span> <span class="o">=</span> <span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xi</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zi</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">z</span>

<span class="c1"># CNOT conjugation on symplectic bits</span>
<span class="c1"># Conjugation: under CNOT(c-&gt;t): x_t ^= x_c ; z_c ^= z_t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_cnot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="c1"># x,z ints with bits over 5 qubits</span>
    <span class="c1"># compute bits</span>
    <span class="n">x_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="n">x_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="n">z_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="n">z_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="c1"># Update: x_t&#39; = x_t ^ x_c ; z_c&#39; = z_c ^ z_t</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="p">((</span><span class="n">x_t</span> <span class="o">^</span> <span class="p">(</span><span class="n">x_c</span><span class="p">))</span> <span class="o">^</span> <span class="n">x_t</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">t</span>  <span class="c1"># set bit t to x_t&#39;</span>
    <span class="n">z</span> <span class="o">^=</span> <span class="p">((</span><span class="n">z_c</span> <span class="o">^</span> <span class="p">(</span><span class="n">z_t</span><span class="p">))</span> <span class="o">^</span> <span class="n">z_c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">c</span>  <span class="c1"># set bit c to z_c&#39;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">z</span>

<span class="c1"># We&#39;ll prepare mapping for the local 2-qubit error applied on qubits (i,j) after a gate at position pos,</span>
<span class="c1"># propagated through the subsequent CNOTs to the end. We&#39;ll store 16 possibilities (including II) per position.</span>

<span class="c1"># Define the sequence of gates (control, target) in chronological order:</span>
<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="c1"># Define all 2-qubit Pauli types on a given pair (including II at index 0) in a fixed order list</span>
<span class="n">paulis_single</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">pauli_pairs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">paulis_single</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">paulis_single</span><span class="p">:</span>
        <span class="n">pauli_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="c1"># Index 0 corresponds to (&#39;I&#39;,&#39;I&#39;), the identity (no error); error model uses only the 15 non-identity ones.</span>

<span class="c1"># Precompute conjugated errors to end for each position and each local pauli pair.</span>
<span class="n">E_end</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of list: E_end[pos][pp_index] -&gt; (x,z)</span>
<span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
    <span class="c1"># Build mapping for this pos</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pauli_pairs</span><span class="p">:</span>
        <span class="c1"># Initialize x,z as identity</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># place local pauli on qubits c and t</span>
        <span class="n">xa</span><span class="p">,</span> <span class="n">za</span> <span class="o">=</span> <span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">xb</span><span class="p">,</span> <span class="n">zb</span> <span class="o">=</span> <span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xa</span><span class="p">:</span> <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">za</span><span class="p">:</span> <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xb</span><span class="p">:</span> <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zb</span><span class="p">:</span> <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># Propagate through subsequent CNOTs pos+1..end</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">c2</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">conj_cnot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>
        <span class="n">mapping</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="n">E_end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>

<span class="c1"># Now enumerate all patterns across 5 positions, each with 16 options; track k (#non-identity), acceptance and &#39;good&#39; classification.</span>

<span class="c1"># Stabilizer generators on data 0..3</span>
<span class="c1"># S1 = XXXX -&gt; x bits 0..3 set to 1, z all 0</span>
<span class="n">S1_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">S1_z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">S1_x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">q</span><span class="p">)</span>
<span class="c1"># S2 = ZZZZ -&gt; z bits 0..3 set to 1</span>
<span class="n">S2_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">S2_z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">S2_z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">q</span><span class="p">)</span>

<span class="c1"># Logical Z operators on data only</span>
<span class="c1"># Z_A = ZZII (on qubits 0 and 1)</span>
<span class="n">ZA_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ZA_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Z_B = ZIZI (on qubits 0 and 2)</span>
<span class="n">ZB_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ZB_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Function to check commutation: returns 0 if commute, 1 if anticommute.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">symp_comm</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="p">):</span>
    <span class="c1"># parity of x1·z2 + z1·x2 over all 5 qubits or 4 as appropriate</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">bin</span><span class="p">((</span><span class="n">x1</span> <span class="o">&amp;</span> <span class="n">z2</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">((</span><span class="n">z1</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>

<span class="c1"># We&#39;ll aggregate counts per k</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="n">counts_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">counts_good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>

<span class="c1"># Enumerate all patterns. To speed up, we can precompute arrays of (x,z,k) for each position option.</span>
<span class="c1"># For each pos, option index 0..15 has E_end bits; also whether it&#39;s identity (k contribution 0) or not (k contribution 1 for non-identity), but identity is index 0.</span>

<span class="n">pos_options</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">E_end</span><span class="p">[</span><span class="n">pos</span><span class="p">]):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">opts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">))</span>
    <span class="n">pos_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>

<span class="c1"># Now enumerate with nested loops (5 positions). Using iterative loops for speed.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_all</span><span class="p">():</span>
    <span class="n">counts_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
    <span class="n">counts_good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
    <span class="c1"># We&#39;ll use local variables for speed</span>
    <span class="n">options0</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">options1</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">options2</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">options3</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">options4</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">idx0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
        <span class="n">x0</span><span class="p">,</span><span class="n">z0</span><span class="p">,</span><span class="n">k0</span> <span class="o">=</span> <span class="n">options0</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
            <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">k1</span> <span class="o">=</span> <span class="n">options1</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">x01</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">^</span> <span class="n">x1</span>
            <span class="n">z01</span> <span class="o">=</span> <span class="n">z0</span> <span class="o">^</span> <span class="n">z1</span>
            <span class="n">k01</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">+</span> <span class="n">k1</span>
            <span class="k">for</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="p">,</span><span class="n">k2</span> <span class="o">=</span> <span class="n">options2</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
                <span class="n">x012</span> <span class="o">=</span> <span class="n">x01</span> <span class="o">^</span> <span class="n">x2</span>
                <span class="n">z012</span> <span class="o">=</span> <span class="n">z01</span> <span class="o">^</span> <span class="n">z2</span>
                <span class="n">k012</span> <span class="o">=</span> <span class="n">k01</span> <span class="o">+</span> <span class="n">k2</span>
                <span class="k">for</span> <span class="n">idx3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                    <span class="n">x3</span><span class="p">,</span><span class="n">z3</span><span class="p">,</span><span class="n">k3</span> <span class="o">=</span> <span class="n">options3</span><span class="p">[</span><span class="n">idx3</span><span class="p">]</span>
                    <span class="n">x0123</span> <span class="o">=</span> <span class="n">x012</span> <span class="o">^</span> <span class="n">x3</span>
                    <span class="n">z0123</span> <span class="o">=</span> <span class="n">z012</span> <span class="o">^</span> <span class="n">z3</span>
                    <span class="n">k0123</span> <span class="o">=</span> <span class="n">k012</span> <span class="o">+</span> <span class="n">k3</span>
                    <span class="k">for</span> <span class="n">idx4</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                        <span class="n">x4</span><span class="p">,</span><span class="n">z4</span><span class="p">,</span><span class="n">k4</span> <span class="o">=</span> <span class="n">options4</span><span class="p">[</span><span class="n">idx4</span><span class="p">]</span>
                        <span class="n">x_all</span> <span class="o">=</span> <span class="n">x0123</span> <span class="o">^</span> <span class="n">x4</span>
                        <span class="n">z_all</span> <span class="o">=</span> <span class="n">z0123</span> <span class="o">^</span> <span class="n">z4</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">k0123</span> <span class="o">+</span> <span class="n">k4</span>
                        <span class="c1"># Acceptance conditions:</span>
                        <span class="c1"># anc acceptance: x bit at qubit 4 must be 0</span>
                        <span class="n">anc_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_all</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">anc_x</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="c1"># data acceptance: commute with S1 and S2</span>
                        <span class="c1"># Compute comm on data only; but our comm function uses all bits; we can mask down to 0..3</span>
                        <span class="n">mask_data</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># bits 0..3 set</span>
                        <span class="n">x_data</span> <span class="o">=</span> <span class="n">x_all</span> <span class="o">&amp;</span> <span class="n">mask_data</span>
                        <span class="n">z_data</span> <span class="o">=</span> <span class="n">z_all</span> <span class="o">&amp;</span> <span class="n">mask_data</span>
                        <span class="c1"># comm with S1: x_data dot z_S1 + z_data dot x_S1 -&gt; reduces to parity of bits of z_data since z_S1=0, x_S1=1111</span>
                        <span class="c1"># We&#39;ll compute using symp_comm with bits restricted to data</span>
                        <span class="k">if</span> <span class="p">((</span><span class="nb">bin</span><span class="p">(</span><span class="n">z_data</span> <span class="o">&amp;</span> <span class="n">S1_x</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># anticomm with S1</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="p">((</span><span class="nb">bin</span><span class="p">(</span><span class="n">x_data</span> <span class="o">&amp;</span> <span class="n">S2_z</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># anticomm with S2</span>
                            <span class="k">continue</span>
                        <span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c1"># &#39;good&#39; if commutes with ZA and ZB: i.e., x_data parity on qubits {0,1} and {0,2} even.</span>
                        <span class="c1"># We&#39;ll compute via symp_comm on data bits</span>
                        <span class="c1"># For Z_A: zA has z bits on 0 and 1; xA=0</span>
                        <span class="c1"># Commute if x_data parity on {0,1} is even</span>
                        <span class="n">xa_parity_01</span> <span class="o">=</span> <span class="p">((</span><span class="n">x_data</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="n">x_data</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">xa_parity_01</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">xb_parity_02</span> <span class="o">=</span> <span class="p">((</span><span class="n">x_data</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="n">x_data</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">xb_parity_02</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts_acc</span><span class="p">,</span> <span class="n">counts_good</span>

<span class="n">counts_acc</span><span class="p">,</span> <span class="n">counts_good</span> <span class="o">=</span> <span class="n">process_all</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;counts_acc:&#39;</span><span class="p">,</span> <span class="n">counts_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;counts_good:&#39;</span><span class="p">,</span> <span class="n">counts_good</span><span class="p">)</span>

<span class="c1"># Also compute total number of patterns for each k for sanity: choose patterns with exactly k non-identity faults across 5 gates, with 15 choices each.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>
<span class="n">N_total_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_total_k:&#39;</span><span class="p">,</span> <span class="n">N_total_k</span><span class="p">)</span>

<span class="c1"># Let&#39;s compute acceptance fractions per k, and good fraction per k.</span>
<span class="n">fractions_acc</span> <span class="o">=</span> <span class="p">[</span><span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">N_total_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">N_total_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="n">fractions_good</span> <span class="o">=</span> <span class="p">[</span><span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">N_total_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">N_total_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fractions_acc per k:&#39;</span><span class="p">,</span> <span class="n">fractions_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fractions_good per k:&#39;</span><span class="p">,</span> <span class="n">fractions_good</span><span class="p">)</span>

<span class="c1"># Now compute F(p) as rational function of p using the counts. We&#39;ll present numerator and denominator coefficients.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
 <span class="n">den</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">w_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">+=</span> <span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_k</span>
    <span class="n">den</span> <span class="o">+=</span> <span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_k</span>

<span class="c1"># Simplify to series to O(p^3)</span>
<span class="n">series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># up to p^2 terms</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series F(p) up to p^2:&#39;</span><span class="p">,</span> <span class="n">series</span><span class="p">)</span>

<span class="c1"># Also maybe get exact simplified rational function form</span>
<span class="n">F_expr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F(p) simplified expression:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">F_expr</span><span class="p">)</span>

<span class="c1"># We can also output coefficients of polynomial of numerator and denominator if needed.</span>
<span class="n">num_poly</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="n">den_poly</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Numerator poly:&#39;</span><span class="p">,</span> <span class="n">num_poly</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Denominator poly:&#39;</span><span class="p">,</span> <span class="n">den_poly</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>  File &quot;&lt;stdin&gt;&quot;, line 200
    den = 0
IndentationError: unexpected indent
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="c1"># We&#39;ll implement symplectic representation for Pauli strings on 5 qubits (0..3 data, 4 ancilla)</span>
<span class="c1"># Pauli string represented by two bit arrays x, z of length 5.</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Helper: construct Pauli from per-qubit char list like [&#39;I&#39;,&#39;X&#39;,&#39;Z&#39;,&#39;Y&#39;,&#39;I&#39;]</span>
<span class="n">pauli_char_to_bits</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">pauli_from_chars</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">zi</span> <span class="o">=</span> <span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xi</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zi</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">z</span>

<span class="c1"># CNOT conjugation on symplectic bits</span>
<span class="c1"># Conjugation: under CNOT(c-&gt;t): x_t ^= x_c ; z_c ^= z_t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_cnot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="c1"># x,z ints with bits over 5 qubits</span>
    <span class="n">x_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="n">x_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="n">z_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="n">z_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="c1"># Update: x_t&#39; = x_t ^ x_c ; z_c&#39; = z_c ^ z_t</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="p">((</span><span class="n">x_t</span> <span class="o">^</span> <span class="p">(</span><span class="n">x_c</span><span class="p">))</span> <span class="o">^</span> <span class="n">x_t</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">t</span>  <span class="c1"># set bit t to x_t&#39;</span>
    <span class="n">z</span> <span class="o">^=</span> <span class="p">((</span><span class="n">z_c</span> <span class="o">^</span> <span class="p">(</span><span class="n">z_t</span><span class="p">))</span> <span class="o">^</span> <span class="n">z_c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">c</span>  <span class="c1"># set bit c to z_c&#39;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">z</span>

<span class="c1"># Define the sequence of gates (control, target) in chronological order:</span>
<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="c1"># Define all 2-qubit Pauli types on a given pair (including II at index 0) in a fixed order list</span>
<span class="n">paulis_single</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">pauli_pairs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">paulis_single</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">paulis_single</span><span class="p">:</span>
        <span class="n">pauli_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="c1"># Index 0 corresponds to (&#39;I&#39;,&#39;I&#39;), the identity (no error); error model uses only the 15 non-identity ones.</span>

<span class="c1"># Precompute conjugated errors to end for each position and each local pauli pair.</span>
<span class="n">E_end</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of list: E_end[pos][pp_index] -&gt; (x,z)</span>
<span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
    <span class="c1"># Build mapping for this pos</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pauli_pairs</span><span class="p">:</span>
        <span class="c1"># Initialize x,z as identity</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># place local pauli on qubits c and t</span>
        <span class="n">xa</span><span class="p">,</span> <span class="n">za</span> <span class="o">=</span> <span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">xb</span><span class="p">,</span> <span class="n">zb</span> <span class="o">=</span> <span class="n">pauli_char_to_bits</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xa</span><span class="p">:</span> <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">za</span><span class="p">:</span> <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xb</span><span class="p">:</span> <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zb</span><span class="p">:</span> <span class="n">z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># Propagate through subsequent CNOTs pos+1..end</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">c2</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">conj_cnot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span>
        <span class="n">mapping</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="n">E_end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>

<span class="c1"># Stabilizer generators on data 0..3</span>
<span class="n">S1_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">S1_z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">S1_x</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">q</span><span class="p">)</span>
<span class="n">S2_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">S2_z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">S2_z</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">q</span><span class="p">)</span>

<span class="c1"># Logical Z operators on data only</span>
<span class="n">ZA_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ZA_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ZB_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ZB_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>

<span class="c1"># Precompute options per position: (x,z,k) where k=0 if identity else 1</span>
<span class="n">pos_options</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">E_end</span><span class="p">[</span><span class="n">pos</span><span class="p">]):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">opts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">))</span>
    <span class="n">pos_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>

<span class="c1"># Enumerate and count</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_all</span><span class="p">():</span>
    <span class="n">counts_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
    <span class="n">counts_good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
    <span class="n">options0</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">options1</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">options2</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">options3</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">options4</span> <span class="o">=</span> <span class="n">pos_options</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">mask_data</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># bits 0..3 set</span>
    <span class="k">for</span> <span class="n">idx0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
        <span class="n">x0</span><span class="p">,</span><span class="n">z0</span><span class="p">,</span><span class="n">k0</span> <span class="o">=</span> <span class="n">options0</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
            <span class="n">x1</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">k1</span> <span class="o">=</span> <span class="n">options1</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">x01</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">^</span> <span class="n">x1</span>
            <span class="n">z01</span> <span class="o">=</span> <span class="n">z0</span> <span class="o">^</span> <span class="n">z1</span>
            <span class="n">k01</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">+</span> <span class="n">k1</span>
            <span class="k">for</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                <span class="n">x2</span><span class="p">,</span><span class="n">z2</span><span class="p">,</span><span class="n">k2</span> <span class="o">=</span> <span class="n">options2</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
                <span class="n">x012</span> <span class="o">=</span> <span class="n">x01</span> <span class="o">^</span> <span class="n">x2</span>
                <span class="n">z012</span> <span class="o">=</span> <span class="n">z01</span> <span class="o">^</span> <span class="n">z2</span>
                <span class="n">k012</span> <span class="o">=</span> <span class="n">k01</span> <span class="o">+</span> <span class="n">k2</span>
                <span class="k">for</span> <span class="n">idx3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                    <span class="n">x3</span><span class="p">,</span><span class="n">z3</span><span class="p">,</span><span class="n">k3</span> <span class="o">=</span> <span class="n">options3</span><span class="p">[</span><span class="n">idx3</span><span class="p">]</span>
                    <span class="n">x0123</span> <span class="o">=</span> <span class="n">x012</span> <span class="o">^</span> <span class="n">x3</span>
                    <span class="n">z0123</span> <span class="o">=</span> <span class="n">z012</span> <span class="o">^</span> <span class="n">z3</span>
                    <span class="n">k0123</span> <span class="o">=</span> <span class="n">k012</span> <span class="o">+</span> <span class="n">k3</span>
                    <span class="k">for</span> <span class="n">idx4</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                        <span class="n">x4</span><span class="p">,</span><span class="n">z4</span><span class="p">,</span><span class="n">k4</span> <span class="o">=</span> <span class="n">options4</span><span class="p">[</span><span class="n">idx4</span><span class="p">]</span>
                        <span class="n">x_all</span> <span class="o">=</span> <span class="n">x0123</span> <span class="o">^</span> <span class="n">x4</span>
                        <span class="n">z_all</span> <span class="o">=</span> <span class="n">z0123</span> <span class="o">^</span> <span class="n">z4</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">k0123</span> <span class="o">+</span> <span class="n">k4</span>
                        <span class="c1"># anc acceptance: require anc x=0</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">x_all</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">x_data</span> <span class="o">=</span> <span class="n">x_all</span> <span class="o">&amp;</span> <span class="n">mask_data</span>
                        <span class="n">z_data</span> <span class="o">=</span> <span class="n">z_all</span> <span class="o">&amp;</span> <span class="n">mask_data</span>
                        <span class="c1"># Comm with S1 (XXXX): anticomm if parity of z_data bits is 1</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">z_data</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="c1"># Comm with S2 (ZZZZ): anticomm if parity of x_data bits is 1</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c1"># &#39;Good&#39; if commutes with ZA and ZB: even parity of x on qubits {0,1} and {0,2}</span>
                        <span class="n">xa_parity_01</span> <span class="o">=</span> <span class="p">((</span><span class="n">x_data</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="n">x_data</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">xa_parity_01</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">xb_parity_02</span> <span class="o">=</span> <span class="p">((</span><span class="n">x_data</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="n">x_data</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">xb_parity_02</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts_acc</span><span class="p">,</span> <span class="n">counts_good</span>

<span class="n">counts_acc</span><span class="p">,</span> <span class="n">counts_good</span> <span class="o">=</span> <span class="n">process_all</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;counts_acc:&#39;</span><span class="p">,</span> <span class="n">counts_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;counts_good:&#39;</span><span class="p">,</span> <span class="n">counts_good</span><span class="p">)</span>

<span class="n">N_total_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_total_k:&#39;</span><span class="p">,</span> <span class="n">N_total_k</span><span class="p">)</span>
<span class="n">fractions_acc</span> <span class="o">=</span> <span class="p">[</span><span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">N_total_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">N_total_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="n">fractions_good</span> <span class="o">=</span> <span class="p">[</span><span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">N_total_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">N_total_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fractions_acc per k:&#39;</span><span class="p">,</span> <span class="n">fractions_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fractions_good per k:&#39;</span><span class="p">,</span> <span class="n">fractions_good</span><span class="p">)</span>

<span class="c1"># Build symbolic expression for F(p)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">den</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">w_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">+=</span> <span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_k</span>
    <span class="n">den</span> <span class="o">+=</span> <span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_k</span>
<span class="n">F_expr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F(p) simplified:&#39;</span><span class="p">,</span> <span class="n">F_expr</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series expansion up to p^3:&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">F_expr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1"># Also compute acceptance probability expression for context</span>
<span class="n">Pacc_expr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc(p) simplified:&#39;</span><span class="p">,</span> <span class="n">Pacc_expr</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc series:&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">Pacc_expr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="nx">counts_acc</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">282</span><span class="p">,</span><span class="w"> </span><span class="mi">4222</span><span class="p">,</span><span class="w"> </span><span class="mi">31637</span><span class="p">,</span><span class="w"> </span><span class="mi">94923</span><span class="p">]</span>
<span class="nx">counts_good</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">138</span><span class="p">,</span><span class="w"> </span><span class="mi">1198</span><span class="p">,</span><span class="w"> </span><span class="mi">7397</span><span class="p">,</span><span class="w"> </span><span class="mi">24027</span><span class="p">]</span>
<span class="nx">N_total_k</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">75</span><span class="p">,</span><span class="w"> </span><span class="mi">2250</span><span class="p">,</span><span class="w"> </span><span class="mi">33750</span><span class="p">,</span><span class="w"> </span><span class="mi">253125</span><span class="p">,</span><span class="w"> </span><span class="mi">759375</span><span class="p">]</span>
<span class="nx">fractions_acc</span><span class="w"> </span><span class="nx">per</span><span class="w"> </span><span class="nx">k</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="m m-Double">1.0</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.09333333333333334</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.12533333333333332</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.1250962962962963</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.12498567901234568</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.1250014814814815</span><span class="p">]</span>
<span class="nx">fractions_good</span><span class="w"> </span><span class="nx">per</span><span class="w"> </span><span class="nx">k</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="m m-Double">1.0</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.09333333333333334</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.06133333333333333</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.0354962962962963</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.029222716049382716</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">0.03164049382716049</span><span class="p">]</span>
<span class="nx">F</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="nx">simplified</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="mi">229376</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1116160</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2198400</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2214000</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1147500</span><span class="o">*</span><span class="nx">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">253125</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">262144</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1269760</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2457600</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2376000</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1147500</span><span class="o">*</span><span class="nx">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">253125</span><span class="p">)</span>
<span class="nx">Series</span><span class="w"> </span><span class="nx">expansion</span><span class="w"> </span><span class="nx">up</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">p</span><span class="o">^</span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">16</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">25</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">704</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">375</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">O</span><span class="p">(</span><span class="nx">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="nx">P_acc</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="nx">simplified</span><span class="p">:</span><span class="w"> </span><span class="o">-</span><span class="mi">262144</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">5</span><span class="o">/</span><span class="mi">253125</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">253952</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">4</span><span class="o">/</span><span class="mi">50625</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">32768</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3375</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">704</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">75</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">68</span><span class="o">*</span><span class="nx">p</span><span class="o">/</span><span class="mi">15</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="nx">P_acc</span><span class="w"> </span><span class="nx">series</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">68</span><span class="o">*</span><span class="nx">p</span><span class="o">/</span><span class="mi">15</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">704</span><span class="o">*</span><span class="nx">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">75</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">O</span><span class="p">(</span><span class="nx">p</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="mi">229376</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">1116160</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2198400</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2214000</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1147500</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="mi">253125</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">262144</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">1269760</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2457600</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2376000</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1147500</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="mi">253125</span><span class="p">)</span>
<span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">val</span><span class="p">)))</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="mf">0</span><span class="w"> </span><span class="mf">1.0</span>
<span class="mf">0.001</span><span class="w"> </span><span class="mf">0.9999993581195542</span>
<span class="mf">0.01</span><span class="w"> </span><span class="mf">0.9999340913140433</span>
<span class="mf">0.02</span><span class="w"> </span><span class="mf">0.9997284757339906</span>
<span class="mf">0.05</span><span class="w"> </span><span class="mf">0.9981451484841417</span>
<span class="mf">0.1</span><span class="w"> </span><span class="mf">0.9913903803885744</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">counts_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">282</span><span class="p">,</span> <span class="mi">4222</span><span class="p">,</span> <span class="mi">31637</span><span class="p">,</span> <span class="mi">94923</span><span class="p">]</span>
<span class="n">counts_good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">138</span><span class="p">,</span> <span class="mi">1198</span><span class="p">,</span> <span class="mi">7397</span><span class="p">,</span> <span class="mi">24027</span><span class="p">]</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">den</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">w_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">+=</span> <span class="n">counts_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_k</span>
    <span class="n">den</span> <span class="o">+=</span> <span class="n">counts_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_k</span>
<span class="n">num_simplified</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good(p):&#39;</span><span class="p">,</span> <span class="n">num_simplified</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good series:&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">num_simplified</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>P_good(p): -229376*p**5/253125 + 223232*p**4/50625 - 29312*p**3/3375 + 656*p**2/75 - 68*p/15 + 1
P_good series: 1 - 68*p/15 + 656*p**2/75 - 29312*p**3/3375 + O(p**4)
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    <div class="content markdown-body"><p>Step-by-Step Derivation</p>
<p>1) Code, circuit and noise model</p>
<ul>
<li>Data qubits: 0,1,2,3. Ancilla: 4.</li>
<li>Stabilizers: S1 = XXXX, S2 = ZZZZ (on qubits 0–3).</li>
<li>Logical operators (up to stabilizers): X_A = X I X I, X_B = X X I I, Z_A = Z Z I I, Z_B = Z I Z I.</li>
<li>Circuit (right-to-left action): H1 → CNOT12 → CNOT10 → CNOT23 → CNOT34 → CNOT04 → measure Z4.</li>
<li>Noise: after each CNOTij, a two-qubit depolarizing channel applies one of the 15 non-identity Paulis on qubits i and j uniformly with probability p/15; identity with probability 1 − p. No other gates are noisy.</li>
</ul>
<p>We post-select on:
- The ancilla measurement Z4 = +1 (outcome “0”).
- The state being in the codespace, i.e., both stabilizers S1 and S2 measured as +1 (all detectable errors discarded).</p>
<p>Target logical state: |00⟩AB. Logical-state fidelity is the conditional overlap with |00⟩AB given that the run is accepted by the post-selection.</p>
<p>2) Reduce all faults to a single Pauli at the end (Clifford/Pauli propagation)</p>
<ul>
<li>The circuit is Clifford and the faults are Pauli. Any pattern of faults can be commuted forward to a single effective Pauli operator E at the end of the circuit.</li>
<li>Conjugation through a CNOT(c→t) in symplectic form (x,z ∈ {0,1}^n):</li>
<li>x_t → x_t ⊕ x_c</li>
<li>z_c → z_c ⊕ z_t
  i.e., Xc → Xc Xt, Zt → Zc Zt; Xt and Zc unchanged.</li>
</ul>
<p>We label the five CNOTs in time order:
- g1: CNOT12, g2: CNOT10, g3: CNOT23, g4: CNOT34, g5: CNOT04.</p>
<p>For a fault after gj we propagate it through gj+1,…,g5 by the above rules.</p>
<p>3) Acceptance conditions in terms of the final Pauli E</p>
<p>Write E = Edata ⊗ Eanc with Eanc acting on qubit 4 and Edata on qubits 0–3. Because we post-select on syndromes, acceptance is purely a commutation/parity condition on E:</p>
<ul>
<li>
<p>Ancilla acceptance: measuring Z4 = +1 is deterministic unless Eanc anticommutes with Z4. Since Eanc is a single-qubit Pauli on qubit 4, acceptance ⇔ Eanc ∈ {I, Z}. In symplectic bits, this is x4 = 0.</p>
</li>
<li>
<p>Code acceptance: the data error must commute with both stabilizers S1 and S2:</p>
</li>
<li>Commute with S1 = XXXX ⇔ parity of z-bits on qubits 0–3 is even.</li>
<li>Commute with S2 = ZZZZ ⇔ parity of x-bits on qubits 0–3 is even.</li>
</ul>
<p>Equivalently, in symplectic form for data-only x,z on 0–3:
- Accept iff (∑q zq) mod 2 = 0 and (∑q xq) mod 2 = 0.</p>
<p>4) Logical effect on |00⟩AB and “good” vs “bad” accepted errors</p>
<p>Among accepted errors, the logical state fidelity with |00⟩AB is:
- 1 if the induced logical operator has no X on either logical qubit (i.e., it is a product of stabilizers and logical Z’s only).
- 0 if an X (or Y) acts on A and/or B.</p>
<p>This is equivalent to checking commutation with the logical Z’s:
- Z_A = ZZII acts on data qubits 0 and 1.
- Z_B = ZIZI acts on data qubits 0 and 2.</p>
<p>Thus an accepted error Edata is “good” (fidelity 1 on |00⟩AB) iff it commutes with both Z_A and Z_B, i.e. the parity of x-bits on {0,1} and on {0,2} is even:
- (x0 ⊕ x1) = 0 and (x0 ⊕ x2) = 0.</p>
<p>If either parity is odd, an X (or Y) logical flip occurs on A or B, and the overlap with |00⟩AB is zero.</p>
<p>5) Exact counting over all fault patterns</p>
<p>There are 5 noisy CNOTs, each with 16 possibilities (I or one of 15 two-qubit Paulis). For each pattern we:
- Propagate each fault to the end using the conjugation rules above and multiply the resulting Paulis (symplectic XOR of x and z bits).
- Check ancilla acceptance (x4 = 0).
- Check code acceptance (even parities of x and z on data).
- If accepted, check “good” vs “bad” using parity tests with Z_A and Z_B.</p>
<p>This exhaustive Clifford-Pauli enumeration yields the number of accepted patterns and the number of accepted-good patterns as a function of k, the number of non-identity faults in the pattern:</p>
<ul>
<li>
<p>Total patterns with exactly k faults: Ntot(k) = C(5,k) 15^k.</p>
</li>
<li>
<p>Accepted patterns:</p>
</li>
<li>
<p>counts_acc(k) = [1, 7, 282, 4222, 31637, 94923] for k = 0,…,5.</p>
</li>
<li>
<p>Accepted-good (no logical X) patterns:</p>
</li>
<li>counts_good(k) = [1, 7, 138, 1198, 7397, 24027] for k = 0,…,5.</li>
</ul>
<p>Sanity checks:
- For k = 1, counts_acc(1) = counts_good(1) = 7: any single fault that evades detection is purely Z-type on the logicals, i.e. the circuit is first-order fault-tolerant for preparing |00⟩AB.</p>
<p>6) From counts to probabilities and fidelity</p>
<p>Each pattern with exactly k faults has probability weight (p/15)^k (1 − p)^(5 − k). Define
- Pacc(p) = sum_k counts_acc(k) (p/15)^k (1 − p)^(5 − k),
- Pgood(p) = sum_k counts_good(k) (p/15)^k (1 − p)^(5 − k).</p>
<p>The post-selected logical state fidelity is
F(p) = Pgood(p) / Pacc(p).</p>
<p>Closed-form expressions (exact):</p>
<ul>
<li>
<p>Pacc(p) = 1 − (68/15) p + (704/75) p^2 − (32768/3375) p^3 + (253952/50625) p^4 − (262144/253125) p^5.</p>
</li>
<li>
<p>Pgood(p) = 1 − (68/15) p + (656/75) p^2 − (29312/3375) p^3 + (223232/50625) p^4 − (229376/253125) p^5.</p>
</li>
</ul>
<p>Hence
F(p) = (229376 p^5 − 1116160 p^4 + 2198400 p^3 − 2214000 p^2 + 1147500 p − 253125) / (262144 p^5 − 1269760 p^4 + 2457600 p^3 − 2376000 p^2 + 1147500 p − 253125).</p>
<p>Small‑p expansion (shows fault tolerance order):
F(p) = 1 − (16/25) p^2 − (704/375) p^3 + O(p^4).</p>
<p>In particular, the linear term vanishes (no first‑order logical infidelity after post-selection), and the leading logical infidelity is quadratic with coefficient 16/25 = 0.64.</p>
<p>Final Answer:
The post‑selected logical-state fidelity for preparing |00⟩AB with the given circuit and two‑qubit depolarizing noise p after each CNOT is
F(p) = Pgood(p) / Pacc(p),
with
Pacc(p) = 1 − (68/15) p + (704/75) p^2 − (32768/3375) p^3 + (253952/50625) p^4 − (262144/253125) p^5,
Pgood(p) = 1 − (68/15) p + (656/75) p^2 − (29312/3375) p^3 + (223232/50625) p^4 − (229376/253125) p^5.
Equivalently,
F(p) = (229376 p^5 − 1116160 p^4 + 2198400 p^3 − 2214000 p^2 + 1147500 p − 253125) / (262144 p^5 − 1269760 p^4 + 2457600 p^3 − 2376000 p^2 + 1147500 p − 253125),
with small‑p expansion
F(p) = 1 − (16/25) p^2 − (704/375) p^3 + O(p^4).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    <div class="content markdown-body"><p>Final Answer:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">229376</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">1116160</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2198400</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2214000</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1147500</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="mi">253125</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">262144</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">1269760</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2457600</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2376000</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1147500</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="mi">253125</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.548497
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>