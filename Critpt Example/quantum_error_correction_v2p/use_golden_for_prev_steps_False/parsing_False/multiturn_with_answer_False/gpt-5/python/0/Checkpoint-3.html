<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">üåì</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Ideal output state</li>
<li>Start from |0000‚ü© on qubits (0,1,2,3). Apply the circuit U = CNOT03 H0 CNOT21 H2 (right-to-left order).</li>
<li>H2: |0‚ü©2 ‚Üí |+‚ü©2, so</li>
</ul>
<div class="arithmatex">\[
|\psi_1\rangle=\frac{1}{\sqrt{2}}\,|0\rangle_0|0\rangle_1(|0\rangle_2+|1\rangle_2)|0\rangle_3.
\]</div>
<ul>
<li>CNOT21 (control 2, target 1):</li>
</ul>
<div class="arithmatex">\[
|\psi_2\rangle=\frac{1}{\sqrt{2}}\,|0\rangle_0\,(|00\rangle_{1,2}+|11\rangle_{1,2})\,|0\rangle_3.
\]</div>
<ul>
<li>H0:</li>
</ul>
<div class="arithmatex">\[
|\psi_3\rangle=\frac{1}{\sqrt{2}}\,|+\rangle_0\,(|00\rangle_{1,2}+|11\rangle_{1,2})\,|0\rangle_3.
\]</div>
<ul>
<li>CNOT03 (control 0, target 3):</li>
</ul>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle=\frac{1}{2}\, (|00\rangle_{0,3}+|11\rangle_{0,3})\otimes(|00\rangle_{1,2}+|11\rangle_{1,2}).
\]</div>
<p>Thus, the ideal four-qubit state is a product of two Bell states:</p>
<div class="arithmatex">\[
|\psi_{\text{ideal}}\rangle=|\Phi^+\rangle_{0,3}\otimes|\Phi^+\rangle_{1,2},\quad |\Phi^+\rangle=\frac{|00\rangle+|11\rangle}{\sqrt{2}}.
\]</div>
<ul>
<li>Noise model and its placement</li>
<li>Each CNOT is followed by a two-qubit depolarizing channel on its two qubits:</li>
</ul>
<div class="arithmatex">\[
\mathcal{D}_p(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\in\mathcal{P}_{2}\setminus\{II\}} P\rho P,
\]</div>
<div class="codehilite"><pre><span></span><code>where $\mathcal{P}_{2}=\{I,X,Y,Z\}^{\otimes 2}$ on that pair.
</code></pre></div>

<ul>
<li>The first channel acts on qubits (2,1) immediately after CNOT21; the remaining gates act only on qubits (0,3), so this noise does not propagate or mix with later gates.</li>
<li>The second channel acts on qubits (0,3) after the final CNOT03. Therefore the final state is</li>
</ul>
<div class="arithmatex">\[
\rho_{\text{final}}=\mathcal{D}_p^{(0,3)}\!\big(|\Phi^+\rangle\langle\Phi^+|_{0,3}\big)\;\otimes\;\mathcal{D}_p^{(1,2)}\!\big(|\Phi^+\rangle\langle\Phi^+|_{1,2}\big).
\]</div>
<ul>
<li>Fidelity factorizes</li>
<li>The physical state fidelity with the ideal pure product state is</li>
</ul>
<div class="arithmatex">\[
\]</div>
<div class="codehilite"><pre><span></span><code>where $F_{a,b}=\langle\Phi^+|\mathcal{D}_p^{(a,b)}(|\Phi^+\rangle\langle\Phi^+|)|\Phi^+\rangle$.
</code></pre></div>

<ul>
<li>
<p>Since both channels are identical, <span class="arithmatex">\(F_{0,3}=F_{1,2}\equiv F_{\text{pair}}\)</span>, hence <span class="arithmatex">\(F=F_{\text{pair}}^2\)</span>.</p>
</li>
<li>
<p>Two-qubit fidelity on a Bell state</p>
</li>
<li>For <span class="arithmatex">\(|\Phi^+\rangle\)</span>, the only two-qubit Paulis (modulo phase) that map <span class="arithmatex">\(|\Phi^+\rangle\)</span> to <span class="arithmatex">\(\pm|\Phi^+\rangle\)</span> are <span class="arithmatex">\(\{II,XX,YY,ZZ\}\)</span>. All other 12 Paulis map it to orthogonal Bell states.</li>
<li>Therefore</li>
</ul>
<div class="arithmatex">\[
F_{\text{pair}}=(1-p)+3\left(\frac{p}{15}\right)=1-p+\frac{p}{5}=1-\frac{4p}{5}.
\]</div>
<ul>
<li>Combine the two independent pairs</li>
</ul>
<div class="arithmatex">\[
F(p)=\Big(1-\frac{4p}{5}\Big)^2=1-\frac{8}{5}p+\frac{16}{25}p^2.
\]</div>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>See equations above.</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Probabilities are unitless. The depolarizing probability per two-qubit gate is <span class="arithmatex">\(p\)</span>.</li>
</ul>
<ol start="4">
<li>Final Answer:
F(p) = (1 - 4p/5)^2 = 1 - (8/5)p + (16/25)p^2.</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Ideal (noise-free) output of the circuit</li>
<li>As in Subproblem 1, starting from |0000‚ü© and applying
    H2 ‚Üí CNOT21 ‚Üí H0 ‚Üí CNOT03
    gives the pure 4-qubit state</li>
</ul>
<div class="arithmatex">\[
      =|\Phi^+\rangle_{0,3}\otimes|\Phi^+\rangle_{1,2},\qquad
\]</div>
<ul>
<li>
<p>This state lies in the [[4,2,2]] code space (it is +1 for both stabilizers <span class="arithmatex">\(S_X=XXXX=(XX)_{03}(XX)_{12}\)</span> and <span class="arithmatex">\(S_Z=ZZZZ=(ZZ)_{03}(ZZ)_{12}\)</span>), and encodes the logical Bell state <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> with logical stabilizers <span class="arithmatex">\(X_AX_B=(XX)_{12}\)</span> and <span class="arithmatex">\(Z_AZ_B=(ZZ)_{12}\)</span>.</p>
</li>
<li>
<p>Noise model and locality</p>
</li>
<li>Each CNOT is followed by a 2-qubit depolarizing channel on its two qubits:</li>
</ul>
<div class="arithmatex">\[
\mathcal{D}_p(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\neq II}P\rho P,
\]</div>
<div class="codehilite"><pre><span></span><code>with $P\in\{I,X,Y,Z\}^{\otimes 2}$ on that pair.
</code></pre></div>

<ul>
<li>The two channels act independently on disjoint pairs: after CNOT21 on (1,2) and after CNOT03 on (0,3). Because the later gates do not couple these pairs, we can treat the final noisy state as</li>
</ul>
<div class="arithmatex">\[
\rho=\mathcal{D}_p^{(0,3)}\!\otimes\,\mathcal{D}_p^{(1,2)}\big(|\psi_{\text{ideal}}\rangle\langle\psi_{\text{ideal}}|\big).
\]</div>
<ul>
<li>Bell-pair flip classification</li>
<li>For any two-qubit Pauli <span class="arithmatex">\(P\)</span> acting on a Bell pair, define the flip vector</li>
</ul>
<div class="arithmatex">\[
v(P)=(\delta_X,\delta_Z)\in\{0,1\}^2,
\]</div>
<div class="codehilite"><pre><span></span><code>where $\delta_X$ is 1 if $P$ anticommutes with $XX$ on that pair, and $\delta_Z$ is 1 if $P$ anticommutes with $ZZ$ on that pair. Then
<span class="k">-</span> $v=(0,0)$ maps $|\Phi^+\rangle$ to itself,
<span class="k">-</span> $v=(1,0)$ maps $|\Phi^+\rangle\to|\Phi^-\rangle$,
<span class="k">-</span> $v=(0,1)$ maps $|\Phi^+\rangle\to|\Psi^+\rangle$,
<span class="k">-</span> $v=(1,1)$ maps $|\Phi^+\rangle\to|\Psi^-\rangle$.
</code></pre></div>

<ul>
<li>On a given pair, the 16 Paulis partition evenly into four classes by <span class="arithmatex">\(v\)</span>, with</li>
</ul>
<div class="arithmatex">\[
\#\{P:\,v(P)=v\}=4\quad\text{for each }v,
\]</div>
<div class="codehilite"><pre><span></span><code>and explicitly $v=(0,0)$ corresponds to $\{II,XX,YY,ZZ\}$; each of the other three classes contains four non-identity operators.
</code></pre></div>

<ul>
<li>Post-selection on the code</li>
<li>The code stabilizers are <span class="arithmatex">\(S_X=(XX)_{03}(XX)_{12}\)</span> and <span class="arithmatex">\(S_Z=(ZZ)_{03}(ZZ)_{12}\)</span>. After applying Pauli errors <span class="arithmatex">\(P_{03}\)</span> on (0,3) and <span class="arithmatex">\(Q_{12}\)</span> on (1,2), the total eigenvalue flips of <span class="arithmatex">\(S_X\)</span> and <span class="arithmatex">\(S_Z\)</span> are given by</li>
</ul>
<div class="arithmatex">\[
v(P_{03}\otimes Q_{12})=v(P_{03})\oplus v(Q_{12}).
\]</div>
<ul>
<li>
<p>Post-selecting on ‚Äúno detected error‚Äù means we keep only those terms with <span class="arithmatex">\(v(P_{03})=v(Q_{12})\)</span> (so the net flips of <span class="arithmatex">\(S_X,S_Z\)</span> are zero).</p>
</li>
<li>
<p>Weights per class</p>
</li>
<li>For a single depolarizing channel on one pair:<ul>
<li>The identity has weight <span class="arithmatex">\(w(I)=1-p\)</span>.</li>
<li>Each non-identity has weight <span class="arithmatex">\(w_{\neq I}=p/15\)</span>.</li>
</ul>
</li>
<li>Hence the total weight in each class on one pair is</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Acceptance probability and conditional distribution</li>
<li>Acceptance requires the two pairs have the same class <span class="arithmatex">\(v\)</span>, so the total accepted weight is</li>
</ul>
<div class="arithmatex">\[
      =\Big(1-\frac{4p}{5}\Big)^2+3\Big(\frac{4p}{15}\Big)^2
\]</div>
<ul>
<li>Logical fidelity conditioned on acceptance</li>
<li>The encoded Bell state is stabilized by the logical operators <span class="arithmatex">\(X_AX_B\)</span> and <span class="arithmatex">\(Z_AZ_B\)</span>, whose physical representatives can be taken as <span class="arithmatex">\((XX)_{12}\)</span> and <span class="arithmatex">\((ZZ)_{12}\)</span>. Therefore the logical state remains the target <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> if and only if the (1,2) pair stays in <span class="arithmatex">\(|\Phi^+\rangle\)</span>, i.e., <span class="arithmatex">\(v(Q_{12})=(0,0)\)</span>.</li>
<li>Because acceptance also requires <span class="arithmatex">\(v(P_{03})=v(Q_{12})\)</span>, the accepted events that preserve the logical state are exactly those with <span class="arithmatex">\(v=(0,0)\)</span> on both pairs. Their total weight is <span class="arithmatex">\(W_{00}^2\)</span>.</li>
<li>Thus the logical state fidelity after post-selection is</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Closed forms and small-p expansion</li>
<li>Simplifying,</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>For small <span class="arithmatex">\(p\)</span>,</li>
</ul>
<div class="arithmatex">\[
F_L(p)=1-\frac{16}{75}\,p^2+O(p^3),
\]</div>
<div class="codehilite"><pre><span></span><code>i.e., logical infidelity is second order in $p$ under post-selection.
</code></pre></div>

<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>See equations above.</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Probabilities are unitless; <span class="arithmatex">\(p\)</span> is the two-qubit depolarizing probability per CNOT.</li>
</ul>
<ol start="4">
<li>Final Answer:</li>
</ol>
<div class="arithmatex">\[
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># We&#39;ll enumerate error patterns for the given circuit and compute conditional logical fidelity.</span>
<span class="c1"># 5 data qubits (0..3) + ancilla (4)</span>
<span class="c1"># Circuit order (executed right-to-left): H1, CNOT12, CNOT10, CNOT23, CNOT34, CNOT04, M4</span>
<span class="c1"># Errors after each CNOT: E1 after CNOT12, E2 after CNOT10, E3 after CNOT23, E4 after CNOT34, E5 after CNOT04.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>

<span class="n">n</span><span class="o">=</span><span class="mi">5</span>

<span class="c1"># Bit masks</span>
<span class="n">DATA_MASK</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># qubits 0..3</span>
<span class="n">ANC_BIT</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span>

<span class="c1"># Symplectic representation helpers</span>
<span class="c1"># Pauli mapping: 0:I, 1:X, 2:Y, 3:Z</span>
<span class="n">px</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">pz</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Conjugation by CNOT c-&gt;t on symplectic bits (x,z) integers</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_cnot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="c1"># x_t&#39; = x_t XOR x_c</span>
    <span class="c1"># z_c&#39; = z_c XOR z_t</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
    <span class="n">xt</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
    <span class="n">zc</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
    <span class="n">zt</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
    <span class="c1"># update bits</span>
    <span class="n">xt_new</span> <span class="o">=</span> <span class="n">xt</span> <span class="o">^</span> <span class="n">xc</span>
    <span class="n">zc_new</span> <span class="o">=</span> <span class="n">zc</span> <span class="o">^</span> <span class="n">zt</span>
    <span class="c1"># apply updates</span>
    <span class="k">if</span> <span class="n">xt_new</span> <span class="o">!=</span> <span class="n">xt</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zc_new</span> <span class="o">!=</span> <span class="n">zc</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">z</span>

<span class="c1"># Build suffix gate lists for each error location (after that gate)</span>
<span class="c1"># order: after CNOT12 -&gt; gates: CNOT10, CNOT23, CNOT34, CNOT04</span>
<span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span>
    <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span>
    <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span>
    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span>
    <span class="p">[]</span>
<span class="p">]</span>

<span class="c1"># For each location, map 16 2-qubit Paulis on its gate qubits to final (x,z)</span>
<span class="c1"># gate qubit pairs in order</span>
<span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="c1"># Precompute mapping arrays E_maps[loc][p_idx] -&gt; (x,z)</span>
<span class="n">E_maps</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">loc</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="c1"># Build initial x,z</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">px</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">c</span>
                <span class="n">z</span> <span class="o">|=</span> <span class="n">pz</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">c</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">px</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">t</span>
                <span class="n">z</span> <span class="o">|=</span> <span class="n">pz</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">t</span>
            <span class="c1"># propagate through suffix</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">cc</span><span class="p">,</span><span class="n">tt</span><span class="p">)</span> <span class="ow">in</span> <span class="n">suffixes</span><span class="p">[</span><span class="n">loc</span><span class="p">]:</span>
                <span class="n">x</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">conj_cnot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">cc</span><span class="p">,</span><span class="n">tt</span><span class="p">)</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="n">E_maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="c1"># Build stabilizer state generators for |00&gt;_L on data qubits: S_X=XXXX, S_Z=ZZZZ, Z_A=ZZII, Z_B=ZIZI</span>
<span class="c1"># Represented as (x,z) on 4 data qubits; ancilla qubit ignored here</span>
<span class="n">SX_x</span> <span class="o">=</span> <span class="mb">0b1111</span><span class="p">;</span> <span class="n">SX_z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">SZ_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">SZ_z</span> <span class="o">=</span> <span class="mb">0b1111</span>
<span class="n">ZA_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ZA_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Z0 Z1</span>
<span class="n">ZB_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ZB_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Z0 Z2</span>

<span class="c1"># Generate the 16-element stabilizer group of the GHZ |00&gt;_L state on 4 qubits</span>
<span class="n">stab_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="c1"># We can generate by combining the four independent generators</span>
<span class="n">gens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">SX_x</span><span class="p">,</span><span class="n">SX_z</span><span class="p">),(</span><span class="n">SZ_x</span><span class="p">,</span><span class="n">SZ_z</span><span class="p">),(</span><span class="n">ZA_x</span><span class="p">,</span><span class="n">ZA_z</span><span class="p">),(</span><span class="n">ZB_x</span><span class="p">,</span><span class="n">ZB_z</span><span class="p">)]</span>
<span class="c1"># enumerate all 16 products ignoring phase; XOR for bits</span>
<span class="k">for</span> <span class="n">s0</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">s3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">if</span> <span class="n">s0</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">^=</span> <span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">z</span> <span class="o">^=</span> <span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">s1</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">^=</span> <span class="n">gens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">z</span> <span class="o">^=</span> <span class="n">gens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">s2</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">^=</span> <span class="n">gens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">z</span> <span class="o">^=</span> <span class="n">gens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">s3</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">^=</span> <span class="n">gens</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">z</span> <span class="o">^=</span> <span class="n">gens</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">stab_set</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>

<span class="c1"># Now enumerate all 16^5 patterns</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="n">N_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>  <span class="c1"># counts of accepted patterns by k errors</span>
<span class="n">N_good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">N_total_by_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">N_acc_total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">N_good_total</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># We&#39;ll also verify single-fault detection property by counting accepted k=1 events</span>

<span class="k">for</span> <span class="n">a0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">x0</span><span class="p">,</span><span class="n">z0</span> <span class="o">=</span> <span class="n">E_maps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">a0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span><span class="n">z1</span> <span class="o">=</span> <span class="n">E_maps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">a1</span><span class="p">]</span>
        <span class="n">x01</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">^</span> <span class="n">x1</span>
        <span class="n">z01</span> <span class="o">=</span> <span class="n">z0</span> <span class="o">^</span> <span class="n">z1</span>
        <span class="k">for</span> <span class="n">a2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
            <span class="n">x2</span><span class="p">,</span><span class="n">z2</span> <span class="o">=</span> <span class="n">E_maps</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">a2</span><span class="p">]</span>
            <span class="n">x012</span> <span class="o">=</span> <span class="n">x01</span> <span class="o">^</span> <span class="n">x2</span>
            <span class="n">z012</span> <span class="o">=</span> <span class="n">z01</span> <span class="o">^</span> <span class="n">z2</span>
            <span class="k">for</span> <span class="n">a3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                <span class="n">x3</span><span class="p">,</span><span class="n">z3</span> <span class="o">=</span> <span class="n">E_maps</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">a3</span><span class="p">]</span>
                <span class="n">x0123</span> <span class="o">=</span> <span class="n">x012</span> <span class="o">^</span> <span class="n">x3</span>
                <span class="n">z0123</span> <span class="o">=</span> <span class="n">z012</span> <span class="o">^</span> <span class="n">z3</span>
                <span class="k">for</span> <span class="n">a4</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                    <span class="n">x4</span><span class="p">,</span><span class="n">z4</span> <span class="o">=</span> <span class="n">E_maps</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">a4</span><span class="p">]</span>
                    <span class="n">xfin</span> <span class="o">=</span> <span class="n">x0123</span> <span class="o">^</span> <span class="n">x4</span>
                    <span class="n">zfin</span> <span class="o">=</span> <span class="n">z0123</span> <span class="o">^</span> <span class="n">z4</span>
                    <span class="c1"># number of non-identity errors k</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">a1</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">a2</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">a3</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">a4</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">N_total_by_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># acceptance: ancilla X must be 0, and commute with SX,SZ on data</span>
                    <span class="n">anc_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfin</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">anc_x</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># data bits</span>
                    <span class="n">xdat</span> <span class="o">=</span> <span class="n">xfin</span> <span class="o">&amp;</span> <span class="n">DATA_MASK</span>
                    <span class="n">zdat</span> <span class="o">=</span> <span class="n">zfin</span> <span class="o">&amp;</span> <span class="n">DATA_MASK</span>
                    <span class="c1"># commute with SX: parity of zdat must be 0</span>
                    <span class="c1"># commute with SZ: parity of xdat must be 0</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">zdat</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">xdat</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># accepted</span>
                    <span class="n">N_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># good if (xdat,zdat) in stab_set</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">xdat</span><span class="p">,</span><span class="n">zdat</span><span class="p">)</span> <span class="ow">in</span> <span class="n">stab_set</span><span class="p">:</span>
                        <span class="n">N_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># Summaries</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;N_total_by_k:&quot;</span><span class="p">,</span> <span class="n">N_total_by_k</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;N_acc by k:&quot;</span><span class="p">,</span> <span class="n">N_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;N_good by k:&quot;</span><span class="p">,</span> <span class="n">N_good</span><span class="p">)</span>

<span class="c1"># Now produce symbolic numerator and denominator coefficients for F(p)</span>
<span class="c1"># Prob per pattern with k errors: (1-p)^(5-k)*(p/15)^k</span>
<span class="c1"># So N_good(p) = sum_k N_good[k] * (1-p)^(5-k) * (p/15)^k</span>
<span class="c1"># P_acc(p) = sum_k N_acc[k] * (1-p)^(5-k) * (p/15)^k</span>
<span class="c1"># We&#39;ll express as polynomials in p up to degree 5. Let q=1-p.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="c1"># We&#39;ll compute exact rational coefficients for numerator and denominator in terms of p^k.</span>
<span class="c1"># Expand (1-p)^(5-k) p^k * (1/15)^k = sum_{j=0}^{5-k} C(5-k,j) (-p)^j p^k * 15^{-k}</span>
<span class="c1"># = sum_{t=k}^{5} C(5-k, t-k) (-1)^{t-k} p^t * 15^{-k}</span>
<span class="c1"># We&#39;ll compute arrays coeff_num[t], coeff_den[t] rational numbers.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="n">coeff_num</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="n">coeff_den</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">comb</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">k</span><span class="p">))</span> <span class="o">*</span> <span class="n">comb</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>
        <span class="n">coeff_num</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">N_good</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span>
        <span class="n">coeff_den</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">N_acc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Numerator coeffs (p^t):&quot;</span><span class="p">,</span> <span class="n">coeff_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Denominator coeffs (p^t):&quot;</span><span class="p">,</span> <span class="n">coeff_den</span><span class="p">)</span>

<span class="c1"># Optionally, display F(p) rational polynomial: [We&#39;ll present as quotient of these polynomials]</span>

<span class="c1"># Let&#39;s also produce simplified rational function as a ratio of polynomials with integer coefficients by multiplying out denominators gcd.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">lcm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">gcd</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">//</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

<span class="c1"># Find common denominator for numerator and denominator polynomials</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">gcd</span>

<span class="n">D_num</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">D_den</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_num</span><span class="p">:</span>
    <span class="n">D_num</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">D_num</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_den</span><span class="p">:</span>
    <span class="n">D_den</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">D_den</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>

<span class="n">int_num</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">D_num</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_num</span><span class="p">]</span>
<span class="n">int_den</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">D_den</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_den</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Integer-coeff numerator (over </span><span class="si">{}</span><span class="s2">):&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">D_num</span><span class="p">),</span> <span class="n">int_num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Integer-coeff denominator (over </span><span class="si">{}</span><span class="s2">):&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">D_den</span><span class="p">),</span> <span class="n">int_den</span><span class="p">)</span>

<span class="c1"># For sanity, compute small-p expansion of F(p) to p^2 or higher by series division</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">decimal</span>

<span class="k">def</span><span class="w"> </span><span class="nf">series_div</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="c1"># compute series c such that sum a_i p^i / sum b_i p^i = sum c_i p^i up to len(a)-1</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">-=</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">/</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="c1"># Convert to floats for series</span>
<span class="n">an</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_num</span><span class="p">]</span>
<span class="n">bd</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_den</span><span class="p">]</span>
<span class="n">ser</span> <span class="o">=</span> <span class="n">series_div</span><span class="p">(</span><span class="n">an</span><span class="p">,</span><span class="n">bd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Series coefficients (to p^5):&quot;</span><span class="p">,</span> <span class="n">ser</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>N_total_by_k: [1, 75, 2250, 33750, 253125, 759375]
N_acc by k: [1, 7, 282, 4222, 31637, 94923]
N_good by k: [1, 7, 138, 1198, 7397, 24027]
Numerator coeffs (p^t): [Fraction(1, 1), Fraction(-68, 15), Fraction(656, 75), Fraction(-29312, 3375), Fraction(223232, 50625), Fraction(-229376, 253125)]
Denominator coeffs (p^t): [Fraction(1, 1), Fraction(-68, 15), Fraction(704, 75), Fraction(-32768, 3375), Fraction(253952, 50625), Fraction(-262144, 253125)]
Integer-coeff numerator (over 253125): [253125, -1147500, 2214000, -2198400, 1116160, -229376]
Integer-coeff denominator (over 253125): [253125, -1147500, 2376000, -2457600, 1269760, -262144]
Series coefficients (to p^5): [1.0, 0.0, -0.6400000000000006, -1.8773333333333366, -3.1099259259259355, -2.5607585185185364]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># Evaluate F_L(p) numerically for sample p values</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="n">coeff_num</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">68</span><span class="o">/</span><span class="mi">15</span><span class="p">,</span> <span class="mi">656</span><span class="o">/</span><span class="mi">75</span><span class="p">,</span> <span class="o">-</span><span class="mi">29312</span><span class="o">/</span><span class="mi">3375</span><span class="p">,</span> <span class="mi">223232</span><span class="o">/</span><span class="mi">50625</span><span class="p">,</span> <span class="o">-</span><span class="mi">229376</span><span class="o">/</span><span class="mi">253125</span><span class="p">]</span>
<span class="n">coeff_den</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">68</span><span class="o">/</span><span class="mi">15</span><span class="p">,</span> <span class="mi">704</span><span class="o">/</span><span class="mi">75</span><span class="p">,</span> <span class="o">-</span><span class="mi">32768</span><span class="o">/</span><span class="mi">3375</span><span class="p">,</span> <span class="mi">253952</span><span class="o">/</span><span class="mi">50625</span><span class="p">,</span> <span class="o">-</span><span class="mi">262144</span><span class="o">/</span><span class="mi">253125</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">poly_val</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)))</span>

<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">poly_val</span><span class="p">(</span><span class="n">coeff_num</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">poly_val</span><span class="p">(</span><span class="n">coeff_den</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">den</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="mf">0.0</span><span class="w"> </span><span class="mf">1.0</span>
<span class="mf">0.001</span><span class="w"> </span><span class="mf">0.999999358119554</span>
<span class="mf">0.01</span><span class="w"> </span><span class="mf">0.9999340913140434</span>
<span class="mf">0.02</span><span class="w"> </span><span class="mf">0.9997284757339905</span>
<span class="mf">0.05</span><span class="w"> </span><span class="mf">0.9981451484841417</span>
<span class="mf">0.1</span><span class="w"> </span><span class="mf">0.9913903803885744</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    <div class="content markdown-body"><ol>
<li>Step-by-Step Derivation</li>
</ol>
<ul>
<li>Ideal (noise-free) state prepared by the circuit</li>
<li>Start in |00000‚ü© on qubits (0,1,2,3,4).</li>
<li>Apply H1 ‚Üí CNOT12 ‚Üí CNOT10 ‚Üí CNOT23 to get a 4-qubit GHZ on the data and ancilla |0‚ü©:</li>
</ul>
<div class="arithmatex">\[
|\psi_{\text{data}}\rangle=\frac{|0000\rangle_{0..3}+|1111\rangle_{0..3}}{\sqrt{2}},\qquad |0\rangle_4.
\]</div>
<ul>
<li>The pair of CNOTs CNOT34, CNOT04 computes the Z-parity Z0Z3 onto the ancilla. In the ideal GHZ state this parity is +1, so M4 deterministically yields 0.</li>
<li>The 4-qubit GHZ is stabilized by S_X=XXXX and S_Z=ZZZZ and is the logical state |00‚ü©AB, since</li>
</ul>
<div class="arithmatex">\[
Z_A=Z_0Z_1,\quad Z_B=Z_0Z_2,\quad Z_A|\psi\rangle=Z_B|\psi\rangle=+|\psi\rangle.
\]</div>
<ul>
<li>Noise model and algebraic reduction</li>
<li>After each CNOT, a two-qubit depolarizing channel acts on that gate‚Äôs two qubits:</li>
</ul>
<div class="arithmatex">\[
\mathcal{D}_p(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\neq II}P\rho P.
\]</div>
<ul>
<li>
<p>There are 5 CNOTs, hence 5 error locations. Because the circuit is Clifford and the noise is Pauli, each error can be conjugated through the suffix of the circuit to a single Pauli at the end. Multiple errors multiply (up to a global phase that is irrelevant).</p>
</li>
<li>
<p>Post-selection (acceptance) conditions</p>
</li>
<li>Ancilla post-selection M4=0: at the end of the circuit, an X or Y on the ancilla flips the measurement bit, so acceptance requires the ancilla Pauli be I or Z (no X-part on qubit 4).</li>
<li>
<p>Code post-selection ‚Äúall detectable errors‚Äù: at the end, the data Pauli must commute with S_X=XXXX and S_Z=ZZZZ. In symplectic form this is equivalent to requiring an even number of X-type factors and an even number of Z-type factors on the data qubits 0..3.</p>
</li>
<li>
<p>Logical fidelity conditioned on acceptance</p>
</li>
<li>The target logical state |00‚ü©AB is the unique +1 eigenstate of the four commuting generators {S_X, S_Z, Z_A, Z_B}. Thus, among accepted events, the logical state is correct if and only if the final data Pauli lies in the 16-element stabilizer group G=‚ü®S_X,S_Z,Z_A,Z_B‚ü©. Any accepted Pauli outside G is a nontrivial logical operator (e.g., contains X_A and/or X_B) and maps |00‚ü©AB to an orthogonal logical computational basis state.</li>
<li>
<p>Therefore, the logical fidelity equals the total probability weight of accepted-and-correct patterns divided by the total accepted weight.</p>
</li>
<li>
<p>Exact counting over all Pauli-error patterns</p>
</li>
<li>Each of the 5 error locations contributes 16 possibilities (I or one of 15 non-identity Paulis), so there are 16^5 patterns. For a pattern with k non-identity errors, the probability weight is (1‚àíp)^(5‚àík) (p/15)^k.</li>
<li>Conjugating each error to the end and multiplying yields a final 5-qubit Pauli. We accept a pattern if:<ul>
<li>the ancilla has no X-part (I or Z on qubit 4), and</li>
<li>the data part commutes with S_X and S_Z.</li>
</ul>
</li>
<li>Among accepted patterns, the pattern is ‚Äúgood‚Äù (preserves |00‚ü©AB) if the data Pauli ‚àà G=‚ü®S_X,S_Z,Z_A,Z_B‚ü©.</li>
</ul>
<p>The acceptance and ‚Äúgood‚Äù counts by k (number of error locations with a non-identity Pauli) are:
  - N_acc(k) = [1, 7, 282, 4222, 31637, 94923] for k=0..5,
  - N_good(k) = [1, 7, 138, 1198, 7397, 24027] for k=0..5.</p>
<ul>
<li>Logical fidelity as a function of p</li>
<li>Let</li>
</ul>
<div class="arithmatex">\[
    N_{\text{good}}(p)&amp;=\sum_{k=0}^{5} N_{\text{good}}(k)\,(1-p)^{5-k}\left(\frac{p}{15}\right)^k,\\
    P_{\text{acc}}(p)&amp;=\sum_{k=0}^{5} N_{\text{acc}}(k)\,(1-p)^{5-k}\left(\frac{p}{15}\right)^k.
\]</div>
<ul>
<li>Then</li>
</ul>
<div class="arithmatex">\[
F_L(p)=\frac{N_{\text{good}}(p)}{P_{\text{acc}}(p)}.
\]</div>
<p>Expanding and collecting powers of p gives the exact rational polynomials</p>
<div class="arithmatex">\[
  N_{\text{good}}(p)&amp;=1-\frac{68}{15}p+\frac{656}{75}p^2-\frac{29312}{3375}p^3+\frac{223232}{50625}p^4-\frac{229376}{253125}p^5,\\
  P_{\text{acc}}(p)&amp;=1-\frac{68}{15}p+\frac{704}{75}p^2-\frac{32768}{3375}p^3+\frac{253952}{50625}p^4-\frac{262144}{253125}p^5,
\]</div>
<p>so that</p>
<div class="arithmatex">\[
F_L(p)=\frac{1-\frac{68}{15}p+\frac{656}{75}p^2-\frac{29312}{3375}p^3+\frac{223232}{50625}p^4-\frac{229376}{253125}p^5}{1-\frac{68}{15}p+\frac{704}{75}p^2-\frac{32768}{3375}p^3+\frac{253952}{50625}p^4-\frac{262144}{253125}p^5}.
\]</div>
<p>Equivalently, multiplying numerator and denominator by 253125 gives integer-coefficient polynomials:</p>
<div class="arithmatex">\[
F_L(p)=\frac{253125-1147500\,p+2214000\,p^2-2198400\,p^3+1116160\,p^4-229376\,p^5}{253125-1147500\,p+2376000\,p^2-2457600\,p^3+1269760\,p^4-262144\,p^5}.
\]</div>
<ul>
<li>Small-p expansion</li>
</ul>
<div class="arithmatex">\[
F_L(p)=1-\frac{16}{25}p^2-\frac{2816}{1500}p^3+O(p^4),
\]</div>
<p>i.e., the logical infidelity is second order in p (as expected for a fault-tolerant, post-selected preparation), with leading coefficient 16/25.</p>
<ol start="2">
<li>Mathematical Typesetting</li>
</ol>
<ul>
<li>See equations above.</li>
</ul>
<ol start="3">
<li>Conventions and Units</li>
</ol>
<ul>
<li>Probabilities are unitless; p is the two-qubit depolarizing probability per CNOT. The measurement is assumed ideal.</li>
</ul>
<ol start="4">
<li>Final Answer:</li>
</ol>
<div class="arithmatex">\[
F_L(p)=\frac{1-\frac{68}{15}p+\frac{656}{75}p^2-\frac{29312}{3375}p^3+\frac{223232}{50625}p^4-\frac{229376}{253125}p^5}{1-\frac{68}{15}p+\frac{704}{75}p^2-\frac{32768}{3375}p^3+\frac{253952}{50625}p^4-\frac{262144}{253125}p^5}\,,
\]</div>
<p>so that for small p,</p>
<div class="arithmatex">\[
F_L(p)=1-\frac{16}{25}p^2+O(p^3).
\]</div></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">253125</span> <span class="o">-</span> <span class="mi">1147500</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2214000</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2198400</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1116160</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">229376</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">253125</span> <span class="o">-</span> <span class="mi">1147500</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2376000</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2457600</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1269760</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">262144</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.653366
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>