<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Define Pauli matrices</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">Z</span><span class="p">}</span>

<span class="c1"># Utility to get n-qubit operator from single-qubit ops dictionary mapping qubit index to op</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="c1"># Create n-qubit gate from single-qubit gate on qubit q</span>

<span class="k">def</span><span class="w"> </span><span class="nf">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">gate</span><span class="p">):</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">gate</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="c1"># Two-qubit Pauli on qubits a,b using labels p1,p2</span>

<span class="k">def</span><span class="w"> </span><span class="nf">two_qubit_pauli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="c1"># CNOT gate on n qubits, control c, target t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="c1"># Build via projectors on control</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">X_t</span> <span class="o">=</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">P0_c</span> <span class="o">=</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">P0</span><span class="p">)</span>
    <span class="n">P1_c</span> <span class="o">=</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">P1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P0_c</span> <span class="o">+</span> <span class="n">P1_c</span> <span class="o">@</span> <span class="n">X_t</span>

<span class="c1"># Projector onto ancilla=0 on qubit 4 of 5-qubit system</span>

<span class="k">def</span><span class="w"> </span><span class="nf">proj_anc0</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">anc_index</span><span class="p">):</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">anc_index</span><span class="p">,</span> <span class="n">P0</span><span class="p">)</span>

<span class="c1"># Extract data state after measuring ancilla in 0 (unnormalized vector)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">project_ancilla0_state</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">anc_index</span><span class="p">):</span>
    <span class="c1"># Equivalent to applying P0 and then renormalizing and discarding ancilla qubit</span>
    <span class="n">P0_op</span> <span class="o">=</span> <span class="n">proj_anc0</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">anc_index</span><span class="p">)</span>
    <span class="n">psi_p</span> <span class="o">=</span> <span class="n">P0_op</span> <span class="o">@</span> <span class="n">psi</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">psi_p</span><span class="p">,</span> <span class="n">psi_p</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span>
    <span class="c1"># Factor out ancilla dimension</span>
    <span class="c1"># Reshape psi into (2^anc, 2^(n-1)) with anc as last or specific? We&#39;ll move anc to last for convenience</span>
    <span class="c1"># We&#39;ll reorder basis to put ancilla as last qubit without permuting too many times: brute force</span>
    <span class="c1"># Simpler: iterate basis states</span>
    <span class="k">return</span> <span class="n">p0</span><span class="p">,</span> <span class="kc">None</span>

<span class="c1"># Let&#39;s implement a function to extract the normalized data vector conditioned on ancilla=0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">data_state_conditional_on_ancilla0</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">anc_index</span><span class="p">):</span>
    <span class="c1"># Build data vector of size 2^(n-1) by selecting entries where ancilla bit=0</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span>
    <span class="n">data_dim</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data_dim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># The bit ordering we use is qubit 0 as most significant or least? In kron, first qubit is leftmost (most significant)</span>
    <span class="c1"># We&#39;ll define basis index bits with qubit 0 as most significant.</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c1"># Determine ancilla bit</span>
        <span class="c1"># Convert idx to n-bit binary</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">idx</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>  <span class="c1"># q=0 is most significant</span>
        <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">anc_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Compute data index by removing ancilla bit</span>
            <span class="n">data_bits</span> <span class="o">=</span> <span class="p">[</span><span class="n">bits</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">q</span> <span class="o">!=</span> <span class="n">anc_index</span><span class="p">]</span>
            <span class="c1"># Convert to integer</span>
            <span class="n">di</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">data_bits</span><span class="p">:</span>
                <span class="n">di</span> <span class="o">=</span> <span class="p">(</span><span class="n">di</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">b</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amp</span>
            <span class="n">p0</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">amp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p0</span><span class="p">,</span> <span class="n">data</span>

<span class="c1"># Build 5-qubit circuit unitary applying gates and inserting after-CNOT errors as specified</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span>
<span class="n">anc</span><span class="o">=</span><span class="mi">4</span>
<span class="c1"># Define the sequence of CNOTs as (control, target)</span>
<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="c1"># Define initial state |00000&gt;</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">psi0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="c1"># Precompute unitary pieces</span>
<span class="n">U_H1</span> <span class="o">=</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="n">U_CNOTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>

<span class="c1"># Build list of two-qubit Pauli labels</span>
<span class="n">pauli_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">pauli_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">pauli_labels</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pauli_labels</span><span class="p">]</span>
<span class="c1"># Index mapping for error on particular pair of qubits</span>
<span class="n">error_pairs_qubits</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="c1"># We&#39;ll enumerate all combinations of 2-qubit errors across the 5 sites.</span>
<span class="c1"># For each site, choose a pair label from pauli_pairs. We&#39;ll treat &#39;II&#39; as identity (no error) with weight (1-p),</span>
<span class="c1"># all others with weight p/15.</span>

<span class="c1"># Precompute two-qubit operators for each site and pair label to speed up</span>
<span class="n">site_error_ops</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">site_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">qa</span><span class="p">,</span> <span class="n">qb</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">error_pairs_qubits</span><span class="p">):</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">pauli_pairs</span><span class="p">:</span>
        <span class="n">ops</span><span class="p">[(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">two_qubit_pauli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">qa</span><span class="p">,</span> <span class="n">qb</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
    <span class="n">site_error_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="c1"># Stabilizer operators on data (qubits 0-3)</span>
<span class="n">Sx_data</span> <span class="o">=</span> <span class="n">kron_n</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">])</span>
<span class="n">Sz_data</span> <span class="o">=</span> <span class="n">kron_n</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">Z</span><span class="p">])</span>
<span class="c1"># Lift to 5-qubit operator acting trivially on ancilla when needed</span>
<span class="n">Sx5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Sx_data</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="n">Sz5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Sz_data</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

<span class="c1"># Ideal logical |00&gt;_L data state</span>
<span class="c1"># |00&gt;_L = (|0000&gt; + |1111&gt;)/sqrt(2)</span>
<span class="n">psi_00L_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">psi_00L_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">psi_00L_data</span><span class="p">[(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Define logical Z operators on data qubits A and B for optional checking (Z_A=ZZII, Z_B=ZIZI)</span>
<span class="n">Z_A</span> <span class="o">=</span> <span class="n">kron_n</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">Z_B</span> <span class="o">=</span> <span class="n">kron_n</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>

<span class="c1"># Function to compute acceptance and fidelity contributions for a given error tuple</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_error_tuple</span><span class="p">(</span><span class="n">err_labels</span><span class="p">):</span>
    <span class="c1"># err_labels: list of length 5, each an (p1,p2) tuple label</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">psi0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">U_H1</span> <span class="o">@</span> <span class="n">psi</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">U_CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">psi</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">site_error_ops</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">err_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">E</span> <span class="o">@</span> <span class="n">psi</span>
    <span class="c1"># Ancilla measurement post-selection probability and data state</span>
    <span class="n">p0</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data_state_conditional_on_ancilla0</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">anc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># no acceptance</span>
    <span class="c1"># Check stabilizers on data</span>
    <span class="c1"># Compute expectations &lt;XXXX&gt; and &lt;ZZZZ&gt;</span>
    <span class="n">eX</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Sx_data</span> <span class="o">@</span> <span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
    <span class="n">eZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Sz_data</span> <span class="o">@</span> <span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
    <span class="c1"># Accept if both +1 (within tolerance)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-9</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">eX</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">eZ</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="c1"># Compute fidelity with |00&gt;_L</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">psi_00L_data</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p0</span> <span class="o">*</span> <span class="n">f</span><span class="p">,</span> <span class="mi">1</span>

<span class="c1"># Enumerate all sequences; accumulate A_k and N_k where k=# non-identity errors</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">count_acc_by_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="c1"># We&#39;ll do nested loops; 16^5 ~ 1,048,576 combos; manageable.</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">pauli_pairs</span>

<span class="k">for</span> <span class="n">l0</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l3</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l4</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="n">err_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">l0</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">l3</span><span class="p">,</span><span class="n">l4</span><span class="p">]</span>
                    <span class="c1"># count k: number of sites where label!=(&#39;I&#39;,&#39;I&#39;)</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">err_labels</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">lab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">))</span>
                    <span class="n">p0</span><span class="p">,</span> <span class="n">contrib</span><span class="p">,</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">process_error_tuple</span><span class="p">(</span><span class="n">err_labels</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">p0</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p0</span>
                        <span class="n">N</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">contrib</span>
                        <span class="n">count_acc_by_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A_k (sum p_anc0 over accepted) by k:&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_k (sum p_anc0 * fidelity) by k:&#39;</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;count accepted sequences by k:&#39;</span><span class="p">,</span> <span class="n">count_acc_by_k</span><span class="p">)</span>

<span class="c1"># Also compute acceptance probability and conditional fidelity for a few p values by combining</span>

<span class="k">def</span><span class="w"> </span><span class="nf">F_of_p</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="c1"># weight factor per k: C = (1-p)^(5-k) * (p/15)^k times multiplicity of sequences.</span>
    <span class="c1"># But our A and N already sum over sequences with their p0; we only need to multiply by those factors.</span>
    <span class="c1"># However, we need to know the number of sequences with given labels combos; we already aggregated across all sequences.</span>
    <span class="c1"># The overall acceptance numerator is sum_k N[k] * (p/15)^k * (1-p)^(5-k)</span>
    <span class="c1"># Denominator acceptance is sum_k A[k] * (p/15)^k * (1-p)^(5-k)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">den</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="n">N</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">den</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">,</span> <span class="n">den</span>

<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]:</span>
    <span class="n">Fp</span><span class="p">,</span> <span class="n">Pac</span> <span class="o">=</span> <span class="n">F_of_p</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Fp</span><span class="p">,</span> <span class="n">Pac</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>A_k (sum p_anc0 over accepted) by k: [0.9999999999999998, 6.999999999999999, 281.99999999999994, 4221.999999999999, 31636.999999999996, 94922.99999999999]
N_k (sum p_anc0 * fidelity) by k: [0.9999999999999998, 6.999999999999999, 137.99999999999997, 1197.9999999999998, 7396.999999999999, 24026.999999999996]
count accepted sequences by k: [1, 7, 282, 4222, 31637, 94923]
0.0 1.0 0.9999999999999998
1e-06 0.99999999999936 0.999995466676053
0.0001 0.9999999935981224 0.9995467605236247
0.001 0.9999993581195541 0.9954760436293114
0.01 0.9999340913140433 0.9555956743560909
0.05 0.9981451484841415 0.7956173988345675
0.1 0.9913903803885744 0.6313155735703704
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="mi">15</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">282</span><span class="p">,</span><span class="mi">4222</span><span class="p">,</span><span class="mi">31637</span><span class="p">,</span><span class="mi">94923</span><span class="p">]</span>
<span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">138</span><span class="p">,</span><span class="mi">1198</span><span class="p">,</span><span class="mi">7397</span><span class="p">,</span><span class="mi">24027</span><span class="p">]</span>
<span class="n">Pac</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="n">Num</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">Num</span><span class="o">/</span><span class="n">Pac</span><span class="p">)</span>
<span class="n">Pac_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">Pac</span><span class="p">)</span>
<span class="n">Num_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">Num</span><span class="p">)</span>
<span class="n">F_series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  <span class="c1"># up to p^5</span>
<span class="n">Pac_series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">Pac_s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pac polynomial:&#39;</span><span class="p">,</span> <span class="n">Pac_s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Num polynomial:&#39;</span><span class="p">,</span> <span class="n">Num_s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F series:&#39;</span><span class="p">,</span> <span class="n">F_series</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pac series:&#39;</span><span class="p">,</span> <span class="n">Pac_series</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Pac polynomial: -262144*p**5/253125 + 253952*p**4/50625 - 32768*p**3/3375 + 704*p**2/75 - 68*p/15 + 1
Num polynomial: -229376*p**5/253125 + 223232*p**4/50625 - 29312*p**3/3375 + 656*p**2/75 - 68*p/15 + 1
F series: 1 - 16*p**2/25 - 704*p**3/375 - 10496*p**4/3375 - 216064*p**5/84375 + O(p**6)
Pac series: -262144*p**5/253125 + 253952*p**4/50625 - 32768*p**3/3375 + 704*p**2/75 - 68*p/15 + 1
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">decimal</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decimal</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span><span class="mi">375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">10496</span><span class="p">,</span><span class="mi">3375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">216064</span><span class="p">,</span><span class="mi">84375</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">])</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>[0.64, 1.8773333333333333, 3.1099259259259258, 2.5607585185185187]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># Verify ideal final state</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">psi0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">U_H1</span> <span class="o">@</span> <span class="n">psi</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">U_CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">psi</span>
<span class="c1"># ancilla 0 projection</span>
<span class="n">p0</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data_state_conditional_on_ancilla0</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">anc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;p0 ideal&#39;</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
<span class="c1"># Compare to |00&gt;_L vector</span>
<span class="n">overlap</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">psi_00L_data</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;overlap with 00L:&#39;</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
<span class="c1"># Check stabilizers</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;stabilizers eX eZ:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Sx_data</span> <span class="o">@</span> <span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Sz_data</span> <span class="o">@</span> <span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
<span class="c1"># Also compute Z_A and Z_B expectations</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Z_A, Z_B =&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Z_A</span> <span class="o">@</span> <span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Z_B</span> <span class="o">@</span> <span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
NameError: name &#39;psi0&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span><span class="w"> </span><span class="nf">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">gate</span><span class="p">):</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">ops</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">gate</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">X_t</span> <span class="o">=</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">P0_c</span> <span class="o">=</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">P0</span><span class="p">)</span>
    <span class="n">P1_c</span> <span class="o">=</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">P1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P0_c</span> <span class="o">+</span> <span class="n">P1_c</span> <span class="o">@</span> <span class="n">X_t</span>

<span class="n">n</span><span class="o">=</span><span class="mi">5</span>
<span class="n">anc</span><span class="o">=</span><span class="mi">4</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">psi0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">U_H1</span> <span class="o">=</span> <span class="n">single_qubit_gate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="n">cnots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">U_CNOTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CNOT</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cnots</span><span class="p">]</span>

<span class="n">psi</span> <span class="o">=</span> <span class="n">psi0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">U_H1</span> <span class="o">@</span> <span class="n">psi</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">U_CNOTs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">psi</span>

<span class="c1"># project ancilla 0</span>
<span class="k">def</span><span class="w"> </span><span class="nf">data_state_conditional_on_ancilla0</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">anc_index</span><span class="p">):</span>
    <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span>
    <span class="n">data_dim</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data_dim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">p0</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">idx</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">anc_index</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">di</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">q</span><span class="o">!=</span><span class="n">anc_index</span><span class="p">:</span>
                    <span class="n">di</span> <span class="o">=</span> <span class="p">(</span><span class="n">di</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="n">bits</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amp</span>
            <span class="n">p0</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">amp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">p0</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p0</span><span class="p">,</span> <span class="n">data</span>

<span class="n">p0</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data_state_conditional_on_ancilla0</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">anc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
<span class="n">Sx_data</span> <span class="o">=</span> <span class="n">kron_n</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">])</span>
<span class="n">Sz_data</span> <span class="o">=</span> <span class="n">kron_n</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">Z</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;eigs&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Sx_data</span><span class="nd">@data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Sz_data</span><span class="nd">@data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
<span class="c1"># Build |00&gt;_L = (|0000&gt;+|1111&gt;)/sqrt(2)</span>
<span class="n">psi_00L_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">psi_00L_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">psi_00L_data</span><span class="p">[(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;overlap&#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">psi_00L_data</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># check Z_A and Z_B</span>
<span class="n">Z_A</span> <span class="o">=</span> <span class="n">kron_n</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="n">Z_B</span> <span class="o">=</span> <span class="n">kron_n</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">I</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Z_A, Z_B&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Z_A</span><span class="nd">@data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">Z_B</span><span class="nd">@data</span><span class="p">))</span><span class="o">.</span><span class="n">real</span> <span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>p0 0.9999999999999998
eigs 1.0000000000000002 1.0000000000000002
overlap 1.0
Z_A, Z_B 1.0000000000000002 1.0000000000000002
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<ul>
<li>Code, stabilizers, logicals, and target</li>
<li>
<p>We work with the [[4,2,2]] stabilizer code on data qubits 0,1,2,3 with stabilizer generators S = {XXXX, ZZZZ}. A standard logical basis is
    |00⟩L = (|0000⟩ + |1111⟩)/√2,
    |01⟩L = (|0011⟩ + |1100⟩)/√2,
    |10⟩L = (|0101⟩ + |1010⟩)/√2,
    |11⟩L = (|0110⟩ + |1001⟩)/√2,
    and one convenient choice of logical operators (up to stabilizers) is X_A = X I X I, X_B = X X I I, Z_A = Z Z I I, Z_B = Z I Z I. This matches the specification in the prompt and the usual presentation of the [[4,2,2]] code. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</p>
</li>
<li>
<p>Ideal, noiseless preparation circuit reaches |00⟩L</p>
</li>
<li>Circuit (right-to-left order): H1 → CNOT12 → CNOT10 → CNOT23 → CNOT34 → CNOT04 → measure ancilla 4 in Z.</li>
<li>Evolving |0000⟩data ⊗ |0⟩4:
    1) H1 prepares (|0⟩1 + |1⟩1)/√2 on qubit 1.
    2) CNOT12, CNOT10 copy qubit-1 into qubits 2 and 0, giving a 3-qubit cat on 1,2,0.
    3) CNOT23 extends cat to qubit 3, yielding (|0000⟩ + |1111⟩)/√2 on 0–3.
    4) CNOT34 and CNOT04 parity-load the ancilla with Z-check parities but, on this cat state, leave ancilla in |0⟩ (the net parity is even) so measuring ancilla returns 0 with unit probability in the ideal case.</li>
<li>
<p>Thus, in the absence of noise the post-selected data state is |00⟩L. (The above steps rely only on standard CNOT/H action.) (<a href="https://en.wikipedia.org/wiki/Controlled_NOT_gate?utm_source=openai">en.wikipedia.org</a>)</p>
</li>
<li>
<p>Noise model (after each two-qubit gate)</p>
</li>
<li>
<p>After each CNOTij we apply a two-qubit depolarizing channel on those two qubits that samples one of the 15 non-identity two-qubit Paulis uniformly with probability p/15 (and identity with probability 1−p). This is the uniform two-qubit Pauli channel; in general, for n qubits, choosing each non-identity Pauli with probability λ/(4^n−1) corresponds to an n-qubit depolarizing channel with parameter λ. For n=2 this gives “15 equally likely non-identity Paulis.” (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>, <a href="https://en.wikipedia.org/wiki/Quantum_depolarizing_channel?utm_source=openai">en.wikipedia.org</a>)</p>
</li>
<li>
<p>Why Clifford+Pauli lets us count exactly</p>
</li>
<li>
<p>The circuit is Clifford and the noise is Pauli. Any Pauli error inserted anywhere propagates through by conjugation under the Clifford circuit to another Pauli on data and ancilla just before measurement. CNOT conjugation rules:
    CNOT(X⊗I)CNOT = X⊗X, CNOT(I⊗X)CNOT = I⊗X, CNOT(Z⊗I)CNOT = Z⊗I, CNOT(I⊗Z)CNOT = Z⊗Z,
    and H permutes X↔Z (and Y→±Y), which ensures we can track errors as Paulis throughout. (<a href="https://wangbard.github.io/posts/Clifford-gates-and-non-Clifford-gates/?utm_source=openai">wangbard.github.io</a>)</p>
</li>
<li>
<p>Post-selection rule</p>
</li>
<li>
<p>We accept only runs where (i) the ancilla measurement yields 0 and (ii) both stabilizers XXXX and ZZZZ return +1 (i.e., the state lies in the code space). If a propagated Pauli anticommutes with either stabilizer, the run is rejected by the stabilizer check; if it flips the ancilla outcome (e.g., an X or Y on the ancilla right before Z measurement in cases when the ancilla would be |0⟩), it is rejected by the ancilla post-selection. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</p>
</li>
<li>
<p>What contributes to logical infidelity for the target |00⟩L?</p>
</li>
<li>
<p>Among Paulis that commute with S (i.e., lie in the normalizer), logical Z-type operators Z_A, Z_B, or Z_A Z_B act trivially on the particular target |00⟩L, because it is the +1 eigenstate of both Z_A and Z_B. In contrast, any logical with an X or Y on A and/or B maps |00⟩L to an orthogonal logical basis state and so reduces fidelity. Therefore, conditional (post-selected) logical infidelity is driven by accepted error events whose net action is a logical X- or Y-type on at least one logical qubit.</p>
</li>
<li>
<p>Exact counting via exhaustive Clifford–Pauli enumeration</p>
</li>
<li>Because there are five two-qubit gates, each followed by a 16-outcome Pauli selection (II with prob 1−p and 15 non-identity with prob p/15), there are 16^5 = 1,048,576 error strings. We exhaustively enumerated all such strings using a stabilizer-state simulation of the 5-qubit circuit (data 0–3 plus ancilla 4):
    1) Apply the ideal gates,
    2) insert the chosen two-qubit Pauli after each CNOT,
    3) compute the probability of ancilla outcome 0 (projective measurement in Z),
    4) post-select on ancilla=0 and check stabilizers XXXX and ZZZZ on data,
    5) for accepted runs, compute fidelity with |00⟩L.</li>
<li>Let k be the number of non-identity errors in a string. Define
    Ak = Σ(accepted strings with k faults) P(ancilla=0 | that string),
    Nk = Σ(accepted strings with k faults) P(ancilla=0 | that string) × Fidelity.
    The overall acceptance probability and conditional fidelity are
    Pacc(p) = Σk Ak (p/15)^k (1−p)^{5−k},  F(p) = [Σk Nk (p/15)^k (1−p)^{5−k}] / Pacc(p).</li>
<li>
<p>Exact enumeration yields the integer sums
    A0=1, A1=7, A2=282, A3=4222, A4=31637, A5=94923,
    N0=1, N1=7, N2=138, N3=1198, N4=7397, N5=24027.
    Two immediate consequences:
    • N1=A1, so there is no linear-in-p logical infidelity after post-selection (all accepted single-fault events are either benign, e.g., logical Z-type on |00⟩L, or stabilizer-equivalent to identity).
    • The leading logical infidelity appears at O(p^2). (These results come purely from the Clifford–Pauli propagation and the specified post-selection.) </p>
</li>
<li>
<p>Closed-form polynomials</p>
</li>
<li>Substituting the Ak, Nk into the definitions gives exact polynomials (after expanding (1−p) factors):
    Pacc(p) = 1 − (68/15)p + (704/75)p^2 − (32768/3375)p^3 + (253952/50625)p^4 − (262144/253125)p^5,
    Numer(p) = 1 − (68/15)p + (656/75)p^2 − (29312/3375)p^3 + (223232/50625)p^4 − (229376/253125)p^5.
    Therefore the post-selected logical fidelity is the rational function
    F(p) = Numer(p) / Pacc(p).</li>
<li>Small-p expansion (to fifth order):
    F(p) = 1 − (16/25)p^2 − (704/375)p^3 − (10496/3375)p^4 − (216064/84375)p^5 + O(p^6).
    Numerically, F(p) = 1 − 0.64 p^2 − 1.877333… p^3 − 3.109925… p^4 − 2.560759… p^5 + O(p^6).</li>
<li>The absence of a linear term confirms fault-tolerance of this flagged preparation against single two-qubit-gate faults under the stated post-selection. (CNOT/H Clifford propagation and the uniform two-qubit depolarizing model used here are standard; see above references.) (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>, <a href="https://wangbard.github.io/posts/Clifford-gates-and-non-Clifford-gates/?utm_source=openai">wangbard.github.io</a>, <a href="https://en.wikipedia.org/wiki/Controlled_NOT_gate?utm_source=openai">en.wikipedia.org</a>, <a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</li>
</ul>
<p>2) Mathematical Typesetting</p>
<ul>
<li>Logical fidelity as a function of two-qubit gate error p:</li>
<li>Let r := p/15. With k the number of non-identity two-qubit faults,
    P_{\mathrm{acc}}(p) = \sum_{k=0}^5 A_k\, r^k (1-p)^{5-k}, \quad
    \mathcal{N}(p) = \sum_{k=0}^5 N_k\, r^k (1-p)^{5-k},
    \quad F(p) = \frac{\mathcal{N}(p)}{P_{\mathrm{acc}}(p)}.</li>
<li>From exhaustive enumeration,
    A_0=1,\; A_1=7,\; A_2=282,\; A_3=4222,\; A_4=31637,\; A_5=94923,
    N_0=1,\; N_1=7,\; N_2=138,\; N_3=1198,\; N_4=7397,\; N_5=24027.</li>
<li>Expanded polynomials:
    P_{\mathrm{acc}}(p) = 1 - \frac{68}{15}p + \frac{704}{75}p^2 - \frac{32768}{3375}p^3 + \frac{253952}{50625}p^4 - \frac{262144}{253125}p^5,
    \
    \mathcal{N}(p) = 1 - \frac{68}{15}p + \frac{656}{75}p^2 - \frac{29312}{3375}p^3 + \frac{223232}{50625}p^4 - \frac{229376}{253125}p^5,
    \
    F(p)=\frac{\mathcal{N}(p)}{P_{\mathrm{acc}}(p)} = 1 - \frac{16}{25}p^2 - \frac{704}{375}p^3 - \frac{10496}{3375}p^4 - \frac{216064}{84375}p^5 + O(p^6).</li>
</ul>
<p>3) Conventions and Units</p>
<ul>
<li>Qubits are dimensionless; probabilities p∈[0,1]. Ordering of qubits is (0,1,2,3,4) with 4 the ancilla. Stabilizers and logicals follow the convention given in the prompt and in the standard [[4,2,2]] presentation. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</li>
</ul>
<p>4) Final Answer:
- The post-selected logical state fidelity as a function of the two-qubit gate error rate p is
  F(p) = [1 − (68/15)p + (656/75)p^2 − (29312/3375)p^3 + (223232/50625)p^4 − (229376/253125)p^5] / [1 − (68/15)p + (704/75)p^2 − (32768/3375)p^3 + (253952/50625)p^4 − (262144/253125)p^5].
  Equivalently, its small-p expansion is
  F(p) = 1 − (16/25)p^2 − (704/375)p^3 − (10496/3375)p^4 − (216064/84375)p^5 + O(p^6).
  In particular, there is no O(p) term: the leading infidelity is 0.64 p^2. (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>, <a href="https://wangbard.github.io/posts/Clifford-gates-and-non-Clifford-gates/?utm_source=openai">wangbard.github.io</a>, <a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#13</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#14</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">656</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">29312</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">223232</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">229376</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">262144</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:09.848426
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>