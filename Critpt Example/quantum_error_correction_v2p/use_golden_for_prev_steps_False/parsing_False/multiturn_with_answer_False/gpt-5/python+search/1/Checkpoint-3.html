<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">üåì</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<ul>
<li>What the circuit prepares ideally</li>
<li>Start in |0000&gt; (qubits ordered 0,1,2,3).</li>
<li>Apply H2: |0&gt;2 ‚Üí (|0&gt;2 + |1&gt;2)/‚àö2.</li>
<li>Apply CNOT21: this entangles qubits 2‚Üí1, giving a Bell state on (2,1):
    |Œ¶+&gt;21 = (|00&gt;21 + |11&gt;21)/‚àö2.</li>
<li>Apply H0 then CNOT03: this prepares a Bell state on (0,3),
    |Œ¶+&gt;03 = (|00&gt;03 + |11&gt;03)/‚àö2.</li>
<li>Hence the ideal final 4-qubit state is the product of two Bell states
    |Œ®ideal&gt; = |Œ¶+&gt;21 ‚äó |Œ¶+&gt;03.
    The Bell state |Œ¶+&gt; is a stabilizer state with generators X‚äóX and Z‚äóZ. (<a href="https://qiskit.qotlabs.org/api/qiskit/qiskit.quantum_info.StabilizerState?utm_source=openai">qiskit.qotlabs.org</a>)</li>
<li>
<p>The ideal state lies in the [[4,2,2]] code space with stabilizers XXXX and ZZZZ, since
    (X0X3)(X2X1) = XXXX and (Z0Z3)(Z2Z1) = ZZZZ both stabilize |Œ¶+&gt;03 ‚äó |Œ¶+&gt;21. This matches the standard [[4,2,2]] code description with stabilizers {XXXX, ZZZZ}. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</p>
</li>
<li>
<p>Noise model (per the problem statement)</p>
</li>
<li>After each two-qubit gate, a two-qubit depolarizing channel applies one of the 15 non-identity two-qubit Pauli operators uniformly at random with probability p/15 each (and applies identity with probability 1‚àíp). This is the standard ‚Äúuniform Pauli‚Äù form of depolarization on two qubits. (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html">qiskit.github.io</a>)</li>
<li>
<p>In our circuit there are exactly two such noise insertions:
    1) after CNOT21 on the pair (2,1); 2) after CNOT03 on the pair (0,3).
    These two noise events act on disjoint qubit pairs and are independent; the subsequent single-qubit H0 and the other CNOT act on different qubits, so they do not transform the earlier (2,1) error.</p>
</li>
<li>
<p>Fidelity reduction for a single Bell pair hit by a 2-qubit depolarizing error</p>
</li>
<li>Let E be the two-qubit Pauli sampled by the (two-qubit) depolarizing channel on a Bell pair.</li>
<li>For the pure target |Œ¶+&gt;, the state fidelity after the Pauli E is
    Fpair = ‚ü®Œ¶+| E |Œ¶+‚ü©‚ü®Œ¶+| E |Œ¶+‚ü© = 1 if E maps |Œ¶+&gt; to itself up to a global phase, and 0 otherwise.</li>
<li>The stabilizer (up to phase) of |Œ¶+&gt; is generated by X‚äóX and Z‚äóZ; consequently the only Paulis that preserve |Œ¶+&gt; up to a phase are
    { I‚äóI, X‚äóX, Z‚äóZ, Y‚äóY }.
    All other two-qubit Paulis take |Œ¶+&gt; to an orthogonal Bell state. (<a href="https://qiskit.qotlabs.org/api/qiskit/qiskit.quantum_info.StabilizerState?utm_source=openai">qiskit.qotlabs.org</a>)</li>
<li>
<p>Under the specified channel on a given pair:
    P(E = I‚äóI) = 1 ‚àí p,
    P(E ‚àà {X‚äóX, Y‚äóY, Z‚äóZ}) = 3 √ó (p/15).
    Therefore
    Fpair(p) = (1 ‚àí p) + 3 (p/15) = 1 ‚àí (12/15) p = 1 ‚àí (4/5) p.</p>
</li>
<li>
<p>Total 4-qubit physical state fidelity</p>
</li>
<li>The two error channels act independently on disjoint pairs (2,1) and (0,3), and the ideal state is the tensor product of the two Bell pairs. Hence the final-state fidelity is the product of the two independent pair fidelities:
    F4q(p) = [Fpair(p)]^2 = [1 ‚àí (4/5) p]^2.</li>
</ul>
<p>2) Mathematical Typesetting</p>
<ul>
<li>Ideal state:</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Single-pair fidelity under the two-qubit depolarizing channel:</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Total fidelity:</li>
</ul>
<div class="arithmatex">\[
    = \left(1-\frac{4}{5}p\right)^2
\]</div>
<p>3) Conventions and Units</p>
<ul>
<li>Qubits are labeled 0,1,2,3; logical qubits A,B; stabilizers XXXX and ZZZZ; logical Paulis as given in the problem statement. The depolarizing probability parameter is p per two-qubit gate as defined above. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>, <a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html">qiskit.github.io</a>)</li>
</ul>
<p>4) Final Answer</p>
<p>Final Answer:
Fphys(p) = [1 ‚àí (4/5)p]^2 = 1 ‚àí (8/5)p + (16/25)p^2.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<ul>
<li>Ideal encoded target and the prepared state</li>
<li>The [[4,2,2]] code has stabilizer generators S = {XXXX, ZZZZ}. We label physical qubits 0,1,2,3. The ideal logical target is the encoded Bell (logical GHZ) state (|00‚ü©AB + |11‚ü©AB)/‚àö2 in the codespace stabilized by S. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>)</li>
<li>The given circuit (right-to-left) H2 ‚Üí CNOT21 ‚Üí H0 ‚Üí CNOT03 prepares two physical Bell pairs on disjoint qubit pairs (2,1) and (0,3):</li>
</ul>
<div class="arithmatex">\[
\]</div>
<div class="codehilite"><pre><span></span><code>A Bell state |Œ¶+‚ü© is a simultaneous +1 eigenstate of X‚äóX and Z‚äóZ; the four Bell states are labeled by the eigenvalue pair (a_x,a_z)‚àà{¬±1}^2. ([en.wikipedia.org](https://en.wikipedia.org/wiki/Bell_state))
</code></pre></div>

<ul>
<li>Noise model and where it appears</li>
<li>
<p>After each two-qubit gate, a 2-qubit depolarizing channel applies, which with probability 1‚àíp does nothing, and with total probability p applies a uniformly random non-identity 2-qubit Pauli (there are 4^2‚àí1=15 of them), each with probability p/15. We have two such insertions: after CNOT21 (on qubits 2,1) and after CNOT03 (on qubits 0,3). Because the two CNOTs act on disjoint pairs, the two error events are independent and never propagate into each other. (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>)</p>
</li>
<li>
<p>How a 2-qubit Pauli acts on a Bell pair</p>
</li>
<li>The stabilizer of |Œ¶+‚ü© is generated by X‚äóX and Z‚äóZ, so the 2-qubit Pauli group partitions into four cosets relative to this stabilizer. Acting on |Œ¶+‚ü©, these cosets map it to exactly one of the four Bell states. In particular, elements in the stabilizer coset {II, XX, ZZ, (‚àí)YY} leave |Œ¶+‚ü© invariant up to a global phase; the other three cosets map |Œ¶+‚ü© to Œ¶‚àí, Œ®+, or Œ®‚àí, respectively. Thus, for a single 2-qubit depolarizing error on a Bell pair:<ul>
<li>Remains |Œ¶+‚ü© with probability</li>
</ul>
</li>
</ul>
<div class="arithmatex">\[
p_0 = (1-p) + 3\frac{p}{15} = 1-\frac{4}{5}p.
\]</div>
<div class="codehilite"><pre><span></span><code>- Becomes each of the other three Bell states with equal probability
</code></pre></div>

<div class="arithmatex">\[
p_1 = \frac{4}{15}p.
\]</div>
<div class="codehilite"><pre><span></span><code>(There are 3 non-identity stabilizer elements and three other cosets of size 4.) ([en.wikipedia.org](https://en.wikipedia.org/wiki/Bell_state), [qiskit.github.io](https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai))
</code></pre></div>

<ul>
<li>What ‚Äúpost-select on all detectable errors‚Äù means here</li>
<li>
<p>We measure the two code stabilizers XXXX and ZZZZ and keep only outcomes with eigenvalue +1 for both. Since XXXX = (X0X3)(X2X1) and ZZZZ = (Z0Z3)(Z2Z1), their measurement outcomes equal the products of the individual pair outcomes for X‚äóX and Z‚äóZ, respectively. If the Bell state on pair (0,3) has labels (a_x,a_z) and on (2,1) has (b_x,b_z), then the code-syndrome is (a_x b_x, a_z b_z). Acceptance (+1,+1) occurs iff (a_x,a_z) = (b_x,b_z), i.e., both pairs end in the same Bell state. Errors that anti-commute with at least one stabilizer are detected and discarded; those commuting with both are undetected (logical) and are kept. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>, <a href="https://learning.quantum.ibm.com/course/foundations-of-quantum-error-correction/the-stabilizer-formalism?utm_source=openai">learning.quantum.ibm.com</a>)</p>
</li>
<li>
<p>Acceptance probability</p>
</li>
<li>The two pairs are independent with the same distribution over Bell labels. Let p0 and p1 be as above. The probability to accept is the probability that both pairs have the same label:</li>
</ul>
<div class="arithmatex">\[
      = \Big(1-\tfrac{4}{5}p\Big)^2 + 3\Big(\tfrac{4}{15}p\Big)^2
\]</div>
<ul>
<li>Logical state conditioned on acceptance and its fidelity</li>
<li>Conditioned on acceptance, the (encoded) 2-qubit logical state is an incoherent mixture of the four orthogonal logical Bell states corresponding to the four Bell labels shared by the two pairs:<ul>
<li>Correct logical target (both pairs Œ¶+): weight p0^2.</li>
<li>Three orthogonal logical Bell states (both pairs Œ¶‚àí, Œ®+, Œ®‚àí): total weight 3 p1^2.</li>
</ul>
</li>
<li>Since these four logical states are mutually orthogonal within the codespace, the logical fidelity with the target equals the posterior probability of the ‚ÄúŒ¶+ and Œ¶+‚Äù branch:</li>
</ul>
<div class="arithmatex">\[
      = \frac{p_0^2}{p_0^2 + 3 p_1^2}
\]</div>
<ul>
<li>Small-p expansion (shows error suppression by post-selection)</li>
<li>Expanding the exact expression:</li>
</ul>
<div class="arithmatex">\[
F_{\text{logical}}(p) = 1 - \frac{16}{75}p^2 + O(p^3),
\]</div>
<div class="codehilite"><pre><span></span><code>i.e., all O(p) logical infidelity is removed by post-selection, consistent with the distance-2, error-detecting nature of the [[4,2,2]] code. ([errorcorrectionzoo.org](https://errorcorrectionzoo.org/c/stab_4_2_2))
</code></pre></div>

<p>2) Mathematical Typesetting</p>
<ul>
<li>Single-pair output probabilities under depolarizing noise:</li>
</ul>
<div class="arithmatex">\[
p_0 = 1-\frac{4}{5}p,\qquad p_1 = \frac{4}{15}p.
\]</div>
<ul>
<li>Acceptance probability:</li>
</ul>
<div class="arithmatex">\[
P_{\text{acc}}(p) = p_0^2 + 3p_1^2 = 1 - \frac{8}{5}p + \frac{64}{75}p^2.
\]</div>
<ul>
<li>Logical fidelity (post-selected):</li>
</ul>
<div class="arithmatex">\[
    = \frac{p_0^2}{p_0^2 + 3p_1^2}
    = \frac{\big(1-\frac{4}{5}p\big)^2}
           {1 - \frac{8}{5}p + \frac{64}{75}p^2}
\]</div>
<p>3) Conventions and Units</p>
<ul>
<li>Physical qubits ordered (0,1,2,3). Logical qubits (A,B). Stabilizers S = {XXXX, ZZZZ}. Two-qubit depolarizing noise of strength p appended after each CNOT gate; no other noise. Post-selection keeps only +1 outcomes on both stabilizers. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>, <a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>)</li>
</ul>
<p>4) Final Answer:
F_logical(p) = [(1 ‚àí 4p/5)^2] / [1 ‚àí (8/5)p + (64/75)p^2] = 1 ‚àí (16/75)p^2 + O(p^3).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>

<span class="c1"># Define basic matrices</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="c1"># Pauli dict</span>
<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="n">I</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">X</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="n">Y</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">:</span><span class="n">Z</span><span class="p">}</span>
<span class="n">pauli_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

<span class="c1"># Utilities to build n-qubit ops</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span><span class="w"> </span><span class="nf">embed_single</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># op acts on qubit q (0-indexed, with 0 as leftmost? We&#39;ll choose qubit ordering 0..n-1 left-to-right.)</span>
    <span class="c1"># We&#39;ll map qubit index 0 as most significant bit (leftmost in tensor ordering)</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span> <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">q</span> <span class="k">else</span> <span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">embed_two</span><span class="p">(</span><span class="n">opA</span><span class="p">,</span> <span class="n">qA</span><span class="p">,</span> <span class="n">opB</span><span class="p">,</span> <span class="n">qB</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># return operator acting with opA on qA and opB on qB, identity elsewhere</span>
    <span class="c1"># qubits are 0..n-1 left-to-right</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">qA</span><span class="p">:</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opA</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="n">qB</span><span class="p">:</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opB</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="c1"># Build full matrix of CNOT on n qubits</span>
    <span class="c1"># Using projector method: |0&gt;&lt;0|_c ‚äó I + |1&gt;&lt;1|_c ‚äó X_t</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">term0</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">control</span><span class="p">)</span>
    <span class="n">term1</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">control</span><span class="p">)</span>
    <span class="n">Xt</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span> <span class="o">+</span> <span class="n">term1</span> <span class="o">@</span> <span class="n">Xt</span>

<span class="c1"># Stabilizers for data qubits 0..3 (ancilla is qubit 4)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">stabilizer_projector</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># n includes ancilla qubit as highest index (4)</span>
    <span class="c1"># Build XXXX and ZZZZ on data qubits only (0..3)</span>
    <span class="n">X4</span> <span class="o">=</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">@</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># X on 0,1,2,3</span>
    <span class="c1"># But embed_two only handles two qubits; we build product of XX on (0,1) and (2,3)</span>
    <span class="c1"># Actually above line is correct: apply XX on 0-1 then on 2-3; they commute</span>
    <span class="n">Z4</span> <span class="o">=</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">@</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">Iall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">Iall</span> <span class="o">+</span> <span class="n">X4</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">@</span> <span class="p">(</span><span class="n">Iall</span> <span class="o">+</span> <span class="n">Z4</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">P</span>

<span class="c1"># Target logical |00&gt; state on data qubits is (|0000&gt;+|1111&gt;)/sqrt(2)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">logical00_state</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># n=5 qubits, with ancilla 4; we return vector in full Hilbert space with ancilla |0&gt;</span>
    <span class="n">ket0000</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ket1111</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1"># index mapping: basis index with qubits 0..4: basis bits b0 b1 b2 b3 b4; state index int(b0...b4,2)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">idx</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>
        <span class="n">val</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="c1"># ancilla fixed 0</span>
    <span class="n">ket0000</span><span class="p">[</span><span class="n">idx</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">ket1111</span><span class="p">[</span><span class="n">idx</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="n">ket0000</span> <span class="o">+</span> <span class="n">ket1111</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">state</span>

<span class="c1"># Build the noiseless state prep unitary</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="c1"># Apply operations right-to-left: H1, CNOT12, CNOT10, CNOT23, CNOT34, CNOT04</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">@</span> <span class="n">U</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">@</span> <span class="n">U</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">@</span> <span class="n">U</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">U</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">U</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">U</span>

<span class="c1"># Verify that U |00000&gt; yields |overline{00} on data, ancilla 0</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">psi0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">psi0</span>

<span class="c1"># compute overlap with logical00_state</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">logical00_state</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">ov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noiseless overlap amplitude with |L00, a0&gt;:&#39;</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Squared magnitude:&#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ov</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Build projector onto ancilla |0&gt;</span>
<span class="n">P_a0</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">),</span> <span class="n">n</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="n">stabilizer_projector</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># Confirm acceptance prob noiseless</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">P_a0</span> <span class="o">@</span> <span class="n">P_code</span> <span class="o">@</span> <span class="n">psi</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noiseless acceptance probability:&#39;</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>

<span class="c1"># Generate list of 15 non-identity two-qubit Paulis on a given pair as label tuples</span>
<span class="n">nonId_two_paulis</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">pauli_labels</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pauli_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">nonId_two_paulis</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>

<span class="c1"># Define function to embed two-qubit Pauli on specific qubit pair</span>

<span class="k">def</span><span class="w"> </span><span class="nf">two_qubit_pauli_op</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">label_pair</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">label_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">label_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="c1"># Function to simulate with specific error tuple for up to two faults</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_with_errors</span><span class="p">(</span><span class="n">errors</span><span class="p">):</span>
    <span class="c1"># errors is dict mapping gate index to label pair, gate indices 1..5 for the five CNOTs in order [12,10,23,34,04]</span>
    <span class="c1"># Build the unitary with errors inserted after each CNOT</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># We&#39;ll apply sequentially starting from |000..0&gt;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">psi0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># define sequence: H1, CNOT12, E1, CNOT10, E2, CNOT23, E3, CNOT34, E4, CNOT04, E5</span>
    <span class="c1"># H1</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT12</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_qubit_pauli_op</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT10</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_qubit_pauli_op</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT23</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_qubit_pauli_op</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT34</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">4</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_qubit_pauli_op</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT04</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">5</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_qubit_pauli_op</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>

    <span class="c1"># Compute acceptance probability and correct-target probability</span>
    <span class="c1"># acceptance projector P = P_code ‚äó |0&gt;&lt;0|_a</span>
    <span class="n">P_acc</span> <span class="o">=</span> <span class="n">P_a0</span> <span class="o">@</span> <span class="n">P_code</span>
    <span class="n">psi_acc</span> <span class="o">=</span> <span class="n">P_acc</span> <span class="o">@</span> <span class="n">state</span>
    <span class="n">p_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">psi_acc</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># ||P psi||^2, since P is projector but order matters? Here it&#39;s &lt;psi|P|psi&gt;</span>
    <span class="c1"># Correct-target projector</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">logical00_state</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># includes ancilla 0</span>
    <span class="n">P_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>
    <span class="n">p_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">P_target</span> <span class="o">@</span> <span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="c1"># But p_target includes ancilla=0 implicitly and no stabilizer measurement; Actually phi lies in code subspace, so P_target &lt;= P_acc</span>
    <span class="k">return</span> <span class="n">p_acc</span><span class="p">,</span> <span class="n">p_target</span>

<span class="c1"># Enumerate 0,1,2-fault cases and compute coefficients</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="c1"># Gate mapping indices and qubit pairs</span>
<span class="n">pairs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">:(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">:(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="mi">5</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)}</span>

<span class="c1"># 0 faults</span>
<span class="n">pacc0</span><span class="p">,</span> <span class="n">ptarget0</span> <span class="o">=</span> <span class="n">simulate_with_errors</span><span class="p">({})</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;0 faults: P_acc=&#39;</span><span class="p">,</span> <span class="n">pacc0</span><span class="p">,</span> <span class="s1">&#39;P_target=&#39;</span><span class="p">,</span> <span class="n">ptarget0</span><span class="p">)</span>

<span class="c1"># 1 fault cases</span>
<span class="n">acc1</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">cor1</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">nonId_two_paulis</span><span class="p">:</span>
        <span class="n">pacc</span><span class="p">,</span> <span class="n">ptgt</span> <span class="o">=</span> <span class="n">simulate_with_errors</span><span class="p">({</span><span class="n">gi</span><span class="p">:</span> <span class="n">lab</span><span class="p">})</span>
        <span class="n">acc1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pacc</span><span class="p">)</span>
        <span class="n">cor1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptgt</span><span class="p">)</span>

<span class="n">acc1_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">acc1</span><span class="p">))</span>
<span class="n">cor1_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cor1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum over single fault P_acc contributions (unweighted):&#39;</span><span class="p">,</span> <span class="n">acc1_sum</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum over single fault P_target contributions (unweighted):&#39;</span><span class="p">,</span> <span class="n">cor1_sum</span><span class="p">)</span>

<span class="c1"># 2 fault cases</span>
<span class="n">acc2</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">cor2</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">gi</span><span class="p">,</span> <span class="n">gj</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab1</span> <span class="ow">in</span> <span class="n">nonId_two_paulis</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">lab2</span> <span class="ow">in</span> <span class="n">nonId_two_paulis</span><span class="p">:</span>
            <span class="n">pacc</span><span class="p">,</span> <span class="n">ptgt</span> <span class="o">=</span> <span class="n">simulate_with_errors</span><span class="p">({</span><span class="n">gi</span><span class="p">:</span> <span class="n">lab1</span><span class="p">,</span> <span class="n">gj</span><span class="p">:</span> <span class="n">lab2</span><span class="p">})</span>
            <span class="n">acc2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pacc</span><span class="p">)</span>
            <span class="n">cor2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptgt</span><span class="p">)</span>

<span class="n">acc2_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">acc2</span><span class="p">))</span>
<span class="n">cor2_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cor2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum over two-fault P_acc contributions (unweighted):&#39;</span><span class="p">,</span> <span class="n">acc2_sum</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum over two-fault P_target contributions (unweighted):&#39;</span><span class="p">,</span> <span class="n">cor2_sum</span><span class="p">)</span>

<span class="c1"># Now assemble series up to O(p^2)</span>
<span class="c1"># Using weights: k=0: (1 - 5p + 10 p^2), k=1: (p/15 - 4 p^2/15), k=2: (p^2/225)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">Pacc_series</span> <span class="o">=</span> <span class="p">(</span><span class="n">pacc0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
               <span class="o">+</span> <span class="p">(</span><span class="n">acc1_sum</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span>
               <span class="o">+</span> <span class="p">(</span><span class="n">acc2_sum</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">225</span><span class="p">))</span>
<span class="n">Pcor_series</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptarget0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
               <span class="o">+</span> <span class="p">(</span><span class="n">cor1_sum</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span>
               <span class="o">+</span> <span class="p">(</span><span class="n">cor2_sum</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">225</span><span class="p">))</span>
<span class="n">Pacc_series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">Pacc_series</span><span class="p">))</span>
<span class="n">Pcor_series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">Pcor_series</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pacc_series:&#39;</span><span class="p">,</span> <span class="n">Pacc_series</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pcor_series:&#39;</span><span class="p">,</span> <span class="n">Pcor_series</span><span class="p">)</span>
<span class="c1"># Fidelity F = Pcor_series / Pacc_series up to O(p^2)</span>
<span class="n">F_series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">Pcor_series</span> <span class="o">/</span> <span class="n">Pacc_series</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># series up to p^2</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fidelity series up to O(p^2):&#39;</span><span class="p">,</span> <span class="n">F_series</span><span class="p">)</span>

<span class="c1"># Also give exact rational coefficients numerically</span>
<span class="n">F2_coeff</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">F_series</span><span class="o">.</span><span class="n">removeO</span><span class="p">())</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Quadratic coefficient (p^2 term) in infidelity 1-F:&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">F2_coeff</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F_series no O():&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">F_series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()))</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Noiseless overlap amplitude with |L00, a0&gt;: (0.4999999999999999+0j)
Squared magnitude: 0.2499999999999999
Noiseless acceptance probability: 0.24999999999999994
0 faults: P_acc= 0.9999999999999998 P_target= 0.9999999999999997
Sum over single fault P_acc contributions (unweighted): 6.999999999999998
Sum over single fault P_target contributions (unweighted): 6.999999999999997
Sum over two-fault P_acc contributions (unweighted): 281.9999999999999
Sum over two-fault P_target contributions (unweighted): 137.99999999999994
Pacc_series: 9.38666666666666*p**2 - 4.53333333333333*p + 1.0
Pcor_series: 8.74666666666666*p**2 - 4.53333333333333*p + 1.0
Fidelity series up to O(p^2): 1.0 - 0.639999999999999*p**2 + O(p**3)
Quadratic coefficient (p^2 term) in infidelity 1-F: 0
F_series no O(): 1.0 - 0.639999999999999*p**2
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Exact sums as integers</span>
<span class="n">acc1_sum</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">cor1_sum</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">acc2_sum</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">282</span><span class="p">)</span>
<span class="n">cor2_sum</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">138</span><span class="p">)</span>
<span class="c1"># Base terms</span>
<span class="n">pacc0</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ptarget0</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Pacc_series</span> <span class="o">=</span> <span class="p">(</span><span class="n">pacc0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
               <span class="o">+</span> <span class="p">(</span><span class="n">acc1_sum</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span>
               <span class="o">+</span> <span class="p">(</span><span class="n">acc2_sum</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">225</span><span class="p">))</span>
<span class="n">Pcor_series</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptarget0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
               <span class="o">+</span> <span class="p">(</span><span class="n">cor1_sum</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">15</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">15</span><span class="p">)</span>
               <span class="o">+</span> <span class="p">(</span><span class="n">cor2_sum</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">225</span><span class="p">))</span>
<span class="n">Pacc_series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">Pacc_series</span><span class="p">))</span>
<span class="n">Pcor_series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">Pcor_series</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pacc_series exact:&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">(</span><span class="n">Pacc_series</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pcor_series exact:&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">(</span><span class="n">Pcor_series</span><span class="p">))</span>
<span class="n">F_series</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">Pcor_series</span> <span class="o">/</span> <span class="n">Pacc_series</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F series:&#39;</span><span class="p">,</span> <span class="n">F_series</span><span class="p">)</span>
<span class="n">F2</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">F_series</span><span class="o">.</span><span class="n">removeO</span><span class="p">())</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Coeff p^2:&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">(</span><span class="n">F2</span><span class="p">))</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Pacc_series exact: 704*p**2/75 - 68*p/15 + 1
Pcor_series exact: 656*p**2/75 - 68*p/15 + 1
F series: 1 - 16*p**2/25 + O(p**3)
Coeff p^2: -16/25
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>

<span class="c1"># Rebuild from previous run</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="n">I</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">X</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="n">Y</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">:</span><span class="n">Z</span><span class="p">}</span>
<span class="n">pauli_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span><span class="w"> </span><span class="nf">embed_single</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span> <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">q</span> <span class="k">else</span> <span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">embed_two</span><span class="p">(</span><span class="n">opA</span><span class="p">,</span> <span class="n">qA</span><span class="p">,</span> <span class="n">opB</span><span class="p">,</span> <span class="n">qB</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">qA</span><span class="p">:</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opA</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="n">qB</span><span class="p">:</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opB</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">term0</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">control</span><span class="p">)</span>
    <span class="n">term1</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">control</span><span class="p">)</span>
    <span class="n">Xt</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">term0</span> <span class="o">+</span> <span class="n">term1</span> <span class="o">@</span> <span class="n">Xt</span>

<span class="n">n</span><span class="o">=</span><span class="mi">5</span>
<span class="n">P_a0</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">),</span> <span class="n">n</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">X4</span> <span class="o">=</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">@</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="n">Z4</span> <span class="o">=</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">@</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="n">Iall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="p">(</span><span class="n">Iall</span> <span class="o">+</span> <span class="n">X4</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">@</span> <span class="p">(</span><span class="n">Iall</span> <span class="o">+</span> <span class="n">Z4</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

<span class="n">nonId_two_paulis</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">pauli_labels</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pauli_labels</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">two_qubit_pauli_op</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">label_pair</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">label_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">label_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="n">pairs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">:(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">:(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="mi">5</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)}</span>

<span class="n">psi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">psi0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1"># sequence</span>
<span class="n">seq</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>

<span class="c1"># Build unitaries for fixed sequence</span>
<span class="n">Us</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;H&#39;</span><span class="p">:</span>
        <span class="n">Us</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">embed_single</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;CNOT&#39;</span><span class="p">:</span>
        <span class="n">c</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Us</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Us</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># Precompute two-qubit Pauli ops for each gate index</span>
<span class="n">Eops</span> <span class="o">=</span> <span class="p">{</span><span class="n">gi</span><span class="p">:</span> <span class="p">[</span><span class="n">two_qubit_pauli_op</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">pairs</span><span class="p">[</span><span class="n">gi</span><span class="p">],</span> <span class="n">lab</span><span class="p">)</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">nonId_two_paulis</span><span class="p">]</span> <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)}</span>

<span class="c1"># Function to compute p_acc and p_target given set of faulty gates and their indices in list of 15 errors</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_faults</span><span class="p">(</span><span class="n">faults</span><span class="p">):</span>
    <span class="c1"># faults: dict of gi -&gt; idx (0..14) into nonId_two_paulis</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">psi0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">u_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;E&#39;</span><span class="p">:</span>
            <span class="n">gi</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">faults</span><span class="p">:</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">Eops</span><span class="p">[</span><span class="n">gi</span><span class="p">][</span><span class="n">faults</span><span class="p">[</span><span class="n">gi</span><span class="p">]]</span> <span class="o">@</span> <span class="n">state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">Us</span><span class="p">[</span><span class="n">u_idx</span><span class="p">]</span> <span class="o">@</span> <span class="n">state</span>
            <span class="n">u_idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># acceptance and target</span>
    <span class="n">P_acc</span> <span class="o">=</span> <span class="n">P_a0</span> <span class="o">@</span> <span class="n">P_code</span>
    <span class="n">psi_acc</span> <span class="o">=</span> <span class="n">P_acc</span> <span class="o">@</span> <span class="n">state</span>
    <span class="n">p_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">psi_acc</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="c1"># target projector</span>
    <span class="c1"># Build target |L00,a0&gt;</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="c1"># indices for |0000,0&gt; and |1111,0&gt;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">idx</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">idx</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">idx</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">p_tgt</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">p_acc</span><span class="p">,</span> <span class="n">p_tgt</span>

<span class="c1"># Enumerate k=3 faults</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
<span class="n">acc3_sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">cor3_sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">gates</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
    <span class="c1"># iterate over all 15^3 choices</span>
    <span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">faults</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span><span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gates</span><span class="p">,</span> <span class="n">idxs</span><span class="p">)}</span>
        <span class="n">pacc</span><span class="p">,</span> <span class="n">ptgt</span> <span class="o">=</span> <span class="n">simulate_faults</span><span class="p">(</span><span class="n">faults</span><span class="p">)</span>
        <span class="n">acc3_sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">pacc</span><span class="p">))</span>
        <span class="n">cor3_sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ptgt</span><span class="p">))</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Enumerated cases:&#39;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum accepted k=3:&#39;</span><span class="p">,</span> <span class="n">acc3_sum</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum correct k=3:&#39;</span><span class="p">,</span> <span class="n">cor3_sum</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="n">Traceback</span><span class="w"> </span><span class="p">(</span><span class="n">most</span><span class="w"> </span><span class="n">recent</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">last</span><span class="p">):</span>
<span class="w">  </span><span class="n">File</span><span class="w"> </span><span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">122</span><span class="p">,</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">File</span><span class="w"> </span><span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">93</span><span class="p">,</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">simulate_faults</span>
<span class="n">ValueError</span><span class="p">:</span><span class="w"> </span><span class="n">matmul</span><span class="p">:</span><span class="w"> </span><span class="n">Input</span><span class="w"> </span><span class="n">operand</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">enough</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="p">(</span><span class="n">has</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">gufunc</span><span class="w"> </span><span class="n">core</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">signature</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="err">?</span><span class="p">,</span><span class="n">k</span><span class="p">),(</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="err">?</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">n</span><span class="err">?</span><span class="p">,</span><span class="n">m</span><span class="err">?</span><span class="p">)</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span><span class="o">,</span><span class="w"> </span><span class="nn">itertools</span>
<span class="c1"># Rebuild environment again</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="n">paulis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="n">I</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">X</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="n">Y</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">:</span><span class="n">Z</span><span class="p">}</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="n">nonId</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span><span class="w"> </span><span class="nf">embed_single</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span> <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">q</span> <span class="k">else</span> <span class="n">I</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">embed_two</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">qA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">qB</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">ops</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">qA</span><span class="p">:</span>
            <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">A</span>
        <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="n">qB</span><span class="p">:</span>
            <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">B</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">I</span>
    <span class="k">return</span> <span class="n">kron_n</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">@</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>

<span class="n">n</span><span class="o">=</span><span class="mi">5</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">);</span> <span class="n">psi0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">P_a0</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">),</span> <span class="n">n</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">X4</span> <span class="o">=</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">@</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="n">Z4</span> <span class="o">=</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">@</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="n">P_code</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">X4</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">@</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">Z4</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

<span class="n">pairs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">:(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">:(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="mi">5</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">two_pauli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">lab</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span> <span class="n">B</span> <span class="o">=</span> <span class="n">paulis</span><span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">embed_two</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">q1</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">q2</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_with_errors</span><span class="p">(</span><span class="n">errors</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">psi0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># H1</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">embed_single</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT12, then error 1</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_pauli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT10, error 2</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_pauli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT23, error 3</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_pauli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT34, error 4</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">4</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_pauli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># CNOT04, error 5</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">cnot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">@</span> <span class="n">state</span>
    <span class="k">if</span> <span class="mi">5</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">two_pauli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">errors</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
    <span class="c1"># acceptance</span>
    <span class="n">P_acc</span> <span class="o">=</span> <span class="n">P_a0</span> <span class="o">@</span> <span class="n">P_code</span>
    <span class="n">p_acc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">P_acc</span> <span class="o">@</span> <span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="c1"># target</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">idx</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">idx</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">idx</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">p_tgt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p_acc</span><span class="p">,</span> <span class="n">p_tgt</span>

<span class="c1"># quick check</span>
<span class="n">pacc0</span><span class="p">,</span> <span class="n">ptgt0</span> <span class="o">=</span> <span class="n">simulate_with_errors</span><span class="p">({})</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;0-fault check acc, tgt:&#39;</span><span class="p">,</span> <span class="n">pacc0</span><span class="p">,</span> <span class="n">ptgt0</span><span class="p">)</span>

<span class="c1"># 3-fault enumeration counts</span>
<span class="n">acc3_sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">cor3_sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">gates</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">lab1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lab2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">lab3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="n">gates</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">nonId</span><span class="p">[</span><span class="n">lab1</span><span class="p">],</span> <span class="n">gates</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">nonId</span><span class="p">[</span><span class="n">lab2</span><span class="p">],</span> <span class="n">gates</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">nonId</span><span class="p">[</span><span class="n">lab3</span><span class="p">]}</span>
                <span class="n">pacc</span><span class="p">,</span> <span class="n">ptgt</span> <span class="o">=</span> <span class="n">simulate_with_errors</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
                <span class="c1"># Expect pacc &amp; ptgt to be 0 or 1; accumulate ints using round</span>
                <span class="n">acc3_sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">pacc</span><span class="p">))</span>
                <span class="n">cor3_sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ptgt</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k=3 sums:&#39;</span><span class="p">,</span> <span class="n">acc3_sum</span><span class="p">,</span> <span class="n">cor3_sum</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#13</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="mf">0</span><span class="o">-</span><span class="n">fault</span><span class="w"> </span><span class="n">check</span><span class="w"> </span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="n">tgt</span><span class="p">:</span><span class="w"> </span><span class="mf">0.9999999999999998</span><span class="w"> </span><span class="mf">0.9999999999999996</span>
<span class="n">k</span><span class="o">=</span><span class="mf">3</span><span class="w"> </span><span class="n">sums</span><span class="p">:</span><span class="w"> </span><span class="mf">4222</span><span class="w"> </span><span class="mf">1198</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#14</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span><span class="o">,</span><span class="w"> </span><span class="nn">itertools</span>
<span class="c1"># Reuse previously defined functions in this session</span>

<span class="n">nonId</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)]</span>

<span class="c1"># We&#39;ll import simulate_with_errors from previous cell; it&#39;s defined.</span>

<span class="n">acc4_sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">cor4_sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">gates</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="n">gates</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">nonId</span><span class="p">[</span><span class="n">idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)}</span>
        <span class="n">pacc</span><span class="p">,</span> <span class="n">ptgt</span> <span class="o">=</span> <span class="n">simulate_with_errors</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
        <span class="n">acc4_sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">pacc</span><span class="p">))</span>
        <span class="n">cor4_sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ptgt</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k=4 sums:&#39;</span><span class="p">,</span> <span class="n">acc4_sum</span><span class="p">,</span> <span class="n">cor4_sum</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#15</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 13, in &lt;module&gt;
NameError: name &#39;simulate_with_errors&#39; is not defined
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#16</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<ul>
<li>Ideal target and the (fault‚Äëtolerant) preparation circuit</li>
<li>Data qubits: 0,1,2,3. Ancilla (flag): 4 initialized in |0‚ü©.</li>
<li>Circuit (right-to-left): H1, CNOT12, CNOT10, CNOT23, CNOT34, CNOT04, then measure qubit 4.</li>
<li>Without noise, after H1‚ÜíCNOT12‚ÜíCNOT10‚ÜíCNOT23 the data end in
    |œàdata‚ü© = (|0000‚ü© + |1111‚ü©)/‚àö2 = |overline{00}‚ü©, which is a +1 eigenstate of XXXX and ZZZZ (the [[4,2,2]] code stabilizers). The code‚Äôs logical basis states are, e.g., |overline{00}‚ü© = (|0000‚ü©+|1111‚ü©)/‚àö2. The code is [[4,2,2]] with stabilizers XXXX, ZZZZ. The stated logicals are consistent with standard presentations. (<a href="https://ar5iv.labs.arxiv.org/html/1907.11157?utm_source=openai">ar5iv.labs.arxiv.org</a>, <a href="https://arxiv.org/html/2405.03032v1?utm_source=openai">arxiv.org</a>)</li>
<li>
<p>The last two gates CNOT34, CNOT04 implement a Z-parity check between data qubits 3 and 0 onto ancilla 4: starting with ancilla |0‚ü©, the measurement outcome is b4 = b3 ‚äï b0, so ancilla=|0‚ü© means even ZZ parity. This is the usual two‚ÄëCNOT parity‚Äëmeasurement pattern. (<a href="https://en.wikipedia.org/wiki/Parity_measurement?utm_source=openai">en.wikipedia.org</a>)</p>
</li>
<li>
<p>Noise model and post-selection</p>
</li>
<li>After each two-qubit gate, a two‚Äëqubit depolarizing error acts: with probability 1‚àíp nothing happens; with total probability p, one of the 15 non‚Äëidentity two‚Äëqubit Pauli operators is applied, each with probability p/15. This is the ‚Äúuniform Pauli‚Äù parametrization of an n‚Äëqubit depolarizing channel. (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>)</li>
<li>There are five two-qubit gates in the circuit, hence five independent error locations: after CNOT12, CNOT10, CNOT23, CNOT34, CNOT04.</li>
<li>
<p>We post-select on ancilla measuring |0‚ü© and on passing both code stabilizers XXXX=+1 and ZZZZ=+1 (i.e., projection into the codespace). (<a href="https://ar5iv.labs.arxiv.org/html/1907.11157?utm_source=openai">ar5iv.labs.arxiv.org</a>)</p>
</li>
<li>
<p>What contributes to logical infidelity?</p>
</li>
<li>Let Pacc be the total acceptance probability and Pcor the accepted weight in the target logical state |overline{00}‚ü©. The logical fidelity is Flog(p) = Pcor/Pacc.</li>
<li>
<p>A single fault (one two-qubit Pauli at one location) is either detected (flag 1 and/or stabilizer ‚àí1) or, if accepted, is stabilizer-equivalent and leaves the encoded state unchanged. Therefore all O(p) contributions to logical infidelity vanish; this is the hallmark of fault-tolerance for this flagged preparation. We verify this explicitly below.</p>
</li>
<li>
<p>Exhaustive Pauli enumeration to second order (exact counting)</p>
</li>
<li>Because the circuit and projectors are all Clifford/Pauli, for each fixed fault pattern the acceptance indicators are deterministic. We exhaustively enumerated every single- and double-fault two-qubit Pauli pattern under the stated model and computed:
    ‚Ä¢ For k=0 faults: accept = 1; correct = 1.
    ‚Ä¢ For k=1 (5√ó15=75 patterns): the sum over patterns of acceptance indicators equals 7; the sum over ‚Äúcorrect‚Äù indicators also equals 7. Hence all accepted single faults are logically correct (no O(p) infidelity).
    ‚Ä¢ For k=2 (10√ó15^2=2250 patterns): the sum of accept indicators is 282; the sum of ‚Äúcorrect‚Äù indicators is 138; hence 282‚àí138=144 two‚Äëfault patterns are accepted but land in the wrong logical state.
    These integers were obtained by an exact state‚Äëvector simulation with projections onto ancilla |0‚ü© and the codespace, then counting accepted/target outcomes for each Pauli pattern; details match the projectors S used in typical [[4,2,2]] analyses. (<a href="https://arxiv.org/html/2405.03032v2?utm_source=openai">arxiv.org</a>)</li>
<li>From these counts we assemble Pacc and Pcor to order p^2. Expand each term to O(p^2) using (1‚àíp)^m = 1 ‚àí m p + m(m‚àí1)p^2/2:
    ‚Ä¢ Weight of exactly k faults at specified locations with given Paulis is (1‚àíp)^(5‚àík) (p/15)^k.
    ‚Ä¢ Hence
      Pacc(p) = 1¬∑(1‚àíp)^5 + 7¬∑(p/15)(1‚àíp)^4 + 282¬∑(p/15)^2(1‚àíp)^3 + O(p^3),
      Pcor(p) = 1¬∑(1‚àíp)^5 + 7¬∑(p/15)(1‚àíp)^4 + 138¬∑(p/15)^2(1‚àíp)^3 + O(p^3).
    ‚Ä¢ Expanding and collecting terms yields
      Pacc(p) = 1 ‚àí (68/15)p + (704/75)p^2 + O(p^3),
      Pcor(p) = 1 ‚àí (68/15)p + (656/75)p^2 + O(p^3).</li>
<li>Logical fidelity (post‚Äëselected):
    Flog(p) = Pcor/Pacc = 1 ‚àí (16/25) p^2 + O(p^3).
    The linear term cancels, as expected for a distance‚Äë2, flagged fault‚Äëtolerant preparation. (<a href="https://ar5iv.labs.arxiv.org/html/1907.11157?utm_source=openai">ar5iv.labs.arxiv.org</a>)</li>
</ul>
<p>2) Mathematical Typesetting</p>
<ul>
<li>Ideal encoded target and checks:</li>
</ul>
<div class="arithmatex">\[
\]</div>
<ul>
<li>Post-selection acceptance and correct weight to O(p^2):</li>
</ul>
<div class="arithmatex">\[
  P_{\text{acc}}(p) &amp;= (1-p)^5 + 7\,\frac{p}{15}(1-p)^4 + 282\left(\frac{p}{15}\right)^2(1-p)^3 + O(p^3)\\
                    &amp;= 1 - \frac{68}{15}p + \frac{704}{75}p^2 + O(p^3),\\[4pt]
  P_{\text{cor}}(p) &amp;= (1-p)^5 + 7\,\frac{p}{15}(1-p)^4 + 138\left(\frac{p}{15}\right)^2(1-p)^3 + O(p^3)\\
                    &amp;= 1 - \frac{68}{15}p + \frac{656}{75}p^2 + O(p^3).
\]</div>
<ul>
<li>Logical fidelity (post‚Äëselected on ancilla |0‚ü© and codespace):</li>
</ul>
<div class="arithmatex">\[
\]</div>
<p>3) Conventions and Units</p>
<ul>
<li>Code: [[4,2,2]] with stabilizers XXXX, ZZZZ; logical basis as given. (<a href="https://arxiv.org/html/2405.03032v1?utm_source=openai">arxiv.org</a>)</li>
<li>Noise: two‚Äëqubit depolarizing channel after each CNOT; with total probability p a uniformly random non‚Äëidentity two‚Äëqubit Pauli is applied (15 possibilities), otherwise identity with probability 1‚àíp. (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>)</li>
<li>Ancilla parity check: CNOT34 then CNOT04 measures Z-parity of qubits 3 and 0; keep ancilla outcome |0‚ü©. (<a href="https://en.wikipedia.org/wiki/Parity_measurement?utm_source=openai">en.wikipedia.org</a>)</li>
</ul>
<p>4) Final Answer:
Flogical(p) = 1 ‚àí (16/25) p^2 + O(p^3).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#17</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#18</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.597645
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>