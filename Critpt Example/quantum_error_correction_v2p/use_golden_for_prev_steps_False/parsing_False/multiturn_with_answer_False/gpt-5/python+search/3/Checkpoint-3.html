<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-3</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "‚ñ∂ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-3</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">üåì</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<p>Goal and noise model
- We prepare the 4-qubit physical state using the circuit
  CNOT03 ¬∑ H0 ¬∑ CNOT21 ¬∑ H2
  where H gates are ideal and each CNOTij is followed by an independent 2-qubit depolarizing channel that, with probability p, applies one of the 15 non-identity 2-qubit Paulis uniformly (probability p/15 each), and with probability 1‚àíp applies the identity. This is the standard ‚Äúuniform Pauli‚Äù form of an n=2 depolarizing channel (4^2‚àí1=15), used widely in simulators; see, e.g., Qiskit‚Äôs depolarizing_error construction and discussion of uniform Pauli channels. (<a href="https://qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud/documentation/stable/0.24/_modules/qiskit/providers/aer/noise/errors/standard_errors.html?utm_source=openai">qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud</a>, <a href="https://en.wikipedia.org/wiki/Quantum_depolarizing_channel?utm_source=openai">en.wikipedia.org</a>)</p>
<ul>
<li>The ideal target state is the encoded logical Bell (GHZ of two logical qubits) state
  |Œ¶+‚ü©AB = (|00‚ü©AB + |11‚ü©AB)/‚àö2
  inside the [[4,2,2]] code whose stabilizers are XXXX and ZZZZ. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>)</li>
</ul>
<p>Identify the stabilizer of the prepared state
- The logical-Bell state is stabilized by the logical operators XAXB and ZAZB. With the given logicals,
  ZAZB = (ZZII)(ZIZI) = IZZI,   XAXB = (XIXI)(XXII) = IXXI.
- Together with the code stabilizers XXXX and ZZZZ, a convenient generating set for the stabilizer of the final ideal 4-qubit state is
  g1 = XXXX,  g2 = ZZZZ,  g3 = IXXI,  g4 = IZZI.
  Hence the (pure) ideal state |œà‚ü© is the unique +1 eigenstate of the Abelian group
  Sœà = ‚ü®g1, g2, g3, g4‚ü© with |Sœà| = 16.</p>
<p>Useful fact about stabilizer states
- For any stabilizer state |œà‚ü© and any Pauli P, ‚ü®œà|P|œà‚ü© = 0 unless P ‚àà ¬±Sœà; if P ‚àà ¬±Sœà, then P|œà‚ü© = ¬±|œà‚ü©, so the density matrix is unchanged by conjugation with P. Consequently, when a classical mixture of Pauli errors is applied, the state fidelity with |œà‚ü© equals the total probability weight of those Pauli errors that lie in ¬±Sœà. (<a href="https://arxiv.org/html/2403.08441v2?utm_source=openai">arxiv.org</a>)</p>
<p>Where the two error channels act and why they commute with later gates
- The error after CNOT21 acts only on qubits {2,1}; no later gate touches these qubits, since H0 acts on 0 and CNOT03 acts on {0,3}. The error after CNOT03 acts only on {0,3} and is last in the circuit. Therefore the total error at the end is a tensor product
  E = P21 ‚äó Q03,
  with P21 ‚àà {two-qubit Paulis on (2,1)} and Q03 ‚àà {two-qubit Paulis on (0,3)}, chosen independently with the probabilities specified above.</p>
<p>Classify which Pauli errors stabilize the ideal state
- We need all elements of Sœà that factor as operators supported on (1,2) and/or (0,3). Using the generators:
  ‚Ä¢ Elements supported only on (1,2): {I, X1X2, Y1Y2, Z1Z2} = {I, g3, g3g4, g4}.
  ‚Ä¢ Elements supported only on (0,3): {I, X0X3, Y0Y3, Z0Z3} = {I, g1g3, g1g2g3g4, g2g4}.
  ‚Ä¢ The remaining 9 elements of Sœà act nontrivially on both pairs (0,3) and (1,2).</p>
<p>Compute the fidelity as a probability sum
Let p be the error rate per two-qubit gate.</p>
<ul>
<li>
<p>Case A: No error on either gate (identity on both pairs).
  Probability: (1‚àíp)^2.
  This yields E = I ‚àà Sœà, so contributes (1‚àíp)^2.</p>
</li>
<li>
<p>Case B: Exactly one gate has a non-identity error.
  Suppose (2,1) has the error and (0,3) is identity. Then E ‚àà Sœà iff P21 ‚àà {X1X2, Y1Y2, Z1Z2}, i.e., 3 of the 15 non-identity two-qubit Paulis. Probability contribution:
  (1‚àíp) √ó p √ó (3/15).
  The same holds if only (0,3) errs, giving an identical contribution.
  Total for Case B: 2 √ó (1‚àíp) √ó p √ó (3/15).</p>
</li>
<li>
<p>Case C: Both gates have non-identity errors.
  Then E ‚àà Sœà iff P21 ‚äó Q03 equals one of the 9 stabilizers that act nontrivially on both pairs. There are 9 favorable pairs out of 15√ó15 total. Probability contribution:
  9 √ó (p/15)^2.</p>
</li>
</ul>
<p>Sum all three cases:</p>
<div class="arithmatex">\[
\begin{aligned}
F(p)
&amp;= (1-p)^2 \;+\; 2(1-p)\,p\left(\frac{3}{15}\right) \;+\; 9\left(\frac{p}{15}\right)^2 \\
&amp;= (1-p)^2 \;+\; \frac{2p(1-p)}{5} \;+\; \frac{p^2}{25}.
\end{aligned}
\]</div>
<p>Simplify:</p>
<div class="arithmatex">\[
F(p) = 1 - \frac{8}{5}\,p + \frac{16}{25}\,p^2.
\]</div>
<p>Checks
- Small p: F(p) ‚âà 1 ‚àí (8/5)p, meaning a linear coefficient reduced from 2 (two gates) because a 3/15 fraction of single-gate Pauli errors stabilize the target state. 
- p = 1: F(1) = 1/25 = 9/225, matching the fraction of 2-gate error pairs that land in Sœà (9 of 225).</p>
<p>2) Mathematical Typesetting</p>
<p>All equations are presented above in LaTeX.</p>
<p>3) Conventions and Units</p>
<p>We use the standard Pauli group conventions and the stabilizer formalism; the two-qubit depolarizing channel is the uniform Pauli channel over 15 non-identity two-qubit Paulis. (<a href="https://qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud/documentation/stable/0.24/_modules/qiskit/providers/aer/noise/errors/standard_errors.html?utm_source=openai">qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud</a>)</p>
<p>4) Final Answer:
F(p) = 1 ‚àí (8/5)p + (16/25)p^2</p>
<p>References:
- [[4,2,2]] code stabilizers XXXX and ZZZZ; codeword structure. Error Correction Zoo, ‚Äú[[4,2,2]] Four-qubit code.‚Äù (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>)
- Bell state stabilizers are +XX and +ZZ (illustrated in Qiskit StabilizerState docs). (<a href="https://docs.quantum.ibm.com/api/qiskit/0.38/qiskit.quantum_info.StabilizerState?utm_source=openai">docs.quantum.ibm.com</a>)
- Two-qubit depolarizing = uniform Pauli over 4^n‚àí1 non-identity Paulis. Qiskit Aer standard_errors; Wikipedia depolarizing channel background. (<a href="https://qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud/documentation/stable/0.24/_modules/qiskit/providers/aer/noise/errors/standard_errors.html?utm_source=openai">qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud</a>, <a href="https://en.wikipedia.org/wiki/Quantum_depolarizing_channel?utm_source=openai">en.wikipedia.org</a>)
- Expectation of Pauli on a stabilizer state is zero unless the Pauli is (¬±) in the stabilizer group. (<a href="https://arxiv.org/html/2403.08441v2?utm_source=openai">arxiv.org</a>)</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<p>Setup and noise model
- We run the 4‚Äëqubit circuit (right-to-left)
  (CNOT03)(H0)(CNOT21)(H2),
  with ideal single-qubit H‚Äôs. Each CNOT is followed by an independent 2‚Äëqubit depolarizing channel: with probability 1‚àíp nothing happens and with probability p one of the 4^2‚àí1=15 non-identity two‚Äëqubit Pauli operators is applied uniformly (p/15 each). This is the standard n‚Äëqubit depolarizing channel. [Cirq documentation spells this out; identical definition is used widely.] (<a href="https://quantumai.google/reference/python/cirq/DepolarizingChannel?utm_source=openai">quantumai.google</a>)</p>
<ul>
<li>
<p>The code is the [[4,2,2]] code with stabilizer generators S=‚ü®XXXX, ZZZZ‚ü©. Its codespace is the simultaneous +1 eigenspace of these two operators. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</p>
</li>
<li>
<p>The target logical state is the logical Bell state |Œ¶+„ÄâAB=(|00„ÄâAB+|11„ÄâAB)/‚àö2, which (at the logical level) is stabilized by XAXB and ZAZB; equivalently the physical state prepared by the circuit is a 4‚Äëqubit stabilizer state whose stabilizer contains {XXXX, ZZZZ} together with logical-Bell stabilizers mapped into the code. For the 2‚Äëqubit Bell state itself, the (phase-free) stabilizer set is {II, XX, ZZ} (with ‚àíYY also in the full Pauli stabilizer group), so XX and ZZ generate it. (<a href="https://quantumcomputing.stackexchange.com/questions/18235/what-is-a-stabilizer-state?utm_source=openai">quantumcomputing.stackexchange.com</a>)</p>
</li>
</ul>
<p>Where the errors land
- No gate after CNOT21 touches qubits 2 or 1, and CNOT03 is last and only touches qubits 0 and 3. Hence the total Pauli error at the end factors as
  E = P21 ‚äó Q03,
  with P21 acting on qubits {2,1} and Q03 on {0,3}, independently drawn per the depolarizing model above.</p>
<p>Post-selection rule (detect-then-keep)
- ‚ÄúPost-select on all detectable errors‚Äù means we discard any run whose final stabilizer measurements report a nontrivial syndrome. For Pauli errors, an error is undetected exactly when it commutes with every stabilizer generator; i.e., E lies in the centralizer/normalizer N(S) of S in the 4‚Äëqubit Pauli group. If E‚àâN(S), at least one generator anticommutes with E and yields a ‚àí1 outcome, so we reject the run. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)</p>
<p>Commutation constraints in parity form
- Represent a Pauli string by binary ‚ÄúX- and Z-parity‚Äù indicators: for each qubit j, let xj=1 if the local Pauli is X or Y and zj=1 if it is Z or Y (else 0). A Pauli E commutes with XXXX iff the total parity of {Z,Y} across all four qubits is even, i.e., ‚àëj zj‚â°0 (mod 2). It commutes with ZZZZ iff ‚àëj xj‚â°0 (mod 2). This is the standard symplectic-commutation rule in the stabilizer formalism. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)</p>
<p>Classify two-qubit Paulis on a given pair
- For any fixed pair, say (2,1), group the 16 Paulis (including II) by the two parities (a,b)‚â°(‚àëxj mod 2, ‚àëzj mod 2) on that pair:
  ‚Ä¢ Class 00: {II, XX, YY, ZZ} (size 4; among these, the 3 non-identity are XX, YY, ZZ)
  ‚Ä¢ Class 10: {XI, IX, YZ, ZY} (size 4)
  ‚Ä¢ Class 01: {ZI, IZ, XY, YX} (size 4)
  ‚Ä¢ Class 11: {XZ, ZX, IY, YI} (size 4)</p>
<p>Acceptance (probability that the run is kept)
- No error: accepted with probability (1‚àíp)^2 (E=I‚ààN(S)).
- Exactly one gate errs (say on (2,1)): E lies in N(S) iff that pair error has even x-parity and even z-parity, i.e., it is in class 00 and non-identity ‚áí exactly 3 acceptable Paulis out of 15. The same holds if only (0,3) errs. Contribution: 2(1‚àíp)p(3/15).
- Both gates err: E=P21‚äóQ03 commutes with XXXX and ZZZZ iff the pairwise parities match between the two pairs (a,b)21=(a,b)03 (both constraints). Counting acceptable pairs among 15√ó15=225 possibilities:
  class 00: 3√ó3=9
  class 10: 4√ó4=16
  class 01: 4√ó4=16
  class 11: 4√ó4=16
  Total 57. Contribution: p^2¬∑(57/225)=p^2¬∑(19/75).</p>
<p>Therefore the post-selection acceptance probability is</p>
<div class="arithmatex">\[
P_{\rm acc}(p)
=(1-p)^2+2(1-p)p\frac{3}{15}+p^2\frac{57}{225}
=1-\frac{8}{5}p+\frac{64}{75}p^2.
\]</div>
<p>‚ÄúGood‚Äù (logically correct) undetected errors
- Among accepted runs (E‚ààN(S)), the logical two-qubit state equals the intended |Œ¶+„ÄâAB iff E acts on the codespace as an element of the logical-Bell stabilizer subgroup generated by XAXB and ZAZB (global phases ignored), i.e., E is in the state‚Äôs stabilizer. For our circuit this occurs exactly when:
  ‚Ä¢ No error, or
  ‚Ä¢ A single-pair error is one of {XX,YY,ZZ} on that pair, or
  ‚Ä¢ Both pairs have errors from {XX,YY,ZZ} on each pair (9 combinations).
  This is precisely the same counting that gave the physical 4‚Äëqubit state fidelity in Subproblem 1:</p>
<div class="arithmatex">\[
P_{\rm good}(p)=(1-p)^2+2(1-p)p\frac{3}{15}+9\left(\frac{p}{15}\right)^2
=1-\frac{8}{5}p+\frac{16}{25}p^2,
\]</div>
<p>since {XX,YY,ZZ} stabilize the Bell state up to phase. (<a href="https://quantumcomputing.stackexchange.com/questions/18235/what-is-a-stabilizer-state?utm_source=openai">quantumcomputing.stackexchange.com</a>)</p>
<p>Logical fidelity conditioned on passing detection
- The desired quantity is the conditional fidelity of the logical 2‚Äëqubit state given acceptance (syndrome +1), i.e.,</p>
<div class="arithmatex">\[
F_{\rm logical}(p)=\frac{P_{\rm good}(p)}{P_{\rm acc}(p)}
=\frac{1-\frac{8}{5}p+\frac{16}{25}p^2}{1-\frac{8}{5}p+\frac{64}{75}p^2}
=\frac{75-120p+48p^2}{75-120p+64p^2}.
\]</div>
<p>Sanity checks
- Small‚Äëp expansion: using (1+Œ±p+Œ≤p^2)/(1+Œ≥p+Œ¥p^2)=1+(Œ±‚àíŒ≥)p+[Œ≤‚àíŒ¥‚àíŒ≥(Œ±‚àíŒ≥)]p^2+‚Ä¶ and noting the linear terms cancel, we get</p>
<div class="arithmatex">\[
F_{\rm logical}(p)=1-\frac{16}{75}p^2+O(p^3),
\]</div>
<p>showing first‚Äëorder errors are removed by post‚Äëselection, as expected for a distance‚Äë2 detection code. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)
- At p=1: Flogical(1)=(1/25)/(19/75)=3/19‚âà0.1579.</p>
<p>2) Mathematical Typesetting</p>
<p>All key steps above are written in LaTeX.</p>
<p>3) Conventions and Units</p>
<ul>
<li>Stabilizer-code notions (codespace as +1 eigenspace; undetected ‚áî in the normalizer; commutation via parity/symplectic rule) follow standard stabilizer formalism. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>, <a href="https://learning.quantum.ibm.com/course/foundations-of-quantum-error-correction/the-stabilizer-formalism?utm_source=openai">learning.quantum.ibm.com</a>)</li>
<li>Two‚Äëqubit depolarizing channel is uniform over the 15 non-identity two‚Äëqubit Paulis with total weight p. (<a href="https://quantumai.google/reference/python/cirq/DepolarizingChannel?utm_source=openai">quantumai.google</a>)</li>
<li>[[4,2,2]] code stabilizers {XXXX, ZZZZ}. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</li>
<li>Bell |Œ¶+„Äâ stabilizer generated by {XX, ZZ} (with ‚àíYY also in the group). (<a href="https://quantumcomputing.stackexchange.com/questions/18235/what-is-a-stabilizer-state?utm_source=openai">quantumcomputing.stackexchange.com</a>)</li>
</ul>
<p>4) Final Answer:
Flogical(p) = (75 ‚àí 120 p + 48 p^2) / (75 ‚àí 120 p + 64 p^2) = [1 ‚àí (8/5)p + (16/25)p^2] / [1 ‚àí (8/5)p + (64/75)p^2].</p>
<p>Equivalently, for small p: Flogical(p) = 1 ‚àí (16/75)p^2 + O(p^3).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-3">Checkpoint 3</h2>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="c1"># We&#39;ll enumerate all Pauli error combinations for the 5 two-qubit gates in the circuit</span>
<span class="c1"># Gates (from earliest to latest):</span>
<span class="c1"># 1) CNOT_{12} (control 1, target 2)</span>
<span class="c1"># 2) CNOT_{10} (control 1, target 0)</span>
<span class="c1"># 3) CNOT_{23} (control 2, target 3)</span>
<span class="c1"># 4) CNOT_{34} (control 3, target 4)</span>
<span class="c1"># 5) CNOT_{04} (control 0, target 4)</span>
<span class="c1"># After each gate, a 2-qubit depolarizing error may occur on that gate&#39;s qubits.</span>
<span class="c1"># We will propagate each inserted two-qubit Pauli forward through the remaining CNOTs,</span>
<span class="c1"># accumulate the total Pauli on 5 qubits (0..4), and then check acceptance conditions.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>

<span class="c1"># Pauli multiplication table ignoring global phase: maps (P,Q) -&gt; (R, phase)</span>
<span class="c1"># We&#39;ll carry the phase but ultimately ignore for acceptance checks.</span>
<span class="n">paulis</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
<span class="c1"># multiplication table with phase factors (1, -1, 1j, -1j)</span>
<span class="n">mult</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">):(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">):(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">):(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">):(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">):(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">):(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">):(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">):(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">):(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">):(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">):(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">):(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">):(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">):(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">):(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">):(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
<span class="p">}</span>

<span class="c1"># Conjugation of single-qubit Pauli by CNOT(c,t)</span>
<span class="c1"># We implement conjugation on a full 5-qubit Pauli string P (list of length 5)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">cnot_conj</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="c1"># Copy to avoid in-place mis-order</span>
    <span class="n">Pc</span><span class="p">,</span> <span class="n">Pt</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="c1"># Apply the standard conjugation rules</span>
    <span class="c1"># X on control -&gt; X on control and X on target</span>
    <span class="c1"># Z on target -&gt; Z on control and Z on target</span>
    <span class="c1"># Y handled by compositions</span>
    <span class="c1"># We&#39;ll update by multiplying appropriate factors</span>
    <span class="c1"># Initialize to identity and compose corrections</span>
    <span class="c1"># Do it via explicit cases on (Pc, Pt)</span>

    <span class="c1"># Map using operator identities:</span>
    <span class="c1"># Conjugation acts linearly on the Pauli group; we can implement via table mapping of basis elements</span>
    <span class="c1"># We&#39;ll just apply rules per component:</span>

    <span class="c1"># Start with identity on both positions, then multiply mapped contributions</span>
    <span class="c1"># But easier: use known mapping on generators X_c, Z_c, X_t, Z_t and reconstruct Y via X*Z up to phase</span>

    <span class="c1"># We&#39;ll decompose Pc and Pt into X/Z bits to apply mapping. Simpler: handle 16 cases directly using rules:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_single</span><span class="p">(</span><span class="n">Pc</span><span class="p">,</span> <span class="n">Pt</span><span class="p">):</span>
        <span class="c1"># returns new (Pc&#39;, Pt&#39;) up to a phase. We&#39;ll also return the phase.</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Start from identity; later multiply in effect of Pc and Pt one by one</span>
        <span class="c1"># Conjugation is homomorphism: U (A B) U‚Ä† = (U A U‚Ä†)(U B U‚Ä†)</span>
        <span class="c1"># So treat Pc at c position and Pt at t position separately, then multiply results on those two qubits</span>
        <span class="c1"># We&#39;ll build arrays for 5-qubit string but only care about c and t positions.</span>
        <span class="c1"># First: effect of Pc at control</span>
        <span class="n">P_c_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;X&#39;</span><span class="p">:(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;Y&#39;</span><span class="p">:(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;Z&#39;</span><span class="p">:(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)}</span>
        <span class="n">P_t_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;X&#39;</span><span class="p">:(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;Y&#39;</span><span class="p">:(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;Z&#39;</span><span class="p">:(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)}</span>
        <span class="c1"># Apply known rules by replacing c and t operators:</span>
        <span class="c1"># For control:</span>
        <span class="k">if</span> <span class="n">Pc</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="n">Pc1</span><span class="p">,</span> <span class="n">phase1</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span>
            <span class="n">Pt1</span><span class="p">,</span> <span class="n">phase1b</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">Pc</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="c1"># X_c -&gt; X_c X_t</span>
            <span class="n">Pc1</span><span class="p">,</span> <span class="n">Pt1</span><span class="p">,</span> <span class="n">phase1</span><span class="p">,</span> <span class="n">phase1b</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">Pc</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
            <span class="c1"># Z_c -&gt; Z_c</span>
            <span class="n">Pc1</span><span class="p">,</span> <span class="n">Pt1</span><span class="p">,</span> <span class="n">phase1</span><span class="p">,</span> <span class="n">phase1b</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">Pc</span> <span class="o">==</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span>
            <span class="c1"># Y_c -&gt; Y_c X_t</span>
            <span class="n">Pc1</span><span class="p">,</span> <span class="n">Pt1</span><span class="p">,</span> <span class="n">phase1</span><span class="p">,</span> <span class="n">phase1b</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="c1"># For target:</span>
        <span class="k">if</span> <span class="n">Pt</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="n">Pc2</span><span class="p">,</span> <span class="n">phase2</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span>
            <span class="n">Pt2</span><span class="p">,</span> <span class="n">phase2b</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">Pt</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="c1"># X_t -&gt; X_t</span>
            <span class="n">Pc2</span><span class="p">,</span> <span class="n">Pt2</span><span class="p">,</span> <span class="n">phase2</span><span class="p">,</span> <span class="n">phase2b</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">Pt</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
            <span class="c1"># Z_t -&gt; Z_c Z_t</span>
            <span class="n">Pc2</span><span class="p">,</span> <span class="n">Pt2</span><span class="p">,</span> <span class="n">phase2</span><span class="p">,</span> <span class="n">phase2b</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">Pt</span> <span class="o">==</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span>
            <span class="c1"># Y_t -&gt; Z_c Y_t</span>
            <span class="n">Pc2</span><span class="p">,</span> <span class="n">Pt2</span><span class="p">,</span> <span class="n">phase2</span><span class="p">,</span> <span class="n">phase2b</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="c1"># Now multiply contributions on c and t qubits: (Pc1 on c) * (Pc2 on c) and (Pt1 on t) * (Pt2 on t)</span>
        <span class="n">Pc_new</span><span class="p">,</span> <span class="n">phc</span> <span class="o">=</span> <span class="n">mult</span><span class="p">[(</span><span class="n">Pc1</span><span class="p">,</span> <span class="n">Pc2</span><span class="p">)]</span>
        <span class="n">Pt_new</span><span class="p">,</span> <span class="n">pht</span> <span class="o">=</span> <span class="n">mult</span><span class="p">[(</span><span class="n">Pt1</span><span class="p">,</span> <span class="n">Pt2</span><span class="p">)]</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">phase1</span> <span class="o">*</span> <span class="n">phase1b</span> <span class="o">*</span> <span class="n">phase2</span> <span class="o">*</span> <span class="n">phase2b</span> <span class="o">*</span> <span class="n">phc</span> <span class="o">*</span> <span class="n">pht</span>
        <span class="k">return</span> <span class="n">Pc_new</span><span class="p">,</span> <span class="n">Pt_new</span><span class="p">,</span> <span class="n">phase</span>


    <span class="n">Pc_new</span><span class="p">,</span> <span class="n">Pt_new</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span> <span class="n">map_single</span><span class="p">(</span><span class="n">Pc</span><span class="p">,</span> <span class="n">Pt</span><span class="p">)</span>
    <span class="n">P</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pc_new</span><span class="p">,</span> <span class="n">Pt_new</span>
    <span class="c1"># Other positions unchanged</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="n">ph</span>

<span class="c1"># Multiply two 5-qubit Pauli strings (ignoring global phase aside from detection). Return product string and phase.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pauli_mult</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span> <span class="n">mult</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">phase</span> <span class="o">*=</span> <span class="n">ph</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">phase</span>

<span class="c1"># Generate all 2-qubit non-identity Pauli errors on a given pair (i,j)</span>
<span class="c1"># Represent errors as 5-qubit strings with I elsewhere</span>

<span class="k">def</span><span class="w"> </span><span class="nf">two_qubit_paulis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">paulis</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">paulis</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">b</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="c1"># Precompute error sets for each gate pair in order of insertion (right-to-left mapping):</span>
<span class="c1"># But note: we listed them earliest-&gt;latest above; we&#39;ll use that order for later conjugations</span>
<span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">errs_per_gate</span> <span class="o">=</span> <span class="p">[</span><span class="n">two_qubit_paulis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>

<span class="c1"># Precompute conjugation of any 5-qubit Pauli by each of the subsequent CNOTs</span>
<span class="c1"># For speed, we can apply cnot_conj sequentially as needed.</span>

<span class="c1"># We need to compute, for a given set of per-gate choices (identity or a specific 2q Pauli), the final total Pauli just before measurement.</span>
<span class="c1"># We&#39;ll implement enumeration over all combinations but group by k (number of non-identity gates).</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">N_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">N_good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">N_total_by_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>

<span class="c1"># Build the target state&#39;s stabilizer group on data qubits (0..3)</span>
<span class="c1"># Generators: XXXX, ZZZZ, ZZII, ZIZI</span>

<span class="k">def</span><span class="w"> </span><span class="nf">data_pauli_str</span><span class="p">(</span><span class="n">s4</span><span class="p">):</span>
    <span class="c1"># s4 is 4-char for data; return 5-char with ancilla I</span>
    <span class="k">return</span> <span class="n">s4</span> <span class="o">+</span> <span class="s1">&#39;I&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_full5_from_data</span><span class="p">(</span><span class="n">s4</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">q</span><span class="p">,</span><span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s4</span><span class="p">):</span>
        <span class="n">s</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># Helper to build generators</span>
<span class="n">G_data</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">G_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;XXXX&#39;</span><span class="p">)</span>
<span class="n">G_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ZZZZ&#39;</span><span class="p">)</span>
<span class="n">G_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ZZII&#39;</span><span class="p">)</span>
<span class="n">G_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ZIZI&#39;</span><span class="p">)</span>

<span class="c1"># Build full 5-qubit versions (with I on ancilla)</span>
<span class="n">G5</span> <span class="o">=</span> <span class="p">[</span><span class="n">make_full5_from_data</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">G_data</span><span class="p">]</span>

<span class="c1"># Build the 4-qubit stabilizer group S_target (set of 4-char strings) ignoring phases</span>
<span class="n">S_target</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="c1"># generate 2^4 combinations</span>
<span class="k">for</span> <span class="n">m0</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">m1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">m2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">m3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;IIII&#39;</span>
                <span class="k">if</span> <span class="n">m0</span><span class="p">:</span>
                    <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="n">G5</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>  <span class="c1"># We&#39;ll just use 5-qubit mult and slice</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">m1</span><span class="p">:</span>
                    <span class="n">s5</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="n">G5</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s5</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">m2</span><span class="p">:</span>
                    <span class="n">s5</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="n">G5</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s5</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">m3</span><span class="p">:</span>
                    <span class="n">s5</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="n">G5</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s5</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">S_target</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># Alternatively, rebuild more cleanly using 4-qubit multiplication</span>
<span class="c1"># We&#39;ll create a 4-qubit multiplication that ignores phase.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pauli_mult4</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span> <span class="n">mult</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">phase</span> <span class="o">*=</span> <span class="n">ph</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">phase</span>

<span class="c1"># Rebuild S_target cleanly</span>
<span class="n">S_target</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;IIII&#39;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;XXXX&#39;</span><span class="p">,</span><span class="s1">&#39;ZZZZ&#39;</span><span class="p">,</span><span class="s1">&#39;ZZII&#39;</span><span class="p">,</span><span class="s1">&#39;ZIZI&#39;</span><span class="p">]:</span>
    <span class="c1"># expand by multiplying existing elements by g</span>
    <span class="n">S_target</span> <span class="o">=</span> <span class="n">S_target</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="n">pauli_mult4</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">g</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">S_target</span><span class="p">)})</span>
<span class="c1"># Actually that only adds one generator; we need to generate the whole group by combining; do iterative closure</span>
<span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">newS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">S_target</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">S_target</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;XXXX&#39;</span><span class="p">,</span><span class="s1">&#39;ZZZZ&#39;</span><span class="p">,</span><span class="s1">&#39;ZZII&#39;</span><span class="p">,</span><span class="s1">&#39;ZIZI&#39;</span><span class="p">]:</span>
            <span class="n">ab</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pauli_mult4</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ab</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newS</span><span class="p">:</span>
                <span class="n">newS</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">S_target</span> <span class="o">=</span> <span class="n">newS</span>

<span class="c1"># Build the normalizer condition with respect to S_code={XXXX, ZZZZ}: commute iff even X/Y count and even Z/Y count on data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">commutes_with_stabilizers</span><span class="p">(</span><span class="n">data4</span><span class="p">):</span>
    <span class="c1"># even parity of X/Y across all four: sum x_j mod 2 = 0</span>
    <span class="c1"># even parity of Z/Y across all four: sum z_j mod 2 = 0</span>
    <span class="n">x_par</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">z_par</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">data4</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">):</span>
            <span class="n">x_par</span> <span class="o">^=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">):</span>
            <span class="n">z_par</span> <span class="o">^=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x_par</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">z_par</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Ancilla acceptance: ancilla char must be not X or Y (i.e., I or Z)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">ancilla_accept</span><span class="p">(</span><span class="n">anc_ch</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">anc_ch</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>

<span class="c1"># Now enumerate all combinations. For each gate, include &#39;I&#39; option besides the 15 two-qubit errors.</span>
<span class="c1"># We&#39;ll prepare a list of per-gate options as [ [&#39;I&#39;], [list of 15 two-qubit strings] ]</span>

<span class="n">errs_with_I</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">gate_errs</span> <span class="ow">in</span> <span class="n">errs_per_gate</span><span class="p">:</span>
    <span class="n">errs_with_I</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s1">&#39;I&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">gate_errs</span><span class="p">)</span>

<span class="c1"># Precompute subsequent conjugation sequences for performance: For an error inserted after gate g (0-based),</span>
<span class="c1"># it must be conjugated by gates g+1..4 (the later ones). We&#39;ll implement cnot_conj accordingly.</span>

<span class="c1"># define CNOT list for conjugations in order (later gates)</span>
<span class="n">cnot_list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="c1"># Conjugate a 5-qubit Pauli P by the sequence of later CNOTs starting after index g</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_after_gate</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">cnot_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">P</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cnot_conj</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span>

<span class="c1"># For performance, precompute the image of each possible non-identity error for each gate under later conjugations</span>
<span class="n">pre_images</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gate_errs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">errs_per_gate</span><span class="p">):</span>
    <span class="n">imap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gate_errs</span><span class="p">:</span>
        <span class="n">imap</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">conj_after_gate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">pre_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imap</span><span class="p">)</span>

<span class="c1"># Function to multiply 5-qubit Paulis (ignore phase)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">mult5</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pauli_mult</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Iterate all combinations; count by k (number of non-identity selections)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>

<span class="n">N_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">N_good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>
<span class="n">N_total_by_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>

<span class="c1"># We&#39;ll iterate more efficiently: for each gate choose index in 0..15 where 0 means identity, 1..15 picks from gate_errs</span>

<span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]):</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span> <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">N_total_by_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Build total Pauli by multiplying the propagated errors from each non-identity gate</span>
    <span class="n">total</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span><span class="o">*</span><span class="mi">5</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idxs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># select the (i-1)th error from errs_per_gate[g]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">errs_per_gate</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># propagate to end</span>
        <span class="n">s_prop</span> <span class="o">=</span> <span class="n">pre_images</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
        <span class="c1"># multiply into total</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">mult5</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">s_prop</span><span class="p">)</span>
    <span class="c1"># Acceptance conditions</span>
    <span class="n">data4</span> <span class="o">=</span> <span class="n">total</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">anc</span> <span class="o">=</span> <span class="n">total</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ancilla_accept</span><span class="p">(</span><span class="n">anc</span><span class="p">)</span> <span class="ow">and</span> <span class="n">commutes_with_stabilizers</span><span class="p">(</span><span class="n">data4</span><span class="p">):</span>
        <span class="n">N_acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Good if data4 is in S_target</span>
        <span class="k">if</span> <span class="n">data4</span> <span class="ow">in</span> <span class="n">S_target</span><span class="p">:</span>
            <span class="n">N_good</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># Report counts</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_total_by_k:&#39;</span><span class="p">,</span> <span class="n">N_total_by_k</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_acc:&#39;</span><span class="p">,</span> <span class="n">N_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_good:&#39;</span><span class="p">,</span> <span class="n">N_good</span><span class="p">)</span>

<span class="c1"># Sanity: N_total_by_k should be [1, 5*15, comb(5,2)*15**2, comb(5,3)*15**3, comb(5,4)*15**4, 15**5]</span>
<span class="n">expected</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="mi">15</span><span class="p">,</span> <span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">15</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">15</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="mi">15</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="mi">5</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Expected totals by k:&#39;</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>N_total_by_k: [1, 75, 2250, 33750, 253125, 759375]
N_acc: [1, 7, 282, 4222, 31637, 94923]
N_good: [1, 7, 138, 1198, 7397, 24027]
Expected totals by k: [1, 75, 2250, 33750, 253125, 759375]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>

<span class="n">N_acc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">282</span><span class="p">,</span> <span class="mi">4222</span><span class="p">,</span> <span class="mi">31637</span><span class="p">,</span> <span class="mi">94923</span><span class="p">]</span>
<span class="n">N_good</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">138</span><span class="p">,</span> <span class="mi">1198</span><span class="p">,</span> <span class="mi">7397</span><span class="p">,</span> <span class="mi">24027</span><span class="p">]</span>

<span class="c1"># Build polynomials for P_acc and P_good: coefficients for p^k (1-p)^(5-k)/15^k</span>
<span class="c1"># We&#39;ll expand (1-p)^(5-k) = sum_{j=0}^{5-k} comb(5-k, j) (-p)^j</span>
<span class="c1"># So total power is p^{k+j} with coefficient N[k] * comb(5-k, j) * (-1)^j / 15^k</span>

<span class="c1"># We&#39;ll compute coefficients up to degree 5 for numerator polynomials directly as Fractions.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">expand_poly</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="o">-</span><span class="n">k</span><span class="p">):</span>
            <span class="n">power</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">j</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">j</span><span class="p">),</span> <span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>
            <span class="n">coeff</span><span class="p">[</span><span class="n">power</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">coeff</span>

<span class="n">coeff_acc</span> <span class="o">=</span> <span class="n">expand_poly</span><span class="p">(</span><span class="n">N_acc</span><span class="p">)</span>
<span class="n">coeff_good</span> <span class="o">=</span> <span class="n">expand_poly</span><span class="p">(</span><span class="n">N_good</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc coefficients (for p^0..p^5):&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_acc</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good coefficients (for p^0..p^5):&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_good</span><span class="p">])</span>

<span class="c1"># For readability, present as decimals too</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc coeff decimals:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_acc</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good coeff decimals:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_good</span><span class="p">])</span>

<span class="c1"># Small-p series for F = P_good / P_acc up to p^3 (using series division)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_acc</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_good</span><span class="p">]</span>

<span class="c1"># Series division: F = (b0 + b1 p + b2 p^2 + ... ) / (a0 + a1 p + a2 p^2 + ...)</span>
<span class="c1"># We&#39;ll compute up to order p^3</span>

<span class="n">b0</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">b3</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
<span class="n">a0</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>

<span class="c1"># Compute coefficients f0..f3 s.t. (a0 + a1 p + a2 p^2 + a3 p^3) (f0 + f1 p + f2 p^2 + f3 p^3) = (b0 + b1 p + b2 p^2 + b3 p^3) up to p^3</span>

<span class="n">f0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">/</span><span class="n">a0</span>
<span class="n">f1</span> <span class="o">=</span> <span class="p">(</span><span class="n">b1</span> <span class="o">-</span> <span class="n">a1</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">/</span><span class="n">a0</span>
<span class="n">f2</span> <span class="o">=</span> <span class="p">(</span><span class="n">b2</span> <span class="o">-</span> <span class="n">a1</span><span class="o">*</span><span class="n">f1</span> <span class="o">-</span> <span class="n">a2</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">/</span><span class="n">a0</span>
<span class="n">f3</span> <span class="o">=</span> <span class="p">(</span><span class="n">b3</span> <span class="o">-</span> <span class="n">a1</span><span class="o">*</span><span class="n">f2</span> <span class="o">-</span> <span class="n">a2</span><span class="o">*</span><span class="n">f1</span> <span class="o">-</span> <span class="n">a3</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">/</span><span class="n">a0</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series F(p) = f0 + f1 p + f2 p^2 + f3 p^3 + ...&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">)</span>

<span class="c1"># Also produce exact rational polynomials for P_acc and P_good as common denominator 15^5</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">gcd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>

<span class="c1"># Convert to common denom 15^5 by multiplying</span>
<span class="n">D</span> <span class="o">=</span> <span class="mi">15</span><span class="o">**</span><span class="mi">5</span>
<span class="n">num_acc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">D</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_acc</span><span class="p">]</span>
<span class="n">num_good</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">D</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_good</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc numerator with denom 15^5:&#39;</span><span class="p">,</span> <span class="n">num_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good numerator with denom 15^5:&#39;</span><span class="p">,</span> <span class="n">num_good</span><span class="p">)</span>

<span class="c1"># Optionally simplify by gcd</span>

<span class="k">def</span><span class="w"> </span><span class="nf">poly_gcd_ints</span><span class="p">(</span><span class="n">coefs</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">g</span>

<span class="n">g_acc</span> <span class="o">=</span> <span class="n">poly_gcd_ints</span><span class="p">(</span><span class="n">num_acc</span><span class="p">)</span>
<span class="n">g_good</span> <span class="o">=</span> <span class="n">poly_gcd_ints</span><span class="p">(</span><span class="n">num_good</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gcds:&#39;</span><span class="p">,</span> <span class="n">g_acc</span><span class="p">,</span> <span class="n">g_good</span><span class="p">)</span>

<span class="c1"># We can present P_acc(p) = (A0 + A1 p + ... + A5 p^5) / 15^5, same for P_good</span>
<span class="c1"># But better to present as exact rational coefficients simplified fractions.</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>P_acc coefficients (for p^0..p^5):
[&#39;1&#39;, &#39;-68/15&#39;, &#39;704/75&#39;, &#39;-32768/3375&#39;, &#39;253952/50625&#39;, &#39;-262144/253125&#39;]
P_good coefficients (for p^0..p^5):
[&#39;1&#39;, &#39;-68/15&#39;, &#39;656/75&#39;, &#39;-29312/3375&#39;, &#39;223232/50625&#39;, &#39;-229376/253125&#39;]
P_acc coeff decimals: [1.0, -4.533333333333333, 9.386666666666667, -9.709037037037037, 5.016335802469136, -1.0356306172839507]
P_good coeff decimals: [1.0, -4.533333333333333, 8.746666666666666, -8.685037037037038, 4.409520987654321, -0.9061767901234568]
Series F(p) = f0 + f1 p + f2 p^2 + f3 p^3 + ...

1.0 0.0 -0.6400000000000006 -1.8773333333333362
P_acc numerator with denom 15^5: [759375, -3442500, 7128000, -7372800, 3809280, -786432]
P_good numerator with denom 15^5: [759375, -3442500, 6642000, -6595200, 3348480, -688128]
gcds: 3 3
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span><span class="s1">&#39;-68/15&#39;</span><span class="p">,</span><span class="s1">&#39;704/75&#39;</span><span class="p">,</span><span class="s1">&#39;-32768/3375&#39;</span><span class="p">,</span><span class="s1">&#39;253952/50625&#39;</span><span class="p">,</span><span class="s1">&#39;-262144/253125&#39;</span><span class="p">]]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span><span class="s1">&#39;-68/15&#39;</span><span class="p">,</span><span class="s1">&#39;656/75&#39;</span><span class="p">,</span><span class="s1">&#39;-29312/3375&#39;</span><span class="p">,</span><span class="s1">&#39;223232/50625&#39;</span><span class="p">,</span><span class="s1">&#39;-229376/253125&#39;</span><span class="p">]]</span>

<span class="n">b0</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">b3</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
<span class="n">a0</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>

<span class="n">f0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">/</span><span class="n">a0</span>
<span class="n">f1</span> <span class="o">=</span> <span class="p">(</span><span class="n">b1</span> <span class="o">-</span> <span class="n">a1</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">/</span><span class="n">a0</span>
<span class="n">f2</span> <span class="o">=</span> <span class="p">(</span><span class="n">b2</span> <span class="o">-</span> <span class="n">a1</span><span class="o">*</span><span class="n">f1</span> <span class="o">-</span> <span class="n">a2</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">/</span><span class="n">a0</span>
<span class="n">f3</span> <span class="o">=</span> <span class="p">(</span><span class="n">b3</span> <span class="o">-</span> <span class="n">a1</span><span class="o">*</span><span class="n">f2</span> <span class="o">-</span> <span class="n">a2</span><span class="o">*</span><span class="n">f1</span> <span class="o">-</span> <span class="n">a3</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">/</span><span class="n">a0</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exact series coefficients f0..f3:&#39;</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">)</span>

<span class="c1"># Let&#39;s also present F(p) as a rational function with integer-coefficient polynomials by clearing denominators using 15^5</span>
<span class="n">D</span> <span class="o">=</span> <span class="mi">15</span><span class="o">**</span><span class="mi">5</span>
<span class="n">num_acc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">D</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="n">num_good</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">D</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Num_acc with denom 15^5:&#39;</span><span class="p">,</span> <span class="n">num_acc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Num_good with denom 15^5:&#39;</span><span class="p">,</span> <span class="n">num_good</span><span class="p">)</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Exact series coefficients f0..f3: 1 0 -16/25 -704/375
Num_acc with denom 15^5: [759375, -3442500, 7128000, -7372800, 3809280, -786432]
Num_good with denom 15^5: [759375, -3442500, 6642000, -6595200, 3348480, -688128]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="n">P_acc</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">68</span><span class="p">,</span><span class="mi">15</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span><span class="mi">75</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">32768</span><span class="p">,</span><span class="mi">3375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span><span class="mi">50625</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">262144</span><span class="p">,</span><span class="mi">253125</span><span class="p">)]</span>
<span class="n">P_good</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">68</span><span class="p">,</span><span class="mi">15</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">656</span><span class="p">,</span><span class="mi">75</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">29312</span><span class="p">,</span><span class="mi">3375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">223232</span><span class="p">,</span><span class="mi">50625</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">229376</span><span class="p">,</span><span class="mi">253125</span><span class="p">)]</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>

<span class="k">def</span><span class="w"> </span><span class="nf">eval_poly</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">powp</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">Fraction</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc(1) =&#39;</span><span class="p">,</span> <span class="n">eval_poly</span><span class="p">(</span><span class="n">P_acc</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">eval_poly</span><span class="p">(</span><span class="n">P_acc</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_good(1) =&#39;</span><span class="p">,</span> <span class="n">eval_poly</span><span class="p">(</span><span class="n">P_good</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">eval_poly</span><span class="p">(</span><span class="n">P_good</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F(1) =&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">eval_poly</span><span class="p">(</span><span class="n">P_good</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">eval_poly</span><span class="p">(</span><span class="n">P_acc</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#13</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>P_acc(1) = 10547/84375 0.1250014814814815
P_good(1) = 8009/253125 0.03164049382716049
F(1) = 0.25312095066527607
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#14</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<p>Goal, circuit, and noise model
- We prepare the logical two‚Äëqubit state |00„ÄâAB of the [[4,2,2]] code using, right‚Äëto‚Äëleft, the circuit
  H1 ‚Üí CNOT12 ‚Üí CNOT10 ‚Üí CNOT23 ‚Üí CNOT34 ‚Üí CNOT04 ‚Üí measure Z on ancilla 4.
  Only the two‚Äëqubit CNOT gates are faulty; each is followed by an independent two‚Äëqubit depolarizing channel that applies one of the 15 non‚Äëidentity two‚Äëqubit Paulis with probability p/15 and the identity with probability 1‚àíp. This is the standard n‚Äëqubit depolarizing channel, uniform over the 4^n‚àí1 non‚Äëidentity Paulis. (<a href="https://quantumai.google/reference/python/cirq/DepolarizingChannel?utm_source=openai">quantumai.google</a>, <a href="https://en.wikipedia.org/wiki/Quantum_depolarizing_channel?utm_source=openai">en.wikipedia.org</a>, <a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>)</p>
<ul>
<li>
<p>The [[4,2,2]] code has stabilizers S=‚ü®XXXX, ZZZZ‚ü©. A convenient logical basis is
  |00ÃÑ„Äâ=(|0000„Äâ+|1111„Äâ)/‚àö2, |01ÃÑ„Äâ=(|0011„Äâ+|1100„Äâ)/‚àö2, |10ÃÑ„Äâ=(|0101„Äâ+|1010„Äâ)/‚àö2, |11ÃÑ„Äâ=(|0110„Äâ+|1001„Äâ)/‚àö2.
  Thus the target is |00ÃÑ„Äâ, stabilized by {XXXX, ZZZZ, ZZII, ZIZI}. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>, <a href="https://ar5iv.labs.arxiv.org/html/1907.11157v1?utm_source=openai">ar5iv.labs.arxiv.org</a>)</p>
</li>
<li>
<p>The last two CNOTs map the Z‚Äëparity of qubits 0 and 3 onto ancilla 4 (control‚Üítarget), so ideally the ancilla reads |0„Äâ because in |00ÃÑ„Äâ we have Z0Z3=+1 (bits 0 and 3 are equal in both |0000„Äâ and |1111„Äâ). More generally, two control‚Üíancilla CNOTs perform a ZZ parity measurement on the controls. (<a href="https://en.wikipedia.org/wiki/Parity_measurement?utm_source=openai">en.wikipedia.org</a>)</p>
</li>
</ul>
<p>Pauli‚Äëframe method (move all errors to the end)
- Insert, after each CNOT, a two‚Äëqubit Pauli error E(g) supported on that gate‚Äôs qubits:
  E(12), E(10), E(23), E(34), E(04). Push each forward to the end by conjugating through the subsequent CNOTs using the standard rules (U P U‚Ä†):
  Xc ‚Üí XcXt, Zt ‚Üí ZcZt, Xt ‚Üí Xt, Zc ‚Üí Zc, and similarly Y via Y=iXZ. (<a href="https://rainij.github.io/solutions-qcqi-nielsen-chuang/chapter_10.html?utm_source=openai">rainij.github.io</a>, <a href="https://en.wikipedia.org/wiki/Controlled_NOT_gate?utm_source=openai">en.wikipedia.org</a>)
- The total error just before measuring qubit 4 is the product
  Efinal = E‚Ä≤(12) E‚Ä≤(10) E‚Ä≤(23) E‚Ä≤(34) E‚Ä≤(04),
  where each E‚Ä≤(‚ãÖ) is the propagated image.</p>
<p>Acceptance (post‚Äëselection) conditions
- Ancilla pass: Z‚Äëbasis measurement outcome flips iff the pre‚Äëmeasurement Pauli on qubit 4 has an X or Y component; I or Z leaves the outcome unchanged. This follows because for any state a|0„Äâ+b|1„Äâ, measuring Z after an X (or Y) swaps the probabilities of 0 and 1, i.e., flips the classical result; Z only adds phase. Therefore accept the run iff the ancilla factor of Efinal is I or Z.
- Code‚Äësyndrome pass: a Pauli on data qubits 0‚Äì3 commutes with XXXX iff the total number of Z/Y on the four data qubits is even, and commutes with ZZZZ iff the total number of X/Y is even (symplectic commutation). Equivalently, accept iff both parities are even so that Efinal lies in the normalizer of S. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)</p>
<p>Logical correctness among accepted runs
- Let Starget = ‚ü®XXXX, ZZZZ, ZZII, ZIZI‚ü© be the 16‚Äëelement stabilizer of |00ÃÑ„Äâ on data qubits. If the data part of Efinal lies in Starget (phase ignored), the physical state equals the target; if it lies in the normalizer but not in Starget, the logical two‚Äëqubit state is wrong though undetected by the code syndrome. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</p>
<p>Exact counting by exhaustive Pauli enumeration (fault‚Äëpath analysis)
- Each of the five CNOTs is followed by either I (prob. 1‚àíp) or one of 15 Paulis (prob. p/15). We enumerated all (1+15)^5=1,048,576 error patterns. For each pattern we:
  1) propagated the Pauli to the end using the CNOT conjugation rules,
  2) tested ancilla pass (qubit 4 ‚àà {I,Z}),
  3) tested code pass (even X/Y and even Z/Y on data), and
  4) tested ‚Äúgood‚Äù (data Pauli ‚àà Starget).
- Grouping by k, the number of faulty two‚Äëqubit gates (k=0‚Ä¶5), yields the counts:
  Nacc(k) = [1, 7, 282, 4222, 31637, 94923],
  Ngood(k) = [1, 7, 138, 1198, 7397, 24027].
  These are exact integers from exhaustive enumeration (numerical code available upon request).</p>
<p>From counts to probabilities
- Let
  Pacc(p) = Œ£k Nacc(k) (p^k (1‚àíp)^{5‚àík} / 15^k),
  Pgood(p) = Œ£k Ngood(k) (p^k (1‚àíp)^{5‚àík} / 15^k).
  Expanding,
  $
  \begin{aligned}
  P_{\rm acc}(p) &amp;= 1 - \tfrac{68}{15}p + \tfrac{704}{75}p^2 - \tfrac{32768}{3375}p^3 + \tfrac{253952}{50625}p^4 - \tfrac{262144}{253125}p^5,\
  P_{\rm good}(p) &amp;= 1 - \tfrac{68}{15}p + \tfrac{656}{75}p^2 - \tfrac{29312}{3375}p^3 + \tfrac{223232}{50625}p^4 - \tfrac{229376}{253125}p^5.
  \end{aligned}
  $</p>
<p>Logical state fidelity conditioned on post‚Äëselection
- The desired logical fidelity is the conditional probability that the accepted run is logically correct:
  $
  F_{\rm logical}(p)=\frac{P_{\rm good}(p)}{P_{\rm acc}(p)}.
  $
  In closed form,
  $
  F_{\rm logical}(p)=
  \frac{1 - \frac{68}{15}p + \frac{656}{75}p^2 - \frac{29312}{3375}p^3 + \frac{223232}{50625}p^4 - \frac{229376}{253125}p^5}
       {1 - \frac{68}{15}p + \frac{704}{75}p^2 - \frac{32768}{3375}p^3 + \frac{253952}{50625}p^4 - \frac{262144}{253125}p^5}.
  $</p>
<p>Series check and sanity tests
- Small‚Äëp expansion (series division):
  $
  F_{\rm logical}(p)=1-\frac{16}{25}\,p^2 - \frac{704}{375}\,p^3 + O(p^4),
  $
  showing first‚Äëorder faults are removed by post‚Äëselection (as expected for a distance‚Äë2 detection code), while second‚Äëorder faults dominate. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)
- At p=0: Flogical=1. At p=1: Flogical ‚âà 0.2531. The linear term vanishes, consistent with ‚Äúsingle‚Äëfault‚Äëtolerant‚Äù state preparation with verification. The acceptance probability itself is Pacc(p)=1‚àí(68/15)p+O(p^2), reflecting that most single‚Äëgate faults are rejected by either the ancilla parity check or the code stabilizers.</p>
<p>Why the ancilla measurement criterion above is correct
- The two control‚Üíancilla CNOTs implement a ZZ parity measurement onto qubit 4 prepared in |0„Äâ; measuring Z on qubit 4 returns the parity bit. A pre‚Äëmeasurement X (or Y=iXZ) on the measured qubit interchanges |0„Äâ and |1„Äâ probabilities, flipping the classical result, whereas Z changes only phase and leaves the distribution invariant. Hence ‚Äúaccept ‚áî ancilla Pauli ‚àà {I,Z}‚Äù. (<a href="https://en.wikipedia.org/wiki/Parity_measurement?utm_source=openai">en.wikipedia.org</a>)</p>
<p>References used
- Two‚Äëqubit depolarizing (uniform Pauli) channel. (<a href="https://quantumai.google/reference/python/cirq/DepolarizingChannel?utm_source=openai">quantumai.google</a>, <a href="https://en.wikipedia.org/wiki/Quantum_depolarizing_channel?utm_source=openai">en.wikipedia.org</a>, <a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>)
- [[4,2,2]] code, stabilizers, and codewords; |00ÃÑ„Äâ=(|0000„Äâ+|1111„Äâ)/‚àö2. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>, <a href="https://ar5iv.labs.arxiv.org/html/1907.11157v1?utm_source=openai">ar5iv.labs.arxiv.org</a>)
- Conjugation (propagation) of Pauli errors through CNOT. (<a href="https://rainij.github.io/solutions-qcqi-nielsen-chuang/chapter_10.html?utm_source=openai">rainij.github.io</a>, <a href="https://en.wikipedia.org/wiki/Controlled_NOT_gate?utm_source=openai">en.wikipedia.org</a>)
- Stabilizer formalism and symplectic (parity) commutation test for acceptance. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)
- Parity‚Äëmeasurement with ancilla via cascaded CNOTs. (<a href="https://en.wikipedia.org/wiki/Parity_measurement?utm_source=openai">en.wikipedia.org</a>)</p>
<p>2) Mathematical Typesetting</p>
<p>All equations above are given in LaTeX.</p>
<p>3) Conventions and Units</p>
<ul>
<li>Phase factors of Paulis are irrelevant for acceptance and fidelity; we work in the phase‚Äëfree Pauli group.</li>
<li>Qubit order: data (0,1,2,3), ancilla (4). CNOTij means control i, target j.</li>
</ul>
<p>4) Final Answer:
Flogical(p) = [1 ‚àí (68/15)p + (656/75)p^2 ‚àí (29312/3375)p^3 + (223232/50625)p^4 ‚àí (229376/253125)p^5] / [1 ‚àí (68/15)p + (704/75)p^2 ‚àí (32768/3375)p^3 + (253952/50625)p^4 ‚àí (262144/253125)p^5].</p>
<p>Equivalently, for small p,
Flogical(p) = 1 ‚àí (16/25)p^2 ‚àí (704/375)p^3 + O(p^4).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#15</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#16</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">656</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">29312</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">223232</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">229376</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">262144</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.581657
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>