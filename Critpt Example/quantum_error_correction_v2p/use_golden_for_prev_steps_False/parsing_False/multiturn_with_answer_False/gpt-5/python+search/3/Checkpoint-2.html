<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<p>Goal and noise model
- We prepare the 4-qubit physical state using the circuit
  CNOT03 · H0 · CNOT21 · H2
  where H gates are ideal and each CNOTij is followed by an independent 2-qubit depolarizing channel that, with probability p, applies one of the 15 non-identity 2-qubit Paulis uniformly (probability p/15 each), and with probability 1−p applies the identity. This is the standard “uniform Pauli” form of an n=2 depolarizing channel (4^2−1=15), used widely in simulators; see, e.g., Qiskit’s depolarizing_error construction and discussion of uniform Pauli channels. (<a href="https://qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud/documentation/stable/0.24/_modules/qiskit/providers/aer/noise/errors/standard_errors.html?utm_source=openai">qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud</a>, <a href="https://en.wikipedia.org/wiki/Quantum_depolarizing_channel?utm_source=openai">en.wikipedia.org</a>)</p>
<ul>
<li>The ideal target state is the encoded logical Bell (GHZ of two logical qubits) state
  |Φ+⟩AB = (|00⟩AB + |11⟩AB)/√2
  inside the [[4,2,2]] code whose stabilizers are XXXX and ZZZZ. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>)</li>
</ul>
<p>Identify the stabilizer of the prepared state
- The logical-Bell state is stabilized by the logical operators XAXB and ZAZB. With the given logicals,
  ZAZB = (ZZII)(ZIZI) = IZZI,   XAXB = (XIXI)(XXII) = IXXI.
- Together with the code stabilizers XXXX and ZZZZ, a convenient generating set for the stabilizer of the final ideal 4-qubit state is
  g1 = XXXX,  g2 = ZZZZ,  g3 = IXXI,  g4 = IZZI.
  Hence the (pure) ideal state |ψ⟩ is the unique +1 eigenstate of the Abelian group
  Sψ = ⟨g1, g2, g3, g4⟩ with |Sψ| = 16.</p>
<p>Useful fact about stabilizer states
- For any stabilizer state |ψ⟩ and any Pauli P, ⟨ψ|P|ψ⟩ = 0 unless P ∈ ±Sψ; if P ∈ ±Sψ, then P|ψ⟩ = ±|ψ⟩, so the density matrix is unchanged by conjugation with P. Consequently, when a classical mixture of Pauli errors is applied, the state fidelity with |ψ⟩ equals the total probability weight of those Pauli errors that lie in ±Sψ. (<a href="https://arxiv.org/html/2403.08441v2?utm_source=openai">arxiv.org</a>)</p>
<p>Where the two error channels act and why they commute with later gates
- The error after CNOT21 acts only on qubits {2,1}; no later gate touches these qubits, since H0 acts on 0 and CNOT03 acts on {0,3}. The error after CNOT03 acts only on {0,3} and is last in the circuit. Therefore the total error at the end is a tensor product
  E = P21 ⊗ Q03,
  with P21 ∈ {two-qubit Paulis on (2,1)} and Q03 ∈ {two-qubit Paulis on (0,3)}, chosen independently with the probabilities specified above.</p>
<p>Classify which Pauli errors stabilize the ideal state
- We need all elements of Sψ that factor as operators supported on (1,2) and/or (0,3). Using the generators:
  • Elements supported only on (1,2): {I, X1X2, Y1Y2, Z1Z2} = {I, g3, g3g4, g4}.
  • Elements supported only on (0,3): {I, X0X3, Y0Y3, Z0Z3} = {I, g1g3, g1g2g3g4, g2g4}.
  • The remaining 9 elements of Sψ act nontrivially on both pairs (0,3) and (1,2).</p>
<p>Compute the fidelity as a probability sum
Let p be the error rate per two-qubit gate.</p>
<ul>
<li>
<p>Case A: No error on either gate (identity on both pairs).
  Probability: (1−p)^2.
  This yields E = I ∈ Sψ, so contributes (1−p)^2.</p>
</li>
<li>
<p>Case B: Exactly one gate has a non-identity error.
  Suppose (2,1) has the error and (0,3) is identity. Then E ∈ Sψ iff P21 ∈ {X1X2, Y1Y2, Z1Z2}, i.e., 3 of the 15 non-identity two-qubit Paulis. Probability contribution:
  (1−p) × p × (3/15).
  The same holds if only (0,3) errs, giving an identical contribution.
  Total for Case B: 2 × (1−p) × p × (3/15).</p>
</li>
<li>
<p>Case C: Both gates have non-identity errors.
  Then E ∈ Sψ iff P21 ⊗ Q03 equals one of the 9 stabilizers that act nontrivially on both pairs. There are 9 favorable pairs out of 15×15 total. Probability contribution:
  9 × (p/15)^2.</p>
</li>
</ul>
<p>Sum all three cases:</p>
<div class="arithmatex">\[
\begin{aligned}
F(p)
&amp;= (1-p)^2 \;+\; 2(1-p)\,p\left(\frac{3}{15}\right) \;+\; 9\left(\frac{p}{15}\right)^2 \\
&amp;= (1-p)^2 \;+\; \frac{2p(1-p)}{5} \;+\; \frac{p^2}{25}.
\end{aligned}
\]</div>
<p>Simplify:</p>
<div class="arithmatex">\[
F(p) = 1 - \frac{8}{5}\,p + \frac{16}{25}\,p^2.
\]</div>
<p>Checks
- Small p: F(p) ≈ 1 − (8/5)p, meaning a linear coefficient reduced from 2 (two gates) because a 3/15 fraction of single-gate Pauli errors stabilize the target state. 
- p = 1: F(1) = 1/25 = 9/225, matching the fraction of 2-gate error pairs that land in Sψ (9 of 225).</p>
<p>2) Mathematical Typesetting</p>
<p>All equations are presented above in LaTeX.</p>
<p>3) Conventions and Units</p>
<p>We use the standard Pauli group conventions and the stabilizer formalism; the two-qubit depolarizing channel is the uniform Pauli channel over 15 non-identity two-qubit Paulis. (<a href="https://qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud/documentation/stable/0.24/_modules/qiskit/providers/aer/noise/errors/standard_errors.html?utm_source=openai">qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud</a>)</p>
<p>4) Final Answer:
F(p) = 1 − (8/5)p + (16/25)p^2</p>
<p>References:
- [[4,2,2]] code stabilizers XXXX and ZZZZ; codeword structure. Error Correction Zoo, “[[4,2,2]] Four-qubit code.” (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2">errorcorrectionzoo.org</a>)
- Bell state stabilizers are +XX and +ZZ (illustrated in Qiskit StabilizerState docs). (<a href="https://docs.quantum.ibm.com/api/qiskit/0.38/qiskit.quantum_info.StabilizerState?utm_source=openai">docs.quantum.ibm.com</a>)
- Two-qubit depolarizing = uniform Pauli over 4^n−1 non-identity Paulis. Qiskit Aer standard_errors; Wikipedia depolarizing channel background. (<a href="https://qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud/documentation/stable/0.24/_modules/qiskit/providers/aer/noise/errors/standard_errors.html?utm_source=openai">qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud</a>, <a href="https://en.wikipedia.org/wiki/Quantum_depolarizing_channel?utm_source=openai">en.wikipedia.org</a>)
- Expectation of Pauli on a stabilizer state is zero unless the Pauli is (±) in the stabilizer group. (<a href="https://arxiv.org/html/2403.08441v2?utm_source=openai">arxiv.org</a>)</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-Step Derivation</p>
<p>Setup and noise model
- We run the 4‑qubit circuit (right-to-left)
  (CNOT03)(H0)(CNOT21)(H2),
  with ideal single-qubit H’s. Each CNOT is followed by an independent 2‑qubit depolarizing channel: with probability 1−p nothing happens and with probability p one of the 4^2−1=15 non-identity two‑qubit Pauli operators is applied uniformly (p/15 each). This is the standard n‑qubit depolarizing channel. [Cirq documentation spells this out; identical definition is used widely.] (<a href="https://quantumai.google/reference/python/cirq/DepolarizingChannel?utm_source=openai">quantumai.google</a>)</p>
<ul>
<li>
<p>The code is the [[4,2,2]] code with stabilizer generators S=⟨XXXX, ZZZZ⟩. Its codespace is the simultaneous +1 eigenspace of these two operators. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</p>
</li>
<li>
<p>The target logical state is the logical Bell state |Φ+〉AB=(|00〉AB+|11〉AB)/√2, which (at the logical level) is stabilized by XAXB and ZAZB; equivalently the physical state prepared by the circuit is a 4‑qubit stabilizer state whose stabilizer contains {XXXX, ZZZZ} together with logical-Bell stabilizers mapped into the code. For the 2‑qubit Bell state itself, the (phase-free) stabilizer set is {II, XX, ZZ} (with −YY also in the full Pauli stabilizer group), so XX and ZZ generate it. (<a href="https://quantumcomputing.stackexchange.com/questions/18235/what-is-a-stabilizer-state?utm_source=openai">quantumcomputing.stackexchange.com</a>)</p>
</li>
</ul>
<p>Where the errors land
- No gate after CNOT21 touches qubits 2 or 1, and CNOT03 is last and only touches qubits 0 and 3. Hence the total Pauli error at the end factors as
  E = P21 ⊗ Q03,
  with P21 acting on qubits {2,1} and Q03 on {0,3}, independently drawn per the depolarizing model above.</p>
<p>Post-selection rule (detect-then-keep)
- “Post-select on all detectable errors” means we discard any run whose final stabilizer measurements report a nontrivial syndrome. For Pauli errors, an error is undetected exactly when it commutes with every stabilizer generator; i.e., E lies in the centralizer/normalizer N(S) of S in the 4‑qubit Pauli group. If E∉N(S), at least one generator anticommutes with E and yields a −1 outcome, so we reject the run. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)</p>
<p>Commutation constraints in parity form
- Represent a Pauli string by binary “X- and Z-parity” indicators: for each qubit j, let xj=1 if the local Pauli is X or Y and zj=1 if it is Z or Y (else 0). A Pauli E commutes with XXXX iff the total parity of {Z,Y} across all four qubits is even, i.e., ∑j zj≡0 (mod 2). It commutes with ZZZZ iff ∑j xj≡0 (mod 2). This is the standard symplectic-commutation rule in the stabilizer formalism. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)</p>
<p>Classify two-qubit Paulis on a given pair
- For any fixed pair, say (2,1), group the 16 Paulis (including II) by the two parities (a,b)≡(∑xj mod 2, ∑zj mod 2) on that pair:
  • Class 00: {II, XX, YY, ZZ} (size 4; among these, the 3 non-identity are XX, YY, ZZ)
  • Class 10: {XI, IX, YZ, ZY} (size 4)
  • Class 01: {ZI, IZ, XY, YX} (size 4)
  • Class 11: {XZ, ZX, IY, YI} (size 4)</p>
<p>Acceptance (probability that the run is kept)
- No error: accepted with probability (1−p)^2 (E=I∈N(S)).
- Exactly one gate errs (say on (2,1)): E lies in N(S) iff that pair error has even x-parity and even z-parity, i.e., it is in class 00 and non-identity ⇒ exactly 3 acceptable Paulis out of 15. The same holds if only (0,3) errs. Contribution: 2(1−p)p(3/15).
- Both gates err: E=P21⊗Q03 commutes with XXXX and ZZZZ iff the pairwise parities match between the two pairs (a,b)21=(a,b)03 (both constraints). Counting acceptable pairs among 15×15=225 possibilities:
  class 00: 3×3=9
  class 10: 4×4=16
  class 01: 4×4=16
  class 11: 4×4=16
  Total 57. Contribution: p^2·(57/225)=p^2·(19/75).</p>
<p>Therefore the post-selection acceptance probability is</p>
<div class="arithmatex">\[
P_{\rm acc}(p)
=(1-p)^2+2(1-p)p\frac{3}{15}+p^2\frac{57}{225}
=1-\frac{8}{5}p+\frac{64}{75}p^2.
\]</div>
<p>“Good” (logically correct) undetected errors
- Among accepted runs (E∈N(S)), the logical two-qubit state equals the intended |Φ+〉AB iff E acts on the codespace as an element of the logical-Bell stabilizer subgroup generated by XAXB and ZAZB (global phases ignored), i.e., E is in the state’s stabilizer. For our circuit this occurs exactly when:
  • No error, or
  • A single-pair error is one of {XX,YY,ZZ} on that pair, or
  • Both pairs have errors from {XX,YY,ZZ} on each pair (9 combinations).
  This is precisely the same counting that gave the physical 4‑qubit state fidelity in Subproblem 1:</p>
<div class="arithmatex">\[
P_{\rm good}(p)=(1-p)^2+2(1-p)p\frac{3}{15}+9\left(\frac{p}{15}\right)^2
=1-\frac{8}{5}p+\frac{16}{25}p^2,
\]</div>
<p>since {XX,YY,ZZ} stabilize the Bell state up to phase. (<a href="https://quantumcomputing.stackexchange.com/questions/18235/what-is-a-stabilizer-state?utm_source=openai">quantumcomputing.stackexchange.com</a>)</p>
<p>Logical fidelity conditioned on passing detection
- The desired quantity is the conditional fidelity of the logical 2‑qubit state given acceptance (syndrome +1), i.e.,</p>
<div class="arithmatex">\[
F_{\rm logical}(p)=\frac{P_{\rm good}(p)}{P_{\rm acc}(p)}
=\frac{1-\frac{8}{5}p+\frac{16}{25}p^2}{1-\frac{8}{5}p+\frac{64}{75}p^2}
=\frac{75-120p+48p^2}{75-120p+64p^2}.
\]</div>
<p>Sanity checks
- Small‑p expansion: using (1+αp+βp^2)/(1+γp+δp^2)=1+(α−γ)p+[β−δ−γ(α−γ)]p^2+… and noting the linear terms cancel, we get</p>
<div class="arithmatex">\[
F_{\rm logical}(p)=1-\frac{16}{75}p^2+O(p^3),
\]</div>
<p>showing first‑order errors are removed by post‑selection, as expected for a distance‑2 detection code. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)
- At p=1: Flogical(1)=(1/25)/(19/75)=3/19≈0.1579.</p>
<p>2) Mathematical Typesetting</p>
<p>All key steps above are written in LaTeX.</p>
<p>3) Conventions and Units</p>
<ul>
<li>Stabilizer-code notions (codespace as +1 eigenspace; undetected ⇔ in the normalizer; commutation via parity/symplectic rule) follow standard stabilizer formalism. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>, <a href="https://learning.quantum.ibm.com/course/foundations-of-quantum-error-correction/the-stabilizer-formalism?utm_source=openai">learning.quantum.ibm.com</a>)</li>
<li>Two‑qubit depolarizing channel is uniform over the 15 non-identity two‑qubit Paulis with total weight p. (<a href="https://quantumai.google/reference/python/cirq/DepolarizingChannel?utm_source=openai">quantumai.google</a>)</li>
<li>[[4,2,2]] code stabilizers {XXXX, ZZZZ}. (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>)</li>
<li>Bell |Φ+〉 stabilizer generated by {XX, ZZ} (with −YY also in the group). (<a href="https://quantumcomputing.stackexchange.com/questions/18235/what-is-a-stabilizer-state?utm_source=openai">quantumcomputing.stackexchange.com</a>)</li>
</ul>
<p>4) Final Answer:
Flogical(p) = (75 − 120 p + 48 p^2) / (75 − 120 p + 64 p^2) = [1 − (8/5)p + (16/25)p^2] / [1 − (8/5)p + (64/75)p^2].</p>
<p>Equivalently, for small p: Flogical(p) = 1 − (16/75)p^2 + O(p^3).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">75</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">48</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">75</span> <span class="o">-</span> <span class="mi">120</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">64</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:11.265378
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>