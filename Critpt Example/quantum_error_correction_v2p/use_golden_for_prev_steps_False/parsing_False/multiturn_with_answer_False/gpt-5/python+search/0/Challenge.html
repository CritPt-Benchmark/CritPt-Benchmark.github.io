<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Challenge</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h1 id="main-problem">Challenge</h1>
<p>Suppose that we prepare a logical two-qubit <span class="arithmatex">\(|00\rangle_{AB}\)</span> state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:</p>
<div class="arithmatex">\[
M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1)
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate and <span class="arithmatex">\(M\)</span> is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is <span class="arithmatex">\(|0\rangle\)</span> (<span class="arithmatex">\(|1\rangle\)</span>), the state preparation succeeds (fails).</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring <span class="arithmatex">\(|0\rangle\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>

<span class="c1"># Represent Pauli as two bit arrays x,z for n qubits</span>
<span class="c1"># Index ordering: qubits 0,1,2,3, ancilla 4</span>
<span class="n">n</span><span class="o">=</span><span class="mi">5</span>

<span class="c1"># mapping char to bits</span>
<span class="n">pauli_to_bits</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">bits_to_pauli</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="s1">&#39;Y&#39;</span><span class="p">}</span>

<span class="c1"># Multiplication ignoring global phase: XOR of bits</span>

<span class="k">def</span><span class="w"> </span><span class="nf">mult_bits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># a, b are tuples (x_list, z_list)</span>
    <span class="n">ax</span><span class="p">,</span> <span class="n">az</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">bx</span><span class="p">,</span> <span class="n">bz</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ai</span> <span class="o">^</span> <span class="n">bi</span><span class="p">)</span> <span class="k">for</span> <span class="n">ai</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">bx</span><span class="p">)]</span>
    <span class="n">cz</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ai</span> <span class="o">^</span> <span class="n">bi</span><span class="p">)</span> <span class="k">for</span> <span class="n">ai</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">az</span><span class="p">,</span> <span class="n">bz</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cz</span><span class="p">)</span>

<span class="c1"># Build Pauli from string like &#39;IXIZI&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">str_to_bits</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">zi</span> <span class="o">=</span> <span class="n">pauli_to_bits</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">xi</span><span class="p">;</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">zi</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="c1"># Conjugate Pauli (x,z) by CNOT(control-&gt;target)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">conj_cnot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">p</span>
    <span class="n">x</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">z</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="c1"># Save old values</span>
    <span class="n">xc</span><span class="p">,</span> <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="n">zc</span><span class="p">,</span> <span class="n">zt</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="c1"># Update according to symplectic mapping under CNOT</span>
    <span class="c1"># x_c&#39; = x_c</span>
    <span class="c1"># x_t&#39; = x_t XOR x_c</span>
    <span class="c1"># z_c&#39; = z_c XOR z_t</span>
    <span class="c1"># z_t&#39; = z_t</span>
    <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">xt</span> <span class="o">^</span> <span class="n">xc</span>
    <span class="n">z</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">zc</span> <span class="o">^</span> <span class="n">zt</span>
    <span class="c1"># x[c], z[t] remain the same by assignment</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>

<span class="c1"># Build initial identity Pauli bits</span>
<span class="n">I_bits</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>

<span class="c1"># Generate 4 Pauli options for a single qubit index i: I, X, Y, Z</span>
<span class="n">single_qubit_paulis</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

<span class="c1"># Pauli options for two qubits i,j</span>

<span class="k">def</span><span class="w"> </span><span class="nf">two_qubit_pauli_options</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
    <span class="c1"># generate 16 possibilities including II</span>
    <span class="n">opts</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">single_qubit_paulis</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">single_qubit_paulis</span><span class="p">:</span>
            <span class="c1"># Build string for whole 5-qubit system with default I</span>
            <span class="n">s</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">;</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">b</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">opts</span>

<span class="c1"># Sequence of CNOTs with their pairs (control, target) in time order</span>
<span class="n">cnots</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

<span class="c1"># Precompute for each gate index k the conjugation of any Pauli string under remaining gates to the end</span>
<span class="c1"># We&#39;ll define a function to propagate a Pauli inserted after gate k (i.e., after cnots[k]) to the end by conjugating through gates k+1..end</span>

<span class="k">def</span><span class="w"> </span><span class="nf">propagate_to_end</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">start_k</span><span class="p">):</span>
    <span class="n">p</span><span class="o">=</span><span class="n">bits</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnots</span><span class="p">)):</span>
        <span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">cnots</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">p</span><span class="o">=</span><span class="n">conj_cnot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Commutation check of two Paulis given as bits a (x,z) and b (x,z): they commute if symplectic inner product is 0 mod 2</span>

<span class="k">def</span><span class="w"> </span><span class="nf">commute</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">,</span><span class="n">az</span><span class="o">=</span><span class="n">a</span><span class="p">;</span> <span class="n">bx</span><span class="p">,</span><span class="n">bz</span><span class="o">=</span><span class="n">b</span>
    <span class="c1"># Compute sum over i of (a_x[i]*b_z[i] + a_z[i]*b_x[i]) mod 2</span>
    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">^=</span> <span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bz</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">^</span> <span class="p">(</span><span class="n">az</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Build stabilizers and logical Zs for data qubits 0..3 (ancilla 4 identity)</span>
<span class="c1"># XXXX on 0..3</span>
<span class="n">Sx_str</span> <span class="o">=</span> <span class="s1">&#39;XXXXI&#39;</span>
<span class="n">Sz_str</span> <span class="o">=</span> <span class="s1">&#39;ZZZZI&#39;</span>
<span class="n">Sx</span><span class="o">=</span> <span class="n">str_to_bits</span><span class="p">(</span><span class="n">Sx_str</span><span class="p">)</span>
<span class="n">Sz</span><span class="o">=</span> <span class="n">str_to_bits</span><span class="p">(</span><span class="n">Sz_str</span><span class="p">)</span>

<span class="c1"># Logical Z_A = ZZII on 0,1</span>
<span class="n">ZA_str</span><span class="o">=</span><span class="s1">&#39;ZZIII&#39;</span>  <span class="c1"># qubits 0,1 are Z, others I (2,3 ancilla 4 are I)</span>
<span class="n">ZB_str</span><span class="o">=</span><span class="s1">&#39;ZIZII&#39;</span>  <span class="c1"># qubits 0,2 Z</span>
<span class="n">ZA</span> <span class="o">=</span> <span class="n">str_to_bits</span><span class="p">(</span><span class="n">ZA_str</span><span class="p">)</span>
<span class="n">ZB</span> <span class="o">=</span> <span class="n">str_to_bits</span><span class="p">(</span><span class="n">ZB_str</span><span class="p">)</span>

<span class="c1"># Build the set of 16 Paulis for each gate pair positions</span>
<span class="n">pair_opts</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cnots</span><span class="p">):</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="n">two_qubit_pauli_options</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="n">pair_opts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">str_to_bits</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">])</span>

<span class="c1"># We&#39;ll enumerate all 16^5 patterns; compute acceptance and harm classification</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">prod</span>

<span class="c1"># Precompute identity indexes for faster</span>
<span class="c1"># We&#39;ll also compute for each gate g and option index j the propagated-to-end bits</span>
<span class="n">prop_cache</span><span class="o">=</span><span class="p">[[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">pair_opts</span><span class="p">[</span><span class="n">g</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">bits</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pair_opts</span><span class="p">[</span><span class="n">g</span><span class="p">]):</span>
        <span class="n">prop_cache</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">propagate_to_end</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

<span class="c1"># Now enumerate patterns as 5-tuples of option indices 0..15 per gate. We also need to compute the probability weight symbolically in terms of p. We&#39;ll accumulate counts by k (# non-identity errors) to be able to combine weights easily.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="c1"># We&#39;ll track contributions separated by k for accepted total weight and accepted harmful weight</span>
<span class="n">acc_total_by_k</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># counts of patterns with k non-identity errors that are accepted</span>
<span class="n">acc_bad_by_k</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>    

<span class="c1"># We&#39;ll also store raw counts for sanity</span>

<span class="c1"># Indices for II at each gate: the first option in two_qubit_pauli_options is &#39;I&#39; on both, so str &#39;IIIII&#39; for all except pair positions; yes &#39;I&#39; for both yields &#39;IIIII&#39;. So index 0 corresponds to II.</span>

<span class="c1"># Let&#39;s iterate</span>
<span class="n">count</span><span class="o">=</span><span class="mi">0</span>
<span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
    <span class="c1"># Compose final Pauli at end by XOR-summing the propagated bits for each non-identity selection</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">I_bits</span>
    <span class="n">k_nonid</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">j</span><span class="o">=</span><span class="n">idxs</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>  <span class="c1"># II at that location =&gt; no error</span>
            <span class="k">continue</span>
        <span class="n">k_nonid</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">mult_bits</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">prop_cache</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
    <span class="c1"># Acceptance: ancilla measurement 0 and code detection pass</span>
    <span class="c1"># Ancilla acceptance: no X/Y on qubit 4 =&gt; x4==0</span>
    <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">total</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="c1"># Code detection: commute with both stabilizers on data qubits</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">commute</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">Sx</span><span class="p">):</span>
        <span class="k">continue</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">commute</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">Sz</span><span class="p">):</span>
        <span class="k">continue</span>
    <span class="c1"># If we reach here, it&#39;s accepted</span>
    <span class="n">acc_total_by_k</span><span class="p">[</span><span class="n">k_nonid</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
    <span class="c1"># Harm: do we anticommute with Z_A or Z_B (data qubits)?</span>
    <span class="c1"># We check using commutation with ZA/ZB restricted to n=5 extended with I on ancilla</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">commute</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">ZA</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">commute</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">ZB</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">bad</span><span class="p">:</span>
        <span class="n">acc_bad_by_k</span><span class="p">[</span><span class="n">k_nonid</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total patterns enumerated:&#39;</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Accepted total counts by k:&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">acc_total_by_k</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Accepted bad counts by k:&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">acc_bad_by_k</span><span class="p">))</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="n">Total</span><span class="w"> </span><span class="n">patterns</span><span class="w"> </span><span class="n">enumerated</span><span class="p">:</span><span class="w"> </span><span class="mi">1048576</span>
<span class="n">Accepted</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">counts</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">k</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="mi">282</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="mi">4222</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"> </span><span class="mi">31637</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">:</span><span class="w"> </span><span class="mi">94923</span><span class="p">}</span>
<span class="n">Accepted</span><span class="w"> </span><span class="n">bad</span><span class="w"> </span><span class="n">counts</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">k</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="mi">144</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="mi">3024</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"> </span><span class="mi">24240</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">:</span><span class="w"> </span><span class="mi">70896</span><span class="p">}</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>

<span class="c1"># from earlier manual enumeration we had counts:</span>
<span class="n">A_counts</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">282</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">4222</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">31637</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">94923</span><span class="p">}</span>
<span class="n">B_counts</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">144</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">3024</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">24240</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">70896</span><span class="p">}</span>

<span class="c1"># We&#39;ll form exact rational polynomials in p: P_acc(p) = sum_k A_k (1-p)^(5-k) (p/15)^k</span>
<span class="c1"># We&#39;ll expand them as polynomials with Fraction coefficients: sum c_i * p^i for i=0..5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">expand_poly</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
    <span class="c1"># returns list coeffs c0..c5 for p^i terms</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>
    <span class="n">coeffs</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">Ak</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># term Ak * (1-p)^(5-k) * (p/15)^k</span>
        <span class="c1"># expand (1-p)^(5-k) = sum_{r=0}^{5-k} C(5-k, r) * (-p)^r</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="o">-</span><span class="n">k</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">Ak</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fraction</span><span class="p">(((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">r</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fraction</span><span class="p">(</span><span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;math&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># multiplies p^{r+k}</span>
            <span class="n">deg</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">k</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">deg</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">coeffs</span>

<span class="n">acc_coeffs</span> <span class="o">=</span> <span class="n">expand_poly</span><span class="p">(</span><span class="n">A_counts</span><span class="p">)</span>
<span class="n">bad_coeffs</span> <span class="o">=</span> <span class="n">expand_poly</span><span class="p">(</span><span class="n">B_counts</span><span class="p">)</span>

<span class="n">acc_coeffs</span><span class="p">,</span> <span class="n">bad_coeffs</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>&#39;&#39;
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc coefficients (c0..c5) as Fractions:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">acc_coeffs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_bad&amp;acc coefficients (d0..d5) as Fractions:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bad_coeffs</span><span class="p">)</span>

<span class="c1"># Now also compute series expansions as floats for readability</span>
<span class="n">acc_coeffs_float</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">acc_coeffs</span><span class="p">]</span>
<span class="n">bad_coeffs_float</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bad_coeffs</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc(p) =&#39;</span><span class="p">,</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">acc_coeffs_float</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">+.12g</span><span class="si">}</span><span class="s1"> p^</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">acc_coeffs_float</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">.12g</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_bad(p) =&#39;</span><span class="p">,</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bad_coeffs_float</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">+.12g</span><span class="si">}</span><span class="s1"> p^</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bad_coeffs_float</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">.12g</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>

<span class="c1"># Now derive conditional logical infidelity P_L = P_bad / P_acc and fidelity F = 1 - P_L</span>
<span class="c1"># We&#39;ll compute exact rational function and produce series expansion upto p^5 via power series division</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="k">def</span><span class="w"> </span><span class="nf">series_div</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="c1"># Given two polynomials num and den as coeff lists of Fractions for p^0..p^order, compute series for num/den upto p^order</span>
    <span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">r</span><span class="o">=</span><span class="n">num</span><span class="p">[:]</span>  <span class="c1"># remainder</span>
    <span class="c1"># Using formal power series division: q0 = n0/d0; then adjust recursively</span>
    <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">den</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">-=</span> <span class="n">den</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
        <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">/</span> <span class="n">den</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">q</span>

<span class="n">Linf_coeffs</span> <span class="o">=</span> <span class="n">series_div</span><span class="p">(</span><span class="n">bad_coeffs</span><span class="p">,</span> <span class="n">acc_coeffs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">F_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="n">F_coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Linf_coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">F_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">Linf_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series for logical fidelity F(p) = sum f_i p^i:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">F_coeffs</span><span class="p">])</span>

<span class="c1"># For completeness, also simplify exact rational function as numerator and denominator polynomials with integer coefficients by multiplying by 15^k and such.</span>
<span class="c1"># But for final answer, provide either rational function exact using integers or high-precision coefficients.</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#7</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
NameError: name &#39;acc_coeffs&#39; is not defined

P_acc coefficients (c0..c5) as Fractions:
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#8</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>

<span class="n">A_counts</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">282</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">4222</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">31637</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">94923</span><span class="p">}</span>
<span class="n">B_counts</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">144</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">3024</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">24240</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">70896</span><span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">expand_poly</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
    <span class="n">coeffs</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">Ak</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="o">-</span><span class="n">k</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">Ak</span><span class="p">,</span> <span class="mi">15</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fraction</span><span class="p">(((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">deg</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">k</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">deg</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">coeffs</span>

<span class="n">acc_coeffs</span> <span class="o">=</span> <span class="n">expand_poly</span><span class="p">(</span><span class="n">A_counts</span><span class="p">)</span>
<span class="n">bad_coeffs</span> <span class="o">=</span> <span class="n">expand_poly</span><span class="p">(</span><span class="n">B_counts</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc coefficients (Fractions):&#39;</span><span class="p">,</span> <span class="n">acc_coeffs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_bad&amp;acc coefficients (Fractions):&#39;</span><span class="p">,</span> <span class="n">bad_coeffs</span><span class="p">)</span>

<span class="n">acc_coeffs_float</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">acc_coeffs</span><span class="p">]</span>
<span class="n">bad_coeffs_float</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bad_coeffs</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_acc(p) =&#39;</span><span class="p">,</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">acc_coeffs_float</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">+.12g</span><span class="si">}</span><span class="s1"> p^</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">acc_coeffs_float</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">.12g</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P_bad(p) =&#39;</span><span class="p">,</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bad_coeffs_float</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">+.12g</span><span class="si">}</span><span class="s1"> p^</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bad_coeffs_float</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">.12g</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>

<span class="k">def</span><span class="w"> </span><span class="nf">series_div</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">den</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">-=</span> <span class="n">den</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
        <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">/</span> <span class="n">den</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">q</span>

<span class="n">Linf_coeffs</span> <span class="o">=</span> <span class="n">series_div</span><span class="p">(</span><span class="n">bad_coeffs</span><span class="p">,</span> <span class="n">acc_coeffs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">F_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="n">F_coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Linf_coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">F_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">Linf_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Series for logical fidelity F(p) coefficients (Fractions):&#39;</span><span class="p">,</span> <span class="n">F_coeffs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F(p) =&#39;</span><span class="p">,</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">F_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">:</span><span class="s1">+.12g</span><span class="si">}</span><span class="s1"> p^</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">F_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">:</span><span class="s1">.12g</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
</code></pre></div></div>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#9</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>P_acc coefficients (Fractions): [Fraction(1, 1), Fraction(-68, 15), Fraction(704, 75), Fraction(-32768, 3375), Fraction(253952, 50625), Fraction(-262144, 253125)]
P_bad&amp;acc coefficients (Fractions): [Fraction(0, 1), Fraction(0, 1), Fraction(16, 25), Fraction(-128, 125), Fraction(2048, 3375), Fraction(-32768, 253125)]
P_acc(p) = 1 + -4.53333333333 p^1 + +9.38666666667 p^2 + -9.70903703704 p^3 + +5.01633580247 p^4 + -1.03563061728 p^5
P_bad(p) = 0 + +0 p^1 + +0.64 p^2 + -1.024 p^3 + +0.606814814815 p^4 + -0.12945382716 p^5
Series for logical fidelity F(p) coefficients (Fractions): [Fraction(1, 1), Fraction(0, 1), Fraction(-16, 25), Fraction(-704, 375), Fraction(-10496, 3375), Fraction(-216064, 84375)]
F(p) = 1 + +0 p^1 + -0.64 p^2 + -1.87733333333 p^3 + -3.10992592593 p^4 + -2.56075851852 p^5
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#10</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="n">F_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">704</span><span class="p">,</span><span class="mi">375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">10496</span><span class="p">,</span><span class="mi">3375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">216064</span><span class="p">,</span><span class="mi">84375</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">F_coeffs</span><span class="p">])</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#11</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>[1.0, 0.0, -0.64, -1.8773333333333333, -3.1099259259259258, -2.5607585185185187]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#12</span>
    </div>
    
                    <details class="tool-call">
                      <summary>Tool Call <span class="tag">(code to execute)</span></summary>
                      <div class="markdown-body tool-call-body">
                        <div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">lcm</span>
<span class="n">acc_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">68</span><span class="p">,</span><span class="mi">15</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span><span class="mi">75</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">32768</span><span class="p">,</span><span class="mi">3375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span><span class="mi">50625</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">262144</span><span class="p">,</span><span class="mi">253125</span><span class="p">)]</span>
<span class="c1"># Compute LCM of denominators</span>
<span class="n">L</span><span class="o">=</span><span class="mi">1</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">acc_coeffs</span><span class="p">:</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LCM denom&#39;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="c1"># compute integer numerators for each power after scaling by L</span>
<span class="n">nums</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">acc_coeffs</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scaled integer coefficients (deg0..5):&#39;</span><span class="p">,</span> <span class="n">nums</span><span class="p">)</span>

<span class="n">bad_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">128</span><span class="p">,</span><span class="mi">125</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span><span class="mi">3375</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="o">-</span><span class="mi">32768</span><span class="p">,</span><span class="mi">253125</span><span class="p">)]</span>
<span class="n">L2</span><span class="o">=</span><span class="mi">1</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bad_coeffs</span><span class="p">:</span>
    <span class="n">L2</span><span class="o">=</span><span class="n">lcm</span><span class="p">(</span><span class="n">L2</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LCM denom bad&#39;</span><span class="p">,</span> <span class="n">L2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scaled integer coefficients bad:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">L2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bad_coeffs</span><span class="p">])</span>
</code></pre></div>
                      </div>
                    </details>
</article>


<article class="message role-tool">
    <div class="meta">
        <span class="badge">Tool</span>
        <span class="idx">#13</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code>LCM denom 253125
Scaled integer coefficients (deg0..5): [253125, -1147500, 2376000, -2457600, 1269760, -262144]
LCM denom bad 253125
Scaled integer coefficients bad: [0, 0, 162000, -259200, 153600, -32768]
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#14</span>
    </div>
    <div class="content markdown-body"><p>1) Step-by-step derivation</p>
<p>Setup and conventions</p>
<ul>
<li>Physical qubits: 0,1,2,3; ancilla: 4. Logical qubits: A,B.</li>
<li>Stabilizers: Sx = XXXX, Sz = ZZZZ on data qubits 0–3.</li>
<li>Logical Paulis (as given): XA = XIXI, XB = XXII, ZA = ZZII, ZB = ZIZI.</li>
<li>Circuit (right-to-left execution): H1 → CNOT12 → CNOT10 → CNOT23 → CNOT34 → CNOT04 → M4 in Z basis.</li>
</ul>
<p>Noise model</p>
<ul>
<li>After each two-qubit gate, apply an n = 2 qubit depolarizing channel: with probability 1 − p do nothing; with probability p choose uniformly one of the 4^2 − 1 = 15 non-identity two-qubit Paulis. That is, each non-identity two-qubit Pauli occurs with probability p/15. (<a href="https://quantumai.google/reference/python/cirq/DepolarizingChannel?utm_source=openai">quantumai.google</a>)</li>
</ul>
<p>Clifford propagation of Paulis</p>
<ul>
<li>We analyze errors in the Pauli frame. Under conjugation by CNOT(c→t), Pauli operators transform as
  CNOT (Xc ⊗ I) CNOT† = Xc ⊗ Xt,
  CNOT (Ic ⊗ Xt) CNOT† = Ic ⊗ Xt,
  CNOT (Zc ⊗ I) CNOT† = Zc ⊗ I,
  CNOT (I ⊗ Zt) CNOT† = Zc ⊗ Zt. (<a href="https://wangbard.github.io/posts/Clifford-gates-and-non-Clifford-gates/?utm_source=openai">wangbard.github.io</a>, <a href="https://zxcalc.github.io/book/html/main_htmlch6.html?utm_source=openai">zxcalc.github.io</a>)</li>
<li>In binary symplectic form, this is the update rule for the Pauli vector (x|z):
  x′t = xt ⊕ xc, x′c = xc; z′c = zc ⊕ zt, z′t = zt (other qubits unchanged).</li>
</ul>
<p>Accept/reject (post-selection) criteria</p>
<p>We post-select on both:
- The ancilla measurement M4 giving 0 in Z basis: equivalently, the final Pauli error must have no X or Y on qubit 4 (i.e., x4 = 0). An X or Y on the measured qubit flips the Z-basis outcome, whereas a Z does not. (<a href="https://zxcalc.github.io/book/html/main_htmlch11.html?utm_source=openai">zxcalc.github.io</a>)
- No detectable error on the 4 data qubits, i.e., the final data-qubit Pauli Edata commutes with both stabilizers Sx and Sz:
  [Edata, XXXX] = 0 and [Edata, ZZZZ] = 0.</p>
<p>Logical correctness among accepted runs</p>
<ul>
<li>Among accepted runs, the prepared logical |00⟩AB is wrong if Edata acts nontrivially on the code space (a logical error), i.e., if it anticommutes with at least one of ZA or ZB:
  {Edata, ZA} ≠ 0 or {Edata, ZB} ≠ 0.</li>
<li>An accepted error that is a stabilizer (or identity) is harmless.</li>
</ul>
<p>Counting framework</p>
<ul>
<li>There are five noisy two-qubit gates in the circuit (the five CNOTs). After each, an independent two-qubit Pauli is applied, chosen from the 16 possibilities {II, IX, …, ZZ} with probabilities
  Pr[II] = 1 − p,    Pr[P ≠ II] = p/15.</li>
<li>Denote by k the number of non-identity faults (k = 0,…,5). For a particular pattern (choice of which gates are faulty and which two-qubit Pauli each applies), its probability weight is (1 − p)^(5−k) (p/15)^k.</li>
<li>For each pattern we propagate all five inserted Pauli errors forward to the end of the circuit using the CNOT conjugation rules above, multiply them (Pauli frame; global phases irrelevant), and test the two acceptance conditions plus the logical-error condition.</li>
</ul>
<p>Exhaustive enumeration (stabilizer/Pauli-frame computation)</p>
<ul>
<li>We performed an exact enumeration of all 16^5 = 1,048,576 error patterns using symplectic-Pauli arithmetic:</li>
<li>Track (x|z) bits on 5 qubits.</li>
<li>Conjugate through later CNOTs as in the rule above.</li>
<li>Accept if x4 = 0 and commute with both Sx, Sz.</li>
<li>Among accepted, mark “bad” if anticommutes with ZA or ZB.</li>
<li>The numbers of accepted patterns (Ak) and of accepted-but-logically-bad patterns (Bk) for each k are:
  A0 = 1, A1 = 7, A2 = 282, A3 = 4222, A4 = 31637, A5 = 94923,
  B0 = 0, B1 = 0, B2 = 144, B3 = 3024, B4 = 24240, B5 = 70896.</li>
<li>Therefore
  Pacc(p) = Σk Ak (1 − p)^(5−k) (p/15)^k,
  Pbad(p) = Σk Bk (1 − p)^(5−k) (p/15)^k,
  Plog(p) = Pbad(p)/Pacc(p),  Flog(p) = 1 − Plog(p).</li>
</ul>
<p>Closed-form polynomials</p>
<p>Expanding the sums yields exact polynomials with rational coefficients:</p>
<ul>
<li>
<p>Acceptance probability:
  Pacc(p) = 1 − (68/15) p + (704/75) p^2 − (32768/3375) p^3 + (253952/50625) p^4 − (262144/253125) p^5.</p>
</li>
<li>
<p>Accepted logical-error probability (numerator):
  Pbad(p) = (16/25) p^2 − (128/125) p^3 + (2048/3375) p^4 − (32768/253125) p^5.</p>
</li>
</ul>
<p>Equivalently, with a common denominator 253125:
- 253125 Pacc(p) = 253125 − 1147500 p + 2376000 p^2 − 2457600 p^3 + 1269760 p^4 − 262144 p^5,
- 253125 Pbad(p) = 162000 p^2 − 259200 p^3 + 153600 p^4 − 32768 p^5.</p>
<p>Thus, the conditional logical infidelity and fidelity are
- Plog(p) = Pbad(p)/Pacc(p),
- Flog(p) = 1 − Pbad(p)/Pacc(p)
  = 1 − [162000 p^2 − 259200 p^3 + 153600 p^4 − 32768 p^5] / [253125 − 1147500 p + 2376000 p^2 − 2457600 p^3 + 1269760 p^4 − 262144 p^5].</p>
<p>Small-p series (fault-tolerance check)</p>
<p>Expanding Flog(p) to fifth order in p gives
Flog(p) = 1 − (16/25) p^2 − (704/375) p^3 − (10496/3375) p^4 − (216064/84375) p^5 + O(p^6)
= 1 − 0.64 p^2 − 1.877333333333 p^3 − 3.109925925926 p^4 − 2.560758518519 p^5 + O(p^6).</p>
<ul>
<li>The absence of an O(p) term shows the circuit is first-order fault-tolerant under this error model when post-selecting on both the code syndrome and ancilla outcome.</li>
</ul>
<p>Sanity checks and interpretation</p>
<ul>
<li>Single faults (k = 1) are almost always detected/rejected: A1 = 7 accepted out of 5×15 = 75 possible single-fault patterns; none of the accepted singles cause a logical error (B1 = 0). Logical errors first appear at order p^2 via two-fault mechanisms (B2 = 144), consistent with Flog = 1 − O(p^2).</li>
<li>The acceptance probability for small p is Pacc(p) = 1 − 4.5333… p + 9.3867… p^2 + …; strong linear rejection means post-selection discards most single-fault runs.</li>
</ul>
<p>Notes on sources</p>
<ul>
<li>CNOT’s action on Paulis used for Pauli-frame propagation. (<a href="https://wangbard.github.io/posts/Clifford-gates-and-non-Clifford-gates/?utm_source=openai">wangbard.github.io</a>, <a href="https://zxcalc.github.io/book/html/main_htmlch6.html?utm_source=openai">zxcalc.github.io</a>)</li>
<li>Depolarizing-channel convention p/(4^n − 1) for non-identity Paulis. (<a href="https://quantumai.google/reference/python/cirq/DepolarizingChannel?utm_source=openai">quantumai.google</a>)</li>
<li>[[4,2,2]] code’s stabilizers and logicals (stabilizers match the statement; logical choices are equivalent up to stabilizers). (<a href="https://errorcorrectionzoo.org/c/stab_4_2_2?utm_source=openai">errorcorrectionzoo.org</a>, <a href="https://ar5iv.labs.arxiv.org/html/1907.11157v1?utm_source=openai">ar5iv.labs.arxiv.org</a>)</li>
</ul>
<p>2) Mathematical expressions</p>
<ul>
<li>Pacc(p) = 1 − 68 15 p + 704 75 p^2 − 32768 3375 p^3 + 253952 50625 p^4 − 262144 253125 p^5.</li>
<li>Pbad(p) = 16 25 p^2 − 128 125 p^3 + 2048 3375 p^4 − 32768 253125 p^5.</li>
<li>Flog(p) = 1 − Pbad(p)/Pacc(p).</li>
</ul>
<p>3) Conventions and units</p>
<ul>
<li>Dimensionless probabilities p∈[0,1].</li>
<li>Logical fidelity defined conditionally on acceptance (post-selection).</li>
</ul>
<p>4) Final Answer:
The post-selected logical state fidelity as a function of the two-qubit gate error rate p is
Flog(p) = 1 − Pbad(p)/Pacc(p),
with
Pacc(p) = 1 − 68 15 p + 704 75 p^2 − 32768 3375 p^3 + 253952 50625 p^4 − 262144 253125 p^5,
Pbad(p) = 16 25 p^2 − 128 125 p^3 + 2048 3375 p^4 − 32768 253125 p^5.</p>
<p>Equivalently,
Flog(p) = 1 − 162000 p^2 − 259200 p^3 + 153600 p^4 − 32768 p^5 253125 − 1147500 p + 2376000 p^2 − 2457600 p^3 + 1269760 p^4 − 262144 p^5 ,
and its small-p expansion is
Flog(p) = 1 − 16 25 p^2 − 704 375 p^3 − 10496 3375 p^4 − 216064 84375 p^5 + O(p^6).</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#15</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#16</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of the logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of two-qubit gate error rate $p$.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">P_acc</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">68</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">704</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">253952</span><span class="p">,</span> <span class="mi">50625</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">262144</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">P_bad</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">125</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">3</span>
        <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">3375</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">4</span>
        <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">253125</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">P_bad</span> <span class="o">/</span> <span class="n">P_acc</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.039169
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>