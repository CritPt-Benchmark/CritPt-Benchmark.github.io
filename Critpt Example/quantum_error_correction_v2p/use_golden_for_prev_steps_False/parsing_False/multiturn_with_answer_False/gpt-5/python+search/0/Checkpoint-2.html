<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Checkpoint-2</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

</style>
<style>
    :root {
  --bg: #ffffff;
  --fg: #222222;
  --muted: #555555;
  --border: #e0e0e0;
  --accent: #005fcc;
  --code-bg: #f6f8fa;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
html.dark {
  --bg: #0b0b0b;
  --fg: #e8e8e8;
  --muted: #a0a0a0;
  --border: #333333;
  --accent: #3b82f6;
  --code-bg: #111827;
  --role-user: #0ea5e9;
  --role-assistant: #22c55e;
  --role-system: #9ca3af;
  --return-code: #a35291;
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
  line-height: 1.6;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
  z-index: 10;
}
h1 {
  margin: 0;
  font-size: 1.1rem;
}
.tabs {
  display: flex;
  gap: 0.5rem;
}
.tab {
  padding: 0.4rem 0.8rem;
  border: 1px solid var(--border);
  border-bottom: none;
  background: transparent;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  color: var(--fg);
}
.tab.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}
.tab-content {
  display: none;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border);
}
.tab-content.active {
  display: block;
}
#theme-toggle {
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  font-size: 0.9rem;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
  color: var(--fg);
}
.main {
  max-width: 1200px;
  margin: 0 auto;
}
.message {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.message .meta {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  margin-bottom: 0.6rem;
  color: var(--muted);
  font-size: 0.85rem;
}
.message .badge {
  font-weight: 600;
}
.role-user {
  border-left-color: var(--role-user);
}
.role-assistant {
  border-left-color: var(--role-assistant);
}
.role-system {
  border-left-color: var(--role-system);
}
.role-unknown {
  border-left-color: var(--accent);
}

.output-code-container {
  display: flex;
  gap: 1rem;               /* space between children */
  align-items: center;     /* vertical alignment */
  justify-content: start;  /* horizontal alignment */
}

.output-code-container .codeblock {
  flex: 0 1 auto;
}

.codeblock {
  border: 1px solid var(--border);
  border-left-width: 6px;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin-bottom: 1rem;
  background: rgba(0,0,0,0.02);
}
.codeblock-content {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}

.codeblock.eval_code {
  border-left-color: var(--role-user);
}
.codeblock.target_code {
  border-left-color: var(--role-assistant);
}
.codeblock.output_code {
  border-left-color: var(--role-system);
}

html.dark .codeblock-content {
  background: rgba(255,255,255,0.03);
}
.codeblock > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.codeblock > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.codeblock > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.codeblock[open] > summary::before {
  transform: rotate(90deg);
}
.codeblock .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}

.markdown-body pre code {
  background: var(--code-bg);
  display: block;
  padding: 0.75rem;
  overflow-x: auto;
  border-radius: 4px;
  border: 1px solid var(--border);
}
.markdown-body code {
  background: var(--code-bg);
  padding: 0.15rem 0.3rem;
  border-radius: 4px;
}
/* Extra info tree */
details > summary {
  cursor: pointer;
  font-weight: 600;
}
details .block {
  padding-left: 1rem;
  margin: 0.25rem 0 0.5rem 0;
  border-left: 2px solid var(--border);
}
.kv .key {
  font-weight: 600;
}
.kv .type {
  color: var(--muted);
  margin-left: 0.5rem;
  font-size: 0.85rem;
}
footer {
  margin: 2rem 0;
  text-align: center;
  color: var(--muted);
  font-size: 0.85rem;
}
/* CodeHilite (pygments) overrides to respect theme vars */
.codehilite {
  background: var(--code-bg) !important;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.75rem !important;
}
.reasoning {
  margin-bottom: 0.6rem;
  border: 1px dashed var(--border);
  border-radius: 4px;
  padding: 0.4rem 0.6rem;
  background: rgba(0,0,0,0.02);
}
html.dark .reasoning {
  background: rgba(255,255,255,0.03);
}
.reasoning > summary {
  cursor: pointer;
  font-weight: 600;
  list-style: none; /* remove default triangle in some browsers */
}
.reasoning > summary::-webkit-details-marker {
  display: none; /* Safari/Chrome marker */
}
.reasoning > summary::before {
  content: "▶ ";
  display: inline-block;
  transform: rotate(0deg);
  transition: transform 0.12s ease-out;
}
.reasoning[open] > summary::before {
  transform: rotate(90deg);
}
.reasoning .tag {
  color: var(--muted);
  font-weight: 400;
  font-size: 0.85em;
  margin-left: 0.25rem;
}
.reasoning-body {
  margin-top: 0.5rem;
}
</style>

<!-- ===== MATHJAX CONFIG ===== -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: ".*",
    processHtmlClass: "arithmatex"

    // skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    // if you dynamically add content later, you can call MathJax.typesetPromise()
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<!-- ========================== -->
</head>
<body>
<header>
  <h1>Checkpoint-2</h1>
  <div>
    <button id="theme-toggle" aria-label="toggle dark mode">🌓</button>
  </div>
</header>

<div class="main">
  
<article class="message role-system">
    <div class="meta">
        <span class="badge">System</span>
        <span class="idx">#0</span>
    </div>
    <div class="content markdown-body"><p>You are a physics research assistant specializing in solving complex, research-level problems using precise, step-by-step reasoning.</p>
<p><strong>Input</strong>
Problems will be provided in Markdown format.</p>
<p><strong>Output (Markdown format)</strong></p>
<ol>
<li><strong>Step-by-Step Derivation</strong> - Show every non-trivial step in the solution.  Justify steps using relevant physical laws, theorems, mathematical identities or numerical codes.</li>
<li><strong>Mathematical Typesetting</strong> - Use LaTeX for all mathematics:  <code>$...$</code> for inline expressions, <code>$$...$$</code> for display equations.</li>
<li><strong>Conventions and Units</strong> - Follow the unit system and conventions specified in the problem.</li>
<li>
<p><strong>Final Answer</strong> - At the end of the solution,  start a new line with <strong>&ldquo;Final Answer:&rdquo;</strong>, and present the final result.</p>
<p>For final answers involving values, follow the precision requirements specified in the problem.
If no precision is specified:
- If an exact value is possible, provide it (e.g., \$\sqrt(2)\$, \$\pi/4\$).
- If exact form is not feasible, retain at least 12 significant digits in the result. </p>
</li>
<li>
<p><strong>Formatting Compliance</strong> - If the user requests a specific output format (e.g., code, table),  provide the final answer accordingly.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.
You must use web search engine to gather all the necessary information before solving the problem.</p>
</li>
</ol></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#1</span>
    </div>
    <div class="content markdown-body"><h1 id="problem-setup">Problem setup:</h1>
<p>In quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.</p>
<p>Our convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are <span class="arithmatex">\(XXXX\)</span> and <span class="arithmatex">\(ZZZZ\)</span>, where <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> are Pauli matrices. The logical <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(Z\)</span> operators on the two qubits are <span class="arithmatex">\(X_A = XIXI\)</span>, <span class="arithmatex">\(X_B=XXII\)</span>, <span class="arithmatex">\(Z_A = ZZII\)</span>, <span class="arithmatex">\(Z_B = ZIZI\)</span>, up to multiplication by stabilizers.</p>
<p>We will consider different state preparation circuits consisting of controlled not <span class="arithmatex">\(CNOT_{ij}\)</span> gates, where <span class="arithmatex">\(CNOT_{ij}\)</span> has control qubit <span class="arithmatex">\(i\)</span> and target qubit <span class="arithmatex">\(j\)</span>. As a simple model of quantum errors in hardware, we will suppose that each <span class="arithmatex">\(CNOT_{ij}\)</span> gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability <span class="arithmatex">\(p/15\)</span>. The probability <span class="arithmatex">\(p\)</span> indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity <span class="arithmatex">\(p\)</span>.</p>
<h2 id="subproblem-1">Checkpoint 1</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#2</span>
    </div>
    <div class="content markdown-body"><p>Step-by-Step Derivation</p>
<p>1) Ideal target state and its stabilizers</p>
<ul>
<li>The circuit acts (right-to-left) as H2 → CNOT21 → H0 → CNOT03 on |0000⟩, yielding the pure 4‑qubit state</li>
</ul>
<div class="arithmatex">\[
|\Psi\rangle=\frac{1}{2}\big(|0000\rangle+|1001\rangle+|0110\rangle+|1111\rangle\big).
\]</div>
<p>This state is the [[4,2,2]]-encoded logical Bell (two‑qubit GHZ) state |Φ+⟩AB, i.e., (|00⟩AB+|11⟩AB)/√2, stabilized (in the logical basis) by X_A X_B and Z_A Z_B, exactly as a Bell state is stabilized by XX and ZZ. Using the given physical representatives X_A=XIXI, X_B=XXII, Z_A=ZZII, Z_B=ZIZI, we obtain physical logical stabilizers</p>
<div class="arithmatex">\[
X_A X_B=(XIXI)(XXII)=IXXI,\qquad Z_A Z_B=(ZZII)(ZIZI)=IZZI.
\]</div>
<p>Together with the code stabilizers XXXX and ZZZZ, these generate the 4‑qubit stabilizer group S of |Ψ⟩. In particular, S contains three weight‑2 Paulis on qubits (1,2): IXXI, IZZI, IYYI (up to phases), three weight‑2 Paulis on qubits (0,3): XIII X, ZIIZ, YIIY, and nine weight‑4 Paulis formed by their products (e.g., XXXX, ZZZZ, ZX XZ, XZZX, etc.). The Bell-state stabilizer fact is standard, and Clifford/logical replacement uses the given logical operators. (<a href="https://en.wikipedia.org/wiki/Bell_state?utm_source=openai">en.wikipedia.org</a>)</p>
<p>2) Noise model located in the circuit</p>
<ul>
<li>After each CNOT gate we apply an independent two‑qubit depolarizing channel on that gate’s qubits:</li>
</ul>
<div class="arithmatex">\[
\mathcal{E}_p(\rho)=(1-p)\rho+\frac{p}{15}\sum_{P\in\mathcal{P}_2\setminus\{II\}} P\rho P,
\]</div>
<p>i.e., with probability 1−p no error occurs; with probability p a uniformly random non‑identity 2‑qubit Pauli from the 15 possibilities is applied. One channel acts on qubits (2,1) after CNOT21; the other acts on qubits (0,3) after CNOT03. (A uniform Pauli mixture over all non‑identity n‑qubit Paulis is the “uniform Pauli error” form of the depolarizing channel.) (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>, <a href="https://qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud/documentation/stable/0.24/_modules/qiskit/providers/aer/noise/errors/standard_errors.html?utm_source=openai">qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud</a>)</p>
<ul>
<li>Because later gates act on disjoint qubits (H0 and CNOT03 do not touch qubits 1 or 2), the Pauli error drawn after CNOT21 remains a Pauli on qubits (1,2) until the end, and similarly for the error after CNOT03 on qubits (0,3). Clifford gates map Paulis to Paulis under conjugation; here, disjoint support also makes the propagation trivial. (<a href="https://en.wikipedia.org/wiki/Clifford_gate?utm_source=openai">en.wikipedia.org</a>)</li>
</ul>
<p>3) Fidelity reduction to counting stabilizer elements</p>
<ul>
<li>Let P03 be the (possibly identity) Pauli on qubits (0,3) drawn by the last channel, and P12 the (possibly identity) Pauli on (1,2) drawn by the first. The final state is a classical mixture of (P03⊗P12)|Ψ⟩. For a pure stabilizer state |Ψ⟩, the state fidelity with |Ψ⟩,</li>
</ul>
<div class="arithmatex">\[
\]</div>
<p>equals the total probability that the net Pauli P03⊗P12 lies in the stabilizer group S of |Ψ⟩ (since |Ψ⟩ is the unique +1 eigenstate of S; for P∉S the overlap vanishes). Thus, the fidelity is a counting problem over stabilizer elements reachable by the two channels. (<a href="https://zxcalc.github.io/book/html/main_htmlch6.html?utm_source=openai">zxcalc.github.io</a>)</p>
<p>4) Counting cases that preserve the state</p>
<ul>
<li>
<p>Event types:
  1) No error on either channel: probability (1−p)^2; the net Pauli is I and lies in S.
  2) Exactly one two‑qubit error (on one pair only): probability 2(1−p)p. On a given pair, 3 of the 15 non‑identity two‑qubit Paulis are in S (for (1,2): IXXI, IZZI, IYYI; for (0,3): XIII X, ZIIZ, YIIY). Hence the conditional success probability is 3/15=1/5.
  3) Two errors (one on each pair): probability p^2. There are 15×15=225 ordered pairs of non‑identity Paulis. Exactly 9 give a stabilizer element: all combinations where the (0,3) Pauli is one of {XX,YY,ZZ} and the (1,2) Pauli is one of {XX,YY,ZZ}, yielding the 9 weight‑4 stabilizers (e.g., XXXX= (XX)03⊗(XX)12, ZZZZ= (ZZ)03⊗(ZZ)12, etc.). Thus the conditional success probability is 9/225=1/25.</p>
</li>
<li>
<p>Summing contributions:</p>
</li>
</ul>
<div class="arithmatex">\[
  F(p)
  &amp;= (1-p)^2\;+\;2(1-p)p\cdot\frac{3}{15}\;+\;p^2\cdot\frac{9}{225}\\
  &amp;= (1-p)^2+\frac{2}{5}p(1-p)+\frac{1}{25}p^2\\
  &amp;= 1-\frac{8}{5}p+\frac{16}{25}p^2\\
  &amp;= \big(1-\tfrac{4}{5}p\big)^2.
\]</div>
<p>Notes on ingredients cited: the stabilizers of Bell/|Φ+⟩ are generated by XX and ZZ; two‑qubit depolarizing as a uniform mixture over the 15 non‑identity Paulis is the standard “uniform Pauli error” form of an n‑qubit depolarizing channel; and Clifford gates map Pauli errors to Pauli errors under conjugation, which justifies treating each Pauli error at the end of the circuit. (<a href="https://en.wikipedia.org/wiki/Bell_state?utm_source=openai">en.wikipedia.org</a>, <a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.depolarizing_error.html?utm_source=openai">qiskit.github.io</a>, <a href="https://qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud/documentation/stable/0.24/_modules/qiskit/providers/aer/noise/errors/standard_errors.html?utm_source=openai">qiskit-org-web-resources.s3.us.cloud-object-storage.appdomain.cloud</a>)</p>
<p>Final Answer:
F(p) = 1 − (8/5)p + (16/25)p^2 = (1 − 4p/5)^2.</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#3</span>
    </div>
    <div class="content markdown-body"><h2 id="subproblem-2">Checkpoint 2</h2>
<p>Suppose that we wish to prepare a logical two-qubit GHZ state  <span class="arithmatex">\((|00\rangle_{AB}+|11\rangle_{AB})/\sqrt{2}\)</span> in the [[4,2,2]] code. To do so, we use the following state preparation circuit:</p>
<div class="arithmatex">\[
(CNOT_{03}) (H_0) (CNOT_{21}) (H_2).
\]</div>
<p>Note that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). <span class="arithmatex">\(H\)</span> is a single-qubit Hadamard gate.</p>
<p>What is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate <span class="arithmatex">\(p\)</span>, assuming the state is post-selected on all detectable errors in the code?</p></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#4</span>
    </div>
    <div class="content markdown-body"><p>Step-by-Step Derivation</p>
<p>1) What “post-selecting on all detectable errors” means and how to compute logical fidelity</p>
<ul>
<li>
<p>The [[4,2,2]] code has stabilizer generators S = ⟨XXXX, ZZZZ⟩. Measuring these two generators and keeping only +1 outcomes projects onto the code space. A Pauli error P is “detectable” (and thus rejected) if it anticommutes with at least one generator; equivalently, it is accepted iff it commutes with both generators, i.e., P∈N(S) (the normalizer/centralizer of S). Errors in N(S)\S act as nontrivial logical Paulis; errors in S act trivially. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>, <a href="https://leftasexercise.com/2019/02/11/quantum-error-correction-with-stabilizer-codes/?utm_source=openai">leftasexercise.com</a>)</p>
</li>
<li>
<p>The target logical state is the logical Bell state |Φ+⟩AB = (|00⟩AB+|11⟩AB)/√2. In the logical basis it is stabilized by XAXB and ZAZB, just as a 2‑qubit Bell state is stabilized by XX and ZZ. Hence, among accepted (normalizer) errors, those that are equivalent (mod S) to I, XAXB, ZAZB, or YAYB leave the logical |Φ+⟩ unchanged; any other logical Pauli maps it to an orthogonal Bell state. Therefore the logical fidelity, conditioned on acceptance, is
  Flogical(p) = P{P ∈ Sstate}/P{P ∈ N(S)},
  where Sstate is the full stabilizer group of the prepared 4‑qubit codeword (generated by XXXX, ZZZZ together with physical representatives of XAXB and ZAZB). (<a href="https://zxcalc.github.io/book/html/main_htmlch6.html?utm_source=openai">zxcalc.github.io</a>)</p>
</li>
</ul>
<p>2) Noise model and independence across pairs</p>
<ul>
<li>
<p>The circuit has two CNOTs; we place an independent two‑qubit depolarizing channel after each CNOT. For a 2‑qubit system (d=4), the depolarizing channel is the uniform mixture over the 15 non‑identity 2‑qubit Paulis, so each non‑identity Pauli occurs with probability p/15 and “no error” occurs with probability 1−p. One channel acts on qubits (2,1) after CNOT21; the other acts on (0,3) after CNOT03. Subsequent gates act on disjoint qubits, so each drawn Pauli remains on its pair until the end. (<a href="https://en.wikipedia.org/wiki/Quantum_depolarizing_channel?utm_source=openai">en.wikipedia.org</a>)</p>
</li>
<li>
<p>Denote the (possibly identity) Pauli on pair (1,2) by P12 and on (0,3) by P03. The net (final) Pauli is P = P03 ⊗ P12.</p>
</li>
</ul>
<p>3) Classifying a 2‑qubit Pauli by its commutation with XXXX and ZZZZ</p>
<ul>
<li>
<p>For any Pauli P, P commutes with ZZZZ iff the total number of X or Y factors in P is even, and P commutes with XXXX iff the total number of Z or Y factors is even. For a 2‑qubit Pauli Q acting on a specific pair, define its “syndrome parity” s(Q) = (sX(Q), sZ(Q)) with
  sX(Q) = parity of {Z,Y} in Q,  sZ(Q) = parity of {X,Y} in Q.
  For the two disjoint pairs, acceptance requires the total parity over all 4 qubits to be even, i.e., s(P12) ⊕ s(P03) = (0,0). (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>)</p>
</li>
<li>
<p>Enumerating the 15 non‑identity 2‑qubit Paulis on one pair and grouping by s(Q):
  • s=(0,0): {XX, YY, ZZ} → 3 elements,
  • s=(1,0): {ZI, IZ, XY, YX} → 4 elements,
  • s=(0,1): {XI, IX, YZ, ZY} → 4 elements,
  • s=(1,1): {YI, IY, XZ, ZX} → 4 elements.
  (Here I, X, Y, Z act on the two qubits of that pair.)</p>
</li>
</ul>
<p>4) Probability the run is accepted (passes both stabilizers)</p>
<p>Break into mutually exclusive cases:</p>
<ul>
<li>
<p>No error on either channel: probability (1−p)^2, accepted.</p>
</li>
<li>
<p>Exactly one non‑identity error (on one pair only): probability 2(1−p)p. Acceptance requires that that single 2‑qubit Pauli commute with both generators, i.e., s=(0,0). There are 3 such Paulis out of 15, so conditional acceptance probability = 3/15 = 1/5.</p>
</li>
<li>
<p>Non‑identity errors on both pairs: probability p^2. Acceptance requires s(P12)=s(P03). With counts above, the number of accepted ordered pairs is 3^2+4^2+4^2+4^2 = 57 out of 15×15 = 225. Hence conditional acceptance probability = 57/225 = 19/75.</p>
</li>
</ul>
<p>Therefore the total acceptance probability is</p>
<div class="arithmatex">\[
P_{\mathrm{acc}}(p)
=(1-p)^2+2(1-p)p\cdot\frac{1}{5}+p^2\cdot\frac{19}{75}
=1-\frac{8}{5}p+\frac{64}{75}p^2.
\]</div>
<p>5) Probability the prepared 4‑qubit state equals the ideal (i.e., is in the state stabilizer)</p>
<ul>
<li>The run produces the exact target 4‑qubit state iff the net Pauli P lies in the stabilizer Sstate of that pure state. Counting (as in Subproblem 1): identity contributes (1−p)^2; a single non‑identity on one pair yields a stabilizer element only for the 3 Paulis {XX,YY,ZZ} → probability 2(1−p)p·(3/15); with non‑identity on both pairs, being in Sstate occurs for the 3×3=9 ordered choices in {XX,YY,ZZ}×{XX,YY,ZZ} → probability p^2·(9/225). Thus</li>
</ul>
<div class="arithmatex">\[
P\{P\in S_{\text{state}}\}
=(1-p)^2+2(1-p)p\cdot\frac{3}{15}+p^2\cdot\frac{9}{225}
=1-\frac{8}{5}p+\frac{16}{25}p^2
=\Bigl(1-\frac{4}{5}p\Bigr)^2.
\]</div>
<p>Because |Φ+⟩AB is stabilized by XX and ZZ in the logical basis, P∈Sstate is equivalent to “no logical error” on |Φ+⟩AB. (<a href="https://zxcalc.github.io/book/html/main_htmlch6.html?utm_source=openai">zxcalc.github.io</a>)</p>
<p>6) Logical fidelity conditioned on acceptance</p>
<ul>
<li>By definition,</li>
</ul>
<div class="arithmatex">\[
F_{\mathrm{logical}}(p)
=\Pr\{P\in S_{\text{state}}\mid P\in N(S)\}
=\frac{\Pr\{P\in S_{\text{state}}\}}{\Pr\{P\in N(S)\}}
=\frac{\,1-\frac{8}{5}p+\frac{16}{25}p^2\,}{\,1-\frac{8}{5}p+\frac{64}{75}p^2\,}.
\]</div>
<p>Two useful checks:
  • Small‑p expansion: <span class="arithmatex">\(F_{\mathrm{logical}}(p)=1-\frac{16}{75}p^2+O(p^3)\)</span>, i.e., post‑selection removes all O(p) infidelity, as expected for a distance‑2 detector.
  • Worst case p=1: <span class="arithmatex">\(F_{\mathrm{logical}}(1)=\frac{1/25}{19/75}=\frac{3}{19}\)</span>.</p>
<p>Final Answer:
The logical state fidelity of the post‑selected logical Bell state is</p>
<div class="arithmatex">\[
F_{\mathrm{logical}}(p)
=\frac{1-\frac{8}{5}p+\frac{16}{25}p^2}{1-\frac{8}{5}p+\frac{64}{75}p^2}
=1-\frac{16}{75}p^2+O(p^3),
\]</div>
<p>with acceptance probability <span class="arithmatex">\(P_{\mathrm{acc}}(p)=1-\frac{8}{5}p+\frac{64}{75}p^2\)</span>. (<a href="https://en.wikipedia.org/wiki/Stabilizer_code?utm_source=openai">en.wikipedia.org</a>, <a href="https://zxcalc.github.io/book/html/main_htmlch6.html?utm_source=openai">zxcalc.github.io</a>)</p></div>
</article>


<article class="message role-user">
    <div class="meta">
        <span class="badge">User</span>
        <span class="idx">#5</span>
    </div>
    <div class="content markdown-body"><p>Populate your final answer into the code template provided below. This step is purely for formatting/display purposes. No additional reasoning or derivation should be performed. Do not import any modules or packages beyond what is provided in the template.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a SymPy expression of inputs</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>


<article class="message role-assistant">
    <div class="meta">
        <span class="badge">Assistant</span>
        <span class="idx">#6</span>
    </div>
    <div class="content markdown-body"><div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">answer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the expression of logical state fidelity of the final 2-qubit logical state</span>
<span class="sd">    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ----------</span>
<span class="sd">    p: sympy.Symbol, the two-qubit gate error rate, $p$</span>

<span class="sd">    Outputs</span>
<span class="sd">    ----------</span>
<span class="sd">    F_logical: sympy.Expr, the logical state fidelity as a function of $p$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------ FILL IN YOUR RESULTS BELOW ------------------</span>
    <span class="n">F_logical</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># ---------------------------------------------------------------</span>

    <span class="k">return</span> <span class="n">F_logical</span>
</code></pre></div></div>
</article>

</div>

<footer>
  Generated at 2025-09-24T22:02:10.950880
</footer>

<script>
(function() {
  // Tabs
  const tabs = document.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      tab.classList.add('active');
      const target = document.querySelector(tab.dataset.target);
      if (target) target.classList.add('active');
    });
  });

  // Theme toggle
  const toggleBtn = document.getElementById('theme-toggle');
  function setTheme(dark) {
    if (dark) {
      document.documentElement.classList.add('dark');
      localStorage.setItem('dark', '1');
    } else {
      document.documentElement.classList.remove('dark');
      localStorage.setItem('dark', '0');
    }
  }
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const stored = localStorage.getItem('dark');
  setTheme(stored === null ? prefersDark : stored === '1');

  toggleBtn.addEventListener('click', () => {
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(!isDark);
  });
})();
</script>
</body>
</html>